
Chapter()"Calculus";


AddAnchor("Sin");
AddAnchor("Cos");
AddAnchor("Tan");
AddAnchor("ArcSin");
AddAnchor("ArcCos");
AddAnchor("ArcTan");
SubSection()"Trigonometric functions";
StandardLib();
Topical()"Calling Sequence";
Text()
"Sin(x)<br>
Cos(x)<br>
Tan(x)<br>
ArcSin(x)<br>
ArcCos(x)<br>
ArcTan(x)<br>
";

Topical()"Parameters";
Text()"x - some number";

Topical()"Description";
Text()"These functions represent the trigonometric functions and their
inverses. Yacas leaves them alone even if x is a number, trying to keep
the result as exact as possible. The floating point approximations of
these functions can be forced by using the N(...) functions. <p>

Yacas knows some trigonometric identities, so it can simplify to exact
results even if N is not used. This is the case when the arguments are
of the form Pi, Pi/2 etcetera.
";

Topical()"Examples";
Text()
HtmlCommand(
"In> Sin(1)
Out> Sin(1);
In> N(Sin(1),20)
Out> 0.84147098480789650665;
In> Sin(Pi/4)
Out> Sqrt(2)/2;
");

Topical()"See Also"; 
SeeAlso({"N","Pi"});






AddAnchor("Exp");
SubSection()"Exp(x)";
Text()"Exp(x) : Calculate e^x.";

AddAnchor("Ln");
SubSection()"Ln(x)";
Text()"Ln(x) :  Calculate natural logarithm of x.";

AddAnchor("Sqrt");
SubSection()"Sqrt(x)";
Text()"Sqrt(x) : calculate the square root of x.";

AddAnchor("Abs");
AddAnchor("Sign");
SubSection()"Abs, Sign";
StandardLib();
Topical()"Calling Sequence";
Text()
"Abs(x) <BR>
Sign(x)
";

Topical()"Parameters";
Text()"x - a number";

Topical()"Description";
Text()
"Abs(x) returns the absolute value of a number.
Abs(x)*Sign(x) should always be equal to x. Sign(x) returns 1
if the number is positive, -1 otherwise.";

Topical()"Examples";
Text()
HtmlCommand(
"In> Abs(-2)
Out> 2;
In> Sign(-2)
Out> -1;
");

Topical()"See Also"; 
SeeAlso({});


AddAnchor("Complex");
SubSection()"Complex(x,y)";
Text()"This represents a complex number x+I*y.";

AddAnchor("Re");
SubSection()"Re(z)";
Text()"Return real part of complex number z.";

AddAnchor("Im");
SubSection()"Im(z)";
Text()"Return imaginary part of complex number z.";

AddAnchor("I");
SubSection()"I";
Text()"This is the pure imaginary number I (for which i*I=-1).
You can type 2+I*3, which would evaluate to
Complex(2,3). Re and Im return the real and
imaginary parts of a number respectively.";


AddAnchor("!");
SubSection()"n!";
Text()"Factorial. n! evaluates to n*(n-1)*(n-2)*....*1.";


AddAnchor("Bin");
SubSection()"Bin(n,m)";
Text()"Bin(n,m) evaluates to n!/(n!*(n-m)!)";


AddAnchor("Sum");
SubSection()"Sum(var,from,to,body) and Sum({list})";
Text()"Sum(var,from,to,body) :
Sum does a summation over \"body\", setting variable \"var\"
from \"from\" upto and including \"to\", incrementing it by 1 each
time.":
HtmlNewParagraph():

"Sum({list}) : calculate the sum of the elements in a list.
Example : Sum({1,2,3}) evaluates to 6.";


AddAnchor("Average");
SubSection()"Average({list})";
Text()"Average({list}) : calculate the average of the elements in a list.
Example : Average({1,2,3}) evaluates to 2.";


AddAnchor("Factorize");
SubSection()"Factorize(var,from,to,body) and Factorize({list})";
Text()"Factorize(var,from,to,body) :
Factorize does a factorization over \"body\", setting variable \"var\"
from \"from\" upto and including \"to\", incrementing it by 1 each
time.":

HtmlNewParagraph():

"Factorize({list}) : calculate the product of the elements in a list.
Example : Factorize({1,2,3}) evaluates to 6.";

AddAnchor("Min");
AddAnchor("Max");
SubSection()"Min(x,y), Min({...}), Max(x,y) and Max({...})";
Text()"Min and Max return the minimum and maximum value of their
arguments respectively. Min and max can either be called with
two numbers as arguments, or with a list of numbers.
";


AddAnchor("IsZero");
SubSection()"IsZero(x)";
Text()"IsZero(x) : Returns wether x is zero or not.";


AddAnchor("IsRational");
SubSection()"IsRational(r)";
Text()"IsRational(r) : Rational numbers are anything like a/b, or 2/5.";

AddAnchor("Numer");
SubSection()"Numer(r)";
Text()"Numer(r) : Return numerator of a rational number.";

AddAnchor("Denom");
SubSection()"Denom(r)";
Text()"Denom(r) : Return denominator of a rational number.";


AddAnchor("Commutator");
SubSection()"Commutator(a,b)";
Text()"Commutator(a,b) :
Return \"a b - b a\". For numbers and such this is
zero, for matrices in general it isn't.";

AddAnchor("Taylor");
SubSection()"Taylor(var,var0,order)function";
Text()"Taylor(var,var0,order)function :
Return the Taylor series expansion of function \"function\", with
respect to variable \"var\", around \"var=var0\", upto order \"order\".";

AddAnchor("InverseTaylor");
SubSection()"InverseTaylor(var,value,degree) func";

Text()"InverseTaylor(var,value,degree) func : build a taylor series expansion
of the inverse of function func, with respect to variable var around value, upto
degree. InverseTaylor uses the function ReversePoly to perform the
task.

";

AddAnchor("ReversePoly");
SubSection()"ReversePoly(f,g,var,newvar,degree)";
Text()
"ReversePoly(f,g,var,newvar,degree) :

Given polynomials f(var) and h(var), determine a polynomial
h(newvar) for which h(f(var)) = g(var). The resulting polynomial
will be of degree degree. The only requirement is that the
first derivative of f should not be zero.
":
HtmlNewParagraph():
"
This function is used to determine the taylor series expansion of
a function: if g(var)=var, then h(f(var))=var, so h will be the
inverse of f.
";


AddAnchor("Newton");
SubSection()"Newton(function,variable,initial,accuracy)";
Text()"Newton(function,variable,initial,accuracy) :
Find a zero of \"function\", as a function of \"variable\",
starting around value \"initial\", and continuing until
the value for \"variable\" is maximally \"accuracy\" away
from the correct value.";


AddAnchor("D");
SubSection()"D(variable)expression";
Text()"D(variable)  expression :
Calculate analytic derivative of an expression. \"D(x) Sin(x);\"
\"Cos(x);\".

The D operator is also threaded:
\"D({x,y,z}) Sin(x*y)\" will return {Cos(x*y)*y,Cos(x*y)*x,0}
":

HtmlNewParagraph():
"Alternatively, you can call D with \"D(variable,n)expression\".
In that case the n-th derivative will be taken.";


AddAnchor("Diverge");
SubSection()"Diverge(vector, basis)";
Text()"Diverge(vector, basis) : Calculate the divergence of
a vector.

Example: \"Diverge(FillList(x*y,3),{x,y,z})\" will return
{y,x,0}
";


AddAnchor("Curl");
SubSection()"Curl(vector, basis)";
Text()"Curl(vector, basis) : Calculate the curl of a vector.

Example: \"Curl(FillList(x*y,3),{x,y,z})\" will return
{x,-y,y-x}
";


AddAnchor("Integrate");
SubSection()"Integrate(var,from,to) body";

Text()"Integrate(var,from,to) body : integrate body over variable var=from
to var=to. Currently, only polynomials can be integrated.";


AddAnchor("Simplify");
SubSection()"Simplify(expr)";
Text()"Simplify(expr) : Simplify tries to simplify an expression as much
as possible.";


AddAnchor("RadSimp");
SubSection()"RadSimp";
StandardLib();
Topical()"Calling Sequence";
Text()"RadSimp(expression)";

Topical()"Parameters";
Text()"expression - an expression containing nested radicals";

Topical()"Description";
Text()
"RadSimp tries to unnest nested radicals. It does this using
a simple brute force method, and tries to write it out as an
expression of the form Sqrt(e1) + Sqrt(e2) + ... .
";

Topical()"Examples";
Text()
HtmlCommand(
"In> RadSimp(Sqrt(9+4*Sqrt(2)))
Out> 1+Sqrt(8);
In> RadSimp(Sqrt(5+2*Sqrt(6))+Sqrt(5-2*Sqrt(6)))
Out> Sqrt(12);
In> RadSimp(Sqrt(14+3*Sqrt(3+2*Sqrt(5-12*Sqrt(3-2*Sqrt(2)))))) 
Out> 3+Sqrt(2);
");

Topical()"See Also"; 
SeeAlso({"Simplify"});



AddAnchor("Rationalize");
SubSection()"Rationalize(expr)";
Text()"Rationalize(expr) : convert every real number in expr into a rational
number.";

AddAnchor("Conjugate");
SubSection()"Conjugate(expr)";
Text()"Conjugate(expr) : return the conjugate of expr (given that all
variables are real or integer).
";


AddAnchor("Solve");
SubSection()"Solve(expr1==expr2,variable)";
Text()"Solve(expr1==expr2,variable) :
A very simple solver. It can for now solve expressions where the variable
to be solved for only occurs once.

\"Solve(a+x*y==z,x);\" would evaluate to \"(z-a)/y\".
":
HtmlNewParagraph():
"
Solve can solve simple sets of equations. Pass the equations in a list,
as well as the variables to be solved for. The solver will then use
SuchThat, in combination with Eliminate, to simplify the equations.
This suffices for all linear equations and a large group of simple
non-linear equations.
":
HtmlNewParagraph():
"
When the variable argument receives a list of variables to solve for,
Solve returns a list of results, with each result being a solution
to the set of equations.
";

AddAnchor("SuchThat");
SubSection()"SuchThat(function,var)";
Text()"
SuchThat(function,var) : try to find a simple expression for variable var,
given the equality function=0. This function basically only handles
expressions where the variable var only occurs once. It does its work
by applying the inverse of the top function, until the variable is
reached.
";



AddAnchor("Eliminate");
SubSection()"Eliminate(var,replace,function)";
Text()"
Eliminate(var,replace,function) : replace all instances of
":HtmlTerm("var"):" in ":HtmlTerm("function"):" with ":HtmlTerm("relpace"):"
and call Simplify on the resulting expression.
";


AddAnchor("PSolve");
SubSection()"PSolve(expr,var)";

Text()"PSolve(expr) : solve expr=0 with respect to variable var, treating
it expr as a polynomial. It currently solves upto degree 2.
";


AddAnchor("Pi");
SubSection()"Pi()";
Text()"Pi() : Returns pi to the current precision.";


AddAnchor("Fibonacci");
SubSection()"Fibonacci(n)";
Text()"Fibonacci(n) : Calculate Fibonacci number \"n\".";


AddAnchor("Random");
SubSection()"Random()";
Text()"Random() : Returns a random number between 0 and 1.";


AddAnchor("VarList");
SubSection()"VarList(expression)";
Text()"VarList(expression) : Returns a list with all the variables
\"expression\" depends on. Example: \"VarList(Sin(x));\" should
return \"{x};\".";


AddAnchor("Limit");
SubSection()"Limit(variable,value) function";
Text()"Limit(variable,value)function : determine the
value \"function\" converges to when \"variable\"
goes to \"value\" from positive infinity.
Examples : 
\"Limit(x,0) Sin(x)/x;\" evaluates to \"1\", and 
\"Limit(x,0) (Sin(x)-Tan(x))/(x^3);\" evaluates to \"-1/2\".
";


AddAnchor("TrigSimpCombine");
SubSection()"TrigSimpCombine(expression)";
Text()"TrigSimpCombine(expression) : 
This is the module that does the trigonometric simplification:
Cos(...)*Sin(...) -> Cos(...)+Sin(...)
<P>
It also tries to simplify the resulting expression as much as possible,
trying to combine all like terms.
";


AddAnchor("LagrangeInterpolant");
SubSection()"LagrangeInterpolant({xlist},{ylist},var)";
Text()"
LagrangeInterpolant({xlist},{ylist},var) :

given a set of points (x_i,y_i) with all nonzero y_i, find the
polynomial that goes through these points. The first argument
passed to the function should be the list of x_i values, the
second one should be the list of y_i values, and the third
argument should be the variable used to build up the polynomial.

":HtmlNewParagraph():"

This routine uses the Lagrange interpolant formula to build up the
polynomial. For three terms this is:

":HtmlCommand(
"In> PrettyForm(LagrangeInterpolant(MakeVector(x,3),MakeVector(y,3),x))

y1 * ( x - x2 ) * ( x - x3 )   y2 * ( x - x1 ) * ( x - x3 ) 
---------------------------- + ---------------------------- 
 ( x1 - x2 ) * ( x1 - x3 )      ( x2 - x1 ) * ( x2 - x3 )   

  y3 * ( x - x1 ) * ( x - x2 )
+ ----------------------------
   ( x3 - x1 ) * ( x3 - x2 )  

Out> True;"):"


";




