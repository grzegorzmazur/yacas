
Chapter()"Variables";

AddAnchor(":=");
SubSection()"x:=y";  Text()"
x:=y :  Assignment. The \":=\" operator can be used for three different types
of assignment:

Assigning a variable: as in \"x:=2;\",
Defining a new function: as in \"f(x):=Sin(2*x);\", or
Assigning a list item a value: as in \"list[i] := 2;\"

";

AddAnchor("Set");
SubSection()"Set(variable, value)";  Text()"
Set(variable, value) : Sets variable to evaluated value and returns \"True\".

";

AddAnchor("Clear");
SubSection()"Clear(...)";  Text()"
Clear(...) : Makes sure variables specified in \"...\" are not bound
any more to a value, and returns True.

";

AddAnchor("Local");
SubSection()"Local(...)";  Text()"
Local(...) :
Mark the variables in the unevaluated argument list as
local variables (local within a Prog block or a function).

";

AddAnchor("++");
SubSection()"x++";  Text()"
x++ : increment the variable \"x\".

";

AddAnchor("--");
SubSection()"x--";  Text()"
x-- : decrement the variable \"x\".

";

AddAnchor("Object");
SubSection()"Object(\"predicate\",object)";  Text()"
Object(\"predicate\",object) : declaration of an
incomplete object. This function returns \"object\"
as soon as \"predicate\" returns \"True\" on it. 
Example: \"Object(\"IsNumber\",x);\" returns itself,
where if x was an integer, it would return that
integer.
";


AddAnchor("LazyGlobal");
SubSection()"LazyGlobal";
BuiltIn();
Topical()"Calling Sequence";
Text()"LazyGlobal(var)";

Topical()"Parameters";
Text()"var - variable (held argument)";

Topical()"Description";
Text()"LazyGlobal enforces that a global variable will re-evaluate
when used. The global variable needs to exist for this function
to work. Also, this functionality doesn't survive if Clear(var)
is called afterwards. <P>  </P>

Places where this is used include the global variables % and I.<P>  </P>

The use of lazy in the name stems from the concept of lazy evaluation.
The object the global variable is bound to will only be evaluated when
called. The LazyGlobal property only holds once: after that, the result
of evaluation is stored in the global variable, and it won't be reevaluated again:

":HtmlCommand(
"In> a:=Hold(Taylor(x,0,30)Sin(x))
Out> Taylor(x,0,30)Sin(x);
In> LazyGlobal(a)
"):"

Then the first time you call a it evaluates Taylor(...) and assigns the result to a. The next time
you call a it immediately returns the result.
LazyGlobal is called for \"%\" each time \"%\" changes.

";

Topical()"Examples";
Text()
HtmlCommand(
"In> a:=Hold(2+3)
Out> 2+3;
In> a
Out> 2+3;
In> LazyGlobal(a)
Out> True;
In> a
Out> 5;

");

Topical()"See Also"; 
SeeAlso({"Set","Clear","Local"});


AddAnchor("UniqueConstant");
SubSection()"UniqueConstant";
StandardLib();
Topical()"Calling Sequence";
Text() "UniqueConstant()";

Topical()"Description";
Text()"This function returns a unique constant atom each time you call it,
  starting with a C character, and a unique number appended to it.";

Topical()"Examples";
Text()
HtmlCommand("
In&gt UniqueConstant() 
Out&gt C9 
In&gt  UniqueConstant() 
Out&gt C10 

");



