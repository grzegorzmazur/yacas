<HTML>
<A NAME="c4">

</A>
<A HREF="refchapter4.html#Sin" TARGET="Chapters">
Sin
</A>
, <A HREF="refchapter4.html#Cos" TARGET="Chapters">
Cos
</A>
, <A HREF="refchapter4.html#Tan" TARGET="Chapters">
Tan
</A>
, <A HREF="refchapter4.html#ArcSin" TARGET="Chapters">
ArcSin
</A>
, <A HREF="refchapter4.html#ArcCos" TARGET="Chapters">
ArcCos
</A>
, <A HREF="refchapter4.html#ArcTan" TARGET="Chapters">
ArcTan
</A>
, <A HREF="refchapter4.html#Exp" TARGET="Chapters">
Exp
</A>
, <A HREF="refchapter4.html#Ln" TARGET="Chapters">
Ln
</A>
, <A HREF="refchapter4.html#Sqrt" TARGET="Chapters">
Sqrt
</A>
, <A HREF="refchapter4.html#Abs" TARGET="Chapters">
Abs
</A>
, <A HREF="refchapter4.html#Sign" TARGET="Chapters">
Sign
</A>
, <A HREF="refchapter4.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="refchapter4.html#Re" TARGET="Chapters">
Re
</A>
, <A HREF="refchapter4.html#Im" TARGET="Chapters">
Im
</A>
, <A HREF="refchapter4.html#I" TARGET="Chapters">
I
</A>
, <A HREF="refchapter4.html#!" TARGET="Chapters">
!
</A>
, <A HREF="refchapter4.html#Bin" TARGET="Chapters">
Bin
</A>
, <A HREF="refchapter4.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="refchapter4.html#Average" TARGET="Chapters">
Average
</A>
, <A HREF="refchapter4.html#Factorize" TARGET="Chapters">
Factorize
</A>
, <A HREF="refchapter4.html#Min" TARGET="Chapters">
Min
</A>
, <A HREF="refchapter4.html#Max" TARGET="Chapters">
Max
</A>
, <A HREF="refchapter4.html#IsZero" TARGET="Chapters">
IsZero
</A>
, <A HREF="refchapter4.html#IsRational" TARGET="Chapters">
IsRational
</A>
, <A HREF="refchapter4.html#Numer" TARGET="Chapters">
Numer
</A>
, <A HREF="refchapter4.html#Denom" TARGET="Chapters">
Denom
</A>
, <A HREF="refchapter4.html#Commutator" TARGET="Chapters">
Commutator
</A>
, <A HREF="refchapter4.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="refchapter4.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
, <A HREF="refchapter4.html#ReversePoly" TARGET="Chapters">
ReversePoly
</A>
, <A HREF="refchapter4.html#Newton" TARGET="Chapters">
Newton
</A>
, <A HREF="refchapter4.html#D" TARGET="Chapters">
D
</A>
, <A HREF="refchapter4.html#Diverge" TARGET="Chapters">
Diverge
</A>
, <A HREF="refchapter4.html#Curl" TARGET="Chapters">
Curl
</A>
, <A HREF="refchapter4.html#Integrate" TARGET="Chapters">
Integrate
</A>
, <A HREF="refchapter4.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A HREF="refchapter4.html#RadSimp" TARGET="Chapters">
RadSimp
</A>
, <A HREF="refchapter4.html#Rationalize" TARGET="Chapters">
Rationalize
</A>
, <A HREF="refchapter4.html#Conjugate" TARGET="Chapters">
Conjugate
</A>
, <A HREF="refchapter4.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="refchapter4.html#SuchThat" TARGET="Chapters">
SuchThat
</A>
, <A HREF="refchapter4.html#Eliminate" TARGET="Chapters">
Eliminate
</A>
, <A HREF="refchapter4.html#PSolve" TARGET="Chapters">
PSolve
</A>
, <A HREF="refchapter4.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="refchapter4.html#Fibonacci" TARGET="Chapters">
Fibonacci
</A>
, <A HREF="refchapter4.html#Random" TARGET="Chapters">
Random
</A>
, <A HREF="refchapter4.html#VarList" TARGET="Chapters">
VarList
</A>
, <A HREF="refchapter4.html#Limit" TARGET="Chapters">
Limit
</A>
, <A HREF="refchapter4.html#TrigSimpCombine" TARGET="Chapters">
TrigSimpCombine
</A>
, <A HREF="refchapter4.html#LagrangeInterpolant" TARGET="Chapters">
LagrangeInterpolant
</A>
, <HEAD><TITLE>Calculus</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Calculus
</H1>
<A NAME="Sin">

</A>
<A NAME="Cos">

</A>
<A NAME="Tan">

</A>
<A NAME="ArcSin">

</A>
<A NAME="ArcCos">

</A>
<A NAME="ArcTan">

</A>
<H3>
<HR>Trigonometric functions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Sin(x)<br>
Cos(x)<br>
Tan(x)<br>
ArcSin(x)<br>
ArcCos(x)<br>
ArcTan(x)<br>

<H5>
Parameters:
</H5>
x - some number
<H5>
Description:
</H5>
These functions represent the trigonometric functions and their
inverses. Yacas leaves them alone even if x is a number, trying to keep
the result as exact as possible. The floating point approximations of
these functions can be forced by using the N(...) functions. <p>

Yacas knows some trigonometric identities, so it can simplify to exact
results even if N is not used. This is the case when the arguments are
of the form Pi, Pi/2 etcetera.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(1)
Out> Sin(1);
In> N(Sin(1),20)
Out> 0.84147098480789650665;
In> Sin(Pi/4)
Out> Sqrt(2)/2;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
, <A NAME="Exp">

</A>
<H3>
<HR>Exp(x)
</H3>
Exp(x) : Calculate e^x.
<A NAME="Ln">

</A>
<H3>
<HR>Ln(x)
</H3>
Ln(x) :  Calculate natural logarithm of x.
<A NAME="Sqrt">

</A>
<H3>
<HR>Sqrt(x)
</H3>
Sqrt(x) : calculate the square root of x.
<A NAME="Abs">

</A>
<A NAME="Sign">

</A>
<H3>
<HR>Abs, Sign
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Abs(x) <BR>
Sign(x)

<H5>
Parameters:
</H5>
x - a number
<H5>
Description:
</H5>
Abs(x) returns the absolute value of a number.
Abs(x)*Sign(x) should always be equal to x. Sign(x) returns 1
if the number is positive, -1 otherwise.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Abs(-2)
Out> 2;
In> Sign(-2)
Out> -1;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="Complex">

</A>
<H3>
<HR>Complex(x,y)
</H3>
This represents a complex number x+I*y.
<A NAME="Re">

</A>
<H3>
<HR>Re(z)
</H3>
Return real part of complex number z.
<A NAME="Im">

</A>
<H3>
<HR>Im(z)
</H3>
Return imaginary part of complex number z.
<A NAME="I">

</A>
<H3>
<HR>I
</H3>
This is the pure imaginary number I (for which i*I=-1).
You can type 2+I*3, which would evaluate to
Complex(2,3). Re and Im return the real and
imaginary parts of a number respectively.
<A NAME="!">

</A>
<H3>
<HR>n!
</H3>
Factorial. n! evaluates to n*(n-1)*(n-2)*....*1.
<A NAME="Bin">

</A>
<H3>
<HR>Bin(n,m)
</H3>
Bin(n,m) evaluates to n!/(n!*(n-m)!)
<A NAME="Sum">

</A>
<H3>
<HR>Sum(var,from,to,body) and Sum({list})
</H3>
Sum(var,from,to,body) :
Sum does a summation over "body", setting variable "var"
from "from" upto and including "to", incrementing it by 1 each
time.
<P>
Sum({list}) : calculate the sum of the elements in a list.
Example : Sum({1,2,3}) evaluates to 6.
<A NAME="Average">

</A>
<H3>
<HR>Average({list})
</H3>
Average({list}) : calculate the average of the elements in a list.
Example : Average({1,2,3}) evaluates to 2.
<A NAME="Factorize">

</A>
<H3>
<HR>Factorize(var,from,to,body) and Factorize({list})
</H3>
Factorize(var,from,to,body) :
Factorize does a factorization over "body", setting variable "var"
from "from" upto and including "to", incrementing it by 1 each
time.
<P>
Factorize({list}) : calculate the product of the elements in a list.
Example : Factorize({1,2,3}) evaluates to 6.
<A NAME="Min">

</A>
<A NAME="Max">

</A>
<H3>
<HR>Min(x,y), Min({...}), Max(x,y) and Max({...})
</H3>
Min and Max return the minimum and maximum value of their
arguments respectively. Min and max can either be called with
two numbers as arguments, or with a list of numbers.

<A NAME="IsZero">

</A>
<H3>
<HR>IsZero(x)
</H3>
IsZero(x) : Returns wether x is zero or not.
<A NAME="IsRational">

</A>
<H3>
<HR>IsRational(r)
</H3>
IsRational(r) : Rational numbers are anything like a/b, or 2/5.
<A NAME="Numer">

</A>
<H3>
<HR>Numer(r)
</H3>
Numer(r) : Return numerator of a rational number.
<A NAME="Denom">

</A>
<H3>
<HR>Denom(r)
</H3>
Denom(r) : Return denominator of a rational number.
<A NAME="Commutator">

</A>
<H3>
<HR>Commutator(a,b)
</H3>
Commutator(a,b) :
Return "a b - b a". For numbers and such this is
zero, for matrices in general it isn't.
<A NAME="Taylor">

</A>
<H3>
<HR>Taylor(var,var0,order)function
</H3>
Taylor(var,var0,order)function :
Return the Taylor series expansion of function "function", with
respect to variable "var", around "var=var0", upto order "order".
<A NAME="InverseTaylor">

</A>
<H3>
<HR>InverseTaylor(var,value,degree) func
</H3>
InverseTaylor(var,value,degree) func : build a taylor series expansion
of the inverse of function func, with respect to variable var around value, upto
degree. InverseTaylor uses the function ReversePoly to perform the
task.


<A NAME="ReversePoly">

</A>
<H3>
<HR>ReversePoly(f,g,var,newvar,degree)
</H3>
ReversePoly(f,g,var,newvar,degree) :

Given polynomials f(var) and h(var), determine a polynomial
h(newvar) for which h(f(var)) = g(var). The resulting polynomial
will be of degree degree. The only requirement is that the
first derivative of f should not be zero.

<P>

This function is used to determine the taylor series expansion of
a function: if g(var)=var, then h(f(var))=var, so h will be the
inverse of f.

<A NAME="Newton">

</A>
<H3>
<HR>Newton(function,variable,initial,accuracy)
</H3>
Newton(function,variable,initial,accuracy) :
Find a zero of "function", as a function of "variable",
starting around value "initial", and continuing until
the value for "variable" is maximally "accuracy" away
from the correct value.
<A NAME="D">

</A>
<H3>
<HR>D(variable)expression
</H3>
D(variable)  expression :
Calculate analytic derivative of an expression. "D(x) Sin(x);"
"Cos(x);".

The D operator is also threaded:
"D({x,y,z}) Sin(x*y)" will return {Cos(x*y)*y,Cos(x*y)*x,0}

<P>
Alternatively, you can call D with "D(variable,n)expression".
In that case the n-th derivative will be taken.
<A NAME="Diverge">

</A>
<H3>
<HR>Diverge(vector, basis)
</H3>
Diverge(vector, basis) : Calculate the divergence of
a vector.

Example: "Diverge(FillList(x*y,3),{x,y,z})" will return
{y,x,0}

<A NAME="Curl">

</A>
<H3>
<HR>Curl(vector, basis)
</H3>
Curl(vector, basis) : Calculate the curl of a vector.

Example: "Curl(FillList(x*y,3),{x,y,z})" will return
{x,-y,y-x}

<A NAME="Integrate">

</A>
<H3>
<HR>Integrate(var,from,to) body
</H3>
Integrate(var,from,to) body : integrate body over variable var=from
to var=to. Currently, only polynomials can be integrated.
<A NAME="Simplify">

</A>
<H3>
<HR>Simplify(expr)
</H3>
Simplify(expr) : Simplify tries to simplify an expression as much
as possible.
<A NAME="RadSimp">

</A>
<H3>
<HR>RadSimp
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RadSimp(expression)
<H5>
Parameters:
</H5>
expression - an expression containing nested radicals
<H5>
Description:
</H5>
RadSimp tries to unnest nested radicals. It does this using
a simple brute force method, and tries to write it out as an
expression of the form Sqrt(e1) + Sqrt(e2) + ... .

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> RadSimp(Sqrt(9+4*Sqrt(2)))
Out> 1+Sqrt(8);
In> RadSimp(Sqrt(5+2*Sqrt(6))+Sqrt(5-2*Sqrt(6)))
Out> Sqrt(12);
In> RadSimp(Sqrt(14+3*Sqrt(3+2*Sqrt(5-12*Sqrt(3-2*Sqrt(2)))))) 
Out> 3+Sqrt(2);
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A NAME="Rationalize">

</A>
<H3>
<HR>Rationalize(expr)
</H3>
Rationalize(expr) : convert every real number in expr into a rational
number.
<A NAME="Conjugate">

</A>
<H3>
<HR>Conjugate(expr)
</H3>
Conjugate(expr) : return the conjugate of expr (given that all
variables are real or integer).

<A NAME="Solve">

</A>
<H3>
<HR>Solve(expr1==expr2,variable)
</H3>
Solve(expr1==expr2,variable) :
A very simple solver. It can for now solve expressions where the variable
to be solved for only occurs once.

"Solve(a+x*y==z,x);" would evaluate to "(z-a)/y".

<P>

Solve can solve simple sets of equations. Pass the equations in a list,
as well as the variables to be solved for. The solver will then use
SuchThat, in combination with Eliminate, to simplify the equations.
This suffices for all linear equations and a large group of simple
non-linear equations.

<P>

When the variable argument receives a list of variables to solve for,
Solve returns a list of results, with each result being a solution
to the set of equations.

<A NAME="SuchThat">

</A>
<H3>
<HR>SuchThat
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
SuchThat(expression,variable)
<H5>
Parameters:
</H5>
expression - an expression to solve for <br>
variable - subexpression to look for
<H5>
Description:
</H5>
SuchThat(expression,var) : try to find a simple expression for variable var,
given the equality expression=0. This function basically only handles
expressions where the variable only occurs once. It does its work
by applying the inverse of the top function, until the variable is
reached. Variable can also refer to an expression, in which case it
will try to eliminate for that expression.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> SuchThat(a+b*x,x)
Out> (-a)/b;
In> SuchThat(Cos(a)+Cos(b)^2,Cos(b))
Out> (-Cos(a))^(1/2);
In> Expand(a*x+b*x+c,x)
Out> c+(a+b)*x;
In> SuchThat(%,x)
Out> (-c)/(a+b);
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A NAME="Eliminate">

</A>
<H3>
<HR>Eliminate(var,replace,function)
</H3>

Eliminate(var,replace,function) : replace all instances of
<B><TT>var</TT></B> in <B><TT>function</TT></B> with <B><TT>relpace</TT></B>
and call Simplify on the resulting expression.

<A NAME="PSolve">

</A>
<H3>
<HR>PSolve(expr,var)
</H3>
PSolve(expr) : solve expr=0 with respect to variable var, treating
it expr as a polynomial. It currently solves upto degree 2.

<A NAME="Pi">

</A>
<H3>
<HR>Pi()
</H3>
Pi() : Returns pi to the current precision.
<A NAME="Fibonacci">

</A>
<H3>
<HR>Fibonacci(n)
</H3>
Fibonacci(n) : Calculate Fibonacci number "n".
<A NAME="Random">

</A>
<H3>
<HR>Random()
</H3>
Random() : Returns a random number between 0 and 1.
<A NAME="VarList">

</A>
<H3>
<HR>VarList(expression)
</H3>
VarList(expression) : Returns a list with all the variables
"expression" depends on. Example: "VarList(Sin(x));" should
return "{x};".
<A NAME="Limit">

</A>
<H3>
<HR>Limit(variable,value) function
</H3>
Limit(variable,value)function : determine the
value "function" converges to when "variable"
goes to "value" from positive infinity.
Examples : 
"Limit(x,0) Sin(x)/x;" evaluates to "1", and 
"Limit(x,0) (Sin(x)-Tan(x))/(x^3);" evaluates to "-1/2".

<A NAME="TrigSimpCombine">

</A>
<H3>
<HR>TrigSimpCombine(expression)
</H3>
TrigSimpCombine(expression) : 
This is the module that does the trigonometric simplification:
Cos(...)*Sin(...) -> Cos(...)+Sin(...)
<P>
It also tries to simplify the resulting expression as much as possible,
trying to combine all like terms.

<A NAME="LagrangeInterpolant">

</A>
<H3>
<HR>LagrangeInterpolant({xlist},{ylist},var)
</H3>

LagrangeInterpolant({xlist},{ylist},var) :

given a set of points (x_i,y_i) with all nonzero y_i, find the
polynomial that goes through these points. The first argument
passed to the function should be the list of x_i values, the
second one should be the list of y_i values, and the third
argument should be the variable used to build up the polynomial.


<P>


This routine uses the Lagrange interpolant formula to build up the
polynomial. For three terms this is:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PrettyForm(LagrangeInterpolant(MakeVector(x,3),MakeVector(y,3),x))

y1 * ( x - x2 ) * ( x - x3 )   y2 * ( x - x1 ) * ( x - x3 ) 
---------------------------- + ---------------------------- 
 ( x1 - x2 ) * ( x1 - x3 )      ( x2 - x1 ) * ( x2 - x3 )   

  y3 * ( x - x1 ) * ( x - x2 )
+ ----------------------------
   ( x3 - x1 ) * ( x3 - x2 )  

Out> True;</PRE>
</TABLE>





</BODY>

</FONT>

</HTML>
