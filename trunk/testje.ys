
dn():=
[
  While (True)
  [
    Echo("...OUT> ",Eval(FromString(ReadCmdLineString("...IN> "):";")Read()));
    DumpErrors();
  ];
];

EndOfFile;


Out> 2*Pi+x+y;
In> expr:=MM(x+y+3*Pi/2+2*ArcTan(s),vars)
Out> MultiNomial({ArcTan(s),Pi,x,y},{{1,{{0,{{0,{{0,2}}}}}}},{0,{{1,{{0,{{0,3/2}}}}},{0,{{1,{{0,1}}},{0,{{1,1},{0,0}}}}}}}});
In> res:=MultiDivide(expr,{dv})
Out> {{MultiNomial({ArcTan(s),Pi,x,y},{{0,{{0,{{0,{{0,2}}}}}}}})},MultiNomial({ArcTan(s),Pi,x,y},{{0,{{1,{{0,{{0,5/2}}}}},{0,{{1,{{0,1}}},{0,{{1,1}}}}}}}})};
In> NormalForm(res[1][1])


SpSimplify(_expression) <--
[
  Local(vars,dv,res);
  vars:=MultiExpressionList(expression);
  
];





EndOfFile;

//Expression(Term({factor,factor},{factor,factor}));

SpecialTerm(_X) <--
[
  Local(gather,result,newterm);
  gather:={};
  result:=1;
  `SpecialGather(@X);
  ForEach(item,gather) 
  [
    If(item[2] != 0,
      [
        newterm:=Atom(item[1])^item[2];
        result := `Hold(@result * @newterm);
      ]);
  ];
  result;
];
Macro()SpecialGather(expr);
10 # SpecialGather(_a*_b) <-- [SpecialGather(@a);SpecialGather(@b);];
10 # SpecialGather((_a*_b)^_c) <-- [SpecialGather(@a ^ @c);SpecialGather(@b ^ @c);];
10 # SpecialGather((_a^_b)^_c) <-- SpecialGather(@a ^ (@b * @c));
20 # SpecialGather(a_IsAtom ^ _b) <-- SpecialPow(@a,@b);
30 # SpecialGather(a_IsConstant) <-- [result := result* @a;];
40 # SpecialGather(a_IsAtom) <-- SpecialPow(@a,1);
90 # SpecialGather(_rest) <-- [result := result* @rest;];

Macro()SpecialPow(a,b);
SpecialPow(_a,_b)
<-- [
      Local(name);
      name:=String(@a);
      If(gather[name] = Empty,gather[name]:=0);
      gather[name] := gather[name] + @b;
    ];



Special(_x) <-- Simplify(SpecialExpand(x));

10 # SpecialExpand(_a + _b) <-- SpecialExpand(a)+SpecialExpand(b);
10 # SpecialExpand(_a - _b) <-- SpecialExpand(a)-SpecialExpand(b);
10 # SpecialExpand(   - _b) <--                 -SpecialExpand(b);
10 # SpecialExpand(_a * _b) <-- SpecialTerm(SpecialExpand(a)*SpecialExpand(b));
10 # SpecialExpand(_a ^ _b) <-- SpecialTerm(SpecialExpand(a)^b);
10 # SpecialExpand(_a / _b) <-- SpecialExpand(a)/SpecialExpand(b);
10 # SpecialExpand((_a * _b)^ _c) <-- SpecialTerm(SpecialExpand(a^c)*SpecialExpand(b^c));

90 # SpecialExpand(_rest) <-- rest;

EndOfFile;

10 # PowerExpand( Sqrt( _u * _v)) <-- Sqrt(u) *Sqrt(v);
10 # PowerExpand( Sqrt( _u / _v)) <-- Sqrt(u) /Sqrt(v);
10 # PowerExpand( (_u * _v) ^ _w) <-- 
   [
     Local(left,right);
     left:=PowerExpand(u^w);
     right:=PowerExpand(v^w);
     `Hold((@left) * (@right));
   ];
10 # PowerExpand( (_u / _v) ^ _w) <-- u^w / v^w;
10# PowerExpand( (_u ^ _v) ^_w) <-- PowerExpand( u^(v*w));
10 # PowerExpand( Ln ( _u ^ _v)) <-- v * Ln(  PowerExpand( u ) );
10 # PowerExpand( Ln(_u * _v)) <-- Ln(u) + Ln(v);
10 # PowerExpand( Ln(_u / _v)) <-- Ln(u) - Ln(v);
10 # PowerExpand( Exp( _u + _v)) <-- Exp(u) * Exp(v);
10 # PowerExpand( Exp( _u - _v)) <-- Exp(u) /Exp(v);

99 # PowerExpand( _u + _v) <-- PowerExpand(u) + PowerExpand(v);
99 # PowerExpand( _u - _v) <-- PowerExpand(u) - PowerExpand(v);

100 # PowerExpand( _expr) <-- expr;

50 # PowerExpand(_x ^ n_IsPositiveInteger) <-- 
   [
     ExpandPow(x,n);
   ];

10 # ExpandPow(_x,1) <-- x;
20 # ExpandPow(_x,_n) <-- 
   [
     Local(rest);
     rest:=ExpandPow(x,n-1);
     `Hold((@x)*(@rest));
   ];
EndOfFile;

/*
1) Flatten, based on addition, and process all terms.
2) Separate F(n,k) into G(n)*G(k), and work on them.
3) separate out constants. 
*/
pat:=
{
  (_n + m_IsInteger)! <- (n+m)*(n+(m-1))!,
  (_n - m_IsInteger)! <- (n-(m-1))! / (n-(m-1))
};
FactorialSimplify(_expr) <-- Factor(Simplify(expr /:: pat));

EndOfFile;

 LocalSymbols(theConsts,theFreeVars,msres,msvars,nrconsts,nrvars)
   [
     Expect(_expr,_freeVars) <--
     [
       MM(x);
       Local(terms,realvars,consts);
       realvars:=MultiExpressionList(expr);
//Echo("realvars is ",realvars);

//       freeVars := Concat(freeVars,Select("IsExpect",realvars));

       consts:=Difference(realvars,freeVars);
//Echo("realvars is ",realvars);
//Echo("consts is ",consts);
//Echo("freevars is ",freeVars);

       msvars:=Concat(consts,freeVars);
       theConsts:=consts;  theFreeVars:=freeVars;
       nrconsts:=Length(consts); nrvars:=Length(msvars);
       Check(Length(Intersection(msvars,realvars))=Length(realvars),"Not all variables enumerated!");
       terms:=MM(expr,msvars)[2];

Echo(expr,  " == ",NormalForm(MM(expr,msvars)));
       msres:=0;
       SparseTreeMap("ExpectOp",Length(msvars),terms);
       msres;
     ];

10 # IsExpect(Expect(_a,_b)) <-- True;
20 # IsExpect(_rest) <-- False;

     ExpectOp(deg,coef) :=
     [
       Local(constdeg,freedeg,free,const);
       constdeg:=deg[1 .. nrconsts];
       const:=1;
       If(nrconsts>0,const:=Factorize(theConsts^constdeg));
       freedeg:=deg[(nrconsts+1) .. nrvars];
       free:=Factorize(theFreeVars^freedeg);

//Echo(coef," * ",const," * Rexpect ",free);

       msres:=msres+coef*const*ReExpect(free);
     ];
     10 # ReExpect(n_IsConstant) <-- n;
     20 # ReExpect(_rest) <-- UnList({Expect,rest,theFreeVars});
   ];




EndOfFile;

LocalSymbols(n)
[
// interface part
    0 # zeroVector(n_IsInteger) <-- ZeroVector'(n);
60000 # zeroVector(_n) <-- 
        [
	    ZeroVector'PostErrors(n);
	    UnList({ZeroVector,n});
        ];

// implementation
Function("ZeroVector'",{n})
[
    Local(i,result);
    result:={};
    For(i:=1,i<=n,i++)
    [
      DestructiveInsert(result,1,0);
    ];
    result;
];

// errors
Function("ZeroVector'PostErrors",{n})
[
   Assert("ZeroVector:", "argument is not integer")
	 IsInteger(n) Or IsScalar(n) And IsVariable(n);
];

]; // LocalSymbols(n)



EndOfFile;

// zeroVector as a mathematical object
    0 # zeroVector(n_IsNonNegativeInteger) <-- zeroVector'(n);

// zeroVector' as an utility function
    0 # zeroVector'(n_IsNonNegativeInteger) <-- FillList(0,n);
60000 # zeroVector'(_n) <-- Check(False,"zeroVector' : argument is not an integer");



EndOfFile;


//F(x,y,n) := x*(y^n)

//D(z)F(x,y,n) =   (y^n)    *(D(z)x) + x*n*y^(n-1)*(D(z)y)

D(x)x;

(Deriv(_var)(F(_x,_y,_n))) <-- Simplify(F(Deriv(var)x,y,n)+x*n*F(Deriv(var)y,y,n-1));

Sf(X,Y,M,simplify) :=
[
  Retract("F",3);  
  Local(fres);
  `(fres:=D(x,M)F(@X,@Y,-1));
//Echo("1...",fres);
  `(F(X,Y,Z) := X*(Y^(@M+1+Z)));
  fres := Eval(fres);
  Retract("F",3);  
  If(simplify,fres:=Simplify(fres));
  fres/(Y^(M+1));
];

//nat-tan/t2


EndOfFile;

  LocalSymbols(theConsts,theFreeVars,msres,msvars,nrconsts,nrvars)
  [
    Expect(_expr,_freeVars) <--
    [
      MM(x);
      Local(terms,realvars,consts); 
      realvars:=MultiExpressionList(expr);
      consts:=Difference(realvars,freeVars);
      msvars:=Concat(consts,freeVars);
      theConsts:=consts;  theFreeVars:=freeVars;
      nrconsts:=Length(consts); nrvars:=Length(msvars);
      Check(Length(Intersection(msvars,realvars))=Length(realvars),"Not all variables enumerated!");
      terms:=MM(expr,msvars)[2];
      msres:=0;
      SparseTreeMap("ExpectOp",Length(msvars),terms);
      msres;
    ];
  
    ExpectOp(deg,coef) :=
    [ 
      Local(constdeg,freedeg,free,const);  
      constdeg:=deg[1 .. nrconsts];
      const:=1;
      If(nrconsts>0,const:=Factorize(theConsts^constdeg));
      freedeg:=deg[(nrconsts+1) .. nrvars];
      free:=Factorize(theFreeVars^freedeg);
      msres:=msres+coef*const*ReExpect(free);
    ];
    10 # ReExpect(n_IsConstant) <-- n;
    20 # ReExpect(_rest) <-- UnList({Expect,rest,theFreeVars});
  ];



EndOfFile;


IsConst(_expr) <-- (IsConstant(expr) Or IsFreeOf({x,y,x1,x2,y1,y2,i},expr) Or 
Type(expr)="E");

10 # E(x_IsConst) <-- x;
20 # E(_x+_y) <-- E(x)+E(y);
30 # E(_x*_y)_(IsConst(x) Or IsConst(y)) <-- E(x)*E(y);
40 # E((_x*_y)^_n) <-- E(x^n)*E(y^n);

ReOrder(expr) := NormalForm(MM(expr,{a,x,y,x1,x2,y1,y2,i}));

EndOfFile;


   LocalSymbols(p) 
   [
   10 # Foo(_x,_y)_([p:=x+y; p>0;]) <-- Bar(p);
   20 # Foo(_x,_y) <-- NoBar(p);
   ];


EndOfFile;

   Foo(_x,_y) <-- Foo(x,y,x+y);
   10 # Foo(_x,_y,_p)_(p>0) <-- Bar(p);
   20 # Foo(_x,_y,_p) <-- NoBar(p);   


   Foo(_x,_y) <-- Foo(x,y,0);
   Function()Foo(x,y,p);
   10 # Foo(_x,_y,_dummy)_([p:=x+y; p>0;]) <-- Bar(p);
   20 # Foo(_x,_y,_dummy) <-- NoBar(p);   


   Foo(_x,_y) <-- [ Local(p); Foo2(x,y); ];
   10 # Foo2(_x,_y)_([p:=x+y; p>0;]) <-- Bar(p);
   20 # Foo2(_x,_y) <-- NoBar(p);   
   UnFence(Foo2,2);


   Foo(_x,_y)_([Local(p);p:=...;...;]) <--
   [
	Local(q);
	q:=Bar(p);
	...
   ];




EndOfFile;
EndOfFile;
EndOfFile;
EndOfFile;

  int j=0;
  int k=0;
  while(j<i)
  {
    k=k+j;
    j=j+1;
  }



/* Simplification of nested radicals.
*/

RadSimp(_n) <--
[
  Local(max);
  max := MathCeil(N(Eval(n)^2));
  result:=0;
  result:=RadSimpTry(n,0,1,max);
  if (CheckRadicals(n,result))
    result
  else
    n;
];

/*Echo({"Try ",test}); */

CheckRadicals(_n,_test) <-- Abs(N(Eval(n-test))) < 0.000001;


RadSimpTry(_n,_result,_current,_max)<--
[
  if (N(Eval(result-n)) < 0)
  [
    Local(i);
    For (i:=current,i<=max,i++)
    [
      Local(new, test);
      test:=result+Sqrt(i);

/* Echo({"Cut-try ",test});  */


      if (CheckRadicals(n,test))
      [
        result:=test;
        i:=max+1;
      ];
    ];

    if (N(Eval(result-n)) < 0)
    [
      For (i:=current,i<=max,i++)
      [
        Local(new, test);
        test:=result+Sqrt(i);

/* Echo({"Full-try ",test}); */

        new:=RadSimpTry(n,test,i,max);
	if (CheckRadicals(n,new))
        [
          result:=new;
          i:=max+1;
        ];
      ];
    ];
/*
*/
  ];
  result;
];


