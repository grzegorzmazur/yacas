
DllLoad("filescanner");
AddFileSizes(base_IsString,fname_IsString,False) <-- [ dirsize := dirsize + FileSize(base:fname); ];
10 # ShowDir(base_IsString,".",_isdir) <-- [];
10 # ShowDir(base_IsString,"..",_isdir) <-- [];
20 # ShowDir(base_IsString,dirname_IsString,True) <--
[
  dirsize := 0;
  ScanFiles(base,dirname,"AddFileSizes");
  Echo(dirname," (",(dirsize+(1<<20)-1)>>20," Mb)");
];
ScanMaps(dir_IsString) <-- ScanFiles(dir,"","ShowDir");


EndOfFile;



Macro()DO(for,expr);
Infix("DO",1001);
Prefix("FOR",1000);
Infix("IN",999);
(FOR _var IN _list DO _expr) <-- ForEach(@var,@list)(@expr);


Y:=1;
Z := [
      if (Y = 1)
      [
        Echo("@spot 1:  Y= ",T);
        2 + Y;
      ]
      else if (K = 1) 
      [
        {};
      ]
      else
      0;
    ];



MergeRangesUnion(r1,r2) := Concat(r1,r2);

Macro()ExistsOneRange(var,ranges);
20 # ExistsOneRange(_var,_r1 Or _r2) <-- MergeRangesUnion(ExistsOneRange(@var,@r1),ExistsOneRange(@var,@r2));
20 # ExistsOneRange(_var,_a < _var)  <-- {{@a,Infinity}};
20 # ExistsOneRange(_var,_a <= _var)  <-- {{@a,Infinity}};
20 # ExistsOneRange(_var,_a > _var)  <-- {{-Infinity,@a}};
20 # ExistsOneRange(_var,_a >= _var)  <-- {{-Infinity,@a}};
20 # ExistsOneRange(_var,_var > _a)  <-- {{@a,Infinity}};
20 # ExistsOneRange(_var,_var >= _a)  <-- {{@a,Infinity}};
20 # ExistsOneRange(_var,_var< _a)  <-- {{-Infinity,@a}};
20 # ExistsOneRange(_var,_var<= _a)  <-- {{-Infinity,@a}};
20 # ExistsOneRange(_var,_var = _a)  <-- {{@a,@a}};
20 # ExistsOneRange(_var,_a < _var < _b)  <-- {{@a,@b}};
20 # ExistsOneRange(_var,_a < _var <= _b)  <-- {{@a,@b}};
20 # ExistsOneRange(_var,_a <= _var < _b)  <-- {{@a,@b}};
20 # ExistsOneRange(_var,_a <= _var <= _b)  <-- {{@a,@b}};

Macro()Exists(var,ranges1,ranges2);
Exists(_var,_r1,_r2) <--
[
  Local(ranges1,ranges2,result,min,max);
  ranges1 := ExistsOneRange(@var,@r1);
  ranges2 := ExistsOneRange(@var,@r2);
  result:={};
  ForEach(item1,ranges1)
    ForEach(item2,ranges2)
    [
      min:=Max(item1[1],item2[1]);
      max:=Min(item1[2],item2[2]);
      if (min <= max)
      [
        DestructiveAppend(result,{min,max});
      ];
    ];
  result;
];


EndOfFile;


  10 # f(UniVariate(_var,_first,_coefs),_var) <-- UniVariate(var,0,Concat(FillList(1,first),(coefs+1)));
  20 # f(_expr,_var) <-- NormalForm(f(MakeUni(expr,var),var));


EndOfFile;


Load("inprogress/factortest.ys");

f(ex,dv,n):=
[
  expr:=Expand(ex);
  
  list2:=Mkd(Mkc(expr),Mkc(dv),n);
  Echo("Division ",list2);
  expr2:=Expand(Mkpc(list2[1])*dv)+Mkpc(list2[2]);
  
  list3:=Mkc(expr-expr2);
  Echo("Subtracted ",MkMod(list3,n));
];

EndOfFile;

LocalSymbols(realvars,rest)
[
  OutBracket(_expr) <--
  [
    MM(x);
    Local(terms);
    realvars:=MultiExpressionList(expr);
    terms:=MM(expr,realvars)[2];
    coefs:=FillList(Infinity,Length(realvars));
    SparseTreeMap("OutBracketOp",Length(realvars),terms);
    rest:=0;
    SparseTreeMap("OutBracketRemove",Length(realvars),terms);
    Factorize(realvars^coefs)*rest;
  ];
  OutBracketOp(deg,coef) :=
  [ 
    If(Not(IsZero(coef)),coefs:=Map(Min,{deg,coefs}));
    coef;
  ];
  OutBracketRemove(deg,coef) :=
  [ 
    rest:=rest+coef*Factorize(realvars^(deg-coefs));
  ];
];

EndOfFile;


  Function() RuleSet'Make(name,rules);
  HoldArg(RuleSet'Make,rules);
  Bodied(RuleSet'Make,0);
  RuleSet'Make(_name)(rules_IsList) <--
  [
    Local(enabler);
    Set(enabler,Enabler(name));
    MacroSet(enabler,False);
    ForEach(rule,rules)
    [
      DeclareLocalRule(rule);
    ];
  ];
  
  Enabler(name):=  Atom(String(name):"Enabled");
  
  Function() DeclareLocalRule(rule);
  UnFence(DeclareLocalRule,1);
  
  10 # DeclareLocalRule((_n) # (_pattern)_(_post) <-- _body) 
    <--
    [ 
      `((@n) # (@pattern)_((@enabler) And (@post)) <-- (@body) ); 
    ];
  20 # DeclareLocalRule((_pattern)_(_post) <-- _body) 
    <--
    [
      `((@pattern)_((@enabler) And (@post)) <-- (@body) );
    ];
  30 # DeclareLocalRule((_n) # (_pattern) <-- _body) 
    <--
    [
      `((@n) # (@pattern)_(@enabler) <-- (@body) );
    ];
  40 # DeclareLocalRule((_pattern) <-- _body) 
    <--
    [
      `((@pattern)_(@enabler) <-- (@body) );
    ];
  
  
  RuleSet'Enable(name):=
  [
    Local(enabler);
    Set(enabler,Enabler(name));
    MacroSet(enabler,True);
  ];
  RuleSet'Disable(name):=
  [
    Local(enabler);
    Set(enabler,Enabler(name));
    MacroSet(enabler,False);
  ];


RuleSet'Make(Norbert)
{
  x_IsNumber/y_IsNumber <-- MathDivide(x,y),
  _a*_b-_b*_a <-- 0,
  0 # x_IsNumber-x_IsNumber <-- 0,  
  1 # _x - _x <-- UnList({Atom("-"),x,x})
};
//RuleSet'Enable(Norbert);


EndOfFile;

mdivide(x,y):=
[
  Local(v); MM(1);
  v:=MultiExpressionList(x+y);
  v:=MultiDivide(MM(x,v),{MM(y,v)});
//  Check(False,"fake error raised");
  {NormalForm(v[1][1]),NormalForm(v[2])};
];

mgcd(x,y):=MultiGcd(x,y);


EndOfFile;

OMReadEvalPrint():=
[
  Local(input,stringOut,result);
  While (True)
  [
    input := FromString(ReadCmdLineString("Om> "):";")Read();
    errorString := "";
    stringOut:="";
    result:=False;
    TrapError(stringOut:=ToString()[result:=Eval(input);],errorString:=GetCoreError());
    if(errorString != "") Echo("<OMOBJ><OME><OMSTR>",errorString,"</OMSTR></OME></OMOBJ>");
    if(stringOut != "") Echo("<OMOBJ><OME><OMSTR>",stringOut,"</OMSTR></OME></OMOBJ>");
    Echo(`OMForm(@result));
  ];
];



EndOfFile;


  f(n):=
  [
    Local(i,result);
    Set(result,0);
    Set(i,1);
    Set(n,MathAdd(n,1));
    While(LessThan(i,n))
    [
    WriteString("Hello world!");
      Set(result,MathAdd(result,i));
      Set(i,MathAdd(i,1));
    ];
    result;
  ];


