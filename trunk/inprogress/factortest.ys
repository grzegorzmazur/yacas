
/*

This file is a test ground for algorithms pertaining to factoring polynomials modulo
integers.
*/

// input roots, output poly
Mkp(roots):= Factorize(x-roots);

// Mkpc: input coefs, output poly
Mkpc(coefs):= NormalForm(UniVariate(x,0,coefs));

// Mkn: input roots, output roots modulo an integer
Mkn(list,n):= Mod(list,n);

// Mkc: returns list of coefficients of polynomial
// input poly, output coefficients
Mkc(poly):=
[
  poly:=MakeUni(poly,x);
  Concat(FillList(0,poly[2]),poly[3]);
];

10 # MkMod(_n,Infinity) <-- n;
20 # MkMod(_n,_m) <-- Mod(n,m);


// Division: input coefficients for polys, output coefs for quotient and remainder
Mkd(numer,denom,p):=
[
  Local(q,r,i,j,ln,ld,nq);
  DropEndZeroes(numer);
  DropEndZeroes(denom);

  numer:=Reverse(numer);
  denom:=Reverse(denom);
  ln:=Length(numer);
  ld:=Length(denom);
  q:=FillList(0,ln);
  r:=FillList(0,ln);

  i:=1;
  While(Length(numer)>=Length(denom))
  [
    nq:=MkMod(Div(numer[1],denom[1]),p);
    q[ln-(Length(numer)-ld)] := nq;
    For(j:=1,j<=Length(denom),j++)
    [
      numer[j] := MkMod(numer[j] - nq*denom[j],p);
    ];
    r[i] := MkMod(r[1] + numer[1],p);

    numer := Tail(numer);
    i++;
  ];
  For(j:=0,j<Length(numer),j++)  
  [
    r[i+j] := MkMod(r[i+j] + numer[j+1],p);
  ];
  q:=Reverse(q);
  r:=Reverse(r);
  DropendZeroes(q);
  DropendZeroes(r);
  {q,r};
];

/*
// Greatest common divisor modulo p
// input coefficients to polys n,m, and integer p
// output greatest common divisor
10 # MkGcd(_n,_m,_p)_(Length(n)<Length(m)) <-- MkGcd(m,n);
20 # MkGcd(_n,m_IsZeroVector,_p) <-- n;
30 # MkGcd(_n,_m,_p) <-- 
[
  Local(q,r);
  {q,r} := Mkd(n,m,p);
  MkGcd(m,r,p);
];
*/

BinaryFactor(polynom):=FW(SimpleFactors(polynom));
BinaryFactors(polynom):=
[
  Local(list,i,result,p,newlist,poly,nrroots);

  // Make list of coefficients
  poly:=Mkc(polynom);

  // testpoly is the square-free version of the polynomial, used for finding
  // the factors. the original polynomials is kept around to find the
  // multiplicity of the factor.
  testpoly:=Mkc(Div(polynom,Monic(Gcd(polynom,Deriv(x)polynom))));

  // resulting factors will be stored here
  result:={};
  list:={};

  // Start off with the seeds for factoring
  If(IsZeroVector(Mkd(testpoly,{0,1},2)[2]),list:=0:list);
  If(IsZeroVector(Mkd(testpoly,{-1,1},2)[2]),list:=1:list);
  p:=2;
  nrroots:=Length(poly)-1;

  While(nrroots>0 And Length(list)>0)
  [
    // check if any of the factors already divides the original polynomial
    For(i:=1,i<=Length(list),i++)
    [
      Local(lst1);
      TryFact(-list[i]);
      TryFact(-p+list[i]);
      TryFact(list[i]);
      TryFact(p-list[i]);
    ];  

    // Given the partial solutions so far (potential roots modulo p), determine 
    // new roots up to modulo 2*p. This step essentially adds one binary bit
    // to the potential solutions and checks if they are still a solution.
    newlist:={};
    For(i:=1,i<=Length(list),i++)
    [
      If(IsZeroVector(Mkd(testpoly,{-(list[i]+p),1},2*p)[2]),
        newlist:=(list[i]+p):newlist);
      If(IsZeroVector(Mkd(testpoly,{-(list[i]),1},2*p)[2]),
        newlist:=(list[i]):newlist);
    ];

//Echo(p,Length(list),list);
    // We now have a new set of potential roots, modulo 2*p
    list:=newlist;
    p:=2*p;
  ]; 

  // If the polynom is not one, it is a polynomial which is not reducible any further
  // with this algorithm, return as is.
  If(poly != {1},result:={Mkpc(poly),1}:result);

  result;  
];


/* TryFact is an utility macro used in SimpleFactors. For a polynomial 'poly'
   for which the square-free part is 'testpoly', it determines if the 'root'
   passed in is a root. If so, it is added to the list of results, and the
   macro determines the multiplicity based on 'poly'. The factor (x-root) is
   then divided out of the polynomials.
 */
Macro(TryFact,{root})
[
  lst1:=Mkd(testpoly,{-(@root),1},Infinity);
  If(IsZeroVector(lst1[2]),
    [
      testpoly:=lst1[1];
      lst1:=Mkd(poly,{-(@root),1},Infinity);
      Local(count);
      count:=0;
      While(IsZeroVector(lst1[2]))
      [
        count++;
        poly:=lst1[1];
        lst1:=Mkd(poly,{-(@root),1},Infinity);
        nrroots--;
      ];
      result:={x-(@root),count}:result;
    ]
  );
];


