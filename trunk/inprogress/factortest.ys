/*
TODO
- move to main scripts dir
- allow polys with var other than x
*/


/*

This file is a test ground for algorithms pertaining to factoring
polynomials modulo
integers.
*/

LocalSymbols(PowerMod,Mkp,Mkpc,Mkn,Mkc,MkMod,MkDiv,Mkd,MkGcd,MkExtEuclid,MkExtEuclidAux,TryFact)[


PowerMod(x_IsPositiveInteger, 
    n_IsPositiveInteger,
    m_IsPositiveInteger) <--
[
  Local(result);
  result:=1;
  x:=Mod(x,m);
  While(n != 0)
  [
    if ((n&1) = 1)
  [
      result := Mod(result*x,m);
    ];
    x := Mod(x*x,m);
    n := n>>1;
  ];
  result;
];

// input roots, output poly
Mkp(roots):= Factorize(x-roots);

// Mkpc: input coefs, output poly
Mkpc(coefs):= NormalForm(UniVariate(x,0,coefs));

// Mkn: input roots, output roots modulo an integer
Mkn(list,n):= Mod(list,n);

// Mkc: returns list of coefficients of polynomial
// input poly, output coefficients
Mkc(poly):=
[
  Set(poly,MakeUni(Expand(poly),x));
  Concat(FillList(0,poly[2]),poly[3]);
];

10 # MkMod(_n,Infinity) <-- n;
20 # MkMod(_n,_m) <-- Mod(n,m);

10 # MkDiv(_n,_m,Infinity) <-- Div(n,m);
20 # MkDiv(_n,_m,_p) <-- MkMod(n*m^(p-2),p);

// Division: input coefficients for polys, output coefs for quotient and remainder
Mkd(numer,denom,p):=
[
  Local(q,r,i,j,ln,ld,nq);

  Set(numer,MkMod(numer,p));
  Set(denom,MkMod(denom,p));

  DropEndZeroes(numer);
  DropEndZeroes(denom);

  Set(numer,Reverse(numer));
  Set(denom,Reverse(denom));
  Set(ln,Length(numer));
  Set(ld,Length(denom));
  Set(q,FillList(0,ln));
  Set(r,FillList(0,ln));

  Set(i,1);
  If(ld>0,
  [
    While(Length(numer)>=Length(denom))
    [
//      Set(nq,MkMod(Div(numer[1],denom[1]),p));
      Set(nq,MkDiv(numer[1],denom[1],p));
      q[ln-(Length(numer)-ld)] := nq;
      For(j:=1,j<=Length(denom),j++)
      [
        numer[j] := MkMod(numer[j] - nq*denom[j],p);
      ];
      r[i] := MkMod(r[1] + numer[1],p);

      Set(numer, Tail(numer));
      i++;
    ];
  ]);
  For(j:=0,j<Length(numer),j++)
  [
    r[i+j] := MkMod(r[i+j] + numer[j+1],p);
  ];
  Set(q,Reverse(q));
  Set(r,Reverse(r));
  DropEndZeroes(q);
  DropEndZeroes(r);
  {q,r};
];


// Addition: input coefficients for polys, output coefs 
Mkadd(x,y):=
[
  Local(result,i);
  Set(result,FillList(0,Max(Length(x),Length(y))));
  For(i:=1,i<=Length(x),i++) result[i]:=result[i]+x[i];  
  For(i:=1,i<=Length(y),i++) result[i]:=result[i]+y[i];  
  DropEndZeroes(result);
  result;
];

// Multiplication: input coefficients for polys, output coefs 
Mkmul(x,y):=
[
  Local(result,i,j);
  Set(result,FillList(0,Length(x)+Length(y)));
  For(i:=1,i<=Length(x),i++) 
  [
    For(j:=1,j<=Length(y),j++) 
      result[i+j-1]:=result[i+j-1]+x[i]*y[j];  
  ];
  DropEndZeroes(result);
  result;
];


// Greatest common divisor modulo p
// input coefficients to polys n,m, and integer p
// output greatest common divisor
10 # MkGcd(_n,_m,_p)_(Length(n)<Length(m)) <-- MkGcd(m,n,p);
20 # MkGcd(_n,m_IsZeroVector,_p) <-- n;
30 # MkGcd(_n,_m,_p) <--
[
  Local(q,r);
  {q,r} := Mkd(n,m,p);

  [
    Local(u,i);
    Set(u,1);
    For(i:=1,i<p,i++)
      If(Mod(i*r[Length(r)],p) = 1,Set(u,i));
    Set(r,Mod(r*u,p));
  ];

//  Echo("(n,m) = ",n,m,"(q,r) = ",q,r);
  If(Length(r)>=Length(m),{1},MkGcd(m,r,p));
];


10 # MkExtEuclid(_n,_m,_p)_(Length(n) < Length(m))
   <--
   [
     Local(res);
     Set(res,MkExtEuclid(m,n,p));
     {res[2],res[1],res[3]};
   ];
20 # MkExtEuclid(_n,_m,_p)
   <-- MkExtEuclidAux(p,{{1},{},n},{{},{1},m},{0,0,0});
10 # MkExtEuclidAux(_p,_u,_v,_t)_IsZeroVector(v[3])
   <-- u;
20 # MkExtEuclidAux(_p,_u,_v,_t) <--
[
  Local(q,r);
  {q,r} := Mkd(u[3],v[3],p);

  [
    Local(uu,i);
    Set(uu,1);
    For(i:=1,i<p,i++)
      If(Mod(i*r[Length(r)],p) = 1,Set(uu,i));
    Set(r,Mod(r*uu,p));
  ];


  Set(t,{
       Mod(Mkc(Mkpc(u[1])-Mkpc(v[1])*Mkpc(q)),p),
       Mod(Mkc(Mkpc(u[2])-Mkpc(v[2])*Mkpc(q)),p),
       Mod(Mkc(Mkpc(u[3])-Mkpc(v[3])*Mkpc(q)),p)
     });
   Set(u,v);
   Set(v,t);
//  Echo("(n,m) = ",n,m,"(q,r) = ",q,r);
  If(Length(v[3])>=Length(u[3]),u,MkExtEuclidAux(p,u,v,t));
];






BinaryFactor(polynom):=FW(BinaryFactors(polynom));
BinaryFactors(polynom):=
[
  Local(list,i,result,p,newlist,poly,nrroots,unrat,leadingcoef,lowestcoef,an,origdegree);
  Set(result,{});

  // Make list of coefficients
  Set(poly,Mkc(polynom));

  Set(unrat,Lcm(MapSingle("Denom",poly)));
  Set(poly,unrat*poly);

  Set(origdegree,Length(poly)-1);
  Set(an,poly[Length(poly)]);
  //Echo("poly = ",poly);
  Set(poly,poly* (an^((origdegree-1) .. -1)));
  //Echo("monic poly = ",poly);
  Set(polynom,Mkpc(poly));
  Set(andiv,an^(origdegree-1));

  Set(leadingcoef,poly[Length(poly)]);
  [ 
    Local(i);
    Set(i,1);
    Set(lowestcoef,Abs(poly[i]));
    While (lowestcoef = 0 And i<=Length(poly))
    [
      Set(i,i+1);
      Set(lowestcoef,Abs(poly[i]));
    ];
  ];
  // testpoly is the square-free version of the polynomial, used for finding
  // the factors. the original polynomials is kept around to find the
  // multiplicity of the factor.
  Set(testpoly,Mkc(Div(polynom,Monic(Gcd(polynom,Deriv(x)polynom)))));

  [
    Local(gcd);
    Set(gcd,Gcd(testpoly));
    If(testpoly[Length(testpoly)] < 0,Set(gcd, gcd * -1));
    Set(testpoly,testpoly/gcd);
  ];
//TODO remove?  Set(isMonic, True);
//TODO remove?  If(Abs(testpoly[Length(testpoly)]) != 1,Set(isMonic,False));


//Echo("testpoly = ",testpoly);

  // resulting factors will be stored here
  Set(list,{});

  // Start off with the seeds for factoring
  If(IsZeroVector(Mkd(testpoly,{0,1},2)[2]),Set(list,{0,1}:list));
  If(IsZeroVector(Mkd(testpoly,{1,1},2)[2]),Set(list,{1,1}:list));
  If(IsZeroVector(Mkd(testpoly,{1,0},2)[2]),Set(list,{1,0}:list));
  If(IsZeroVector(Mkd(testpoly,{0,0},2)[2]),Set(list,{0,0}:list));

//Echo("initial list = ",list);

  Set(p,2);
  Set(nrroots,Length(poly)-1);

  While(nrroots>0 And Length(list)>0)
  [
    Local(pp);
    Set(pp,(2*p));
//    Set(pp,NextPrime(2*p));
//    Set(pp,NextPrime(p));

    // check if any of the factors already divides the original polynomial
    For(i:=1,i<=Length(list),i++)
    [
      Local(lst1);

      TryFact({-p+list[i][1],list[i][2]});
      TryFact({list[i][1],list[i][2]});

/*TODO remove?
      If(Not(isMonic),
      [
        TryFact({-p+list[i][1],p+list[i][2]});
        TryFact({list[i][1],p+list[i][2]});
      ]);
*/
    ];

    // Given the partial solutions so far (potential roots modulo p), determine
    // new roots up to modulo 2*p. This step essentially adds one binary bit
    // to the potential solutions and checks if they are still a solution.
    Set(newlist,{});

//Echo("testpoly is ",testpoly);

    For(i:=1,i<=Length(list),i++)
    [
      If(Not(list[i] = {1,0} And p>leadingcoef),
      [

/*
If(p=2 And list[i] = {1,1},
[
  Echo("GOT ",list[i]," ",p," ",pp," ",Mkd(testpoly,{(list[i][1]),list[i][2]+p},pp));
]);
If(p=4 And list[i] = {0,1},
[
  Echo("GOT ",lowestcoef,list[i]," ",p," ",pp," ",Mkd(testpoly,{(list[i][1]+p),list[i][2]},pp));
]);
*/
        If(p<=lowestcoef And IsZeroVector(Mkd(testpoly,{(list[i][1]+p),list[i][2]},pp)[2]),
	  		  Set(newlist,{(list[i][1]+p),list[i][2]}:newlist));
        If(IsZeroVector(Mkd(testpoly,{(list[i][1]),list[i][2]},pp)[2]),
			    Set(newlist,{(list[i][1]),list[i][2]}:newlist));
      ]);
/*TODO remove?
      If(Not(isMonic),
      [
        If(p<=lowestcoef And IsZeroVector(Mkd(testpoly,{(list[i][1]+p),list[i][2]+p},pp)[2]),
          Set(newlist,{(list[i][1]+p),list[i][2]+p}:newlist));
        If(IsZeroVector(Mkd(testpoly,{(list[i][1]),list[i][2]+p},pp)[2]),
          Set(newlist,{(list[i][1]),list[i][2]+p}:newlist));
      ]);
*/
    ];

    Set(newlist,RemoveDuplicates(newlist));

    // We now have a new set of potential roots, modulo 2*p
    Set(list,newlist);

    Set(p,2*p);

//Echo("Solutions modulo ",p," with ",Length(list),"potential solutions",list);
//Echo("     with current result ",result);
//Echo("testpoly is ",testpoly);
  ];

  // If the polynom is not one, it is a polynomial which is not reducible any further
  // with this algorithm, return as is.

//Echo("andiv = ",andiv," an = ",an);
  Set(poly,poly*an^(0 .. (Length(poly)-1)));
  Set(poly,poly/(unrat * andiv ));
  If(poly != {1},Set(result,{Mkpc(poly),1}:result));

  result;
];


/* TryFact is an utility macro used in SimpleFactors. For a polynomial
'poly'
   for which the square-free part is 'testpoly', it determines if the
'root'
   passed in is a root. If so, it is added to the list of results, and the
   macro determines the multiplicity based on 'poly'. The factor (x-root)
is
   then divided out of the polynomials.
 */
Macro(TryFact,{root})
[
  If((@root)[2] != 0,
  [
    Set(lst1,Mkd(testpoly,(@root),Infinity));
    If(IsZeroVector(lst1[2]),
      [
//Echo("testpoly1 ",testpoly);
        Set(testpoly,lst1[1]);
//Echo("testpoly2 ",testpoly);
        Set(lst1,Mkd(poly,(@root),Infinity));
        Local(count);
        Set(count,0);
        While(IsZeroVector(lst1[2]))
        [
          count++;
          Set(poly,lst1[1]);
          Set(lst1,Mkd(poly,(@root),Infinity));
          nrroots--;
        ];
        Local(lgcd);
        Set(lgcd,Gcd({andiv,an*(@root)[2],(@root)[1]}));
        Set(result,{Div(an*(@root)[2],lgcd)*x+Div((@root)[1],lgcd),count}:result);
        Set(andiv,Div(andiv,lgcd^count));
      ]
    );
  ]);
];

Mkmonic(poly):=
[
  Local(lc);
  lc:=poly[Length(poly)];
  poly*(lc^((Length(poly)-2) .. -1));
];

nthroot(x,n):=
[
  Local(s,t,g,p,l,ln,pp);
  Set(l,1);  Set(p,2);  Set(ln,1);
  While ((1<<(n*p))<x) [Set(p,MathMultiply(p,2));Set(ln,MathAdd(ln,1));];
  Set(t,1);  Set(g,1);  Set(s,1);  Set(pp,p);
  While(l<=ln)
  [
    Set(g,MathMod(g-(t*g-x)*s,pp));
    If(LessThan(g,0),Set(g,MathAdd(g,pp)));
    Set(t,PowerMod(g,(n-1),pp*p));
    If(LessThan(t,0),Set(t,MathAdd(t,pp*p)));
    Set(s,MathMod(2*s-n*t*s*s,pp));
    If(LessThan(s,0),Set(s,MathAdd(s,pp)));
    Set(l,MathAdd(l,1));
    Set(pp,MathMultiply(p,pp));
  ];
  g;
];



];

