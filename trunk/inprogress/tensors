
/* Tell the Yacas interpreter that Td is to be used as Td(i)f */
Bodied("Td",60000); 

/* And the simplificaiton rules for X, addition, subtraction
   and multiplication */
/*
10 # (Td(_i)X(_j)) <-- Delta(i,j);
10 # (Td(_i) ( (_f) + (_g) ) ) <-- (Td(i)f) + (Td(i)g);
10 # (Td(_i) ( (_f) - (_g) ) ) <-- (Td(i)f) - (Td(i)g);
10 # (Td(_i) (      - (_g) ) ) <--          -  Td(i)g;
10 # (Td(_i) ( (_f) * (_g) ) ) <-- (Td(i)f)*g + f*(Td(i)g);
*/

/*
5  # Rot(_ii,_ii,_jj,_jj,_angle) <-- 1;
6  # Rot(_ii,_ii,_jj,_kk,_angle) <-- 0;
10 # Rot(_ii,_jj,_ii,_ii,_angle) <-- Cos(angle);
10 # Rot(_ii,_jj,_ii,_jj,_angle) <-- -Sin(angle);
10 # Rot(_ii,_jj,_jj,_ii,_angle) <-- Sin(angle);
10 # Rot(_ii,_jj,_jj,_jj,_angle) <-- Cos(angle);
20 # Rot(_ii,_jj,kk_IsInteger,_kk,_angle)_
     (kk!= ii And kk != jj) <-- 1;

30 # Rot(ii_IsInteger,jj_IsInteger,kk_IsInteger,ll_IsInteger,_angle)_
  (kk != ii And kk != jj) <-- 0;
30 # Rot(ii_IsInteger,jj_IsInteger,kk_IsInteger,ll_IsInteger,_angle)_
  (ll != ii And ll != jj) <-- 0;
*/



/*
f1(i,a):=Eval(TExplicitSum(8)TSum({j})Rot(2,5,i,j,a)*X(j));
f2(i,a1,a2):=Eval(TExplicitSum(16)TSum({j,k})Rot(2,5,i,j,a1)*Rot(5,3,j,k,a2));
*/


/*
10 # g(1,1) <-- 1;
20 # g(i_IsInteger,_i) <-- -1;
30 # g(i_IsInteger,j_IsInteger) <-- 0;
*/


TST(_f) <--
[
  ToFile("dummy.tex")
  [
    Echo({"\\documentclass{article}"});
    Echo({"\\begin{document}"});
    Echo({TeXForm(f)});
    Echo({"\\end{document}"});
  ];
  SystemCall("latex dummy.tex");
  SystemCall("xdvi dummy.dvi");
];



/*


In> RuleBase("f",{a,b})   # define a rule base from the command line
Out> True;
In> RuleBaseArgList("f",2)  # get the list of arguments
Out> {a,b};
In> RuleBaseDefined("f",2)  # check that the function f with 2 arguments is defined (In a RuleBase sense)
Out> True;
In> RuleBaseDefined("f",3)  # check that this is not so for f with 3 arguments
Out> False;
In> MakeVector(a,3)   # create a vector {a1,a2,a3}
Out> {a1,a2,a3};
In> func:="f"
Out> "f";
In> MacroRuleBase(func,MakeVector(a,3))  # MacroRuleBase (can be used to programmatically define a function)
Out> True;
In> RuleBaseDefined("f",3)
Out> True;
In> RuleBaseArgList("f",3)
Out> {a1,a2,a3};



*/



RuleBase("IsTensor", {x});
Rule("IsTensor", 1, 20, True) False;

Function("DefineTensor", {t})
[
  Local(predicate);
/* Add an IsTensor rule at 15 # */

  predicate:=Subst(type,Type(t))
               Subst(nrargs,NrArgs(t))
                 Hold(IsFunction(x) And Type(x)=type And NrArgs(x)=nrargs);
  MacroRule("IsTensor", 1, 15, predicate) True;
];


/*
In> IsTensor(A(i,j))
Out> False;
In> DefineTensor(A(i,j))
Out> True;
In> IsTensor(A(i,j))
Out> True;
*/






