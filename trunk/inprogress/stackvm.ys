
/*
TODO:
x Yank in the other routines I defined so far.
x support for passing arguments
- finish the simulator:
  - not only adding frame, but also pointer to global (or placeholder), and start of code block,
    so we can simulate name spaces, and jumping to other name spaces.
  - typing: declare types, and act correspondingly. Compiler also has to deal with type conversions!
- dynamically extending the list of functions you can call.
- C++ version of the VM
  - API:
    - create a stack
      - function to create a stack with initial arguments on it.
    - create a code array type
      - create a function to add ops to the stack.
      - Create a function to execute a code block with stack
*/



Macro()CompileExpression(expression);
//5 # CompileExpression(_rest) <-- Echo("PExpr is ",@PExpr);
10 # CompileExpression(_x + _y) <-- [CompileExpression(@x);CompileExpression(@y);@PExpr("AddFloats");];
10 # CompileExpression(_x - _y) <-- [CompileExpression(@x);CompileExpression(@y);@PExpr("NegFloat");@PExpr("AddFloats");];
10 # CompileExpression(   - _y) <-- [         CompileExpression(@y);@PExpr("NegFloat");];
10 # CompileExpression(_x * _y) <-- [CompileExpression(@x);CompileExpression(@y);@PExpr("MulFloats");];
10 # CompileExpression(_x / _y) <-- [CompileExpression(@x);CompileExpression(@y);@PExpr("DivFloats");];
10 # CompileExpression(_x ^ _y) <-- [CompileExpression(@x);CompileExpression(@y);@PExpr("PowFloats");];

10 # CompileExpression(Sin(_x)) <-- [CompileExpression(@x);@PExpr("SinFloat");];
10 # CompileExpression(Cos(_x)) <-- [CompileExpression(@x);@PExpr("CosFloat");];
10 # CompileExpression(Tan(_x)) <-- [CompileExpression(@x);@PExpr("TanFloat");];

10 # CompileExpression(ArcSin(_x)) <-- [CompileExpression(@x);@PExpr("AsinFloat");];
10 # CompileExpression(ArcCos(_x)) <-- [CompileExpression(@x);@PExpr("AcosFloat");];
10 # CompileExpression(ArcTan(_x)) <-- [CompileExpression(@x);@PExpr("AtanFloat");];

10 # CompileExpression(Exp(_x))    <-- [CompileExpression(@x);@PExpr("ExpFloat");];
10 # CompileExpression(Ln(_x))     <-- [CompileExpression(@x);@PExpr("LnFloat");];

20 # CompileExpression(x_IsNumber) <-- [@PExpr("PushFloat");@PExpr(@x);];
30 # CompileExpression(x_IsAtom)_Contains(args,x) <-- 
[
  @PExpr("GetArg");
  Local(id);
  Set(id,Find(@args,@x));
  Apply(PExpr,{id});
];

100 # CompileExpression(_rest) <-- Check(False,ToString()Echo("Can not compile expression ",@rest));

UnFence("CompileExpression",1);

Macro("Compile",{ar,expr})
[
  Local(PExpr);
  Local(code,args);
  args:= @ar;
  code:={};
  PExpr := Hold({{n},DestructiveAppend(code,n)});
  CompileExpression(@expr);
  Apply(PExpr,{"Return"});
  code;
];

VMStack'New() <-- {};
VMStack'Push(_stack,_object) <-- Push(stack,object);
VMStack'Pop(_stack) <-- PopFront(stack);

VMStack'PushArguments(_stack,args_IsList) <--
[
  VMStack'Push(stack,Length(stack));
  Local(i);
  For(i:=1,i<=Length(args),i++) VMStack'Push(stack,args[i]);
  stack;  
];

RunFunction(_code,_stack,_pc,_st) <--
[
  Local(op);
  While (st>0)
  [
    Set(op,OpCode());
    `ExecOp(@op);
  ];
  VMStack'Pop(stack);
];
Macro(OpCode,{})
[
  Local(result);
  result:=code[pc];
  pc++;
  result;
];

Macro()ExecOp(op);
ExecOp("PushFloat") <-- VMStack'Push(stack,OpCode());
ExecOp("NegFloat") <-- VMStack'Push(stack,-(VMStack'Pop(stack)));

ExecOp("SinFloat") <-- VMStack'Push(stack,MathSin(VMStack'Pop(stack)));
ExecOp("CosFloat") <-- VMStack'Push(stack,MathCos(VMStack'Pop(stack)));
ExecOp("TanFloat") <-- VMStack'Push(stack,MathTan(VMStack'Pop(stack)));
ExecOp("ExpFloat") <-- VMStack'Push(stack,MathExp(VMStack'Pop(stack)));

ExecOp("AsinFloat") <-- VMStack'Push(stack,MathArcSin(VMStack'Pop(stack)));
ExecOp("AcosFloat") <-- VMStack'Push(stack,MathArcCos(VMStack'Pop(stack)));
ExecOp("AtanFloat") <-- VMStack'Push(stack,MathArcTan(VMStack'Pop(stack)));
ExecOp("LnFloat") <-- VMStack'Push(stack,MathLn(VMStack'Pop(stack)));

ExecOp("AddFloats") <-- VMStack'Push(stack,MathAdd(VMStack'Pop(stack),VMStack'Pop(stack)));
ExecOp("MulFloats") <-- VMStack'Push(stack,MathMultiply(VMStack'Pop(stack),VMStack'Pop(stack)));
ExecOp("DivFloats") <-- 
[
  Local(x,y);
  Set(y,VMStack'Pop(stack));
  Set(x,VMStack'Pop(stack));
  VMStack'Push(stack,MathDivide(x,y));
];

ExecOp("PowFloats") <-- 
[
  Local(x,y);
  Set(y,VMStack'Pop(stack));
  Set(x,VMStack'Pop(stack));
  VMStack'Push(stack,MathPower(x,y));
];

ExecOp("Return") <-- 
[
  Local(result,frame);
  Set(result,VMStack'Pop(stack));
  While(Length(stack) > st)
  [
    VMStack'Pop(stack);
  ];
  Set(st,VMStack'Pop(stack));
  VMStack'Push(stack,result);
];


ExecOp("GetArg") <-- 
[
  Local(index,value);
  Set(index,OpCode());
  Set(value,stack[Length(stack)+1-st-index]);
//Echo("Getting arg nr ",index," value is ",value);
  VMStack'Push(stack,value);
];


/*
code := Compile({},Sin(2)+3^4)
RunFunction(code,VMStack'PushArguments(VMStack'New(),{}),1,1);
*/

PushArgs(args) := VMStack'PushArguments(VMStack'New(),args);
CompileFn(fname,args,body) :=
[
  Local(code);
  code := `Compile(@args,@body);
//Echo("Code is ");
//Write(code);
  `(Function(@fname,@args)RunFunction(@code,PushArgs(@args),1,1));

];


