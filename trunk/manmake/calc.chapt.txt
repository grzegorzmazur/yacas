
			Calculus and elementary functions

*INTRO In this chapter, some facilities for doing calculus are
described. These include functions implementing differentiation,
integration, standard mathematical functions, and solving of
equations.

*CMD Sin, Cos, Tan --- trigonometric functions
*STD
*CALL
	Sin(x)
	Cos(x)
	Tan(x)

*PARMS

{x} -- argument to the function, in radians

*DESC

These functions represent the trigonometric functions sine, cosine,
and tangent respectively. Yacas leaves them alone even if x is a
number, trying to keep the result as exact as possible. The floating
point approximations of these functions can be forced by using the {N} function.

Yacas knows some trigonometric identities, so it can simplify to exact
results even if {N} is not used. This is the case, for instance,
when the argument is a multiple of $Pi$/6 or $Pi$/4.

These functions are threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),20)
	Out> 0.84147098480789650665;
	In> Sin(Pi/4)
	Out> Sqrt(2)/2;

*SEE ArcSin, ArcCos, ArcTan, N, Pi

*CMD ArcSin, ArcCos, ArcTan --- inverse trigonometric functions
*STD
*CALL
	ArcSin(x)
	ArcCos(x)
	ArcTan(x)

*PARMS

{x} -- argument to the function

*DESC

These functions represent the inverse trigonometric functions. For
instance, the value of $ArcSin(x)$ is the number $y$ such that
$Sin(y)$ equals $x$.

Note that the number $y$ is not unique. For instance, $Sin(0)$ and
$Sin(Pi)$ both equal 0, so what should $ArcSin(0)$ be? In Yacas,
it is agreed that the value of $ArcSin(x)$ should be in the interval
[-$Pi$/2,$Pi$/2]. The same goes for $ArcTan(x)$. However, $ArcCos(x)$
is in the interval [0,$Pi$].

Usually, Yacas leaves these functions alone unless it is forced to do
a numerical evaluation by the {N} function. If the
argument is -1, 0, or 1 however, Yacas will simplify the
expression. If the argument is complex,  the expression will be
rewritten using the {Ln} function.

These functions are threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> ArcSin(1)
	Out> Pi/2;
	
	In> ArcSin(1/3)
	Out> ArcSin(1/3);
	In> Sin(ArcSin(1/3))
	Out> 1/3;
	
	In> x:=N(ArcSin(0.75))
	Out> 0.848062;
	In> N(Sin(x))
	Out> 0.7499999477;

*SEE Sin, Cos, Tan, N, Pi, Ln

*CMD Exp --- exponential function
*STD
*CALL
	Exp(x)

*PARMS

{x} -- argument to the function

*DESC

This function calculates $e$ raised to the power $x$, where $e$ is the
mathematic constant 2.71828... One can use {Exp(1)}
to represent $e$.

This function is threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Exp(0)
	Out> 1;
	In> Exp(I*Pi)
	Out> -1;
	In> N(Exp(1))
	Out> 2.7182818284;

*SEE Ln, Sin, Cos, Tan, N

*CMD Ln --- natural logarithm
*STD
*CALL
	Ln(x)

*PARMS

{x} -- argument to the function

*DESC

This function calculates the natural logarithm of "x". This is the
inverse function of the exponential function, {Exp}, i.e. $Ln(x) = y$ implies that $Exp(y) = x$. For complex
arguments, the imaginary part of the logarithm is in the interval
(-$Pi$,$Pi$]. This is compatible with the branch cut of {Arg}.

This function is threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Ln(1)
	Out> 0;
	In> Ln(Exp(x))
	Out> x;
	In> D(x) Ln(x)
	Out> 1/x;

*SEE Exp, Arg

*CMD Sqrt --- square root
*STD
*CALL
	Sqrt(x)

*PARMS

{x} -- argument to the function

*DESC

This function calculates the square root of "x". If the result is
not rational, the call is returned unevaluated unless a numerical
approximation is forced with the {N} function. This
function can also handle negative and complex arguments.

This function is threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Sqrt(16)
	Out> 4;
	In> Sqrt(15)
	Out> Sqrt(15);
	In> N(Sqrt(15))
	Out> 3.8729833462;
	In> Sqrt(4/9)
	Out> 2/3;
	In> Sqrt(-1)
	Out> Complex(0,1);

*SEE Exp, ^, N

*CMD Abs --- absolute value or modulus
*STD
*CALL
	Abs(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the absolute value (also called the modulus) of
"x". If "x" is positive, the absolute value is "x" itself; if
"x" is negative, the absolute value is "-x". For complex "x",
the modulus is the "r" in the polar decomposition
$x = r *Exp(I*phi)$.

This function is connected to the {Sign} function by
the identity "Abs(x) * Sign(x) = x" for real "x".

This function is threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Abs(2);
	Out> 2;
	In> Abs(-1/2);
	Out> -1/2;
	In> Abs(3+4*I);
	Out> 5;

*SEE Sign, Arg

*CMD Sign --- sign of a number
*STD
*CALL
	Sign(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the sign of the real number $x$. It is "1"
for positive numbers and "-1" for negative numbers. Somewhat
arbitrarily, {Sign(0)} is defined to be 1.

This function is connected to the {Abs} function by
the identity $Abs(x) * Sign(x) = x$ for real $x$.

This function is threaded, meaning that if the argument {x} is a
list, the function is applied to all entries in the list.

*E.G.

	In> Sign(2)
	Out> 1;
	In> Sign(-3)
	Out> -1;
	In> Sign(0)
	Out> 1;
	In> Sign(-3) * Abs(-3)
	Out> -3;

*SEE Arg, Abs

*CMD Complex --- construct a complex number
*STD
*CALL
	Complex(r, c)

*PARMS

{r} -- real part

{c} -- imaginary part

*DESC

This function represents the complex number "r + I*c", where "I"
is the imaginary unit. It is the standard representation used in Yacas
to represent complex numbers. Both "r" and "c" are supposed to be
real.

Note that, at the moment, many functions in Yacas assume that all
numbers are real unless it is obvious that it is a complex
number. Hence {Im(Sqrt(x))} evaluates to {0} which is only true for nonnegative "x".

*E.G.

	In> I
	Out> Complex(0,1);
	In> 3+4*I
	Out> Complex(3,4);
	In> Complex(-2,0)
	Out> -2;

*SEE Re, Im, I, Abs, Arg

*CMD Re --- real part of a complex number
*STD
*CALL
	Re(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the real part of the complex number "x".

*E.G.

	In> Re(5)
	Out> 5;
	In> Re(I)
	Out> 0;
	In> Re(Complex(3,4))
	Out> 3;

*SEE Complex, Im

*CMD Im --- imaginary part of a complex number
*STD
*CALL
	Im(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the imaginary part of the complex number "x".

*E.G.

	In> Im(5)
	Out> 0;
	In> Im(I)
	Out> 1;
	In> Im(Complex(3,4))
	Out> 4;

*SEE Complex, Re

*CMD I --- imaginary unit
*STD
*CALL
	I

*DESC

This symbol represents the imaginary unit, which equals the square
root of -1. It evaluates to {Complex(0,1)}.

*E.G.

	In> I
	Out> Complex(0,1);
	In> I = Sqrt(-1)
	Out> True;

*SEE Complex

*CMD Conjugate --- complex conjugate
*STD
*CALL
	Conjugate(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the complex conjugate of "x". The complex
conjugate of $a + I*b$ is $a - I*b$. This function assumes that all
unbound variables are real.

*E.G.

	In> Conjugate(2)
	Out> 2;
	In> Conjugate(Complex(a,b))
	Out> Complex(a,-b);

*SEE Complex, Re, Im

*CMD Arg --- argument of a complex number
*STD
*CALL
	Arg(x)

*PARMS

{x} -- argument to the function

*DESC

This function returns the argument of "x". The argument is the angle
with the positive real axis in the Argand diagram, or the angle
"phi" in the polar representation $r * Exp(I*phi)$ of "x". The
result is in the range ($-Pi$, $Pi$], that is, excluding $-Pi$ but including $Pi$. The
argument of 0 is {Undefined}.

*E.G.

	In> Arg(2)
	Out> 0;
	In> Arg(-1)
	Out> Pi;
	In> Arg(1+I)
	Out> Pi/4;

*SEE Abs, Sign

*CMD RootsOfUnity --- find the $n$ complex roots of unity
*STD
*CALL
	RootsOfUnity(n)

*PARMS

{n} -- positive integer

*DESC

This function returns the list of $n$ roots of unity. The first
element of this list is the primitive $n$-th root of unity, and the last element is simply {1}.

*E.G.
	In> RootsOfUnity(3)
	Out> {Complex(-1/2,Sqrt(3/4)),Complex(-1/2,-Sqrt(3/4)),1};
	In> RootsOfUnity(1)
	Out> {1};
	In> RootsOfUnity(2)
	Out> {-1,1};

*SEE I, Complex 


*CMD !, !!, ***, Subfactorial  --- factorial and related functions
*STD
*CALL
	n!
	n!!
	a *** b
	Subfactorial(m)

*PARMS

{m} -- integer
{n} -- integer, half-integer, or list
{a}, {b} -- numbers

*DESC

The factorial function {n!} calculates the factorial of integer or half-integer numbers. For
nonnegative integers, $n! := n*(n-1)*(n-2)*...*1$. The factorial of
half-integers is defined via Euler's Gamma function, $z! := Gamma(z+1)$. If $n=0$ the function returns $1$.

The "double factorial" function {n!!} calculates $n*(n-2)*(n-4)*...$. This product terminates either with $1$ or with $2$ depending on whether $n$ is odd or even. If $n=0$ the function returns $1$.

The "partial factorial" function {a *** b} calculates the product $a*(a+1)*...$ which is terminated at the least integer not greater than $b$. The arguments $a$ and $b$ do not have to be integers; for integer arguments, {a *** b} = $b! / (a-1)!$. This function is sometimes a lot faster than evaluating the two factorials, especially if $a$ and $b$ are close together. If $a>b$ the function returns $1$.

The {Subfactorial} function can be interpreted as the  number of permutations of {m} objects in which no object 
appears in its natural place, also called "derangements." 

The factorial functions are threaded, meaning that if the argument {n} is a
list, the function will be applied to each element of the list.

Note: For reasons of Yacas syntax, the factorial sign {!} cannot precede other
non-letter symbols such as {+} or {*}. Therefore, you should enter a space
after {!} in expressions such as {x! +1}.

The factorial functions terminate and print an error message if the arguments are too large (currently the limit is $n < 65535$) because exact factorials of such large numbers are computationally expensive and most probably not useful. One can call {LnGammaNum()} to evaluate logarithms of such factorials to desired precision.

*E.G.

	In> 5!
	Out> 120;
	In> 1 * 2 * 3 * 4 * 5
	Out> 120;
	In> (1/2)!
	Out> Sqrt(Pi)/2;
	In> 7!!;
	Out> 105;
	In> 1/3 *** 10;
	Out> 17041024000/59049;
	In> Subfactorial(10)
	Out> 1334961;


*SEE Bin, Factorize, Gamma, !!, ***, Subfactorial

*CMD Bin --- binomial coefficients
*STD
*CALL
	Bin(n, m)

*PARMS

{n}, {m} -- integers

*DESC

This function calculates the binomial coefficient "n" above
"m", which equals $$n! / (m! * (n-m)!)$$

This is equal to the number of ways
to choose "m" objects out of a total of "n" objects if order is
not taken into account. The binomial coefficient is defined to be zero
if "m" is negative or greater than "n"; {Bin(0,0)}=1.

*E.G.

	In> Bin(10, 4)
	Out> 210;
	In> 10! / (4! * 6!)
	Out> 210;

*SEE !, Eulerian

*CMD Eulerian --- Eulerian numbers
*STD
*CALL
	Eulerian(n,m)

*PARMS

{n}, {m} --- integers

*DESC

The Eulerian numbers can be viewed as a generalization of the binomial coefficients,
and are given explicitly by $$ Sum(j,0,k+1,(-1)^j*Bin(n+1,j)*(k-j+1)^n) $$ .

*E.G.

	In> Eulerian(6,2)
	Out> 302;
	In> Eulerian(10,9)
	Out> 1;

*SEE Bin


*CMD Add --- find sum of a list of values
*STD
*CALL
	Add(val1, val2, ...)
	Add({list})

*PARMS

{val1}, {val2} -- expressions

{{list}} -- list of expressions to add

*DESC

This function adds all its arguments and returns their sum. It accepts any
number of arguments. The arguments can be also passed as a list.

*E.G.

	In> Add(1,4,9);
	Out> 14;
	In> Add(1 .. 10);
	Out> 55;

*SEE Average

*CMD Sum --- find sum of a sequence
*STD
*CALL
	Sum(var, from, to, body)

*PARMS

{var} -- variable to iterate over

{from} -- integer value to iterate from

{to} -- integer value to iterate up to

{body} -- expression to evaluate for each iteration

*DESC

The command finds the sum of the sequence generated by an iterative formula. 
The expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" up to "to", and the sum of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".

Warning: {Sum} does not evaluate its arguments {var} and {body} until the actual loop is run.

*E.G.

	In> Sum(i, 1, 3, i^2);
	Out> 14;

*SEE Factorize

*CMD Average --- average of a list of values
*STD
*CALL
	Average(list)

*PARMS

{list} -- list of values to average

*DESC

This command calculates the (arithmetical) average of all the entries in
"list", which is the sum of all entries divided by the number of
entries.

*E.G.

	In> Average({1,2,3,4,5});
	Out> 3;
	In> Average({2,6,7});
	Out> 5;

*SEE Add

*CMD Factorize --- product of a list of values
*STD
*CALL
	Factorize(list)
	Factorize(var, from, to, body)

*PARMS

{list} -- list of values to multiply

{var} -- variable to iterate over

{from} -- integer value to iterate from

{to} -- integer value to iterate up to

{body} -- expression to evaluate for each iteration

*DESC

The first form of the {Factorize} command simply
multiplies all the entries in "list" and returns their product.

If the second calling sequence is used, the expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" up to "to", and the product of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".

*E.G.

	In> Factorize({1,2,3,4});
	Out> 24;
	In> Factorize(i, 1, 4, i);
	Out> 24;

*SEE Sum, Apply

*CMD Min --- minimum of a number of values
*STD
*CALL
	Min(x,y)
	Min(list)

*PARMS

{x}, {y} -- pair of values to determine the minimum of

{list} -- list of values from which the minimum is sought

*DESC

This function returns the minimum value of its argument(s). If the
first calling sequence is used, the smaller of "x" and "y" is
returned. If one uses the second form, the smallest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.

*E.G.

	In> Min(2,3);
	Out> 2;
	In> Min({5,8,4});
	Out> 4;

*SEE Max, Sum, Average

*CMD Max --- maximum of a number of values
*STD
*CALL
	Max(x,y)
	Max(list)

*PARMS

{x}, {y} -- pair of values to determine the maximum of

{list} -- list of values from which the maximum is sought

*DESC

This function returns the maximum value of its argument(s). If the
first calling sequence is used, the larger of "x" and "y" is
returned. If one uses the second form, the largest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.

*E.G.

	In> Max(2,3);
	Out> 3;
	In> Max({5,8,4});
	Out> 8;

*SEE Min, Sum, Average

*CMD IsZero --- test whether argument is zero
*STD
*CALL
	IsZero(n)

*PARMS

{n} -- number to test

*DESC

{IsZero(n)} evaluates to {True} if
"n" is zero. In case "n" is not a number, the function returns
{False}.

*E.G.

	In> IsZero(3.25)
	Out> False;
	In> IsZero(0)
	Out> True;
	In> IsZero(x)
	Out> False;

*SEE IsNumber, IsNotZero

*CMD IsRational --- test whether argument is a rational
*STD
*CALL
	IsRational(expr)

*PARMS

{expr} -- expression to test

*DESC

This commands tests whether the expression "expr" is a rational
number. This is the case if the top-level operator of "expr" is {/}.

*E.G.

	In> IsRational(5)
	Out> False;
	In> IsRational(2/7)
	Out> True;
	In> IsRational(a/b)
	Out> True;
	In> IsRational(x + 1/x)
	Out> False;

*SEE Numer, Denom

*CMD Numer --- numerator of an expression
*STD
*CALL
	Numer(expr)

*PARMS

{expr} -- expression to determine numerator of

*DESC

This function determines the numerator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns this number. If "expr" is neither
rational nor numeric, the function returns unevaluated.

*E.G.

	In> Numer(2/7)
	Out> 2;
	In> Numer(a / x^2)
	Out> a;
	In> Numer(5)
	Out> 5;

*SEE Denom, IsRational, IsNumber

*CMD Denom --- denominator of an expression
*STD
*CALL
	Denom(expr)

*PARMS

{expr} -- expression to determine denominator of

*DESC

This function determines the denominator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns {1}. If "expr" is
neither rational nor numeric, the function returns unevaluated.

*E.G.

	In> Denom(2/7)
	Out> 7;
	In> Denom(a / x^2)
	Out> x^2;
	In> Denom(5)
	Out> 1;

*SEE Numer, IsRational, IsNumber

*CMD Commutator --- commutator of two objects
*STD
*CALL
	Commutator(a, b)

*PARMS

{a}, {b} -- two objects whose commutator should be computed

*DESC

This command computes the commutator of 'a" and "b", i.e. the
expression "a b - b a". For numbers and other objects for which
multiplication is commutative, the commutator is zero. But this is not
necessarily the case for matrices.

*E.G.

	In> Commutator(2,3)
	Out> 0;
	In> PrettyPrinter("PrettyForm");
	
	True
	
	In> A := { {0,x}, {0,0} }
	
	/              \
	| ( 0 ) ( x )  |
	|              |
	| ( 0 ) ( 0 )  |
	\              /
	
	In> B := { {y,0}, {0,z} }
	
	/              \
	| ( y ) ( 0 )  |
	|              |
	| ( 0 ) ( z )  |
	\              /
	
	In> Commutator(A,B)
	
	/                          \
	| ( 0 ) ( x * z - y * x )  |
	|                          |
	| ( 0 ) ( 0 )              |
	\                          /



*CMD Taylor --- univariate Taylor series expansion
*STD
*CALL
	Taylor(var, at, order) expr

*PARMS

{var} -- variable

{at} -- point to get Taylor series around

{order} -- order of approximation

{expr} -- expression to get Taylor series for

*DESC

This function returns the Taylor series expansion of the expression
"expr" with respect to the variable "var" around "at" up to order
"order". This is a polynomial which agrees with "expr" at the
point "var = at", and furthermore the first "order" derivatives of
the polynomial at this point agree with "expr". Taylor expansions
around removable singularities are correctly handled by taking the
limit as "var" approaches "at".

*E.G.

	In> PrettyForm(Taylor(x,0,9) Sin(x))
	
	     3    5      7       9
	    x    x      x       x
	x - -- + --- - ---- + ------
	    6    120   5040   362880
	
	Out> True;

*SEE D, InverseTaylor, ReversePoly, BigOh

*CMD InverseTaylor --- Taylor expansion of inverse
*STD
*CALL
	InverseTaylor(var, at, order) expr

*PARMS

{var} -- variable

{at} -- point to get inverse Taylor series around

{order} -- order of approximation

{expr} -- expression to get inverse Taylor series for

*DESC

This function builds the Taylor series expansion of the inverse of the
expression "expr" with respect to the variable "var" around "at"
up to order "order". It uses the function {ReversePoly} to perform the task.

*E.G.

	In> PrettyPrinter("PrettyForm")
	
	True
	
	In> exp1 := Taylor(x,0,7) Sin(x)
	
	     3    5      7
	    x    x      x
	x - -- + --- - ----
	    6    120   5040
	
	In> exp2 := InverseTaylor(x,0,7) ArcSin(x)
	
	 5      7     3
	x      x     x
	--- - ---- - -- + x
	120   5040   6
	
	In> Simplify(exp1-exp2)
	
	0


*SEE ReversePoly, Taylor, BigOh

*CMD ReversePoly --- solve $h(f(x)) = g(x) + O(x^n)$ for $h$
*STD
*CALL
	ReversePoly(f, g, var, newvar, degree)

*PARMS

{f}, {g} -- functions of "var"

{var} -- a variable

{newvar} -- a new variable to express the result in

{degree} -- the degree of the required solution

*DESC

This function returns a polynomial in "newvar", say "h(newvar)",
with the property that "h(f(var))" equals "g(var)" up to order
"degree". The degree of the result will be at most "degree-1". The
only requirement is that the first derivative of "f" should not be zero.

This function is used to determine the Taylor series expansion of the
inverse of a function "f": if we take "g(var)=var", then
"h(f(var))=var" (up to order "degree"), so "h" will be the
inverse of "f".

*E.G.

	In> f(x):=Eval(Expand((1+x)^4))
	Out> True;
	In> g(x) := x^2
	Out> True;
	In> h(y):=Eval(ReversePoly(f(x),g(x),x,y,8))
	Out> True;
	In> BigOh(h(f(x)),x,8)
	Out> x^2;
	In> h(x)
	Out> (-2695*(x-1)^7)/131072+(791*(x-1)^6)
	/32768 +(-119*(x-1)^5)/4096+(37*(x-1)^4)
	/1024+(-3*(x-1)^3)/64+(x-1)^2/16;

*SEE InverseTaylor, Taylor, BigOh

*CMD BigOh --- drop all terms of a certain order in a polynomial
*STD
*CALL
	BigOh(poly, var, degree)

*PARMS

{poly} -- a univariate polynomial

{var} -- a free variable

{degree} -- positive integer

*DESC

This function drops all terms of order "degree" or higher in
"poly", which is a polynomial in the variable "var".

*E.G.

	In> BigOh(1+x+x^2+x^3,x,2)
	Out> x+1;

*SEE Taylor, InverseTaylor

*CMD Newton --- solve an equation numerically with Newton's method
*STD
*CALL
	Newton(expr, var, initial, accuracy)
	Newton(expr, var, initial, accuracy,min,max)

*PARMS

{expr} -- an expression to find a zero for

{var} -- free variable to adjust to find a zero

{initial} -- initial value for "var" to use in the search

{accuracy} -- minimum required accuracy of the result

{min} -- minimum value for "var" to use in the search

{max} -- maximum value for "var" to use in the search

*DESC

This function tries to numerically find a zero of the expression
{expr}, which should depend only on the variable {var}. It uses
the value {initial} as an initial guess.

The function will iterate using Newton's method until it estimates
that it has come within a distance {accuracy} of the correct
solution, and then it will return its best guess. In particular, it
may loop forever if the algorithm does not converge.

When {min} and {max} are supplied, the Newton iteration takes them
into account by returning {Fail} if it failed to find a root in
the given range. Note this doesn't mean there isn't a root, just
that this algorithm failed to find it due to the trial values
going outside of the bounds.

*E.G.

	In> Newton(Sin(x),x,3,0.0001)
	Out> 3.1415926535;
	In> Newton(x^2-1,x,2,0.0001,-5,5)
	Out> 1;
	In> Newton(x^2+1,x,2,0.0001,-5,5)
	Out> Fail;

*SEE Solve, NewtonNum

*CMD D --- differentiation
*STD
*CALL
	D(var) expr
	D(list) expr
	D(var,n) expr

*PARMS

{var} -- variable

{list} -- a list of variables

{expr} -- expression to take derivatives of

{n} -- order of derivative

*DESC

This function calculates the derivative of the expression {expr} with
respect to the variable {var} and returns it. If the third calling
format is used, the {n}-th derivative is determined. Yacas knows
how the differentiate standard functions such as {Ln}
and {Sin}.

The {D} operator is threaded in both {var} and
{expr}. This means that if either of them is a list, the function is
applied to each entry in the list. The results are collected in
another list which is returned. If both {var} and {expr} are a
list, their lengths should be equal. In this case, the first entry in
the list {expr} is differentiated with respect to the first entry in
the list {var}, the second entry in {expr} is differentiated with
respect to the second entry in {var}, and so on.

The {D} operator returns the original function if $n=0$, a common
mathematical idiom that simplifies many formulae.

*E.G.

	In> D(x)Sin(x*y)
	Out> y*Cos(x*y);
	In> D({x,y,z})Sin(x*y)
	Out> {y*Cos(x*y),x*Cos(x*y),0};
	In> D(x,2)Sin(x*y)
	Out> -Sin(x*y)*y^2;
	In> D(x){Sin(x),Cos(x)}
	Out> {Cos(x),-Sin(x)};

*SEE Integrate, Taylor, Diverge, Curl

*CMD Curl --- curl of a vector field
*STD
*CALL
	Curl(vector, basis)

*PARMS

{vector} -- vector field to take the curl of

{basis} -- list of variables forming the basis

*DESC

This function takes the curl of the vector field "vector" with
respect to the variables "basis". The curl is defined in the usual way,

	Curl(f,x) = {
	    D(x[2]) f[3] - D(x[3]) f[2],
	    D(x[3]) f[1] - D(x[1]) f[3],
	    D(x[1]) f[2] - D(x[2]) f[1]
	}
Both "vector" and "basis" should be lists of length 3.

*EG

	In> Curl({x*y,x*y,x*y},{x,y,z})
	Out> {x,-y,y-x};

*SEE D, Diverge

*CMD Diverge --- divergence of a vector field
*STD
*CALL
	Diverge(vector, basis)

*PARMS

{vector} -- vector field to calculate the divergence of

{basis} -- list of variables forming the basis

*DESC

This function calculates the divergence of the vector field "vector"
with respect to the variables "basis". The divergence is defined as

	Diverge(f,x) = D(x[1]) f[1] + ...
	    + D(x[n]) f[n],
where {n} is the length of the lists "vector" and
"basis". These lists should have equal length.

*EG

	In> Diverge({x*y,x*y,x*y},{x,y,z})
	Out> y+x;

*SEE D, Curl

*CMD Integrate --- integration
*STD
*CALL
	Integrate(var, x1, x2) expr
	Integrate(var) expr

*PARMS

{var} -- atom, variable to integrate over

{x1} -- first point of definite integration

{x2} -- second point of definite integration

{expr} -- expression to integrate

*DESC

This function integrates the expression {expr} with respect to the
variable {var}. The first calling format is used to perform
definite integration: the integration is carried out from $var=x1$
to $var=x2$". The second form is for indefinite integration.

Some simple integration rules have currently been
implemented. Polynomials, some quotients of polynomials,
trigonometric functions and their inverses, hyperbolic functions
and their inverses, {Exp}, and {Ln}, and products of these
functions with polynomials can be integrated.

*E.G.

	In> Integrate(x,a,b) Cos(x)
	Out> Sin(b)-Sin(a);
	In> Integrate(x) Cos(x)
	Out> Sin(x);

*SEE D, UniqueConstant

*CMD Simplify --- try to simplify an expression
*STD
*CALL
	Simplify(expr)

*PARMS

{expr} -- expression to simplify

*DESC

This function tries to simplify the expression {expr} as much
as possible. It does this by grouping powers within terms, and then
grouping similar terms.

*E.G.

	In> a*b*a^2/b-a^3
	Out> (b*a^3)/b-a^3;
	In> Simplify(a*b*a^2/b-a^3)
	Out> 0;

*SEE TrigSimpCombine, RadSimp

*CMD RadSimp --- simplify expression with nested radicals
*STD
*CALL
	RadSimp(expr)

*PARMS

{expr} -- an expression containing nested radicals

*DESC

This function tries to write the expression "expr" as a sum of roots
of integers: $Sqrt(e1) + Sqrt(e2) + ...$, where $e1$, $e2$ and
so on are natural numbers. The expression "expr" may not contain
free variables.

It does this by trying all possible combinations for $e1$, $e2$, ...
Every possibility is numerically evaluated using {N} and compared with the numerical evaluation of
"expr". If the approximations are equal (up to a certain margin),
this possibility is returned. Otherwise, the expression is returned
unevaluated.

Note that due to the use of numerical approximations, there is a small
chance that the expression returned by {RadSimp} is
close but not equal to {expr}. The last example underneath
illustrates this problem. Furthermore, if the numerical value of
{expr} is large, the number of possibilities becomes exorbitantly
big so the evaluation may take very long.

*E.G.

	In> RadSimp(Sqrt(9+4*Sqrt(2)))
	Out> Sqrt(8)+1;
	In> RadSimp(Sqrt(5+2*Sqrt(6)) \
	  +Sqrt(5-2*Sqrt(6)))
	Out> Sqrt(12);
	In> RadSimp(Sqrt(14+3*Sqrt(3+2
	*Sqrt(5-12*Sqrt(3-2*Sqrt(2))))))
	Out> Sqrt(2)+3;

But this command may yield incorrect results:

	In> RadSimp(Sqrt(1+10^(-6)))
	Out> 1;

*SEE Simplify, N

*CMD Rationalize --- convert floating point numbers to fractions
*STD
*CALL
	Rationalize(expr)

*PARMS

{expr} -- an expression containing real numbers

*DESC

This command converts every real number in the expression "expr"
into a rational number. This is useful when a calculation needs to be
done on floating point numbers and the algorithm is unstable.
Converting the floating point numbers to rational numbers will force
calculations to be done with infinite precision (by using rational
numbers as representations).

It does this by finding the smallest integer n such that multiplying
the number with $10^n$ is an integer. Then it divides by $10^n$ again,
depending on the internal gcd calculation to reduce the resulting
division of integers.

*E.G.

	In> x:={1.2, 3.123, 4.5}
	Out> {1.2,3.123,4.5};
	In> Rationalize(x)
	Out> {6/5,3123/1000,9/2};

*SEE IsRational

*CMD Solve --- solve one or more algebraic equations
*STD
*CALL
	Solve(eq, var)
	Solve(eqlist, varlist)

*PARMS

{eq} -- single identity equation

{var} -- single variable

{eqlist} -- list of identity equations

{varlist} -- list of variables

*DESC

This command tries to solve one or more equations. Use the first form
to solve a single equation and the second one for systems of
equations.

The first calling sequence solves the equation "eq" for the variable
"var". Use the {==} operator to form the equation.
The value of "var" which satisfies the equation, is returned. Note
that only one solution is found and returned.

To solve a system of equations, the second form should be used. It
solves the system of equations contained in the list "eqlist" for
the variables appearing in the list "varlist". A list of results is
returned, and each result is a list containing the values of the
variables in "varlist". Again, at most a single solution is
returned.

The task of solving a single equation is simply delegated to {SuchThat}. Multiple equations are solved recursively:
firstly, an equation is sought in which one of the variables occurs
exactly once; then this equation is solved with {SuchThat}; and finally the solution is substituted in the
other equations by {Eliminate} decreasing the number
of equations by one. This suffices for all linear equations and a
large group of simple nonlinear equations.

*E.G.

	In> Solve(a+x*y==z,x)
	Out> (z-a)/y;
	In> Solve({a*x+y==0,x+z==0},{x,y})
	Out> {{-z,z*a}};

This means that "x = (z-a)/y" is a solution of the first equation
and that "x = -z", "y = z*a" is a solution of the systems of
equations in the second command.

An example which {Solve} cannot solve:

	In> Solve({x^2-x == y^2-y,x^2-x == y^3+y},{x,y});
	Out> {};

*SEE SuchThat, Eliminate, PSolve, ==

*CMD SuchThat --- find a value which makes some expression zero
*STD
*CALL
	SuchThat(expr, var)

*PARMS

{expr} -- expression to make zero

{var} -- variable (or subexpression) to solve for

*DESC

This functions tries to find a value of the variable "var" which
makes the expression "expr" zero. It is also possible to pass a
subexpression as "var", in which case {SuchThat}
will try to solve for that subexpression.

Basically, only expressions in which "var" occurs only once are
handled; in fact, {SuchThat} may even give wrong
results if the variables occurs more than once. This is a consequence
of the implementation, which repeatedly applies the inverse of the top
function until the variable "var" is reached.

*E.G.

	In> SuchThat(a+b*x, x)
	Out> (-a)/b;
	In> SuchThat(Cos(a)+Cos(b)^2, Cos(b))
	Out> Cos(a)^(1/2);
	In> A:=Expand(a*x+b*x+c, x)
	Out> (a+b)*x+c;
	In> SuchThat(A, x)
	Out> (-c)/(a+b);

*SEE Solve, Subst, Simplify

*CMD Eliminate --- substitute and simplify
*STD
*CALL
	Eliminate(var, value, expr)

*PARMS

{var} -- variable (or subexpression) to substitute

{value} -- new value of "var"

{expr} -- expression in which the substitution should take place

*DESC

This function uses {Subst} to replace all instances
of the variable (or subexpression) "var" in the expression "expr"
with "value", calls {Simplify} to simplify the
resulting expression, and returns the result.

*E.G.

	In> Subst(Cos(b), c) (Sin(a)+Cos(b)^2/c)
	Out> Sin(a)+c^2/c;
	In> Eliminate(Cos(b), c, Sin(a)+Cos(b)^2/c)
	Out> Sin(a)+c;

*SEE SuchThat, Subst, Simplify

*CMD PSolve --- solve a polynomial equation
*STD
*CALL
	PSolve(poly, var)

*PARMS

{poly} -- a polynomial in "var"

{var} -- a variable

*DESC

This commands returns a list containing the roots of "poly",
considered as a polynomial in the variable "var". If there is only
one root, it is not returned as a one-entry list but just by
itself. A double root occurs twice in the result, and similarly for
roots of higher multiplicity. All polynomials of degree up to 4 are
handled.

*E.G.

	In> PSolve(b*x+a,x)
	Out> -a/b;
	In> PSolve(c*x^2+b*x+a,x)
	Out> {(Sqrt(b^2-4*c*a)-b)/(2*c),(-(b+
	Sqrt(b^2-4*c*a)))/(2*c)};

*SEE Solve, Factor

*CMD Pi() --- numerical approximation of $Pi$
*CORE
*CALL
	Pi()

*DESC

This commands returns the value of the mathematical constant $pi$ at the current
precision, as set by {Precision}. Usually this
function should not be called directly. The constant {Pi} can (and should) be used to represent the exact value of $pi$, as it is recognized by
the simplification rules. When the function {N}
is invoked on an expression, {Pi} will be replaced with the value
returned by {Pi()}.

*E.G.

	In> Pi()
	Out> 3.14159265358979323846;
	In> Sin(3*Pi/2)
	Out> -1;
	In> Sin(3*Pi()/2)
	Out> Sin(4.7123889804);
	In> Precision(35)
	Out> True;
	In> Pi()
	Out> 3.14159265358979323846264338327950288;

*SEE N, Pi, Precision

*CMD Random, RandomSeed --- (pseudo-)random number generator
*STD
*CALL
	Random()
	RandomSeed(init)

*PARAMS
{init} -- positive integer, initial random seed

*DESC

The function {Random} returns a random number, uniformly distributed in the
interval between 0 and 1. The same sequence of random numbers is
generated in every Yacas session.

The random number generator can be initialized by calling {RandomSeed} with an integer value.
Each seed value will result in the same sequence of pseudo-random numbers.

*SEE RandomInteger, RandomPoly, Rng


*CMD RngCreate, RngSeed, Rng --- manipulate random number generators as objects
*STD
*CALL
	RngCreate()
	RngCreate(init)
	RngCreate(option=value,...)
	RngSeed(r, init)
	Rng(r)
	
*PARMS
{init} -- integer, initial seed value

{option} -- atom, option name

{value} -- atom, option value

{r} -- a list, RNG object

*DESC
These commands are an object-oriented interface to (pseudo-)random number generators (RNGs).

{RngCreate} returns a list which is a well-formed RNG object.
Its value should be saved in a variable and used to call {Rng} and {RngSeed}.

{Rng(r)} returns a floating-point random number between 0 and 1 and updates the RNG object {r}.
(Currently, the Gaussian option makes a RNG return a <i>complex</i> random number instead of a real random number.)

{RngSeed(r,init)} re-initializes the RNG object {r} with the seed value {init}.
The seed value should be a positive integer.

The {RngCreate} function accepts several options as arguments.
Currently the following options are available:

*	{seed} -- specify initial seed value, must be a positive integer
*	{dist} -- specify the distribution of the random number; currently {flat} and {gauss} are implemented, and the default is the flat (uniform) distribution
*	{engine} -- specify the RNG engine; currently {default} and {advanced} are available ("advanced" is slower but has much longer period)

If the initial seed is not specified, the value of 76544321 will be used.

The {gauss} option will create a RNG object that generates pairs of Gaussian distributed random numbers as a complex random number.
The real and the imaginary parts of this number are independent random numbers taken from a Gaussian (i.e. "normal") distribution with unit variance.

Note that unlike the global {Random} function, the RNG objects created with {RngCreate} are independent RNGs and do not affect each other.
They generate independent streams of pseudo-random numbers.
However, the {Random} function is slightly faster.

*E.G.

	In> r1:=RngCreate(seed=1,dist=gauss)
	Out> {"GaussianRNGDist","RNGEngine'LCG'2",{1}}
	In> Rng(r1)
	Out> Complex(-1.6668466417,0.228904004);
	In> Rng(r1);
	Out> Complex(0.0279296109,-0.5382405341);
The second RNG gives a uniform distribution (default option) but uses a more complicated algorithm:
	In> [r2:=RngCreate(engine=advanced);Rng(r2);]
	Out> 0.3653615377;
The generator {r1} can be re-initialized with seed 1 again to obtain the same sequence:
	In> RngSeed(r1, 1)
	Out> True;
	In> Rng(r1)
	Out> Complex(-1.6668466417,0.228904004);
	
	


*SEE Random


*CMD Limit --- limit of an expression
*STD
*CALL
	Limit(var, val) expr
	Limit(var, val, dir) expr

*PARMS

{var} -- a variable

{val} -- a number

{dir} -- a direction ({Left} or {Right})

{expr} -- an expression

*DESC

This command tries to determine the value that the expression "expr"
converges to when the variable "var" approaches "val". One may use
{Infinity} or {-Infinity} for
"val". The result of {Limit} may be one of the
symbols {Undefined} (meaning that the limit does not
exist), {Infinity}, or {-Infinity}.

The second calling sequence is used for unidirectional limits. If one
gives "dir" the value {Left}, the limit is taken as
"var" approaches "val" from the positive infinity; and {Right} will take the limit from the negative infinity.

*E.G.

	In> Limit(x,0) Sin(x)/x
	Out> 1;
	In> Limit(x,0) (Sin(x)-Tan(x))/(x^3)
	Out> -1/2;
	In> Limit(x,0) 1/x
	Out> Undefined;
	In> Limit(x,0,Left) 1/x
	Out> -Infinity;
	In> Limit(x,0,Right) 1/x
	Out> Infinity;

*CMD TrigSimpCombine --- combine products of trigonometric functions
*STD
*CALL
	TrigSimpCombine(expr)

*PARMS

{expr} -- expression to simplify

*DESC

This function applies the product rules of trigonometry, e.g.
$Cos(u)*Sin(v) = (1/2)*(Sin(v-u) + Sin(v+u))$. As a
result, all products of the trigonometric functions {Cos} and {Sin} disappear. The function also tries to simplify the resulting expression as much as
possible by combining all similar terms.

This function is used in for instance {Integrate},
to bring down the expression into a simpler form that hopefully can be
integrated easily.

*E.G.

	In> PrettyPrinter("PrettyForm");
	
	True
	
	In> TrigSimpCombine(Cos(a)^2+Sin(a)^2)
	
	1
	
	In> TrigSimpCombine(Cos(a)^2-Sin(a)^2)
	
	Cos( -2 * a )
	
	Out>
	In> TrigSimpCombine(Cos(a)^2*Sin(b))
	
	Sin( b )   Sin( -2 * a + b ) 
	-------- + ----------------- 
	   2               4         
	
	    Sin( -2 * a - b )
	  - -----------------
	            4

*SEE Simplify, Integrate, Expand, Sin, Cos, Tan

*CMD LagrangeInterpolant --- polynomial interpolation
*STD
*CALL
	LagrangeInterpolant(xlist, ylist, var)

*PARMS

{xlist} -- list of argument values

{ylist} -- list of function values

{var} -- free variable for resulting polynomial

*DESC

This function returns a polynomial in the variable "var" which
interpolates the points "(xlist, ylist)". Specifically, the value of
the resulting polynomial at "xlist[1]" is "ylist[1]", the value at
"xlist[2]" is "ylist[2]", etc. The degree of the polynomial is not
greater than the length of "xlist".

The lists "xlist" and "ylist" should be of equal
length. Furthermore, the entries of "xlist" should be all distinct
to ensure that there is one and only one solution.

This routine uses the Lagrange interpolant formula to build up the
polynomial.

*E.G.

	In> f := LagrangeInterpolant({0,1,2}, \
	  {0,1,1}, x);
	Out> (x*(x-1))/2-x*(x-2);
	In> Eval(Subst(x,0) f);
	Out> 0;
	In> Eval(Subst(x,1) f);
	Out> 1;
	In> Eval(Subst(x,2) f);
	Out> 1;
	
	In> PrettyPrinter("PrettyForm");
	
	True
	
	In> LagrangeInterpolant({x1,x2,x3}, {y1,y2,y3}, x)
	
	y1 * ( x - x2 ) * ( x - x3 ) 
	---------------------------- 
	 ( x1 - x2 ) * ( x1 - x3 )   
	
	  y2 * ( x - x1 ) * ( x - x3 )
	+ ----------------------------
	   ( x2 - x1 ) * ( x2 - x3 )
	
	  y3 * ( x - x1 ) * ( x - x2 )
	+ ----------------------------
	   ( x3 - x1 ) * ( x3 - x2 )


*SEE Subst

*CMD Fibonacci --- Fibonacci sequence
*STD
*CALL
	Fibonacci(n)

*PARMS

{n} -- an integer

*DESC

This command calculates and returns the "n"-th Fibonacci number.

The Fibonacci sequence is 1, 1, 2, 3, 5, 8, 13, 21, ... where every
number is the sum of the two preceding numbers. Formally, it is
defined by $F(1) = 1$, $F(2) = 1$, and $F(n+1) = F(n) + F(n-1)$, where $F(n)$
denotes the $n$-th Fibonacci number.

*E.G.

	In> Fibonacci(4)
	Out> 3;
	In> Fibonacci(8)
	Out> 21;
	In> Table(Fibonacci(i), i, 1, 10, 1)
	Out> {1,1,2,3,5,8,13,21,34,55};

			Special functions

*INTRO In this chapter, special and transcendental mathematical functions are described.

*CMD Gamma, GammaNum --- Euler's Gamma function
*STD
*CALL
	Gamma(x)
	GammaNum(number)

*PARMS

{x} -- expression

{number} -- expression that can be evaluated to a number

*DESC

{Gamma(x)} is an interface to Euler's Gamma function $Gamma(x)$. It returns exact values on integer and half-integer arguments. {GammaNum(x)} or equivalently {N(Gamma(x)} takes a numeric parameter and always returns a floating-point number in the current precision.

Note that Euler's constant $gamma<=>0.57722$ is the lowercase {gamma} in Yacas.

*E.G.

	In> Precision(30)
	Out> True;
	In> Gamma(1.3)
	Out> Gamma(1.3);
	In> N(Gamma(1.3))
	Out> 0.897470696306277188493754954771;
	In> Gamma(1.5)
	Out> Sqrt(Pi)/2;
	In> GammaNum(1.5);
	Out> 0.88622692545275801364908374167;

*SEE !, N, gamma

*CMD Zeta, ZetaNum --- Riemann's Zeta function
*STD
*CALL
	Zeta(x)
	ZetaNum(number)

*PARMS

{x} -- expression

{number} -- expression that can be evaluated to a number

*DESC

{Zeta(x)} is an interface to Riemann's Zeta function $zeta(s)$. It returns exact values on integer and half-integer arguments. {ZetaNum(x)} or equivalently {N(Zeta(x)} takes a numeric parameter and always returns a floating-point number in the current precision.

*E.G.

	In> Precision(30)
	Out> True;
	In> Zeta(1)
	Out> Infinity;
	In> Zeta(1.3)
	Out> Zeta(1.3);
	In> N(Zeta(1.3))
	Out> 3.93194921180954422697490751058798;
	In> Zeta(2)
	Out> Pi^2/6;
	In> ZetaNum(2);
	Out> 1.64493406684822643647241516664602;

*SEE !, N


*CMD Bernoulli, BernoulliArray --- Bernoulli numbers and polynomials
*STD
*CALL
	Bernoulli(index)
	BernoulliArray(index)
	Bernoulli(index, x)

*PARMS

{x} -- expression that will be the variable in the polynomial

{index} -- expression that can be evaluated to an integer

*DESC

{Bernoulli(n)} evaluates the $n$-th Bernoulli number. {Bernoulli(n, x)} returns the $n$-th Bernoulli polynomial in the variable $x$. The polynomial is returned in the Horner form.

An auxiliary function {BernoulliArray(n)} might be useful too: it returns an array (of type {GenericArray}) of Bernoulli numbers up to $n$. The array is 1-based, so that the $n$-th Bernoulli number is {BernoulliArray(n)[n+1]}.

*EG

	In> Bernoulli(20);
	Out> -174611/330;
	In> Bernoulli(4, x);
	Out> ((x-2)*x+1)*x^2-1/30;

*SEE Gamma, Zeta

*CMD Euler --- Euler numbers and polynomials
*STD
*CALL
	Euler(index)
	Euler(index,x)

*PARMS

{x} -- expression that will be the variable in the polynomial

{index} -- expression that can be evaluated to an integer

*DESC

{Euler(n)} evaluates the $n$-th Euler number. {Euler(n,x)} returns the $n$-th Euler polynomial in the variable $x$.

*E.G.

	In> Euler(6)
	Out> -61;
	In> A:=Euler(5,x)
	Out> (x-1/2)^5+(-10*(x-1/2)^3)/4+(25*(x-1/2))/16;
	In> Simplify(A)
	Out> (2*x^5-5*x^4+5*x^2-1)/2;

*SEE Bin


*CMD LambertW, LambertWNum --- Lambert's $W$ function
*STD
*CALL
	LambertW(x)
	LambertWNum(x)
*PARMS

{x} -- expression, argument of the function

*DESC

Lambert's $W$ function is (a multiple-valued, complex function) defined for any (complex) $z$ by
$$ W(z) * Exp(W(z)) = z$$.
This function is sometimes useful to represent solutions of transcendental equations. For example, the equation $Ln(x)=3*x$ can be "solved" by writing $x= -3*W(-1/3)$. It is also possible to take a derivative or integrate this function "explicitly".

For real arguments $x$, $W(x)$ is real if $x>= -Exp(-1)$.

{LambertWNum} is an auxiliary function that computes the numerical value of the principal branch of Lambert's $W$ function for real arguments $x>= -Exp(-1)$ to current precision.

*E.G.
	In> LambertW(0)
	Out> 0;
	In> N(LambertW(-0.24/Sqrt(3*Pi)))
	Out> -0.0851224014;

*SEE Exp

*CMD gamma --- Euler's constant $gamma$
*STD
*CALL
	N(gamma)
	gamma()

*DESC

These functions compute Euler's constant $gamma<=>0.57722$...

The constant is available symbolically as {gamma} or numerically as a function {gamma()}.
This is a "cached constant" which is recalculated only when precision is increased.
The numerical value of the constant can also be obtained as {N(gamma)}.
The low-level numerical computations are performed by the routine {GammaConstNum}.

Note that Euler's Gamma function $Gamma(x)$ is the capitalized {Gamma} in Yacas.

*E.G.

	In> gamma+Pi
	Out> gamma+Pi;
	In> N(gamma+Pi)
	Out> 3.7188083184;
	In> [Precision(20);V(gamma());]
	
	CachedConstant: Info: constant gamma is being
	  recalculated at precision 20 
	GammaConstNum: Info: used 56 iterations at
	  working precision 24 
	Out> 0.57721566490153286061;

*SEE Gamma, N, CachedConstant

*CMD GoldenRatio --- the Golden Ratio
*STD
*CALL
	N(GoldenRatio)
	GoldenRatio()

*DESC

These functions compute the "golden ratio"
$$phi <=> 1.6180339887 <=> (1+Sqrt(5))/2 $$.

The ancient Greeks defined the "golden ratio" as follows:
If one divides a length 1 into two pieces $x$ and $1-x$, such that the ratio of 1 to $x$ is the same as the ratio of $x$ to $1-x$, then $1/x <=> 1.618$... is the "golden ratio".


The constant is available symbolically as {GoldenRatio} or numerically as a function {GoldenRatio()}.
This is a "cached constant" which is recalculated only when precision is increased.
The numerical value of the constant can also be obtained as {N(GoldenRatio)}.


*E.G.

	In> x:=GoldenRatio - 1
	Out> GoldenRatio-1;
	In> N(x)
	Out> 0.6180339887;
	In> N(1/GoldenRatio)
	Out> 0.6180339887;
	In> [Precision(20);V(GoldenRatio());]

	CachedConstant: Info: constant GoldenRatio is
	being recalculated at precision 20 
	Out> 1.6180339887498948482;


*SEE N, CachedConstant


*CMD Catalan --- Catalan's Constant
*STD
*CALL
	N(Catalan)
	Catalan()

*DESC

These functions compute Catalan's Constant $Catalan<=>0.9159655941$.

The constant is available symbolically as {Catalan} or numerically as a function {Catalan()}.
This is a "cached constant" which is recalculated only when precision is increased.
The numerical value of the constant can also be obtained as {N(Catalan)}.
The low-level numerical computations are performed by the routine {CatalanConstNum}.


*E.G.

	In> N(Catalan)
	Out> 0.9159655941;
	In> DirichletBeta(2)
	Out> Catalan;
	In> [Precision(20);V(Catalan());]

	CachedConstant: Info: constant Catalan is
	being recalculated at precision 20
	Out> 0.91596559417721901505;


*SEE N, CachedConstant
