			Platform-dependent packages

*INTRO Certain facilities have been developed for use on Unix-like platforms,
which is currently the main development target for Yacas. Other facilities have limited support on the Windows platform as well. These functions are described in this chapter.


*CMD Version --- show version of Yacas
*CORE
*CALL
	Version()

*DESC

The function {Version()} returns a string representing the version of the currently running Yacas interpreter.

*E.G. notest

	In> Version()
	Out> "1.0.48rev3";
	In> LessThan(Version(), "1.0.47")
	Out> False;
	In> GreaterThan(Version(), "1.0.47")
	Out> True;

The last two calls show that the {LessThan} and {GreaterThan}
functions can be used for comparing version numbers. This 
method is only guaranteed, however, if the version is always expressed
in the form {d.d.dd} as above.

*REM
Note that on the Windows platforms the output may be different:
In> Version()
Out> "Windows-latest";

*SEE LessThan, GreaterThan


*CMD PlatformOS --- OS-dependent constants
*CMD OSVersion --- OS-dependent constants
*CMD FilePathSeparator --- OS-dependent constants
*STD
*CALL
	FilePathSeparator()
	PlatformOS()
	OSVersion()

*DESC

The functions {OSVersion()} and {PlatformOS()} return strings with an abbreviated description of the platform for which the current Yacas interpreter was compiled.
Possible values are for instance {"linux-gnu"}, {"Win32"} or {"solaris2.6"}.
These constants can be used in scripts if one needs to know the platform.

The value of {OSVersion()} is normally determined when Yacas is
compiled. It is usually the operating system name and version as reported by the
{config.guess} script.
However, it may be overridden at build time (on non-Unix
systems, the script cannot be run and the value must be specified by hand).

The value of {PlatformOS()} is defined in the library (in {osdep.rep/}).
Thus the library is able to override the platform-specific value.
The scripts should use {PlatformOS()} to distinguish between broad classes of systems.
The currently supported values are {"Unix"} and {"Win32"}.

The function {FilePathSeparator()} returns the string that separates directories in the file system tree. This is the forward slash "{/}" on Unix and the backslash "{\}" on Windows.

*E.G. notest

	In> Check(StringMid'Get(1, 5, OSVersion())="linux", \
	          "BAAA! I WANT LINUX!")
	Out> True;
	In> PlatformOS()
	Out> "Unix";

*SEE MakeFilePath

*CMD CopyFile --- manipulate files and directories
*CMD DeleteFile --- manipulate files and directories
*CMD DeleteDir --- manipulate files and directories
*CMD MakeDir --- manipulate files and directories
*CMD MakeFilePath --- manipulate files and directories
*CMD TemporaryDir --- manipulate files and directories
*CMD TemporaryFile --- manipulate files and directories
*STD
*CALL
	CopyFile("src","dest")
	DeleteFile("file", ...)
	DeleteDir("dir", ...)
	MakeDir("dir1", ...)
	MakeFilePath("dir1", "dir2", ..., "file")
	TemporaryDir()
	TemporaryFile()

*PARMS

{"src"}, {"dest"}, {"file"}, {"dir"} -- strings, names of files and directories

*DESC

These functions provide a platform-independent interface to file operations on the underlying operating system (OS):

*	{CopyFile} will copy a file {"src"} to another file or directory {"dest"}.
*	{DeleteFile} will delete one or more files. If a file does not exist, no error is generated on Unix.
*	{DeleteDir} will delete one or more directories
<i>with all their contents</i>. (No warnings or questions are printed,---use with caution!) If a directory does not exist, no error is generated on Unix.
*	{MakeDir} will create new directories. Under Windows, all intermediate subdirectories must exist for this to work. Under Unix, any intermediate subdirectories will be created automatically if needed.
*	{MakeFilePath} returns a string which is the file path to the given file under given subdirectories. It uses the function {FilePathSeparator()}.
*	{TemporaryDir} and {TemporaryFile} return the names of a temporary directory and a temporary file. (These names are OS-dependent.)

Absolute file paths or relative file paths can be given (the current directory is the directory where Yacas was started).

File and directory names may contain spaces, although the behavior on Windows platform may be incorrect due to its broken filesystem and command interpreter.
File and directory names should not contain double quotes ({"}). (On Unix, double quotes may be escaped by a backslash.)

When operating on many files or directories at once, there may be errors associated with some files but not others.
The functions return {True} only if all operations succeeded.
Error messages from the OS are printed on the console as usual for {SystemCall}.

*E.G. notest

	In> MakeFilePath("", "usr", "bin", "yacas")
	Out> "/usr/bin/yacas";
	In> TemporaryDir()
	Out> "/tmp";
If the file {f1.txt} exists, it can be copied:
	In> CopyFile("f1.txt", "f2.txt")
	Out> True;
Create a subdirectory {subdir} under the temporary directory:
	In> MakeDir(d:=MakeFilePath(TemporaryDir(), \
	  "subdir"))
	Out> True;
	In> d
	Out> "/tmp/subdir";
Copy a file into the newly created temporary location:
	In> CopyFile("f2.txt", d)
	Out> True;
On Unix, spaces can be included in a file name and quotes can be escaped like this:
	In> MakeDir("a \\\"")
	Out> True;
Now a directory with the name "{a "}" is created.

An unsuccessful attempt to delete a directory:
	In> DeleteDir("C:\\WINDOWS")
	Out> False;

*SEE SystemCall, FilePathSeparator


*CMD SystemCallBg --- execute a system command in the background
*STD
*CALL
	SystemCallBg("command")

*PARMS

{"command"} -- string, command line to execute

*DESC

This function is similar to {SystemCall} except the command is executed in the background.
This is useful, for example, to start a GUI program while not interrupting the Yacas session.

Unlike the {SystemCall} function, the return status of the command is not available.

Error messages from the OS are printed on the console as usual for {SystemCall}.


*E.G. notest

	In> SystemCallBg("mozilla")
	Out> True;
(The Yacas session continues right away, but the disk starts to churn until finally the Mozilla window appears.)

*SEE SystemCall
