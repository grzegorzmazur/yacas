
			String manipulation

*CMD SetStringMid --- change a substring
*CORE
*CALL
	SetStringMid(index,substring,string)

*PARMS

{index} -- index of substring to get

{substring} -- substring to store

{string} -- string to store substring in.

*DESC

Set (change) a part of a string. It leaves the original alone, returning
a new changed copy.

*E.G.

	In> SetStringMid(3,"XY","abcdef")
	Out> "abXYef";

*SEE StringMid, Length

*CMD StringMid --- retrieve a substring
*CORE
*CALL
	StringMid(index,length,string)

*PARMS

{index} -- index of substring to get

{length} -- length of substring to get

{string} -- string to get substring from

*DESC

{StringMid} returns a part of a string. Substrings can also be
accessed using the {[]} operator.

*E.G.

	In> StringMid(3,2,"abcdef")
	Out> "cd";
	In> "abcdefg"[2 .. 4]
	Out> "bcd";

*SEE SetStringMid, Length

*CMD String --- convert atom to string
*CMD Atom --- convert string to atom
*CORE
*CALL
	Atom("string")
	String(atom)

*PARMS

{atom} -- an atom

{"string"} -- a string

*DESC

Returns an atom with the string representation given
as the evaluated argument. Example: {Atom("foo");} returns
{foo}.

{String} is the inverse of {Atom}: turns {atom} into {"atom"}.

*E.G.

	In> String(a)
	Out> "a";
	In> Atom("a")
	Out> a;

*CMD ConcatStrings --- concatenate strings
*CORE
*CALL
	ConcatStrings(strings)

*PARMS

{strings} -- one or more strings

*DESC

Concatenates strings.

*E.G.

	In> ConcatStrings("a","b","c")
	Out> "abc";

*SEE :

*CMD LocalSymbols --- create unique local symbols with given prefix
*STD
*CALL
	LocalSymbols(var1, var2, ...) body

*PARMS

{var1}, {var2}, ... -- atoms, symbols to be made local

{body} -- expression to execute

*DESC

Given the symbols passed as the first arguments to LocalSymbols a set of local
symbols will be created, and creates unique ones for them, typically of the
form {$<symbol><number>}, where {symbol} was the symbol entered by the user,
and {number} is a unique number. This scheme was used to ensure that a generated
symbol can not accidentally be entered by a user.

This is useful in cases where a guaranteed free variable is needed,
for example, in the macro-like functions ({For}, {While}, etc.).

*E.G. notest

	In> LocalSymbols(a,b)a+b
	Out> $a6+ $b6;

*SEE UniqueConstant

*CMD PatchString --- execute commands between {<?} and {?>} in strings
*CORE
*CALL
	PatchString(string)

*PARMS

{string} -- a string to patch

*DESC

This function does the same as PatchLoad, but it works on a string
in stead of on the contents of a text file. See PatchLoad for more
details.

*E.G.

	In> PatchString("Two plus three \
	  is <? Write(2+3); ?> ");
	Out> "Two plus three is 5 ";

*SEE PatchLoad

