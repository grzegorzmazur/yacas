
TODO:
  - better examples for for example Integrate
  - fill out the examples in the autocompleter
  - comparison operators should try to fully coerce to real-valued
  - examples should have their own tests
  - make books.html not too wide also
  - make plain site not too wide also
  - center everything, with the back.gif on the sides.
  - step-by-step solver possible?
  - different color scheme for each tab page?

1) Documentation improvements
- document the article mark-up language
- document ":test" to run test code from article
- link to mark-up documentation from the editors.
- what is Yacas? How did it come into existence? Why did I write it? Who is it for?
- mention  the use of lists for passing multiple arguments.
============================================================================================================
- document the algorithms used, and expand on all of the functions
currently implemented.
- separate manual chapter on tensors. (Serge? Is it going to change?). TSimplify and TExplicitSum, TD, X
- document the source code.
- document HoldArg in combination with <-- (or actually remove HoldArg? I want to depreciate UnFence/HoldArg in favor of macros)
- document II, ReII, ImII, IsComplexII
- document ExpressionDepth, PAdicExpandInternal, GetPrimeFactors, Rem, Roots, Apart, Together
- document UnHoldable, GcdReduce, ApplyPure, DestructiveAppendList, PatternMatches, PatternCreate, RuleBaseDefined, Lambda (in combination with Apply), Primes, MapArgs, Substitute,
- document %, |, &, ^, if, else (else binds to the last if)
- document DivPoly, RootsWithMultiples,
- document OdeSolve
- document Dimensions, IsSquareMatrix, Tr.
- document Deriv, Berlekamp, ExtendedEuclidean, ExtendedEuclideanMonic
- document IsVariable
- document the fact that VarList can also be called with a second argument, a filter predicate.
- document Extended predicates in the pattern matcher (needs to be explained).
- document CTokenizer(), DefaultTokenizer()
- document XmlTokenizer, XmlExplodeTag
- document BSearch, FindIsq Search for a zero in a monotonously growing function. BSearch returns -1 if not found, FindIsq returns the insertion point.
- document MultiDivide, MultiGcd, Groebner
- document DefLoadFunction
- document CharString (input integer, output a string with one char, using the ascii code passed in).
- document FloatIsInt
- document Explain what is destructive about the Destructive... routines, why they are there, and when to use them.
- document Do slightly more on pure functions, to show why they are useful. Show for example Select.
- document Explain what Simplify currently does (internal algorithm).
- document The PcreLexer and PcreNextToken functions
- document Small summary of regular expressions syntax accepted.
- document Html... commands.
- document FakeDb... functions.
- document some blurb on the pattern matching/multivirtual functionality.
- Clean up integration code, and document algorithm used.
- document the extra Is... predicates for matrices that was added by Jonathan
- document threaded use of integration

2) Web site improvements
- allow saving multiple programs in cookies
- work through mommies feedback
  - computer calculations made easy zou ik in lijn met het logo plaatsen liefst in lijn met de groene balletjes. Nu zweeft het een beetje los.
  - Get Yacas en contact us is goed, maar ik zou het wat lager plaatsen in lijn met de tabs, maar wel zo laten als tekst links.
- Explain that a connection to the server is not needed, and that Yacas can be run off-line (with a link to a download of the Yacas web site).
============================================================================================================
- have the Java version available as a separate install.
- Set up proper mailing lists
- should I reconsider the way things are compressed? tgz? Why not zip?
- when leaving codeedit page, ask to remember code?
- think through wat it would look like if you could add content
- make all screens go 100% (edit, tutorial?) or at least center?
- create a clickable program snippet that is other than a one-liner (?)
- ideally programs should be uploaded to the datahub from the example
pages themselves, and not from recent.html, but for some reason that did
not work. When going from deeply-linked, trying it out does not work any
more and editing it also not.
- make descr/view/edit pages not reload, but refresh content dynamically
- In the tutorial, at "Solve", show how to verify that results are correct

3) Research
- Scan through my articles
- scan through examples already in examples directory in scripts dir
- take a look at Axiom code
- take a look at Maxima code
============================================================================================================
- Think through series of articles on tensors.
- Quaternions example?
- Example: the logarithmic derivative example from Fateman is nice.
- example: inverse, integrate taylor of 1/f'
- example: generating a polynomial solution for an ordinary DE
- For fun: try to understand Hensel lifting, and can it be made to apply
to say Feynman diagrams?

4) Applet improvements
?- text rendered in console seems to be rendered slightly off, shifted, on Windows (not on my PowerBook).
- clicking on the hint box should do the same as pressing enter
- Error in Yacas console should be shorter: drop the
net.sf.yacas.YacasException as it does not really add anything.
- Render plain text over multiple lines
- create a grapher
============================================================================================================
- optimize the code that finds matching hints
- hints.txt in the yacas.jar.
- tex parse: \lim, \Rightarrow, \max, \min, \zeta, {":=","\\equiv"},{"<>","\\sim "},{"<=>", "\\approx "},{"=>", "\\Rightarrow "},{"%","\\bmod "},
- Store history also in cookies, so you have access to the history next time.

5) Math improvements
============================================================================================================
- allow control over formatting of floats.
- bumping up a version number seems to force a recompile of all the C++ files, config.h rewritten or so?
- make all the code more consistent, assuming that variables are real-valued.
- remove use of UnFence/HoldArg in favor of macros
- after use of UnFence/HoldArg has been removed, remove support for it
- local transforms: postpredicates do not seem to work any more.
- pattern matcher that can work on rings
- Change the system to use the II way of dealing with complex numbers in
favor of the Complex(r,i) construct.
- When the change to the II way of doing complex numbers is finished, add
it to the tutorial (if not already there), and change the manual
accordingly
- replace perl code in favor of C++ code, easier to maintain.
- sparserep from multi, use for uni too
- lists/arrays interchangable
- remove all uses of local files/directories.
- global var access, test code using a function to return a list of global
variables.
- Clean up Solve code, and document algorithm used.
- remove the final references to stdlib in the code.
- put Nl() in a common place (if it is still defined in different places
or an odd place).
- test Apart for polys. This might have to be adjusted by adding using the
same mechanism used for the integer version.
- Taylor on functions containing Abs/Sign can not be trusted (no idea what
I meant by that, but worth checking).
- Define the Local,.. functions based on their Macro counterparts, in the
scripts.
- also define a Head and Tail for arrays, and append/concat/
insert/delete/copy. This will ease swapping between lists and arrays.
- Allow for type convertors in pattern matchers. For instance: IsUniVar,
should be combined with CanBeUni and NormalForm to get the correct one
back.
- A RuleBaseDefined-like function that returns a list of defined arities.
- FindZeroes (polynoms and other functions)
- redivide some code ('newly')
- make suchthat more powerful, so it simplifies sin(x)=cos(x) to tan(x)=1
to x=Pi/4
- groebner bases
- see if using arrays for matrices speeds up things.
- Fix CanBeUni so that it deals correctly with 1/c
- EquateCoefs equate coefficients in two polys, and return as list.
- document /. and /:: with <-
- allow solve to return a list usable in /.
- matrix^negative is inverse^positive

6) Bugs:
============================================================================================================
- some limits not working correctly when using infinity: Limit(x,Infinity)
Zeta(x), Limit(x,Infinity) Factorial(x),
- factorize not checking for correctness of arguments:
Factorize(Infinity), Factorize(-1)
- Limit(x,0)D(x,2)Sin(x)/x never terminates (or rather takes a very long
time), which in turn causes Taylor(x,0,5)Sin(x)/x to never terminate.
- Limit(x,Infinity) x^n/Ln(x) returns n*Infinity, should be Infinity
- Limit(x,0,Right) x^( Ln(a)/(1+Ln(x)) ) returns 1, should be "a"
- Gcd(10,3.3) returns 1, should error with floats, or return unevaluated
like 'Gcd(10,Pi)' and 'Gcd(Exp(1),Exp(2))' do
- Limit(n,Infinity) Sqrt(n+1) - Sqrt(n), the limit is zero, but exhausts
the stack
- [A:={{1,2,3,4},{0,1,2,3},{0,0,1,2},{I,0,I,I}}; EigenValues(A);] hangs
- ArcCos(Cos(beta)) returns beta, but this is not strictly correct for all
values of beta. If I fix this I need to fix it in the tutorial also.
- Limit(n, Infinity) n^5/2^n returns Infinity/(Infinity*Ln(2)), wrong
answer -- L'Hopital's theorem is not always the correct thing to do. There
is a paper by Richardson, Salvy et al "Asymptotic expansions of exp-log
functions" that may be helpful.
- TrigSimpCombine(x^500)' exhausts the stack
- 'Solve(Exp(x^2)==Exp(x),x)' yields {} instead of {0,1}.
- BUG: InverseTaylor not working correctly for Sin and Tan???
- BUG: complex^float.
- Mod(a,b) generates some "UniVariate()" calls if a and b are undefined (I
expected it to return unevaluated). If one of them is defined, and the
other undefined, Mod() returns some numbers. Mod(x,-3) returns
unevaluated. I'm not sure what the "correct" meaning of Mod is for
negative moduli bases, but the answer should in any case be non-negative.
Mod(a,b) is defined as the smallest non-negative number c such that a-c is
divisible by b.
- Simplify(4-x-y) returns 4-y-x, Simplify(4-y-x) returns 4-x-y










:Append:Append(list, expr):append an entry at the end of a list:
:Apply:Apply(fn, arglist):apply a function to arguments:
:ArcCos:ArcCos(x):inverse trigonometric function arc-cosine:
:ArcSin:ArcSin(x):inverse trigonometric function arc-sine:
:ArcTan:ArcTan(x):inverse trigonometric function arc-tangent:
:Arg:Arg(x):argument of a complex number:
:BaseVector:BaseVector(k, n):base vector:
:BigOh:BigOh(poly, var, degree):drop all terms of a certain order in a
polynomial:
:Bin:Bin(n, m):binomial coefficients:
:BitAnd:BitAnd(n,m):bitwise and operation:
:BitOr:BitOr(n,m):bitwise or operation:
:BitXor:BitXor(n,m):bitwise xor operation:
:CanProve:CanProve(proposition):try to prove statement:
:Ceil:Ceil(x):round a number upwards:
:CharacteristicEquation:CharacteristicEquation(matrix,var):get
characteristic polynomial of a matrix:
:CoFactor:CoFactor(M,i,j):cofactor of a matrix:
:Coef:Coef(expr, var, order):coefficient of a polynomial:
:Commutator:Commutator(a, b):commutator of two objects:
:Complex:Complex(r, c):construct a complex number:
:Concat:Concat(list1, list2, ...):concatenate lists:
:ConcatStrings:ConcatStrings(strings):concatenate strings:
:Conjugate:Conjugate(x):complex conjugate:
:ContFrac:ContFrac(x):continued fraction expansion:
:ContFrac:ContFrac(x, depth)::
:Contains:Contains(list, expr):test whether a list contains a certain
element:
:Cos:Cos(x):trigonometric cosine function:
:Count:Count(list, expr):count the number of occurrences of an expression:
:CrossProduct:CrossProduct(a,b):outer product of vectors:
:Curl:Curl(vector, basis):curl of a vector field:
:D:D(var) expr:differentiation:
:D:D(var,n) expr::
:Decimal:Decimal(frac):decimal representation of a rational:
:Degree:Degree(expr):degree of a polynomial:
:Degree:Degree(expr, var)::
:Delete:Delete(list, n):delete an element from a list:
:Denom:Denom(expr):denominator of an expression:
:Determinant:Determinant(M):determinant of a matrix:
:Diagonal:Diagonal(A):extract the diagonal from a matrix:
:DiagonalMatrix:DiagonalMatrix(d):construct a diagonal matrix:
:Difference:Difference(l1, l2):return the difference of two lists:
:Div:Div(x,y):Determine divisor of two mathematical objects:
:Diverge:Diverge(vector, basis):divergence of a vector field:
:Dot:Dot(t1,t2):get dot product of tensors:
:Echo:Echo(item):high-level printing routine:
:Echo:Echo(item,item,item,...)::
:Echo:Echo(list)::
:EigenValues:EigenValues(matrix):get eigenvalues of a matrix:
:EigenVectors:EigenVectors(A,eigenvalues):get eigenvectors of a matrix:
:Eliminate:Eliminate(var, value, expr):substitute and simplify:
:Eval:Eval(expr):force evaluation of expression:
:Exp:Exp(x):exponential function:
:Expand:Expand(expr):transform a polynomial to an expanded form:
:Expand:Expand(expr, var)::
:Expand:Expand(expr, varlist)::
:ExpandBrackets:ExpandBrackets(expr):expand all brackets:
:Factor:Factor(x):factorization, in pretty form:
:FactorialSimplify:FactorialSimplify(expression):Simplify hypergeometric
expressions containing factorials:
:Factorize:Factorize(list):product of a list of values:
:Factorize:Factorize(var, from, to, body)::
:Factors:Factors(x):factorization:
:Find:Find(list, expr):get the index at which a certain element occurs:
:FindRealRoots:FindRealRoots(p):find the real roots of a polynomial:
:Flatten:Flatten(expression,operator):flatten expression w.r.t. some
operator:
:Floor:Floor(x):round a number downwards:
:For:For(init, pred, incr) body:C-style {for} loop:
:ForEach:ForEach(var, list) body:loop over all entries in list:
:FromBase:FromBase(base,"string"):conversion of a number from non-decimal
base to decimal base:
:FromString:FromString(str) body;:connect current input to a string:
:FullForm:FullForm(expr):print an expression in LISP-format:
:Gcd:Gcd(list)::
:Gcd:Gcd(n,m):greatest common divisor:
:GoldenRatio:GoldenRatio():the Golden Ratio:
:GuessRational:GuessRational(x):find optimal rational approximations:
:GuessRational:GuessRational(x, digits)::
:Head:Head(list):the first element of a list:
:HeapSort:HeapSort(list, compare):sort a list:
:Hold:Hold(expr):keep expression unevaluated:
:I:I:imaginary unit:
:Identity:Identity(n):make identity matrix:
:If:If(pred, then):branch point:
:If:If(pred, then, else)::
:Im:Im(x):imaginary part of a complex number:
:InProduct:InProduct(a,b):inner product of vectors (deprecated):
:Insert:Insert(list, n, expr):insert an element into a list:
:Integrate:Integrate(var) expr::
:Integrate:Integrate(var, x1, x2) expr:integration:
:Intersection:Intersection(l1, l2):return the intersection of two lists:
:Inverse:Inverse(M):get inverse of a matrix:
:IsAtom:IsAtom(expr):test for an atom:
:IsBodied:IsBodied("op"):check for function syntax:
:IsBoolean:IsBoolean(expression):test for a Boolean value:
:IsBound:IsBound(var):test for a bound variable:
:IsConstant:IsConstant(expr):test for a constant:
:IsDiagonal:IsDiagonal(A):test for a diagonal matrix:
:IsEven:IsEven(n):test for an even integer:
:IsEvenFunction:IsEvenFunction(expression,variable):Return true if
function is an even function, False otherwise:
:IsFreeOf:IsFreeOf(var, expr):test whether expression depends on variable:
:IsFreeOf:IsFreeOf({var, ...}, expr)::
:IsFunction:IsFunction(expr):test for a composite object:
:IsMatrix:IsMatrix(expr):test for a matrix:
:IsMatrix:IsMatrix(pred,expr)::
:IsNegativeInteger:IsNegativeInteger(n):test for a negative integer:
:IsNegativeNumber:IsNegativeNumber(n):test for a negative number:
:IsNegativeReal:IsNegativeReal(expr):test for a numerically negative value:
:IsNonZeroInteger:IsNonZeroInteger(n):test for a nonzero integer:
:IsList:IsList(expr):test for a list:
:IsNotZero:IsNotZero(n):test for a nonzero number:
:IsNumber:IsNumber(expr):test for a number:
:IsNumericList:IsNumericList({list}):test for a list of numbers:
:IsOdd:IsOdd(n):test for an odd integer:
:IsOddFunction:IsOddFunction(expression,variable):Return true if function
is an odd function, False otherwise:
:IsOrthogonal:IsOrthogonal(A):test for an orthogonal matrix:
:IsPositiveInteger:IsPositiveInteger(n):test for a positive integer:
:IsPositiveNumber:IsPositiveNumber(n):test for a positive number:
:IsPositiveReal:IsPositiveReal(expr):test for a numerically positive value:
:IsPrime:IsPrime(n):test for a prime number:
:IsRational:IsRational(expr):test whether argument is a rational:
:IsSmallPrime:IsSmallPrime(n):test for a (small) prime number:
:IsSquareFree:IsSquareFree(n):test for a square-free number:
:IsSquareMatrix:IsSquareMatrix(expr):test for a square matrix:
:IsSquareMatrix:IsSquareMatrix(pred,expr)::
:IsString:IsString(expr):test for an string:
:IsSymmetric:IsSymmetric(A):test for a symmetric matrix:
:IsUnitary:IsUnitary(A):test for a unitary matrix:
:IsVector:IsVector(expr):test for a vector:
:IsVector:IsVector(pred,expr)::
:IsZero:IsZero(n):test whether argument is zero:
:IsZeroVector:IsZeroVector(list):test whether list contains only zeroes:
:KnownFailure:KnownFailure(test):Mark a test as a known failure:
:LagrangeInterpolant:LagrangeInterpolant(xlist, ylist, var):polynomial
interpolation:
:Lcm:Lcm(list)::
:Lcm:Lcm(n,m):least common multiple:
:LeadingCoef:LeadingCoef(poly):leading coefficient of a polynomial:
:LeadingCoef:LeadingCoef(poly, var)::
:Length:Length(object):the length of a list or string:
:Limit:Limit(var, val) expr:limit of an expression:
:Limit:Limit(var, val, dir) expr::
:LeviCivita:LeviCivita(list):totally anti-symmetric Levi-Civita symbol:
:Listify:Listify(expr):convert a function application to a list:
:Ln:Ln(x):natural logarithm:
:Local:Local(var, ...):declare new local variables:
:LocalSymbols:LocalSymbols(var1, var2, ...) body:create unique local
symbols with given prefix:
:LogicTest:LogicTest(variables,expr1,expr2):verifying equivalence of two
expressions:
:LogicVerify:LogicVerify(question,answer):verifying equivalence of two
expressions:
:Macro:Macro("op", {arglist, ...}) body::
:Macro:Macro("op", {arglist}) body::
:Macro:Macro() func(arglist):declare or define a macro:
:Macro:Macro() func(arglist, ...)::
:MakeVector:MakeVector(var,n):vector of uniquely numbered variable names:
:Map:Map(fn, list):apply an $n$-ary function to all entries in a list:
:MapArgs:MapArgs(expr, fn):apply a function to all top-level arguments:
:MapSingle:MapSingle(fn, list):apply a unary function to all entries in a
list:
:MatrixPower:MatrixPower(mat,n):get nth power of a square matrix:
:MatrixSolve:MatrixSolve(A,b):solve a system of equations:
:Max:Max(list)::
:Max:Max(x,y):maximum of a number of values:
:MaximumBound:MaximumBound(p):return upper bounds on the absolute values
of real roots of a polynomial:
:Min:Min(list)::
:Min:Min(x,y):minimum of a number of values:
:MinimumBound:MinimumBound(p):return lower bounds on the absolute values
of real roots of a polynomial:
:Minor:Minor(M,i,j):get principal minor of a matrix:
:Mod:Mod(x,y):Determine remainder of two mathematical objects after
dividing one by the other:
:Monic:Monic(poly):monic part of a polynomial:
:Monic:Monic(poly, var)::
:N:N(Catalan)::
:N:N(GoldenRatio)::
:N:N(expr):compute numerical approximation:
:N:N(expr, prec)::
:N:N(gamma)::
:Newton:Newton(expr, var, initial, accuracy):solve an equation numerically
with Newton's method:
:Newton:Newton(expr, var, initial, accuracy,min,max)::
:NonN:NonN(expr):calculate part in non-numeric mode:
:Normalize:Normalize(v):normalize a vector:
:Not:Not expr:logical negation:
:NrArgs:NrArgs(expr):return number of top-level arguments:
:NthRoot:NthRoot(m,n):calculate/simplify nth root of an integer:
:NumRealRoots:NumRealRoots(p):return the number of real roots of a
polynomial:
:Numer:Numer(expr):numerator of an expression:
:OMForm:OMForm(expression):convert Yacas expression to OpenMath:
:OMRead:OMRead():convert expression from OpenMath to Yacas expression:
:OSVersion:OSVersion():OS-dependent constants:
:OdeOrder:OdeOrder(eqn):return order of an ODE:
:OdeSolve:OdeSolve(expr1==expr2):general ODE solver:
:OdeTest:OdeTest(eqn,testsol):test the solution of an ODE:
:PAdicExpand:PAdicExpand(n, p):p-adic expansion:
:PSolve:PSolve(poly, var):solve a polynomial equation:
:PatchString:PatchString(string):execute commands between {<?} and {?>} in
strings:
:Permutations:Permutations(list):get all permutations of a list:
:Pi:Pi():numerical approximation of $Pi$:
:Pi:Pi:mathematical constant, $pi$:
:PrimitivePart:PrimitivePart(expr):primitive part of a univariate polynomial:
:Pslq:Pslq(xlist,precision):search for integer relations between reals:
:RadSimp:RadSimp(expr):simplify expression with nested radicals:
:Random:Random():(pseudo-) random number generator:
:RandomIntegerMatrix:RandomIntegerMatrix(rows,cols,from,to):generate a
matrix of random integers:
:RandomIntegerVector:RandomIntegerVector(nr, from, to):generate a vector
of random integers:
:RandomPoly:RandomPoly(var,deg,coefmin,coefmax):construct a random
polynomial:
:Rationalize:Rationalize(expr):convert floating point numbers to fractions:
:Re:Re(x):real part of a complex number:
:Read:Read():read an expression from current input:
:Replace:Replace(list, n, expr):replace an entry in a list:
:Reverse:Reverse(list):return the reversed list (without touching the
original):
:Round:Round(x):round a number to the nearest integer:
:RoundTo:RoundTo(number,precision):Round a real-valued result to a set
number of digits:
:Select:Select(pred, list):select entries satisfying some predicate:
:SetGlobalLazyVariable:SetGlobalLazyVariable(var,value):global variable is
to be evaluated lazily:
:Sign:Sign(x):sign of a number:
:Simplify:Simplify(expr):try to simplify an expression:
:Sin:Sin(x):trigonometric sine function:
:Solve:Solve(eq, var):solve an equation:
:SolveMatrix:SolveMatrix(M,v):solve a linear system:
:Sqrt:Sqrt(x):square root:
:SquareFree:SquareFree(p):return the square-free part of polynomial:
:String:String(atom):convert atom to string:
:Subst:Subst(from, to) expr:perform a substitution:
:SuchThat:SuchThat(expr, var):special purpose solver:
:Sum:Sum(var, from, to, body):find sum of a sequence:
:Table:Table(body, var, from, to, step):evaluate while some variable
ranges over interval:
:TableForm:TableForm(list):print each entry in a list on a line:
:Tail:Tail(list):returns a list without its first element:
:Tan:Tan(x):trigonometric tangent function:
:Taylor:Taylor(var, at, order) expr:univariate Taylor series expansion:
:Time:Time(expr):measure the time taken by a function:
:ToBase:ToBase(base, number):conversion of a number in decimal base to
non-decimal base:
:ToString:ToString() body:connect current output to a string:
:Transpose:Transpose(M):get transpose of a matrix:
:TrigSimpCombine:TrigSimpCombine(expr):combine products of trigonometric
functions:
:True:True:boolean constant representing true:
:TruncRadian:TruncRadian(r):remainder modulo $2*Pi$:
:Type:Type(expr):return the type of an expression:
:UnFlatten:UnFlatten(list,operator,identity):inverse operation of Flatten:
:UnList:UnList(list):convert a list to a function application:
:Undefined:Undefined:constant signifying an undefined result:
:Union:Union(l1, l2):return the union of two lists:
:UniqueConstant:UniqueConstant():create a unique identifier:
:Until:Until(pred) body:loop until a condition is met:
:V:V(expression):set verbose output mode:
:VarList:VarList(expr):list of variables appearing in an expression:
:Verify:Verify(question,answer):verifying equivalence of two expressions:
:VerifyArithmetic:VerifyArithmetic(x,n,m):Special purpose arithmetic
verifiers:
:VerifyDiv:VerifyDiv(u,v):Special purpose arithmetic verifiers:
:Version:Version():show version of Yacas:
:While:While(pred) body:loop while a condition is met:
:WithValue:WithValue(var, val, expr):temporary assignment during an
evaluation:
:WithValue:WithValue({var,...}, {val,...}, expr)::
:Write:Write(expr, ...):low-level printing routine:
:WriteString:WriteString(string):low-level printing routine for strings:
:ZeroMatrix:ZeroMatrix(n):make a zero matrix:
:ZeroMatrix:ZeroMatrix(n, m)::
:ZeroVector:ZeroVector(n):create a vector with all zeroes:


