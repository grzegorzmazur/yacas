
/*
In this file I am working through the exercises from the book "Quantum Field Theory in a nutshell", A. Zee. 
The goal is to do Feynman diagram calculations in the end.
*/


//////////////////////////////////////////////////////////////////////////////////////////////////////////////


/* Wick contraction: in a list of even number of elements {a,b,c,...} return all possible combinations of grouping 
 * two elements. Example:
 * 
 * In> WickContract({1,2,3,4})
 * Out> {{{1,4},{2,3}},{{1,3},{2,4}},{{1,2},{3,4}}}
 *
 * In general, if there are 2*n elements in the input list, then the output list contains (2*n-1)!! items, which is (2*n-1)*(2*n-3)*...*3*1.
 * 
 * Wick contraction is used in the context of quantum field theory.
 * 
 * The function defined below works recursively. It takes the first element of the list passed in, and combines it with every other element
 * in the list, one at a time, removing both items from the list and doing a Wick contraction on the remaining list, combining the results afterwards. 
 * 
 */
LocalSymbols(WickThread) [ // WichThread is a local macro 

Macro(WickThread,{item}) {first,second}:(@item);

10 # WickContract({}) <-- {};
20 # WickContract(list_IsList)_(Length(list) = 2) <-- {{list}};
30 # WickContract(list_IsList)_(IsEven(Length(list))) <--
[
  Local(first,second,i,result);
  {result,first,list} := {{},Head(list),Tail(list)};
  For(i:=Length(list),i>=1,i--)
  [
    second:=list[i];
    result:=Concat(MapSingle(WickThread,WickContract(Delete(list,i))),result);
  ];
  result;
];

]; // end of accessibility to local symbol WickThread



//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* From chapter I.7, the baby problem. 
 * Taking Z(lambda,J) := Exp(-lambda*ddJ^4/(4!))*Exp(J^2/(2*m^2));
 * the task is to expand Z(lambda,J) in a Taylor series with respect to lambda ad J. Each term would
 * correspond to a Feynman diagram in this baby problem.
 * 
 */

Z(lambda,J) := Exp(-lambda*ddJ^4/(4!))*Exp(J^2/(2*m^2));

/* Expand to certain orders in J and lambda. */
ExpandZ(lambdaMax,JMax):=
[
  Local(result,i,final,coef);
  result := Taylor(J,0,JMax)Z(lambda,J);
  result:=Taylor(lambda,0,lambdaMax)result;
  final := 0;
  For(i:=0,i<=lambdaMax,i++)
  [
    coef := Coef(result,ddJ,4*i);
    final:=final+Deriv(J,4*i)coef;
  ];
  final;
];

/* Extract a specific coefficient by expanding a Taylor series first all the way up to the term we want. */
SlowExtractZ(lambdaMax,JMax):=
[
  Local(result,final,coef);
  result:=Taylor(lambda,0,lambdaMax)Taylor(J,0,(JMax+4*lambdaMax))Z(lambda,J);
  coef := Coef(Coef(Coef(result,ddJ,4*lambdaMax),lambda,lambdaMax),J,JMax+4*lambdaMax);
  Simplify((Deriv(J,lambdaMax*4)coef*J^(JMax+4*lambdaMax)))*lambda^lambdaMax;
];


/* Extract specific coefficient of Taylor series expansion, optimized for the baby problem. 
 * The trick is that lambdaIndex determines that the 4*lambdaIndex-th order derivative of J will
 * be taken, so expanding the Taylor series implicitly, writing down the term of order lambdaIndex in lambda
 * and JIndex+4*lambdaIndex and then taking the derivative with respect to J lambdaIndex*4 times, gives
 * the wanted result.
 */
FastExtractZ(lambdaIndex,JIndex):=
[
  Local(jhigh);
  jhigh := (JIndex+4*lambdaIndex)/2;  
  Simplify((Deriv(J,4*lambdaIndex)J^(2*jhigh))*((-lambda)^lambdaIndex/((4!)^lambdaIndex)/(2^jhigh*m^(2*jhigh)*(jhigh!)*(lambdaIndex!))));
];

/* Closed form solution, not needing to take derivatives any more. Gives the same results as FastExtractZ. */
ClosedFormExtractZ(lambdaIndex,JIndex):=
[
  Simplify((1/(lambdaIndex!))*(1/(4!))^lambdaIndex*(-lambda)^lambdaIndex*(1/(((JIndex+4*lambdaIndex)/2)!))*(1/(2*m^2))^((JIndex+4*lambdaIndex)/2)*((JIndex+4*lambdaIndex)!)/(JIndex!)*J^JIndex);
];


