<HTML>
<A NAME="c1">

</A>
<HEAD><TITLE>Yacas Under the Hood</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Yacas Under the Hood
</H1>
This part of the manual is a somewhat in-depth explanation of the
Yacas programming language and environment. It assumes that you have worked
through the introductory tutorial. You should consult the function reference about how to use the various Yacas functions mentioned here.
<A NAME="c1s1">

</A>
<H2>
<HR>The Yacas Architecture
</H2>
Yacas is designed as a small core engine that interprets a library
of scripts. The core engine provides the syntax parser and a number of
hard-wired functions, such as <B><TT>Set()</TT></B> or 
<B><TT>MathExp()</TT></B> which cannot be redefined by the user. The script
library resides in the scripts directory "<B><TT>scripts</TT></B>" and
contains higher-level definitions of functions and constants. The library
scripts are on equal footing with any code the user executes interactively
or any files the user loads.
<P>
Generally, all core functions have plain names and almost all are not
'bodied' or infix operators. The file "src/yacasapi.cc" in the source
tree lists declarations of all kernel functions; consult it for reference.
For many of the core functions, the script library already provides
convenient aliases. For instance, the addition operator "+" is defined in
the script <B><TT>scripts/standard</TT></B> while the actual addition of
numbers is performed through the built-in function
<B><TT>MathAdd</TT></B>.
<A NAME="c1s2">

</A>
<H2>
<HR>Startup and the .def files
</H2>
When Yacas is first started or restarted, it executes the script
"yacasinit" in the scripts directory. This script may load some other
scripts. In order to start up quickly, Yacas does not execute all other
library scripts at first run or at restart. It only executes the file
<B><TT>yacasinit</TT></B> and all .def files in the scripts and addons
directories. These .def files tell the system where it can find definitions
for various functions. For example, the function <B><TT>ArcTan</TT></B> is
mentioned in the file "stdfuncs.def", therefore Yacas will load the file
"stdfuncs" when the user invokes <B><TT>ArcTan</TT></B>. This way Yacas
knows where to look for any given function without actually loading the
file where the function is defined.
<A NAME="c1s3">

</A>
<H2>
<HR>Object types
</H2>
Yacas supports two basic kinds of objects: atoms and compounds. Atoms are (integer or real, arbitrary-precision) numbers such as <B><TT>2.71828</TT></B>, symbolic variables such as <B><TT>A3</TT></B> and character strings. Compounds include functions and expressions, e.g. <B><TT>Cos(a-b)</TT></B> and lists, e.g. <B><TT>{1+a,2+b,3+c}</TT></B>.
<P>
The type of an object is returned by the built-in function <B><TT>Type</TT></B>, for example:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Type(a);
Out> "";
In> Type(F(x));
Out> "F";
In> Type(x+y);
Out> "+";
In> Type({1,2,3});
Out> "List";
</PRE></TR>
</TABLE>
Internally, atoms are stored as strings and compounds as lists. The
functions <B><TT>String()</TT></B> and <B><TT>Atom()</TT></B> convert
between atoms and strings. A Yacas list <B><TT>{1,2,3}</TT></B> is
internally a list <B><TT>(List 1 2 3)</TT></B> which is the same as a
function call <B><TT>List(1,2,3)</TT></B> and for this reason the "type"
of a list is the string <B><TT>"List"</TT></B>. During evaluation, atoms
can be interpreted as numbers, or as variables that may be bound to some
value, while compounds are interpreted as function
calls.
<P>
Note that atoms that result from an <B><TT>Atom()</TT></B> call may be
invalid and never evaluate to anything. For example,
<B><TT>Atom(3X)</TT></B> is an atom with string representation "3X" but
with no other properties.
<P>
Currently, no other lowest-level objects besides strings and lists are provided by the core engine. There is however a possibility to link externally compiled code that will provide additional types of objects. Those will be available in Yacas as "generic objects."
<A NAME="c1s4">

</A>
<H2>
<HR>Evaluation Scheme
</H2>
Evaluation of an object is performed either explicitly by the built-in command <B><TT>Eval()</TT></B> or implicitly when assigning variables or calling functions with the object as argument (except when a function does not evaluate that argument). Evaluation of an object can be explicitly inhibited using <B><TT>Hold()</TT></B>. To make a function not evaluate one of its arguments, a <B><TT>HoldArg(funcname, argname)</TT></B> must be declared for that function. 
<P>
Evaluation when performed on an atom goes as follows: if the atom
is bound locally as a variable, the object it is bound to is returned,
otherwise, if it is bound as a global variable that is returned. Otherwise,
the atom is returned unevaluated.
<P>
Lists of atoms are generally interpreted in the following way: the first
atom of the list is some command, and the atoms following in the list are
considered the arguments. The engine first tries to find out if it is a
built-in command (core function). In that case, the function is executed.
Otherwise, it could be a user-defined function (with a "rule database"),
and in that case the rules from the database are applied to it. If none of
the rules are applicable, or if no rules are defined for it, the object is
returned unevaluated.
<P>
The main properties of this scheme are the following. When objects are
assigned to variables, they generally are evaluated (except if you are
using the <B><TT>Hold()</TT></B> function) because assignment
<B><TT>var := value</TT></B> is really a function call to
<B><TT>Set(var, value)</TT></B> and this function evaluates its second
argument (but not its first argument). When referencing that variable
again, the object which is its value will not be re-evaluated. Also, the
default behaviour of the engine is to return the original expression if it
couldn't be evaluated. This is a desired behaviour if evaluation is used
for simplifying expressions.
<P>
One major design flaw in Yacas (one that other functional languages like
LISP also have) is that when some expression is re-evaluated in another
environment, the local variables contained in the expression to be
evaluated might have a different meaning. In this case it might be useful
to use the functions <B><TT>LocalSymbols</TT></B> and
<B><TT>TemplateFunction</TT></B>. Calling <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>LocalSymbols(a,b)
a+b;</PRE></TR>
</TABLE>
 results in "a" and "b" in the addition being substituted with
unique symbols that can not clash with other variables being used
elsewhere. Use <B><TT>TemplateFunction</TT></B> instead of
<B><TT>Function</TT></B> to define a function whose parameters should be
treaded as unique symbols also.
<A NAME="c1s5">

</A>
<H2>
<HR>Rules
</H2>
<I>Rules</I> are special properties of functions that
are applied when the function object is being evaluated. A function could
have just one rule bound to it; this is similar to having a "function
body" in normal procedural languages. However, Yacas function objects can
also have several rules bound to them. This is analogous of having several
alternative "function bodies" that are executed under different
circumstances. This design is more suitable for symbolic manipulations.

<P>
A function is identified by its name as returned by <B><TT>Type</TT></B>
and the number of arguments, or "arity". The same name can be used with
different arities to define different functions: <B><TT>f(x)</TT></B> is
said to 'have arity 1' and <B><TT>f(x,y)</TT></B> has arity 2. Each of
these functions may possess its own set of specific rules, which we shall
call a "rule database" of a function.
<P>
Each function should be first declared with the built-in command
<B><TT>RuleBase</TT></B> as follows:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>RuleBase("FunctionName",{argument list});</PRE></TR>
</TABLE>
 So, a new (and empty) rule database for <B><TT>f(x,y)</TT></B> could be
created by typing <B><TT>RuleBase("f",{x,y});</TT></B> The names for the
arguments "x" and "y" here are arbitrary, but they will be globally stored
and must be later used in descriptions of particular rules for the function
"f". After the new rulebase declaration, the evaluation engine of Yacas
will begin to really recognize "f" as a function, even though no function
body or equivalently no rules have been defined for it yet.



<P>
The shorthand operator <B><TT>:=</TT></B> for creating user functions that
we illustrated in the tutorial is actually defined in the scripts and it
makes the requisite call to the <B><TT>RuleBase</TT></B> function.
After a <B><TT>RuleBase</TT></B> call you can specify parsing
properties for the function if you like; for example, you could make it an
infix or bodied operator.
<P>
Now we can add some rules to the rule database for a function. A rule
simply states that if a specific function object with a specific arity is
encountered in  an expression and if a certain predicate is true, then
Yacas should replace this function with some other expression. To tell Yacas about a new rule you can use the built-in <B><TT>Rule</TT></B> command. This command is what does the real work for the somewhat more aesthetically pleasing <B><TT>... # ... <-- ... ;</TT></B> construct we have seen in the tutorial. Incidentally, you do not have to call <B><TT>RuleBase</TT></B> explicitly if you use that construct.
<P>
Here is the general syntax for a <B><TT>Rule</TT></B> call: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Rule("foo", arity, precedence, predicate) body;</PRE></TR>
</TABLE>
This specifies that for function <B><TT>foo</TT></B> with given
<B><TT>arity</TT></B> (<B><TT>foo(a,b)</TT></B> has arity 2), there is a
rule that if <B><TT>predicate</TT></B> is true, then <B><TT>body</TT></B>
should be evaluated, and the original expression replaced by the result.
Predicate and body can use the symbolic names of arguments that were
declared in the <B><TT>RuleBase</TT></B> call.
<P>
All rules for a given function can be erased with a call to <B><TT>Retract(funcname, arity)</TT></B>. This is useful, for instance, when too many rules have been entered in the interactive mode. This call undefines the function and also invalidates the <B><TT>RuleBase</TT></B> declaration. 
<P>
You can specify that function arguments are not evaluated before they are
bound to the parameter: <B><TT>HoldArg("foo",a);</TT></B> would then
declare that the a arguments in both <B><TT>foo(a)</TT></B> and <B><TT>foo(a,b)</TT></B> should not be evaluated before bound to "a". Here
the argument name "a" should be the same as that used in the <B><TT>RuleBase</TT></B> call when declaring these functions.
Inhibiting evaluation of certain arguments is useful for procedures
performing actions based partly on a variable in the expression, like
integration, differentiation, looping, etc., and will be typically used for
functions that are algorithmic and procedural by
nature.
<P>
Rule-based programming normally makes heavy use of recursion and it is
important to control the order in which replacement rules are to be
applied. For this purpose, each rule is given a <B><TT>precedence</TT></B>.
Precedences go from low to high, so all rules with precedence 0 will be
tried before any rule with precedence 1.
<P>
You can assign several rules to one and the same function, as long as some of the predicates differ. If none of the predicates is true,
the function with its arguments evaluated is returned.
<P>
This scheme is slightly slower for ordinary functions that just have one
rule (with the predicate <B><TT>True</TT></B>), but it is a desired
behaviour for symbolic manipulation. You can slowly build up your own functions, incrementally testing their properties.
<P>

<A NAME="c1s6">

</A>
<H2>
<HR>Examples of using rules
</H2>
As a simple example, here are the actual <B><TT>RuleBase</TT></B>
and <B><TT>Rule</TT></B> calls needed to define the factorial function:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> RuleBase("f",{n});<P>  </P>Out> True;<P>  </P>In> Rule("f", 1, 10, n=0) 1;<P>  </P>Out> True;<P>  </P>In> Rule("f", 1, 20, IsInteger(n) And n>0) n*f(n-1);<P>  </P>Out> True;
</PRE></TR>
</TABLE>
This definition is entirely equivalent to the one we gave in the tutorial. <B><TT>f(4)</TT></B> should now return 24, while <B><TT>f(a)</TT></B> should return just <B><TT>f(a)</TT></B> if "a" is not bound to any value.
<P>
The <B><TT>Rule</TT></B> commands in this example specified two rules for function "f"
with arity 1: one rule with precedence 10 and predicate <B><TT>n=0</TT></B>, and another with precedence 20 and the predicate that returns <B><TT>True</TT></B> only
if "n" is a positive integer. Rules with lowest precedence get evaluated
first, so the rule with precedence 10 will be tried before the rule with
precedence 20. Note that the predicates and the body use the name "n"
declared by the <B><TT>RuleBase</TT></B> call.
<P>
After declaring <B><TT>RuleBase</TT></B> for a function, you could
tell the parser to treat this function as a postfix operator: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Postfix("f");<P>  </P>Out> True;<P>  </P>In> 4 f;<P>  </P>Out> 24;
</PRE></TR>
</TABLE>
There is already a function <B><TT>Function</TT></B> defined in the
standard scripts that allows you to construct simple functions. An example
would be <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Function ("FirstOf", {list})  list[ 1 ] ; </PRE></TR>
</TABLE>
which simply returns the first element of a list. This could also have
been written as <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Function("FirstOf", {list})<P>  </P>[<P>  </P>  list[1] ;<P>  </P>];</PRE></TR>
</TABLE>
As mentioned before, the [ and ] brackets are also used to combine multiple
operations to be performed one after the other. The result of the last
performed action is returned.
<P>
Finally, the function <B><TT>FirstOf</TT></B> could also have been
defined by typing <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>FirstOf(list):=list[1] ;</PRE></TR>
</TABLE>

<A NAME="c1s7">

</A>
<H2>
<HR>Structured programming
</H2>
Some functions useful for control flow are already defined in Yacas's standard library. Let's look at a possible definition of a looping function <B><TT>ForEach</TT></B>. We shall here consider a somewhat simple-minded definition, while the actual <B><TT>ForEach</TT></B> as defined in the standard script "controlflow" is a little more sophisticated.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Function("ForEach",{foreachitem,foreachlist,foreachbody})<P>  </P>[<P>  </P>   Local(foreachi,foreachlen);<P>  </P>   foreachlen:=Length(foreachlist);<P>  </P>   foreachi:=0;<P>  </P>   While (foreachi < foreachlen)<P>  </P>   [<P>  </P>     foreachi++;<P>  </P>     MacroLocal(foreachitem);<P>  </P>     MacroSet(foreachitem,foreachlist[foreachi]);<P>  </P>     Eval(foreachbody);<P>  </P>   ];<P>  </P>];<P>  </P><P>  </P>Bodied("ForEach");<P>  </P>UnFence("ForEach",3);<P>  </P>HoldArg("ForEach",foreachitem);<P>  </P>HoldArg("ForEach",foreachbody);</PRE></TR>
</TABLE>
Functions like this should probably be defined in a separate file. You can
load such a file with the command <B><TT>Load("file")</TT></B>This is an example of a macro-like function.  Let's look at the last few
lines first. There is a <B><TT>Bodied(...)</TT></B> , which states that a
for command is to be entered as <B><TT>ForEach(item,{list}) body;</TT></B>
. That is, the last argument to the command ForEach should be outside its
brackets.<B><TT>UnFence(...)</TT></B> states that this function can use the local
variables of the calling function. This is necessary, since the body to be
evaluated for each item will probably use some local variables from that
surrounding.
<P>
Finally, <B><TT>HoldArg("function",argument)</TT></B> specifies that
the argument <B><TT>argument</TT></B> should not be evaluated before being
bound to that variable. This holds for <B><TT>foreachitem</TT></B> and
<B><TT>foreachbody</TT></B> , since <B><TT>foreachitem</TT></B> specifies
a variable to be set to that value, and <B><TT>foreachbody</TT></B> is the
expression that should be evaluated <I>after</I> that variable
is set.
<P>
Inside the body of the function definition there are calls to <B><TT>Local(...)</TT></B>. 'Local' declares some local variable that will
only be visible within a block [ ... ]. The command MacroLocal works almost
the same. The difference is that it evaluates its arguments before
performing the action on it. This is needed in this case, because the
variable foreachitem is bound to the variable to be used, and it is
<I>the variable it is bound to</I> we want to make local, not
"foreachitem" itself. MacroSet works similarly, it does the same as Set,
except that it also first evaluates the first argument, thus setting the
variable requested by the user of this function. The Macro... functions in
the built-in functions generally perform the same action as their non-macro
versions, apart from evaluating an argument it would otherwise not
evaluate.
<P>
To see the function in action, you could type: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>ForEach(i,{1,2,3}) [Write(i);NewLine();];</PRE></TR>
</TABLE>
This should obviously write 1, 2 and 3, each on a new line.
<P>
Note: the variable names "foreach..." have been chosen so they won't get
confused with normal variables you use. This is a major design flaw in this
language. Suppose there was a local variable foreachitem, defined in the
calling function, and used in foreachbody. These two would collide, and the
interpreter would use only the last defined version. In general, when
writing a function that calls <B><TT>Eval</TT></B> , it is a good idea to
use variable names that can not easily be mistaken. This is generally the
single largest cause of bugs when writing programs in Yacas. This issue
should be addressed in the future.
<A NAME="c1s8">

</A>
<H2>
<HR>Additional Syntactic Sugar
</H2>
The parser is extended slightly to allow for fancier constructs.
<P>
<UL><LI> Lists, like for example <B><TT>{a,b}</TT></B>. This then
         gets parsed into the internal notation <B><TT>(List a b)</TT></B> , but
         will be printed again as <B><TT>{a,b};</TT></B><LI> Statement blocks like <B><TT>[statement1(); statement2();]</TT></B> , which
         get parsed into <B><TT>(Prog (statement1) (statement2))</TT></B> , and printed out again in the proper form.<LI> Object argument accessors in the form of
         <B><TT>expr[ index ]</TT></B> . These
         are mapped internally to <B><TT>Nth(expr,index)</TT></B> . index 0 returns the
         operator of the object, index 1 the first argument, etc. So,
         if expr is <B><TT>foo(bar)</TT></B> , then
         <B><TT>expr[0]</TT></B> returns foo, and
         <B><TT>expr[1]</TT></B> returns bar. Since Lists of the form
         <B><TT>{...}</TT></B> are essentially the same as
         <B><TT>List(...)</TT></B> , the same accessors
         can be used on lists.<LI> Function blocks like <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>     While (i < 10)<P>  </P>       [<P>  </P>	  Write(i);<P>  </P>         i:=i+1;<P>  </P>       ];</PRE></TR>
</TABLE>
The expression directly following the <B><TT>While(...)</TT></B> block is added as a last argument to the <B><TT>While(...)</TT></B> call. So <B><TT>While(a)b;</TT></B> is parsed to the internal form <B><TT>(While a b).</TT></B>This scheme allows coding the algorithms in an almost C-like syntax.
<P>
Strings are generally represented with quotes around them, like
"this is a string" .  \ in a string will unconditionally add the
next character to the string, so a quote can be added with \" .</UL>
<A NAME="c1s9">

</A>
<H2>
<HR>Scope Of Variable Bindings
</H2>
When setting variables or retrieving variable values, variables
are automatically bound global by default. You can explicitly
specify variables to be local. When invoking a function, a new
stack frame is pushed for the locals, so the code inside a
function body doesn't see the locals of the caller. A statement
block can have its own locals that are not visible outside the
block (blocks have the form <B><TT>[statement1(); statement2(); ]</TT></B> etc.). 
<P>
You can tell the interpreter that a function can see the local variables
from the calling environment by declaring <B><TT>UnFence(funcname,
arity)</TT></B> on the specified function.

</BODY>

</FONT>

</HTML>
