<HTML>
<HEAD><TITLE>Yacas users function reference</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Yacas users function reference
</H1>
<UL>
<LI>
<A HREF="ref.html#c1">
Startup configuration
</A>

</LI>
<LI>
<A HREF="ref.html#c2">
Arithmetic
</A>

</LI>
<LI>
<A HREF="ref.html#c3">
Other operations on numbers
</A>

</LI>
<LI>
<A HREF="ref.html#c4">
Calculus
</A>

</LI>
<LI>
<A HREF="ref.html#c5">
Linear Algebra
</A>

</LI>
<LI>
<A HREF="ref.html#c6">
Polynomials
</A>

</LI>
<LI>
<A HREF="ref.html#c7">
List operations
</A>

</LI>
<LI>
<A HREF="ref.html#c8">
Functional operators
</A>

</LI>
<LI>
<A HREF="ref.html#c9">
Control flow functions
</A>

</LI>
<LI>
<A HREF="ref.html#c10">
Predicates
</A>

</LI>
<LI>
<A HREF="ref.html#c11">
Propositional logic theorem prover
</A>

</LI>
<LI>
<A HREF="ref.html#c12">
Constants
</A>

</LI>
<LI>
<A HREF="ref.html#c13">
Variables
</A>

</LI>
<LI>
<A HREF="ref.html#c14">
Input/Output
</A>

</LI>
<LI>
<A HREF="ref.html#c15">
String manipulation
</A>

</LI>
<LI>
<A HREF="ref.html#c1">
Programming
</A>

</LI>
<LI>
<A HREF="ref.html#c2">
Built-in functions
</A>

</LI>
<LI>
<A HREF="ref.html#c3">
The Yacas plugin structure
</A>

</LI>
<LI>
<A HREF="ref.html#c4">
Generic objects
</A>

</LI>

</UL>
<A NAME="c1">

</A>
<A HREF="refchapter1.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
, <A HREF="refchapter1.html#PrettyPrinter" TARGET="Chapters">
PrettyPrinter
</A>
, <A HREF="refchapter1.html#Help" TARGET="Chapters">
Help
</A>
, <A HREF="refchapter1.html#HistorySize" TARGET="Chapters">
HistorySize
</A>
.
<H1>
Startup configuration
</H1>

Yacas allows you to configure a few things at startup. The file
<B><TT>~/.yacasrc</TT></B> will be executed when Yacas is run. The
following functions can be useful when used in the <B><TT>~/.yacasrc</TT></B> file.
<A NAME="DefaultDirectory">

</A>
<H3>
<HR>DefaultDirectory -- Add directory to path for Yacas scripts
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DefaultDirectory(path)
<H5>
Parameters:
</H5>
path - a string containing a full path where yacas script files reside
<H5>
Description:
</H5>
When loading files, yacas is also allowed to
look in the folder "path". path will be prepended
to the file name before trying to load the file.
This means that "path" should end with a forward slash (under unix-like
operating systems). 
<p> </p>
Yacas first tries to load a file from the current
directory, and otherwise it tries to load from
directories defined with this function, in the
order they are defined. Note there will be at least one directory
specified at start-up time, defined during compilation. This
is the directory Yacas searches for the initialization scripts
and standard scripts.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DefaultDirectory("/home/user/myscripts/");
Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="ref.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="ref.html#FindFile" TARGET="Chapters">
FindFile
</A>
.<A NAME="PrettyPrinter">

</A>
<H3>
<HR>PrettyPrinter -- Set routine to use as pretty-printer
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PrettyPrinter(printer)
<H5>
Parameters:
</H5>
printer - a string containing the name of a function that can
pretty-print an expression
<H5>
Description:
</H5>

This function sets up the function printer to print out the results on
the command line. This can be reset to the internal printer with <B><TT>PrettyPrinter()</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
In> PrettyPrinter("PrettyForm");

True

Out> 
In> Taylor(x,0,5)Sin(x)

     3    5 
    x    x  
x - -- + ---
    6    120

Out> 
In> PrettyPrinter();
Out> True;
In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
.<A NAME="Help">

</A>
<H3>
<HR>Help -- Show documentation for some command
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Help() <br> Help(function)
<H5>
Parameters:
</H5>
function - a string containing the name of a function to show help for
<H5>
Description:
</H5>
When help is requested by the user, by typing <B><TT>?</TT></B>function or <B><TT>??</TT></B>, the functions <B><TT>Help()</TT></B> (for <B><TT>??</TT></B>) and <B><TT>Help(</TT></B>function<B><TT>)</TT></B> (for <B><TT>?</TT></B>function) are called.  By default, lynx is used as a
browser. The help resides in the subdirectory <B><TT>documentation/</TT></B> under the directory the math scripts
were installed in. So the help files can be found using <B><TT>FindFile</TT></B>.
<H5>
Examples:
</H5>
To use netscape for browsing help, enter the following commands:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Help(_f) <-- SystemCall("netscape ":FindFile("documentation/ref.html"):"#":f);
Help() := SystemCall("netscape ":FindFile("documentation/books.html"));
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#SystemCall" TARGET="Chapters">
SystemCall
</A>
, <A HREF="ref.html#FindFile" TARGET="Chapters">
FindFile
</A>
.<A NAME="HistorySize">

</A>
<H3>
<HR>HistorySize -- Set size of history file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
HistorySize(n)
<H5>
Parameters:
</H5>
n - number of lines to store in history file
<H5>
Description:
</H5>
When exiting, yacas saves the command line history to a
file <B><TT>~/.yacas_history</TT></B>. By default it will only
save the last 50 lines, to save space on the harddisk. This can be
overridden with this function. Passing -1 tells the system to save all
the lines.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> HistorySize(200)
Out> True;
In> quit
</PRE></TR>
</TABLE>

<p>  </P><HR><A NAME="c2">

</A>
<A HREF="refchapter2.html#+, -, *, /, ^" TARGET="Chapters">
+, -, *, /, ^
</A>
.
<H1>
Arithmetic
</H1>
<A NAME="+">

</A>
<A NAME="-">

</A>
<A NAME="*">

</A>
<A NAME="/">

</A>
<A NAME="^">

</A>
<A NAME="+, -, *, /, ^">

</A>
<H3>
<HR>+, -, *, /, ^ -- Arithmetic operations
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
x+y  (precedence 6)  <br>
+x                   <br>
x-y  (precedence 5)   <br>
-x                   <br>
x*y  (precedence 3)   <br>
x/y  (precedence 3)   <br>
x^y  (precedence 2)   

<H5>
Parameters:
</H5>
x and y - some objects for which arithmetic operations are defined.
<H5>
Description:
</H5>
These are the basic arithmetic operations. They can work on integers,
rational numbers, complex numbers, vectors, matrices and lists. 
<p> </p>
These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2+3
Out> 5;
In> 2*3
Out> 6;
</PRE></TR>
</TABLE>

<p>  </P><HR><A NAME="c3">

</A>
<A HREF="refchapter3.html#Div, Mod" TARGET="Chapters">
Div, Mod
</A>
, <A HREF="refchapter3.html#Gcd" TARGET="Chapters">
Gcd
</A>
, <A HREF="refchapter3.html#Lcm" TARGET="Chapters">
Lcm
</A>
, <A HREF="refchapter3.html#&lt;&lt;, &gt;&gt;" TARGET="Chapters">
&lt;&lt;, &gt;&gt;
</A>
, <A HREF="refchapter3.html#FromBase, ToBase" TARGET="Chapters">
FromBase, ToBase
</A>
, <A HREF="refchapter3.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="refchapter3.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A HREF="refchapter3.html#N" TARGET="Chapters">
N
</A>
, <A HREF="refchapter3.html#Rationalize" TARGET="Chapters">
Rationalize
</A>
, <A HREF="refchapter3.html#IsPrime" TARGET="Chapters">
IsPrime
</A>
, <A HREF="refchapter3.html#IsPrimePower" TARGET="Chapters">
IsPrimePower
</A>
, <A HREF="refchapter3.html#Factors" TARGET="Chapters">
Factors
</A>
, <A HREF="refchapter3.html#Factor" TARGET="Chapters">
Factor
</A>
, <A HREF="refchapter3.html#PAdicExpand" TARGET="Chapters">
PAdicExpand
</A>
, <A HREF="refchapter3.html#ContFrac" TARGET="Chapters">
ContFrac
</A>
, <A HREF="refchapter3.html#Decimal" TARGET="Chapters">
Decimal
</A>
, <A HREF="refchapter3.html#TruncRadian" TARGET="Chapters">
TruncRadian
</A>
, <A HREF="refchapter3.html#Floor" TARGET="Chapters">
Floor
</A>
, <A HREF="refchapter3.html#Ceil" TARGET="Chapters">
Ceil
</A>
, <A HREF="refchapter3.html#Round" TARGET="Chapters">
Round
</A>
, <A HREF="refchapter3.html#Pslq" TARGET="Chapters">
Pslq
</A>
.
<H1>
Other operations on numbers
</H1>
Besides the arithmetical operations defined in the
previous chapter, one can also use the following operations on
numbers. Many of these also work on polynomials.
<A NAME="Div">

</A>
<A NAME="Mod">

</A>
<A NAME="Div, Mod">

</A>
<H3>
<HR>Div, Mod -- Division with remainder
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Div(x,y) <br>
Mod(x,y)

<H5>
Parameters:
</H5>
x, y - integers, or univariate polynomials
<H5>
Description:
</H5>
<B><TT>Div</TT></B> performs integer division and <B><TT>Mod</TT></B> returns the remainder after division. <B><TT>Div</TT></B> and
<B><TT>Mod</TT></B> are also defined for polynomials.
<p> </p>
If <B><TT>Div(x,y)</TT></B> returns "a" and <B><TT>Mod(x,y)</TT></B> equals "b", then these numbers satisfy x =
a*y + b and 0 <= b < y.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Div(5,3)
Out> 1;
In> Mod(5,3)
Out> 2;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Gcd" TARGET="Chapters">
Gcd
</A>
, <A HREF="ref.html#Lcm" TARGET="Chapters">
Lcm
</A>
.<A NAME="Gcd">

</A>
<H3>
<HR>Gcd -- Greatest common divisor
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Gcd(n,m)   <br>
Gcd(list)
<H5>
Parameters:
</H5>

n,m - integers or univariate polynomials <br>
list - a list of all integers or all univariate polynomials

<H5>
Description:
</H5>

This function returns the greatest common divisor of "n" and "m".
The gcd is the largest number that divides "n" and "m".  It is
also known as the highest common factor (hcf).  The library code calls
<B><TT>MathGcd</TT></B>, which is an internal function.  This
function implements the binary Euclidean algorithm for determining the
greatest common divisor: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Routine for calculating Gcd(n,m)

1) if n = m then return n
2) if both n and m are even then return 2*Gcd(n/2,m/2)
3) if exactly one of n or m (say n) is even then return Gcd(n/2,m)
4) if both n and m are odd and, say, n>m then return Gcd( (n-m)/2,m)
</PRE></TR>
</TABLE>

This is a rather fast algorithm on computers that can efficiently shift
integers. 
<p> </p>
If the second calling form is used, <B><TT>Gcd</TT></B> will
return the greatest common divisor of all the integers or polynomials
in "list". It uses the identity
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Gcd({a,b,c}) = Gcd(Gcd(a,b),c)
</PRE></TR>
</TABLE>

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Gcd(55,10)
Out> 5;
In> Gcd({60,24,120})
Out> 12;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Lcm" TARGET="Chapters">
Lcm
</A>
.<A NAME="Lcm">

</A>
<H3>
<HR>Lcm -- Least common multiple
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Lcm(n,m)
<H5>
Parameters:
</H5>
n, m - integers, or univariate polynomials
<H5>
Description:
</H5>

This command returns the least common multiple of "n" and "m".
The least common multiple of two numbers "n" and "m" is the lowest
number which is an integer multiple of both "n" and "m".
It is calculated with the formula:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Lcm(n,m) = Div(n*m,Gcd(n,m))
</PRE></TR>
</TABLE>

This means it also works on polynomials, since <B><TT>Div</TT></B>, <B><TT>Gcd</TT></B> and multiplication are also defined for
them.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Lcm(60,24)
Out> 120;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Gcd" TARGET="Chapters">
Gcd
</A>
.<A NAME="&lt;&lt;">

</A>
<A NAME="&gt;&gt;">

</A>
<A NAME="&lt;&lt;, &gt;&gt;">

</A>
<H3>
<HR>&lt;&lt;, &gt;&gt; -- Shift operators
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
n&lt;&lt;m <br> n&gt;&gt;m
<H5>
Parameters:
</H5>
n,m - integers
<H5>
Description:
</H5>
These operators shift integers to the left or to the right.
They are similar to the C shift operators. These are sign-extended
shifts, so they act like multiplication or division by powers of 2.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 1 &lt;&lt; 10
Out> 1024;
In> -1024 &gt;&gt; 10
Out> -1;</PRE></TR>
</TABLE>

<A NAME="FromBase">

</A>
<A NAME="ToBase">

</A>
<A NAME="FromBase, ToBase">

</A>
<H3>
<HR>FromBase, ToBase -- Conversion from/to non-decimal base
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FromBase(base,number) <br>
ToBase(base,number)

<H5>
Parameters:
</H5>
base - a base to write the numbers in <br>
number - a number to write out in the base representation
<H5>
Description:
</H5>
<B><TT>FromBase</TT></B> converts "number", written in base
"base", to base 10. <B><TT>ToBase</TT></B> converts "number",
written in base 10, to base "base".
<p> </p>
These functions use the p-adic expansion capabilities of the built-in
arbitrary precision math libraries.  

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> FromBase(2,111111)
Out> 63;
In> ToBase(16,255)
Out> ff;
</PRE></TR>
</TABLE>

The first command writes the binary number <B><TT>111111</TT></B>
in decimal base. The second command converts <B><TT>255</TT></B>
(in decimal base) to hexadecimal base.
<H5>
See Also:
</H5>
<A HREF="ref.html#PAdicExpand" TARGET="Chapters">
PAdicExpand
</A>
.<A NAME="Precision">

</A>
<H3>
<HR>Precision -- Sets the precision
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Precision(n)
<H5>
Parameters:
</H5>
n - new precision
<H5>
Description:
</H5>

This command sets the number of binary digits to be used in
calculations. All subsequent floating point operations will allow for
at least "n" digits after the decimal point.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Precision(10)
Out> True;
In> N(Sin(1))
Out> 0.8414709848;
In> Precision(20)
Out> True;
In> N(Sin(1))
Out> 0.84147098480789650665;
In> GetPrecision()
Out> 20;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="GetPrecision">

</A>
<H3>
<HR>GetPrecision -- Returns the current precision
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
GetPrecision()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

This command returns the current precision, as set by <B><TT>Precision</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> GetPrecision();
Out> 10;
In> Precision(20);
Out> True;
In> GetPrecision();
Out> 20;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="N">

</A>
<H3>
<HR>N -- Numerical approximation
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

N(expr) <br>
N(expr, prec)
<H5>
Parameters:
</H5>
expr - expression to evaluate <br>
prec - precision to use
<H5>
Description:
</H5>

This function forces Yacas to give a numerical approximation to the
expression "expr", using "prec" digits if the second calling
sequence is used, and the precision as set by <B><TT>SetPrecision</TT></B> otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. <B><TT>Sqrt(2)</TT></B> instead of <B><TT>1.41421</TT></B>).
<p> </p>
Application of the <B><TT>N</TT></B> operator will make Yacas
calculate floating point representations of functions whenever
possible. In addition, the variable <B><TT>Pi</TT></B> is bound to
the value of pi up to the required precision.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 1/2
Out> 1/2;
In> N(1/2)
Out> 0.5;
In> Sin(1)
Out> Sin(1);
In> N(Sin(1),10)
Out> 0.8414709848;
In> Pi
Out> Pi;
In> N(Pi,20)
Out> 3.14159265358979323846;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="ref.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
.<A NAME="Rationalize">

</A>
<H3>
<HR>Rationalize -- Convert floating point numbers to fractions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Rationalize(expr)
<H5>
Parameters:
</H5>
expr - an expression containing real numbers
<H5>
Description:
</H5>

This command converts every real number in the expression "expr"
into a rational number. This is useful when a calculation needs to be
done on floating point numbers and the algorithm is unstable.
Converting the floating point numbers to rational numbers will force
calculations to be done with infinite precision (by using rational
numbers as representations).
<p> </p>
It does this by finding the smallest integer n such that multiplying
the number with 10^n is an integer. Then it divides by 10^n again,
depending on the internal gcd calculation to reduce the resulting
division of integers.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> {1.2,3.123,4.5}
Out> {1.2,3.123,4.5};
In> Rationalize(%)
Out> {6/5,3123/1000,9/2};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsRational" TARGET="Chapters">
IsRational
</A>
.<A NAME="IsPrime">

</A>
<H3>
<HR>IsPrime -- Test whether argument is a prime number
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
IsPrime(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This command tests whether "n", which should be a positive integer,
is a prime number. A number is a prime number if it is only divisible
by 1 and itself. As a special case, 1 is not a prime number.
<p> </p>
This function essentially checks for all integers between 2 and the
square root of "n" whether they divide "n", and hence may take a
long time for large numbers.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsPrime(1)
Out> False;
In> IsPrime(2)
Out> True;
In> IsPrime(10)
Out> False;
In> IsPrime(23)
Out> True;
In> Select("IsPrime", 1 .. 100)
Out> {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsPrimePower" TARGET="Chapters">
IsPrimePower
</A>
, <A HREF="ref.html#Factors" TARGET="Chapters">
Factors
</A>
.<A NAME="IsPrimePower">

</A>
<H3>
<HR>IsPrimePower -- Test whether argument is a prime power
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
IsPrime(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This command tests whether "n", which should be a positive integer,
is a prime power, that is whether it is of the form "p^m", with
"p" prime and "m" an integer.
<p> </p>
This function essentially checks for all integers between 2 and the
square root of "n" for the largest divisor, and then tests whether
"n" is a power of this divisor. So it will take a long time for
large numbers.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsPrimePower(9)
Out> True;
In> IsPrimePower(10)
Out> False;
In> Select("IsPrimePower", 1 .. 50)
Out> {2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,37,41,43,47,49};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsPrime" TARGET="Chapters">
IsPrime
</A>
, <A HREF="ref.html#Factors" TARGET="Chapters">
Factors
</A>
.<A NAME="Factors">

</A>
<H3>
<HR>Factors -- Factorization
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Factors(x)
<H5>
Parameters:
</H5>
x - integer or univariate polynomial
<H5>
Description:
</H5>

This function decomposes the integer number "x" into a product of
numbers. Alternatively, if "x" is a univariate polynomial, it is
decomposed in irreducible polynomials.
<p> </p>
The factorization is returned as a list of pairs. The first member of
each pair is the factor, while the second member denotes the power to
which this factor should be raised. So the factorization "x = p1^n1 *
... * p9^n9" is returned as <B><TT>{{p1,n1}, ..., {p9,n9}}</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Factors(24);
Out> {{2,3},{3,1}};
In> Factors(2*x^3 + 3*x^2 - 1);
Out> {{2,1},{x+1,2},{x-1/2,1}};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Factor" TARGET="Chapters">
Factor
</A>
, <A HREF="ref.html#IsPrime" TARGET="Chapters">
IsPrime
</A>
.<A NAME="Factor">

</A>
<H3>
<HR>Factor -- Factorization, in pretty form
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Factors(x)
<H5>
Parameters:
</H5>
x - integer or univariate polynomial
<H5>
Description:
</H5>

This function factorizes "x", like <B><TT>Factors</TT></B>, but
it shows the result in a nicer human readable format.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyForm(Factor(24));

 3    
2  * 3

Out> True;
In> PrettyForm(Factor(2*x^3 + 3*x^2 - 1));

             2   /     1 \
2 * ( x + 1 )  * | x - - |
                 \     2 /

Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Factors" TARGET="Chapters">
Factors
</A>
, <A HREF="ref.html#IsPrime" TARGET="Chapters">
IsPrime
</A>
, <A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
.<A NAME="PAdicExpand">

</A>
<H3>
<HR>PAdicExpand -- p-adic expansion
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
PAdicExpand(n, p)
<H5>
Parameters:
</H5>

n - number, or polynomial, to expand <br>
p - base to expand in
<H5>
Description:
</H5>

This command computes the p-adic expansion of "n". In other words,
"n" is expanded in powers of "p". The argument "n" can be either
an integer or a univariate polynomial. The base "p" should be of the
same type.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyForm(PAdicExpand(1234, 10));

               2     3    
3 * 10 + 2 * 10  + 10  + 4

Out> True;
In> PrettyForm(PAdicExpand(x^3, x-1));

                             2            3    
3 * ( x - 1 ) + 3 * ( x - 1 )  + ( x - 1 )  + 1

Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Mod" TARGET="Chapters">
Mod
</A>
, <A HREF="ref.html#ContFrac" TARGET="Chapters">
ContFrac
</A>
, <A HREF="ref.html#FromBase, ToBase" TARGET="Chapters">
FromBase, ToBase
</A>
.<A NAME="ContFrac">

</A>
<H3>
<HR>ContFrac -- Continued fraction expansion
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

ContFrac(x) <br> 
ContFrac(x, maxdepth)
<H5>
Parameters:
</H5>
x - expression to break down<br>
maxdepth - maximum required depth of result

<H5>
Description:
</H5>

This command returns the continued fraction expansion of "n", which
should be either a floating point number or a polynomial. If
"maxdepth" is not specified, it defaults to 6. The remainder is
denoted by <B><TT>rest</TT></B>.
<p> </p>
This is especially useful for polynomials, since series expansions
that converge slowly will typically converge a lot faster if
calculated using a continued fraction expansion.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyForm(ContFrac(N(Pi)))

             1                 
--------------------------- + 3
           1                   
----------------------- + 7    
        1                      
------------------ + 15        
      1                        
-------------- + 1             
   1                           
-------- + 292                 
rest + 1                       

Out> True;
In> PrettyForm(ContFrac(x^2+x+1, 3))

       x            
---------------- + 1
         x          
1 - ------------    
       x            
    -------- + 1    
    rest + 1        

Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PAdicExpand" TARGET="Chapters">
PAdicExpand
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="Decimal">

</A>
<H3>
<HR>Decimal -- Decimal representation of a rational
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Decimal(frac)
<H5>
Parameters:
</H5>
frac - a rational number
<H5>
Description:
</H5>

This function returns the infinite decimal representation of the
rational number "frac".  It returns a list, with the first element
being the number before the decimal point and the last element the
sequence of digits that will repeat forever. All the intermediate list
elements are the initial digits.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Decimal(1/22)
Out> {0,0,{4,5}};
In> N(1/22,30)
Out> 0.045454545454545454545454545454;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="TruncRadian">

</A>
<H3>
<HR>TruncRadian -- Remainder modulo 2*Pi
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
TruncRadian(r)
<H5>
Parameters:
</H5>
r - a radian
<H5>
Description:
</H5>
TruncRadian calculates r mod 2*Pi, returning a value
between 0 and 2*Pi. This function is used in the trigonometry
functions, just before doing the numerical calculation. It
greatly speeds up the calculation if the value passed is a big
number. <p>  </p>
The library uses the formula

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>

             /   r    \         
r - MathFloor| ------ | * 2 * Pi
             \ 2 * Pi /         


</PRE></TR>
</TABLE>


where r and 2*Pi are calculated with twice the precision used in the
environment to make sure there is no rounding error in the significant
digits.


<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2*Pi()
Out> 6.283185307;
In> TruncRadian(6.28)
Out> 6.28;
In> TruncRadian(6.29)
Out> 0.0068146929;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sin" TARGET="Chapters">
Sin
</A>
, <A HREF="ref.html#Cos" TARGET="Chapters">
Cos
</A>
, <A HREF="ref.html#Tan" TARGET="Chapters">
Tan
</A>
.<A NAME="Floor">

</A>
<H3>
<HR>Floor -- Round a number downwards
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Floor(x)
<H5>
Parameters:
</H5>
x - a number
<H5>
Description:
</H5>
This function returns the largest integer smaller than "x".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Floor(1.1)
Out> 1;
In> Floor(-1.1)
Out> -2;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Ceil" TARGET="Chapters">
Ceil
</A>
, <A HREF="ref.html#Round" TARGET="Chapters">
Round
</A>
.<A NAME="Ceil">

</A>
<H3>
<HR>Ceil -- Round a number upwards
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Ceil(x)
<H5>
Parameters:
</H5>
x - a number
<H5>
Description:
</H5>
This function returns the smallest integer larger than "x".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Ceil(1.1)
Out> 2;
In> Ceil(-1.1)
Out> -1;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Floor" TARGET="Chapters">
Floor
</A>
, <A HREF="ref.html#Round" TARGET="Chapters">
Round
</A>
.<A NAME="Round">

</A>
<H3>
<HR>Round -- Round a number to the nearest integer
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Round(x)
<H5>
Parameters:
</H5>
x - a number
<H5>
Description:
</H5>
This function returns the integer closest to "x". Half-integers
(ie. numbers of the form "n + 0.5", with "n" an integers) are
rounded upwards.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Round(1.49)
Out> 1;
In> Round(1.51)
Out> 2;
In> Round(-1.49)
Out> -1;
In> Round(-1.51)
Out> -2;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Floor" TARGET="Chapters">
Floor
</A>
, <A HREF="ref.html#Ceil" TARGET="Chapters">
Ceil
</A>
.<A NAME="Pslq">

</A>
<H3>
<HR>Pslq -- Search for integer relations between reals
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Pslq(xlist,precision)
<H5>
Parameters:
</H5>
xlist - list of numbers <br>
precision - required number of digits precision of calculation

<H5>
Description:
</H5>

This function is an integer relation detection algorithm. This means
that, given the numbers "x[i]" in the list "xlist", it tries
to find integer coefficients "a[i]" such that "a[1]*x[1] + ... +
a[n]*x[n] = 0". The list of integer coefficients is returned.
<p> </p>
The numbers in "xlist" must evaluate to floating point numbers if
the <B><TT>N</TT></B> operator is applied on them.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Pslq({ 2*Pi+3*Exp(1) , Pi , Exp(1) },20)
Out> {1,-2,-3};
</PRE></TR>
</TABLE>
Note: in this example the system detects correctly that
<B><TT>1 * (2*Pi+3*E) + (-2) * (Pi) + (-3) * (E) = 0</TT></B>
<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<p>  </P><HR><A NAME="c4">

</A>
<A HREF="refchapter4.html#Sin, Cos, Tan" TARGET="Chapters">
Sin, Cos, Tan
</A>
, <A HREF="refchapter4.html#ArcSin, ArcCos, ArcTan" TARGET="Chapters">
ArcSin, ArcCos, ArcTan
</A>
, <A HREF="refchapter4.html#Exp" TARGET="Chapters">
Exp
</A>
, <A HREF="refchapter4.html#Ln" TARGET="Chapters">
Ln
</A>
, <A HREF="refchapter4.html#Sqrt" TARGET="Chapters">
Sqrt
</A>
, <A HREF="refchapter4.html#Abs" TARGET="Chapters">
Abs
</A>
, <A HREF="refchapter4.html#Sign" TARGET="Chapters">
Sign
</A>
, <A HREF="refchapter4.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="refchapter4.html#Re" TARGET="Chapters">
Re
</A>
, <A HREF="refchapter4.html#Im" TARGET="Chapters">
Im
</A>
, <A HREF="refchapter4.html#I" TARGET="Chapters">
I
</A>
, <A HREF="refchapter4.html#Conjugate" TARGET="Chapters">
Conjugate
</A>
, <A HREF="refchapter4.html#Arg" TARGET="Chapters">
Arg
</A>
, <A HREF="refchapter4.html#!" TARGET="Chapters">
!
</A>
, <A HREF="refchapter4.html#Bin" TARGET="Chapters">
Bin
</A>
, <A HREF="refchapter4.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="refchapter4.html#Average" TARGET="Chapters">
Average
</A>
, <A HREF="refchapter4.html#Factorize" TARGET="Chapters">
Factorize
</A>
, <A HREF="refchapter4.html#Min" TARGET="Chapters">
Min
</A>
, <A HREF="refchapter4.html#Max" TARGET="Chapters">
Max
</A>
, <A HREF="refchapter4.html#IsZero" TARGET="Chapters">
IsZero
</A>
, <A HREF="refchapter4.html#IsRational" TARGET="Chapters">
IsRational
</A>
, <A HREF="refchapter4.html#Numer" TARGET="Chapters">
Numer
</A>
, <A HREF="refchapter4.html#Denom" TARGET="Chapters">
Denom
</A>
, <A HREF="refchapter4.html#Commutator" TARGET="Chapters">
Commutator
</A>
, <A HREF="refchapter4.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="refchapter4.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
, <A HREF="refchapter4.html#ReversePoly" TARGET="Chapters">
ReversePoly
</A>
, <A HREF="refchapter4.html#BigOh" TARGET="Chapters">
BigOh
</A>
, <A HREF="refchapter4.html#Newton" TARGET="Chapters">
Newton
</A>
, <A HREF="refchapter4.html#D" TARGET="Chapters">
D
</A>
, <A HREF="refchapter4.html#Curl" TARGET="Chapters">
Curl
</A>
, <A HREF="refchapter4.html#Diverge" TARGET="Chapters">
Diverge
</A>
, <A HREF="refchapter4.html#Integrate" TARGET="Chapters">
Integrate
</A>
, <A HREF="refchapter4.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A HREF="refchapter4.html#RadSimp" TARGET="Chapters">
RadSimp
</A>
, <A HREF="refchapter4.html#Rationalize" TARGET="Chapters">
Rationalize
</A>
, <A HREF="refchapter4.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="refchapter4.html#SuchThat" TARGET="Chapters">
SuchThat
</A>
, <A HREF="refchapter4.html#Eliminate" TARGET="Chapters">
Eliminate
</A>
, <A HREF="refchapter4.html#PSolve" TARGET="Chapters">
PSolve
</A>
, <A HREF="refchapter4.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="refchapter4.html#Random" TARGET="Chapters">
Random
</A>
, <A HREF="refchapter4.html#VarList" TARGET="Chapters">
VarList
</A>
, <A HREF="refchapter4.html#Limit" TARGET="Chapters">
Limit
</A>
, <A HREF="refchapter4.html#TrigSimpCombine" TARGET="Chapters">
TrigSimpCombine
</A>
, <A HREF="refchapter4.html#LagrangeInterpolant" TARGET="Chapters">
LagrangeInterpolant
</A>
, <A HREF="refchapter4.html#Fibonacci" TARGET="Chapters">
Fibonacci
</A>
.
<H1>
Calculus
</H1>
In this chapter, some functions for doing calculus are
described. These include functions implementing differentiation,
integration, standard mathematical functions, and the solving of
equations.
<A NAME="Sin">

</A>
<A NAME="Cos">

</A>
<A NAME="Tan">

</A>
<A NAME="Sin, Cos, Tan">

</A>
<H3>
<HR>Sin, Cos, Tan -- Trigonometric functions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Sin(x) <br>
Cos(x) <br>
Tan(x)
<H5>
Parameters:
</H5>
x - argument to the function, in radians
<H5>
Description:
</H5>

These functions represent the trigonometric functions sine, cosine,
and tangent respectively. Yacas leaves them alone even if x is a
number, trying to keep the result as exact as possible. The floating
point approximations of these functions can be forced by using the <B><TT>N</TT></B> function. 
<p>  </p>
Yacas knows some trigonometric identities, so it can simplify to exact
results even if <B><TT>N</TT></B> is not used. This is the case
when the arguments are multiples of Pi/6 or Pi/4.
<p> </p>
These functions are threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Sin(1)
Out> Sin(1);
In> N(Sin(1),20)
Out> 0.84147098480789650665;
In> Sin(Pi/4)
Out> Sqrt(2)/2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ArcSin, ArcCos, ArcTan" TARGET="Chapters">
ArcSin, ArcCos, ArcTan
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
.<A NAME="ArcSin">

</A>
<A NAME="ArcCos">

</A>
<A NAME="ArcTan">

</A>
<A NAME="ArcSin, ArcCos, ArcTan">

</A>
<H3>
<HR>ArcSin, ArcCos, ArcTan -- Inverse trigonometric functions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

ArcSin(x) <br>
ArcCos(x) <br>
ArcTan(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

These functions represent the inverse trigonometric functions. For
instance, the value of "ArcSin(x)" is the number "y" such that
"Sin(y)" equals "x". 
<p> </p>
Note that the number "y" is not unique. For instance, "Sin(0)" and
"Sin(Pi)" both equal 0, so what should "ArcSin(0)" be? In Yacas,
it is agreed that the value of "ArcSin(x)" should be in the interval
[-Pi/2,Pi/2]. The same goes for "ArcTan(x)". However, "ArcCos(x)"
is in the interval [0,Pi].
<p> </p>
Usually, Yacas leaves these functions alone unless it is forced to do
a numerical evaluation by the <B><TT>N</TT></B> function. If the
argument is -1. 0, or 1 however, Yacas will simplify the
expression. If the argument is complex,  the expression will be
rewritten as a <B><TT>Ln</TT></B> function.
<p> </p>
These functions are threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ArcSin(1)
Out> Pi/2;

In> ArcSin(1/3)
Out> ArcSin(1/3);
In> Sin(ArcSin(1/3))
Out> 1/3;

In> N(ArcSin(0.75))
Out> 0.848062;
In> N(Sin(%))
Out> 0.7499999477;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sin, Cos, Tan" TARGET="Chapters">
Sin, Cos, Tan
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="ref.html#Ln" TARGET="Chapters">
Ln
</A>
.<A NAME="Exp">

</A>
<H3>
<HR>Exp -- Exponential function
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Exp(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function calculates e raised to the power "x", where e is the
mathematic constant 2.71828... One can use <B><TT>Exp(1)</TT></B>
to represent e.
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Exp(0)
Out> 1;
In> Exp(I*Pi)
Out> -1;
In> N(Exp(1))
Out> 2.7182818284;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Ln" TARGET="Chapters">
Ln
</A>
, <A HREF="ref.html#Sin, Cos, Tan" TARGET="Chapters">
Sin, Cos, Tan
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="Ln">

</A>
<H3>
<HR>Ln -- Natural logarithm
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Ln(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function calculates the natural logarithm of "x". This is the
inverse function of the exponential function, <B><TT>Exp</TT></B>, ie. "Ln(x) = y" implies that "Exp(y) = x". For complex
arguments, the imaginary part of the logarithm is in the interval
(-Pi,Pi]. This is compatible with the branch cut of <B><TT>Arg</TT></B>. 
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Ln(1)
Out> 0;
In> Ln(Exp(x))
Out> x;
In> D(x) Ln(x)
Out> 1/x;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Exp" TARGET="Chapters">
Exp
</A>
, <A HREF="ref.html#Arg" TARGET="Chapters">
Arg
</A>
.<A NAME="Sqrt">

</A>
<H3>
<HR>Sqrt -- Square root
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Sqrt(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function calculates the square root of "x". If the result is
not rational, the call is returned unevaluated unless a numerical
approximation is forced with the <B><TT>N</TT></B> function. This
function can also handle negative and complex arguments.
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Sqrt(16)
Out> 4;
In> Sqrt(15)
Out> Sqrt(15);
In> N(Sqrt(15))
Out> 3.8729833462;
In> Sqrt(4/9)
Out> 2/3;
In> Sqrt(-1)
Out> Complex(0,1);</PRE></TR>
</TABLE>

<A HREF="ref.html#Exp" TARGET="Chapters">
Exp
</A>
, <A HREF="ref.html#^" TARGET="Chapters">
^
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="Abs">

</A>
<H3>
<HR>Abs -- Absolute value or modulus
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Abs(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the absolute value (also called the modulus) of
"x". If "x" is positive, the absolute value is "x" itself; if
"x" is negative, the absolute value is "-x". For complex "x",
the modulus is the "r" in the polar decomposition "x = r *
Exp(I*phi)". 
<p> </p>
This function is connected to the <B><TT>Sign</TT></B> function by
the identity "Abs(x) * Sign(x) = x" for real "x".
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Abs(2);
Out> 2;
In> Abs(-1/2);
Out> -1/2;
In> Abs(3+4*I);
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sign" TARGET="Chapters">
Sign
</A>
, <A HREF="ref.html#Arg" TARGET="Chapters">
Arg
</A>
.<A NAME="Sign">

</A>
<H3>
<HR>Sign -- Sign of a number
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Sign(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the sign of the real number "x". It is "1"
for positive numbers and "-1" for negative numbers. Somewhat
arbitrarily, <B><TT>Sign(0)</TT></B> is defined to be 1.
<p> </p>
This function is connected to the <B><TT>Abs</TT></B> function by
the identity "Abs(x) * Sign(x) = x" for real "x".
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Sign(2)
Out> 1;
In> Sign(-3)
Out> -1;
In> Sign(0)
Out> 1;
In> Sign(-3) * Abs(-3)
Out> -3;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Arg" TARGET="Chapters">
Arg
</A>
, <A HREF="ref.html#Abs" TARGET="Chapters">
Abs
</A>
.<A NAME="Complex">

</A>
<H3>
<HR>Complex -- Construct a complex number
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Complex(r, c)
<H5>
Parameters:
</H5>

r - real part <br>
c - imaginary part
<H5>
Description:
</H5>

This function represents the complex number "r + I*c", where "I"
is the imaginary unit. It is the standard representation used in Yacas
to represent complex numbers. Both "r" and "c" are supposed to be
real. 
<p> </p>
Note that, at the moment, many functions in Yacas assume that all
numbers are real unless it is obvious that it is a complex
number. Hence <B><TT>Im(Sqrt(x))</TT></B> evaluates to <B><TT>0</TT></B> which is only true for nonnegative "x".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> I
Out> Complex(0,1);
In> 3+4*I
Out> Complex(3,4);
In> Complex(-2,0)
Out> -2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Re" TARGET="Chapters">
Re
</A>
, <A HREF="ref.html#Im" TARGET="Chapters">
Im
</A>
, <A HREF="ref.html#I" TARGET="Chapters">
I
</A>
, <A HREF="ref.html#Abs" TARGET="Chapters">
Abs
</A>
, <A HREF="ref.html#Arg" TARGET="Chapters">
Arg
</A>
.<A NAME="Re">

</A>
<H3>
<HR>Re -- Real part of a complex number
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Re(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the real part of the complex number "x".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Re(5)
Out> 5;
In> Re(I)
Out> 0;
In> Re(Complex(3,4))
Out> 3;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="ref.html#Im" TARGET="Chapters">
Im
</A>
.<A NAME="Im">

</A>
<H3>
<HR>Im -- Imaginary part of a complex number
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Im(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the imaginary part of the complex number "x".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Im(5)
Out> 0;
In> Im(I)
Out> 1;
In> Im(Complex(3,4))
Out> 4;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="ref.html#Re" TARGET="Chapters">
Re
</A>
.<A NAME="I">

</A>
<H3>
<HR>I -- Imaginary unit
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
I
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

This symbol represents the imaginary unit, which equals the square
root of -1. It evaluates immediately to <B><TT>Complex(0,1)</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> I
Out> Complex(0,1);
In> I = Sqrt(-1)
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Complex" TARGET="Chapters">
Complex
</A>
.<A NAME="Conjugate">

</A>
<H3>
<HR>Conjugate -- Complex conjugate
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Conjugate(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the complex conjugate of "x". The complex
conjugate of "a + I*b" is "a - I*b". This function assumes that all
unbound variables are real.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Conjugate(2)
Out> 2;
In> Conjugate(Complex(a,b))
Out> Complex(a,-b);</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="ref.html#Re" TARGET="Chapters">
Re
</A>
, <A HREF="ref.html#Im" TARGET="Chapters">
Im
</A>
.<A NAME="Arg">

</A>
<H3>
<HR>Arg -- Argument of a complex number
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Arg(x)
<H5>
Parameters:
</H5>
x - argument to the function
<H5>
Description:
</H5>

This function returns the argument of "x". The argument is the angle
with the positive real axis in the Argand diagram, or the angle
"phi" in the polar representation "r * Exp(I*phi)" of "x". The
result lies between -Pi and Pi, excluding -Pi but including Pi. The
argument of 0 is <B><TT>Undefined</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Arg(2)
Out> 0;
In> Arg(-1)
Out> Pi;
In> Arg(1+I)
Out> Pi/4;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Abs" TARGET="Chapters">
Abs
</A>
, <A HREF="ref.html#Sign" TARGET="Chapters">
Sign
</A>
.<A NAME="!">

</A>
<H3>
<HR>! -- Factorial
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
n!
<H5>
Parameters:
</H5>
n - argument to the function
<H5>
Description:
</H5>

This function calculate "n" factorial. For nonnegative integers, n!
equals "n*(n-1)*(n-2)*...*1". The factorial of half-integers,
defined via the gamma function, is also implemented.
<p> </p>
This function is threaded, meaning that if the argument "x" is a
list, the function is applied to all the entries in the list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 5!
Out> 120;
In> 1 * 2 * 3 * 4 * 5
Out> 120;
In> (1/2)!
Out> Sqrt(Pi)/2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Bin" TARGET="Chapters">
Bin
</A>
, <A HREF="ref.html#Factorize" TARGET="Chapters">
Factorize
</A>
.<A NAME="Bin">

</A>
<H3>
<HR>Bin -- Binomial coefficient
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Bin(n, m)
<H5>
Parameters:
</H5>
n, m - integers
<H5>
Description:
</H5>

This function calculates the binomial coefficient "n" above
"m", which equals "n! / (n! * (n-m)!)". This is the number of ways
to choose "m" objects out of a total of "n" objects if order is
not taken into account. The binomial coefficient is defined to be zero
if "m" is negative or greater than "n".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Bin(10, 4)
Out> 210;
In> 10! / (4! * 6!)
Out> 210;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#!" TARGET="Chapters">
!
</A>
.<A NAME="Sum">

</A>
<H3>
<HR>Sum -- Sum of a list of values
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>

Sum(list) <br>
Sum(var, from, to, body)
<H5>
Parameters:
</H5>

list - list of values to sum <br>
var - variable to iterate over <br>
from - integer value to iterate from <br>
to - integer value to iterate upto <br>
body - expression to evaluate for each iteration
<H5>
Description:
</H5>

The first form of the <B><TT>Sum</TT></B> command simply adds all
the entries in "list" and returns their sum.
<p> </p>
If the second calling sequence is used, the expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" upto "to", and the sum of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Sum({1,4,9});
Out> 14;
In> Sum(i, 1, 3, i^2);
Out> 14;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Average" TARGET="Chapters">
Average
</A>
, <A HREF="ref.html#Factorize" TARGET="Chapters">
Factorize
</A>
, <A HREF="ref.html#Apply" TARGET="Chapters">
Apply
</A>
.<A NAME="Average">

</A>
<H3>
<HR>Average -- Average of a list of values
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Average(list)
<H5>
Parameters:
</H5>
list - list of values to average
<H5>
Description:
</H5>

This command calculates the (arithmetical) average of all the entries in
"list", which is the sum of all entries divided by the number of
entries.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Average({1,2,3,4,5});
Out> 3;
In> Average({2,6,7});
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sum" TARGET="Chapters">
Sum
</A>
.<A NAME="Factorize">

</A>
<H3>
<HR>Factorize -- Product of a list of values
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>

Factorize(list) <br>
Factorize(var, from, to, body)
<H5>
Parameters:
</H5>

list - list of values to multiply <br>
var - variable to iterate over <br>
from - integer value to iterate from <br>
to - integer value to iterate upto <br>
body - expression to evaluate for each iteration
<H5>
Description:
</H5>

The first form of the <B><TT>Factorize</TT></B> command simply
multiplies all the entries in "list" and returns their product.
<p> </p>
If the second calling sequence is used, the expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" upto "to", and the product of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Factorize({1,2,3,4});
Out> 24;
In> Factorize(i, 1, 4, i);
Out> 24;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="ref.html#Apply" TARGET="Chapters">
Apply
</A>
.<A NAME="Min">

</A>
<H3>
<HR>Min -- Minimum of a number of values
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>

Min(x,y)  <br>
Min(list)
<H5>
Parameters:
</H5>

x, y - pair of values to determine the minimum of <br>
list - list of values from which the minimum is sought
<H5>
Description:
</H5>

This function returns the minimum value of its argument(s). If the
first calling sequence is used, the smaller of "x" and "y" is
returned. If one uses the second form, the smallest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Min(2,3);
Out> 2;
In> Min({5,8,4});
Out> 4;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Max" TARGET="Chapters">
Max
</A>
, <A HREF="ref.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="ref.html#Average" TARGET="Chapters">
Average
</A>
.<A NAME="Max">

</A>
<H3>
<HR>Max -- Maximum of a number of values
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>

Max(x,y)  <br>
Max(list)
<H5>
Parameters:
</H5>

x, y - pair of values to determine the maximum of <br>
list - list of values from which the maximum is sought
<H5>
Description:
</H5>

This function returns the maximum value of its argument(s). If the
first calling sequence is used, the larger of "x" and "y" is
returned. If one uses the second form, the largest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Max(2,3);
Out> 3;
In> Max({5,8,4});
Out> 8;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Min" TARGET="Chapters">
Min
</A>
, <A HREF="ref.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="ref.html#Average" TARGET="Chapters">
Average
</A>
.<A NAME="IsZero">

</A>
<H3>
<HR>IsZero -- Test whether argument is zero
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsZero(n)
<H5>
Parameters:
</H5>
n - number to test
<H5>
Description:
</H5>
<B><TT>IsZero(n)</TT></B> evaluates to <B><TT>True</TT></B> if
"n" is zero. In case "n" is not a number, the function returns
<B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsZero(3.25)
Out> False;
In> IsZero(0)
Out> True;
In> IsZero(x)
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
.<A NAME="IsRational">

</A>
<H3>
<HR>IsRational -- Test whether argument is a rational
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
IsRational(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This commands tests whether the expression "expr" is a rational
number. This is the case if the top-level operator of "expr" is <B><TT>/</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsRational(5)
Out> False;
In> IsRational(2/7)
Out> True;
In> IsRational(a/b)
Out> True;
In> IsRational(x + 1/x)
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Numer" TARGET="Chapters">
Numer
</A>
, <A HREF="ref.html#Denom" TARGET="Chapters">
Denom
</A>
.<A NAME="Numer">

</A>
<H3>
<HR>Numer -- Numerator of an expression
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Numer(expr)
<H5>
Parameters:
</H5>
expr - expression to determine numerator of
<H5>
Description:
</H5>

This function determines the numerator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns this number. If "expr" is neither
rational nor numeric, the function returns unevaluated.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Numer(2/7)
Out> 2;
In> Numer(a / x^2)
Out> a;
In> Numer(5)
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Denom" TARGET="Chapters">
Denom
</A>
, <A HREF="ref.html#IsRational" TARGET="Chapters">
IsRational
</A>
, <A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
.<A NAME="Denom">

</A>
<H3>
<HR>Denom -- Denominator of an expression
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Denom(expr)
<H5>
Parameters:
</H5>
expr - expression to determine denominator of
<H5>
Description:
</H5>

This function determines the denominator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns <B><TT>1</TT></B>. If "expr" is
neither rational nor numeric, the function returns unevaluated.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Denom(2/7)
Out> 7;
In> Denom(a / x^2)
Out> x^2;
In> Denom(5)
Out> 1;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Numer" TARGET="Chapters">
Numer
</A>
, <A HREF="ref.html#IsRational" TARGET="Chapters">
IsRational
</A>
, <A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
.<A NAME="Commutator">

</A>
<H3>
<HR>Commutator -- Commutator of two objects
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Commutator(a, b)
<H5>
Parameters:
</H5>
a, b - two objects whose commutator should be computed
<H5>
Description:
</H5>

This command computes the commutator of 'a" and "b", ie. the
expression "a b - b a". For numbers and other objects for which
multiplication is commutative, the commutator is zero. But this is not
necessarily the case for matrices.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Commutator(2,3)
Out> 0;
In> PrettyPrinter("PrettyForm");

True

Out> 
In> A := { {0,x}, {0,0} }

/              \
| ( 0 ) ( x )  |
|              |
| ( 0 ) ( 0 )  |
\              /

Out> 
In> B := { {y,0}, {0,z} }

/              \
| ( y ) ( 0 )  |
|              |
| ( 0 ) ( z )  |
\              /

Out> 
In> Commutator(A,B)

/                          \
| ( 0 ) ( x * z - y * x )  |
|                          |
| ( 0 ) ( 0 )              |
\                          /

Out> </PRE></TR>
</TABLE>

<A NAME="Taylor">

</A>
<H3>
<HR>Taylor -- Univariate Taylor series expansion
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Taylor(var, at, order) expr
<H5>
Parameters:
</H5>
var - variable <br>
at - point to get Taylor series around <br>
order - order of approximation <br>
expr - expression to get Taylor series for
<H5>
Description:
</H5>

This function returns the Taylor series expansion of the expression
"expr" with respect to the variable "var" around "at" upto order
"order". This is a polynomial which agrees with "expr" at the
point "var = at", and furthermore the first "order" derivatives of
the polynomial at this point agree with "expr". Taylor expansions
around removable singularities are correctly handled by taking the
limit as "var" approaches "at".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyForm(Taylor(x,0,9) Sin(x))

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#D" TARGET="Chapters">
D
</A>
, <A HREF="ref.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
, <A HREF="ref.html#ReversePoly" TARGET="Chapters">
ReversePoly
</A>
, <A HREF="ref.html#BigOh" TARGET="Chapters">
BigOh
</A>
.<A NAME="InverseTaylor">

</A>
<H3>
<HR>InverseTaylor -- Taylor expansion of inverse
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
InverseTaylor(var, at, order) expr
<H5>
Parameters:
</H5>
var - variable <br>
at - point to get inverse Taylor series around <br>
order - order of approximation <br>
expr - expression to get inverse Taylor series for
<H5>
Description:
</H5>

This function builds the Taylor series expansion of the inverse of the
expression "expr" with respect to the variable "var" around "at"
upto order "order". It uses the function <B><TT>ReversePoly</TT></B> to perform the task.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyPrinter("PrettyForm")

True

Out> 
In> exp1 := Taylor(x,0,7) Sin(x)

     3    5      7 
    x    x      x  
x - -- + --- - ----
    6    120   5040

Out> 
In> exp2 := InverseTaylor(x,0,7) ArcSin(x)

 5      7     3    
x      x     x     
--- - ---- - -- + x
120   5040   6     

Out> 
In> Simplify(exp1-exp2)

0

Out> </PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ReversePoly" TARGET="Chapters">
ReversePoly
</A>
, <A HREF="ref.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="ref.html#BigOh" TARGET="Chapters">
BigOh
</A>
.<A NAME="ReversePoly">

</A>
<H3>
<HR>ReversePoly -- Solve "h(f(x)) = g(x) + O(x^n)" for h
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
ReversePoly(f, g, var, newvar, degree)
<H5>
Parameters:
</H5>
f, g - expressions in "var" <br>
var - a variable<br>
newvar - a new variable to express the result in<br>
degree - the degree of the required solution

<H5>
Description:
</H5>

This function returns a polynomial in "newvar", say "h(newvar)",
with the property that "h(f(var))" equals "g(var)" upto order
"degree". The degree of the result will be at most "degree-1". The
only requirement is that the first derivative of "f" should not be zero.
<p> </p>
This function is used to determine the Taylor series expansion of the
inverse of a function "f": if we take "g(var)=var", then
"h(f(var))=var" (upto order "degree"), so "h" will be the
inverse of "f".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(x):=Eval(Expand((1+x)^4))
Out> True;
In> g(x) := x^2
Out> True;
In> h(y):=Eval(ReversePoly(f(x),g(x),x,y,8))
Out> True;
In> BigOh(h(f(x)),x,8)
Out> x^2;
In> h(x)
Out> (-2695*(x-1)^7)/131072+(791*(x-1)^6)/32768+(-119*(x-1)^5)/4096+(37*(x-1)^4)
/1024+(-3*(x-1)^3)/64+(x-1)^2/16;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
, <A HREF="ref.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="ref.html#BigOh" TARGET="Chapters">
BigOh
</A>
.<A NAME="BigOh">

</A>
<H3>
<HR>BigOh -- Drop all terms of a certain order in a polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
BigOh(poly, var, degree)
<H5>
Parameters:
</H5>
poly - a univariate polynomial <br>
var - a free variable <br>
degree - positive integer
<H5>
Description:
</H5>
This function drops all terms of order "degree" or higher in
"poly", which is a polynomial in the variable "var".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> BigOh(1+x+x^2+x^3,x,2)
Out> x+1;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="ref.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
.<A NAME="Newton">

</A>
<H3>
<HR>Newton -- Solve an equation numerically with Newton's method
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Newton(expr, var, initial, accuracy)
<H5>
Parameters:
</H5>

expr - an expression to find a zero for <br>
var - free variable to adjust to find a zero <br>
initial - initial value for "var" to use in the search      <br>
accuracy - minimum required accuracy of the result

<H5>
Description:
</H5>

This function tries to numerically find a zero of the expression
"expr", which should depend only on the variable "var". It uses
the value "initial" as an initial guess. 
<p> </p>
The function will iterate using Newton's method until it estimates
that it has come within a distance "accuracy" of the correct
solution, and then it will return its best guess. In particular, it
may loop forever if the algorithm does not converge.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Newton(Sin(x),x,3,0.0001)
Out> 3.1415926535;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Solve" TARGET="Chapters">
Solve
</A>
.<A NAME="D">

</A>
<H3>
<HR>D -- Differentiation
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
D(var) expr <br>
D(list) expr <br>
D(var,n) expr

<H5>
Parameters:
</H5>
var - variable <br>
list - a list of variables <br>
expr - expression to take derivative of <br>
n - order of derivative

<H5>
Description:
</H5>

This function calculates the derivative of the expression "expr" with
respect to the variable "var" and returns it. If the third calling
sequence is used, the "n"-th derivative is determined. Yacas knows
how the differentiate standard functions like <B><TT>Ln</TT></B>
and <B><TT>Sin</TT></B>.
<p> </p>
The <B><TT>D</TT></B> operator is threaded in both "var" and
"expr". This means that if either of them is a list, the function is
applied to each entry in the list. The results are collected in
another list which is returned. If both "var" and "expr" are a
list, their lengths should be equal. In this case, the first entry in
the list "expr" is differentiated with respect to the first entry in
the list "var", the second entry in "expr" is differentiated with
respect to the second entry in "var", and so on.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> D(x)Sin(x*y)
Out> y*Cos(x*y);
In> D({x,y,z})Sin(x*y)
Out> {y*Cos(x*y),x*Cos(x*y),0};
In> D(x,2)Sin(x*y)
Out> -Sin(x*y)*y^2;
In> D(x){Sin(x),Cos(x)}
Out> {Cos(x),-Sin(x)};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Integrate" TARGET="Chapters">
Integrate
</A>
, <A HREF="ref.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="ref.html#Diverge" TARGET="Chapters">
Diverge
</A>
, <A HREF="ref.html#Curl" TARGET="Chapters">
Curl
</A>
.<A NAME="Curl">

</A>
<H3>
<HR>Curl -- Curl of a vector field
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Curl(vector, basis)
<H5>
Parameters:
</H5>

vector - vector field to take the curl of <br>
basis - list of variables forming the basis
<H5>
Description:
</H5>

This function takes the curl of the vector field "vector" with
respect to the variables "basis". The curl is defined as
<p> </p> <B><TT>Curl(f,x) = { D(x[2]) f[3] - D(x[3]) f[2], D(x[3]) f[1] -
D(x[1]) f[3], D(x[1]) f[2] - D(x[2]) f[1] }</TT></B>
<p> </p>
Both "vector" and "basis" should be lists of length 3.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Curl({x*y,x*y,x*y},{x,y,z})
Out> {x,-y,y-x};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#D" TARGET="Chapters">
D
</A>
, <A HREF="ref.html#Diverge" TARGET="Chapters">
Diverge
</A>
.<A NAME="Diverge">

</A>
<H3>
<HR>Diverge -- Divergence of a vector field
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Diverge(vector, basis)
<H5>
Parameters:
</H5>

vector - vector field to calculate the divergence of <br>
basis - list of variables forming the basis
<H5>
Description:
</H5>

This function calculates the divergence of the vector field "vector"
with respect to the variables "basis". The divergence is defined as
<p> </p> <B><TT>Diverge(f,x) = D(x[1]) f[1] + ... + D(x[n]) f[n]</TT></B>,
<p> </p>
where <B><TT>n</TT></B> is the length of the lists "vector" and
"basis". These lists should have equal length.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Diverge({x*y,x*y,x*y},{x,y,z})
Out> y+x;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#D" TARGET="Chapters">
D
</A>
, <A HREF="ref.html#Curl" TARGET="Chapters">
Curl
</A>
.<A NAME="Integrate">

</A>
<H3>
<HR>Integrate -- Integration
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Integrate(var, from, to) expr <br>
Integrate(var) expr

<H5>
Parameters:
</H5>
var - variable to integrate over <br>
from - begin of interval to integrate over <br>
to - end of interval to integrate over <br>
expression - expression to integrate 

<H5>
Description:
</H5>

This function integrates the expression "expr" with respect to the
variable "var". The first calling sequence is used to perform
definite integration: the integration is carried out from "var=form"
to "var=to". The second form signifies indefinite integration. In
this case, the function <B><TT>UniqueConstant</TT></B> is called
to get a variable of the form <B><TT>C</TT></B>n (where "n" is
an integer) which represent the integration constant.
<p> </p>
Some simple integration rules have currently been
implemented. Polynomials, quotients of polynomials, the transcendental
functions <B><TT>Sin</TT></B>, <B><TT>Cos</TT></B>, <B><TT>Exp</TT></B>, and <B><TT>Ln</TT></B>, and products of these
functions with polynomials can all be integrated.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Integrate(x,a,b) Cos(x)
Out> Sin(b)-Sin(a);
In> Integrate(x) Cos(x)
Out> Sin(x)+C9;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#D" TARGET="Chapters">
D
</A>
, <A HREF="ref.html#UniqueConstant" TARGET="Chapters">
UniqueConstant
</A>
.<A NAME="Simplify">

</A>
<H3>
<HR>Simplify -- Try to simplify an expression
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Simplify(expr)
<H5>
Parameters:
</H5>
expression - expression to simplify
<H5>
Description:
</H5>

This function tries to simplify the expression "expr" as much
as possible. It does this by grouping powers within terms, and then
grouping like terms.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a*b*a^2/b-a^3
Out> (b*a^3)/b-a^3;
In> Simplify(a*b*a^2/b-a^3)
Out> 0;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#TrigSimpCombine" TARGET="Chapters">
TrigSimpCombine
</A>
, <A HREF="ref.html#RadSimp" TARGET="Chapters">
RadSimp
</A>
.<A NAME="RadSimp">

</A>
<H3>
<HR>RadSimp -- Simplify expression with nested radicals
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RadSimp(expr)
<H5>
Parameters:
</H5>
expr - an expression containing nested radicals
<H5>
Description:
</H5>

This function tries to write the expression "expr" as a sum of roots
of integers: "Sqrt(e1) + Sqrt(e2) + ...", where "e1", "e2" and
so on are natural numbers. The expression "expr" may not contain
free variables.
<p> </p>
It does this by trying all possible combinations for "e1", "e2",
etcetera. Every possibility is numerically evaluated using <B><TT>N</TT></B> and compared with the numerical evaluation of
"expr". If the approximations are equal (upto a certain margin),
this possibility is returned. Otherwise, the expression is returned
unevaluated.
<p> </p>
Note that due to the use of numerical approximations, there is a small
chance that the expression returned by <B><TT>RadSimp</TT></B> is
close but not equal to "expr". The last example underneath
illustrates this problem. Furthermore, if the numerical value of
"expr" is large, the number of possibilities becomes exorbitantly
big so the evaluation may take very long.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> RadSimp(Sqrt(9+4*Sqrt(2)))
Out> Sqrt(8)+1;
In> RadSimp(Sqrt(5+2*Sqrt(6))+Sqrt(5-2*Sqrt(6)))
Out> Sqrt(12);
In> RadSimp(Sqrt(14+3*Sqrt(3+2*Sqrt(5-12*Sqrt(3-2*Sqrt(2)))))) 
Out> Sqrt(2)+3;</PRE></TR>
</TABLE>

<p> </p>
But this command may yield incorrect results: 
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> RadSimp(Sqrt(1+10^(-6)))
Out> 1;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="Rationalize">

</A>
<H3>
<HR>Rationalize -- Convert floating point numbers to fractions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Rationalize(expr)
<H5>
Parameters:
</H5>
expr - an expression containing real numbers
<H5>
Description:
</H5>

This command converts every real number in the expression "expr"
into a rational number. This is useful when a calculation needs to be
done on floating point numbers and the algorithm is unstable.
Converting the floating point numbers to rational numbers will force
calculations to be done with infinite precision (by using rational
numbers as representations).
<p> </p>
It does this by finding the smallest integer n such that multiplying
the number with 10^n is an integer. Then it divides by 10^n again,
depending on the internal gcd calculation to reduce the resulting
division of integers.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> {1.2,3.123,4.5}
Out> {1.2,3.123,4.5};
In> Rationalize(%)
Out> {6/5,3123/1000,9/2};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsRational" TARGET="Chapters">
IsRational
</A>
.<A NAME="Solve">

</A>
<H3>
<HR>Solve -- Solve one or more algebraic equations
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Solve(eq, var) <br>
 Solve(eqlist, varlist)

<H5>
Parameters:
</H5>
eq - single identity equation <br>
var - single variable <br>
eqlist - list of identity equations <br>
varlist - list of variables
<H5>
Description:
</H5>

This command tries to solve one or more equations. Use the first form
to solve a single equation and the second one for systems of
equations.
<p> </p>
The first calling sequence solves the equation "eq" for the variable
"var". Use the <B><TT>==</TT></B> operator to form the equation. 
The value of "var" which satisfies the equation, is returned. Note
that only one solution is found and returned.
<p> </p>
To solve a system of equations, the second form should be used. It
solves the system of equations contained in the list "eqlist" for
the variables appearing in the list "varlist". A list of results is
returned, and each result is a list containing the values of the
variables in "varlist". Again, at most a single solution is
returned.
<p> </p>
The task of solving a single equation is simply delegated to <B><TT>SuchThat</TT></B>. Multiple equations are solved recursively:
firstly, an equation is sought in which one of the variables occurs
exactly once; then this equation is solved with <B><TT>SuchThat</TT></B>; and finally the solution is substituted in the
other equations by <B><TT>Eliminate</TT></B> decreasing the number
of equations by one. This suffices for all linear equations and a
large group of simple nonlinear equations.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Solve(a+x*y==z,x)
Out> (z-a)/y;
In> Solve({a*x+y==0,x+z==0},{x,y})
Out> {{-z,z*a}};</PRE></TR>
</TABLE>

This means that "x = (z-a)/y" is a solution of the first equation
and that "x = -z", "y = z*a" is a solution of the systems of
equations in the second command.
<p> </p>
An example which <B><TT>Solve</TT></B> cannot solve:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Solve({x^2-x == y^2-y, x^2-x == y^3+y}, {x,y});
Out> {};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#SuchThat" TARGET="Chapters">
SuchThat
</A>
, <A HREF="ref.html#Eliminate" TARGET="Chapters">
Eliminate
</A>
, <A HREF="ref.html#PSolve" TARGET="Chapters">
PSolve
</A>
, <A HREF="ref.html#==" TARGET="Chapters">
==
</A>
.<A NAME="SuchThat">

</A>
<H3>
<HR>SuchThat -- Find a value which makes some expression zero
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
SuchThat(expr, var)
<H5>
Parameters:
</H5>
expr - expression to make zero <br>
var - variable (or subexpression) to solve for
<H5>
Description:
</H5>

This functions tries to find a value of the variable "var" which
makes the expression "expr" zero. It is also possible to pass a
subexpression as "var", in which case <B><TT>SuchThat</TT></B>
will try to eliminate for that subexpression.
<p> </p>
Basically, only expressions in which "var" occurs only once are
handled; and in fact, <B><TT>SuchThat</TT></B> may even give wrong
results if the variables occurs more than once. This is a consequence
of the implementation, which repeatedly applies the inverse of the top
function until the variable "var" is reached.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> SuchThat(a+b*x, x)
Out> (-a)/b;
In> SuchThat(Cos(a)+Cos(b)^2, Cos(b))
Out> Cos(a)^(1/2);
In> Expand(a*x+b*x+c, x)
Out> (a+b)*x+c;
In> SuchThat(%, x)
Out> (-c)/(a+b);</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
.<A NAME="Eliminate">

</A>
<H3>
<HR>Eliminate -- Substitute and simplify
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Eliminate(var, value, expr)
<H5>
Parameters:
</H5>

var - variable (or subexpression) to substitute <br>
value - new value of "var" <br>
expr - expression in which the substitution should take place
<H5>
Description:
</H5>

This function uses <B><TT>Subst</TT></B> to replace all instances
of the variable (or subexpression) "var" in the expression "expr"
with "value", calls <B><TT>Simplify</TT></B> to simplify the
resulting expression, and returns the result.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Subst(Cos(b), c) (Sin(a)+Cos(b)^2/c)
Out> Sin(a)+c^2/c;
In> Eliminate(Cos(b), c, Sin(a)+Cos(b)^2/c)
Out> Sin(a)+c;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#SuchThat" TARGET="Chapters">
SuchThat
</A>
, <A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
.<A NAME="PSolve">

</A>
<H3>
<HR>PSolve -- Solve a polynomial equation
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PSolve(poly, var)
<H5>
Parameters:
</H5>

poly - a polynomial in "var" <br>
var - a variable
<H5>
Description:
</H5>

This commands returns a list containing the roots of "poly",
considered as a polynomial in the variable "var". If there is only
one root, it is not returned as a one-entry list but just by
itself. A double root occurs twice in the result, and similarly for
roots of higher multiplicity. All polynomials of degree upto 4 are
handled.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PSolve(b*x+a,x)
Out> -a/b;
In> PSolve(c*x^2+b*x+a,x)
Out> {(Sqrt(b^2-4*c*a)-b)/(2*c),(-(b+Sqrt(b^2-4*c*a)))/(2*c)};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="ref.html#Factor" TARGET="Chapters">
Factor
</A>
.<A NAME="Pi">

</A>
<H3>
<HR>Pi -- Numerical approximation of pi
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Pi()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

This commands returns the mathematical constant pi to the current
precision, as set by <B><TT>Precision</TT></B>. Usually this
function will not be called directly. The constant <B><TT>Pi</TT></B> can (and should) be used to represent pi, as it is recognized by
the simplification rules. Then when the function <B><TT>N</TT></B>
is invoked, <B><TT>Pi</TT></B> will be replaced with the value
returned by <B><TT>Pi()</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Pi()
Out> 3.14159265358979323846;
In> Precision(40)
Out> True;
In> Pi()
Out> 3.1415926535897932384626433832795028841971;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="ref.html#Precision" TARGET="Chapters">
Precision
</A>
.<A NAME="Random">

</A>
<H3>
<HR>Random -- Random number between 0 and 1
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Random()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

This function returns a random number, uniformly distributed in the
interval between 0 and 1. The same sequence of random numbers is
generated in every Yacas session.
<H5>
See Also:
</H5>
<A HREF="ref.html#RandomInteger" TARGET="Chapters">
RandomInteger
</A>
, <A HREF="ref.html#RandomPoly" TARGET="Chapters">
RandomPoly
</A>
.<A NAME="VarList">

</A>
<H3>
<HR>VarList -- List of variables appearing in some expression
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
VarList(expr)
<H5>
Parameters:
</H5>
expr - an expression
<H5>
Description:
</H5>

This command returns a list of all the variables that appear in the
expression "expr".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> VarList(Sin(x))
Out> {x};
In> VarList(x+a*y)
Out> {x,a,y};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsFreeOf" TARGET="Chapters">
IsFreeOf
</A>
, <A HREF="ref.html#IsVariable" TARGET="Chapters">
IsVariable
</A>
.<A NAME="Limit">

</A>
<H3>
<HR>Limit -- Limit of an expression
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Limit(var, val) expr <br>
Limit(var, val, dir) expr
<H5>
Parameters:
</H5>
var - a variable <br>
val - a number <br>
dir - a direction (<B><TT>Left</TT></B> or <B><TT>Right</TT></B>) <br>
expr - an expression
<H5>
Description:
</H5>

This command tries to determine the value that the expression "expr"
converges to when the variable "var" approaches "val". One may use
<B><TT>Infinity</TT></B> or <B><TT>-Infinity</TT></B> for
"val". The result of <B><TT>Limit</TT></B> may be one of the
symbols <B><TT>Undefined</TT></B> (meaning that the limit does not
exist), <B><TT>Infinity</TT></B>, or <B><TT>-Infinity</TT></B>.
<p> </p>
The second calling sequence is used for unidirectional limits. If one
gives "dir" the value <B><TT>Left</TT></B>, the limit is taken as
"var" approaches "val" from the positive infinity; and <B><TT>Right</TT></B> will take the limit from the negative infinity.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Limit(x,0) Sin(x)/x
Out> 1;
In> Limit(x,0) (Sin(x)-Tan(x))/(x^3)
Out> -1/2;
In> Limit(x,0) 1/x
Out> Undefined;
In> Limit(x,0,Left) 1/x
Out> -Infinity;
In> Limit(x,0,Right) 1/x
Out> Infinity;
</PRE></TR>
</TABLE>

<A NAME="TrigSimpCombine">

</A>
<H3>
<HR>TrigSimpCombine -- Combine products of trigonometric functions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
TrigSimpCombine(expr)
<H5>
Parameters:
</H5>
expr - expression to simplify
<H5>
Description:
</H5>

This function applies the product rules of trigonometry, like <B><TT>Cos(u)*Sin(v) = (Sin(v-u) + Sin(v+u)) / 2</TT></B>. As a
result, all products of the trigonometric functions <B><TT>Cos</TT></B> and <B><TT>Sin</TT></B> disappear. The
function also tries to simplify the resulting expression as much as
possible by combining all like terms.
<p> </p>
This function is used in for instance <B><TT>Integrate</TT></B>,
to bring down the expression into a simpler form that hopefully can be
integrated easily.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyPrinter("PrettyForm");

True

Out> 
In> TrigSimpCombine(Cos(a)^2+Sin(a)^2)

1

Out> 
In> TrigSimpCombine(Cos(a)^2-Sin(a)^2)

Cos( -2 * a )

Out> 
In> TrigSimpCombine(Cos(a)^2*Sin(b))

Sin( b )   Sin( -2 * a + b )   Sin( -2 * a - b )
-------- + ----------------- - -----------------
   2               4                   4        

Out> </PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A HREF="ref.html#Integrate" TARGET="Chapters">
Integrate
</A>
, <A HREF="ref.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="ref.html#Sin, Cos, Tan" TARGET="Chapters">
Sin, Cos, Tan
</A>
.<A NAME="LagrangeInterpolant">

</A>
<H3>
<HR>LagrangeInterpolant -- Polynomial interpolation
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
LagrangeInterpolant(xlist, ylist, var)
<H5>
Parameters:
</H5>
xlist - list of argument values <br>
ylist - list of function values <br>
var - free variable for resulting polynomial
<H5>
Description:
</H5>

This function returns a polynomial in the variable "var" which
interpolates the points "(xlist, ylist)". Specifically, the value of
the resulting polynomial at "xlist[1]" is "ylist[1]", the value at
"xlist[2]" is "ylist[2]", etc. The degree of the polynomial is not
greater than the length of "xlist". 
<p> </p>
The lists "xlist" and "ylist" should be of equal
length. Furthermore, the entries of "xlist" should be all distinct
to ensure that there is one and only one solution.
<p> </p>
This routine uses the Lagrange interpolant formula to build up the
polynomial.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f := LagrangeInterpolant({0,1,2}, {0,1,1}, x);
Out> (x*(x-1))/2-x*(x-2);
In> Eval(Subst(x,0) f);
Out> 0;
In> Eval(Subst(x,1) f);
Out> 1;
In> Eval(Subst(x,2) f);
Out> 1;

In> PrettyPrinter("PrettyForm");

True

Out> 
In> LagrangeInterpolant({x1,x2,x3}, {y1,y2,y3}, x)

y1 * ( x - x2 ) * ( x - x3 )   y2 * ( x - x1 ) * ( x - x3 ) 
---------------------------- + ---------------------------- 
 ( x1 - x2 ) * ( x1 - x3 )      ( x2 - x1 ) * ( x2 - x3 )   

  y3 * ( x - x1 ) * ( x - x2 )
+ ----------------------------
   ( x3 - x1 ) * ( x3 - x2 )  

Out> </PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
.<A NAME="Fibonacci">

</A>
<H3>
<HR>Fibonacci -- Fibonacci sequence
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Fibonacci(n)
<H5>
Parameters:
</H5>
n - an integer
<H5>
Description:
</H5>

This command calculates and returns the "n"-th Fibonacci number. 
<p> </p>
The Fibonacci sequence is 1, 1, 2, 3, 5, 8, 13, 21, ..., where every
number is the sum of the two preceding numbers. Formally, it is
defined by F(1) = 1, F(2) = 1, and F(n+1) = F(n) + F(n-1), where F(n)
denotes the n-th Fibonacci number.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Fibonacci(4)
Out> 3;
In> Fibonacci(8)
Out> 21;
In> Table(Fibonacci(i), i, 1, 10, 1)
Out> {1,1,2,3,5,8,13,21,34,55};</PRE></TR>
</TABLE>

<p>  </P><HR><A NAME="c5">

</A>
<A HREF="refchapter5.html#LeviCivita" TARGET="Chapters">
LeviCivita
</A>
, <A HREF="refchapter5.html#Permutations" TARGET="Chapters">
Permutations
</A>
, <A HREF="refchapter5.html#InProduct" TARGET="Chapters">
InProduct
</A>
, <A HREF="refchapter5.html#CrossProduct" TARGET="Chapters">
CrossProduct
</A>
, <A HREF="refchapter5.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
, <A HREF="refchapter5.html#BaseVector" TARGET="Chapters">
BaseVector
</A>
, <A HREF="refchapter5.html#Identity" TARGET="Chapters">
Identity
</A>
, <A HREF="refchapter5.html#ZeroMatrix" TARGET="Chapters">
ZeroMatrix
</A>
, <A HREF="refchapter5.html#DiagonalMatrix" TARGET="Chapters">
DiagonalMatrix
</A>
, <A HREF="refchapter5.html#IsMatrix" TARGET="Chapters">
IsMatrix
</A>
, <A HREF="refchapter5.html#Normalize" TARGET="Chapters">
Normalize
</A>
, <A HREF="refchapter5.html#Transpose" TARGET="Chapters">
Transpose
</A>
, <A HREF="refchapter5.html#Determinant" TARGET="Chapters">
Determinant
</A>
, <A HREF="refchapter5.html#Trace" TARGET="Chapters">
Trace
</A>
, <A HREF="refchapter5.html#Inverse" TARGET="Chapters">
Inverse
</A>
, <A HREF="refchapter5.html#Minor" TARGET="Chapters">
Minor
</A>
, <A HREF="refchapter5.html#CoFactor" TARGET="Chapters">
CoFactor
</A>
, <A HREF="refchapter5.html#SolveMatrix" TARGET="Chapters">
SolveMatrix
</A>
, <A HREF="refchapter5.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
, <A HREF="refchapter5.html#EigenValues" TARGET="Chapters">
EigenValues
</A>
, <A HREF="refchapter5.html#EigenVectors" TARGET="Chapters">
EigenVectors
</A>
, <A HREF="refchapter5.html#IsHermitean" TARGET="Chapters">
IsHermitean
</A>
, <A HREF="refchapter5.html#IsUnitary" TARGET="Chapters">
IsUnitary
</A>
.
<H1>
Linear Algebra
</H1>
This chapter describes the commands for doing linear
algebra. They can be used to manipulate vectors, represented as lists,
and matrices, represented as lists of lists.
<A NAME="LeviCivita">

</A>
<H3>
<HR>LeviCivita -- The totally anti-symmetric Levi Civita tensor
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
LeviCivita(list)
<H5>
Parameters:
</H5>
list - a list of integers 1 .. n in some order
<H5>
Description:
</H5>
"LeviCivita" implements the Levi Civita symbol. This is generally
useful for tensor calculus.  {list}  should be a list of integers,
and this function returns 1 if the integers are in successive order,
eg.  {1,2,3,...}  would return 1. Swapping two elements of this
list would return -1. So, LeviCivita( {2,1,3} ) would evaluate
to -1.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> LeviCivita({1,2,3})
Out> 1;
In> LeviCivita({2,1,3})
Out> -1;
In> LeviCivita({2,2,3})
Out> 0;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Permutations" TARGET="Chapters">
Permutations
</A>
.<A NAME="Permutations">

</A>
<H3>
<HR>Permutations -- Form all permutations of a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Permutations(list)
<H5>
Parameters:
</H5>
list - a list of elements
<H5>
Description:
</H5>
Permutations returns a list with all the permutations of
the original list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Permutations({a,b,c})
Out> {{a,b,c},{a,c,b},{c,a,b},{b,a,c},{b,c,a},{c,b,a}};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#LeviCivita" TARGET="Chapters">
LeviCivita
</A>
.<A NAME="InProduct">

</A>
<H3>
<HR>InProduct -- Inner product of vectors
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

InProduct(a,b) <br>
a . b  (prec. 3)
<H5>
Parameters:
</H5>
a, b - vectors of equal length
<H5>
Description:
</H5>

The inner product of the two vectors "a" and "b" is returned. The
vectors need to have the same size.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> {a,b,c} . {d,e,f};
Out> a*d+b*e+c*f;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#CrossProduct" TARGET="Chapters">
CrossProduct
</A>
.<A NAME="CrossProduct">

</A>
<H3>
<HR>CrossProduct -- Outer product of vectors
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

CrossProduct(a,b) <br>
a X b  (prec. 3)
<H5>
Parameters:
</H5>
a, b - three-dimensional vectors
<H5>
Description:
</H5>

The outer product (also called the cross product) of the vectors "a"
and "b" is returned. The result is perpendicular to both "a" and
"b" and its length is the product of the lengths of the vectors. 
Both "a" and "b" have to be three-dimensional.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> {a,b,c} X {d,e,f};
Out> {b*f-c*e,c*d-a*f,a*e-b*d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#InProduct" TARGET="Chapters">
InProduct
</A>
.<A NAME="ZeroVector">

</A>
<H3>
<HR>ZeroVector -- Create a vector with all zeroes
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
ZeroVector(n)
<H5>
Parameters:
</H5>
n - length of the vector to return
<H5>
Description:
</H5>

This command returns a vector of length "n", filled with zeroes.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ZeroVector(4)
Out> {0,0,0,0};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#BaseVector" TARGET="Chapters">
BaseVector
</A>
, <A HREF="ref.html#ZeroMatrix" TARGET="Chapters">
ZeroMatrix
</A>
, <A HREF="ref.html#IsZeroVector" TARGET="Chapters">
IsZeroVector
</A>
.<A NAME="BaseVector">

</A>
<H3>
<HR>BaseVector -- Base vector
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
BaseVector(k, n)
<H5>
Parameters:
</H5>

k - index of the base vector to construct <br>
n - dimension of the vector
<H5>
Description:
</H5>

This command returns the "k"-th base vector of dimension "n". This
is a vector of length "n" with all zeroes except for the "k"-th
entry, which contains a 1.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> BaseVector(2,4)
Out> {0,1,0,0};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
, <A HREF="ref.html#Identity" TARGET="Chapters">
Identity
</A>
.<A NAME="Identity">

</A>
<H3>
<HR>Identity -- Identity matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Identity(n)
<H5>
Parameters:
</H5>
n - size of the matrix
<H5>
Description:
</H5>

This commands returns the identity matrix of size "n" by "n". This
matrix has ones on the diagonal while the other entries are zero.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Identity(3)
Out> {{1,0,0},{0,1,0},{0,0,1}};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#BaseVector" TARGET="Chapters">
BaseVector
</A>
, <A HREF="ref.html#ZeroMatrix" TARGET="Chapters">
ZeroMatrix
</A>
, <A HREF="ref.html#DiagonalMatrix" TARGET="Chapters">
DiagonalMatrix
</A>
.<A NAME="ZeroMatrix">

</A>
<H3>
<HR>ZeroMatrix -- Matrix filled with zeroes
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
ZeroMatrix(n, m)
<H5>
Parameters:
</H5>

n - number of rows <br>
m - number of columns
<H5>
Description:
</H5>

This command returns a matrix with "n" rows and "m" columns,
completely filled with zeroes.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ZeroMatrix(3,4)
Out> {{0,0,0,0},{0,0,0,0},{0,0,0,0}};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
, <A HREF="ref.html#Identity" TARGET="Chapters">
Identity
</A>
.<A NAME="DiagonalMatrix">

</A>
<H3>
<HR>DiagonalMatrix -- Construct a diagonal matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
DiagonalMatrix(d)
<H5>
Parameters:
</H5>
d - list of values to put on the diagonal
<H5>
Description:
</H5>

This command constructs a diagonal matrix, that is a square matrix
whose off-diagonal entries are all zero. The elements of the vector
"d" are put on the diagonal.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> DiagonalMatrix(1 .. 4)
Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Identity" TARGET="Chapters">
Identity
</A>
, <A HREF="ref.html#ZeroMatrix" TARGET="Chapters">
ZeroMatrix
</A>
.<A NAME="IsMatrix">

</A>
<H3>
<HR>IsMatrix -- Test whether argument is a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsMatrix(M)
<H5>
Parameters:
</H5>
M - a mathematical object
<H5>
Description:
</H5>
IsMatrix returns True if M is a matrix, False otherwise. Something is
considered to be a matrix if it is a list and all the entries of this
list are lists themselves.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsMatrix(ZeroMatrix(3,4))
Out> True;
In> IsMatrix(ZeroVector(4))
Out> False;
In> IsMatrix(3)
Out> False;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsVector" TARGET="Chapters">
IsVector
</A>
.<A NAME="Normalize">

</A>
<H3>
<HR>Normalize -- Normalize a vector
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Normalize(v)
<H5>
Parameters:
</H5>
v - a vector
<H5>
Description:
</H5>
Return the normalized vector of v: a vector going in the same
direction but with length 1.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Normalize({3,4})
Out> {3/5,4/5};
In> % . %
Out> 1;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#InProduct" TARGET="Chapters">
InProduct
</A>
, <A HREF="ref.html#CrossProduct" TARGET="Chapters">
CrossProduct
</A>
.<A NAME="Transpose">

</A>
<H3>
<HR>Transpose -- Transpose of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Transpose(M)
<H5>
Parameters:
</H5>
M - a matrix
<H5>
Description:
</H5>
Transpose returns the transpose of a matrix M. Because matrices are
just lists of lists, this is a useful operation too for lists.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Transpose({{a,b}})
Out> {{a},{b}};
</PRE></TR>
</TABLE>

<A NAME="Determinant">

</A>
<H3>
<HR>Determinant -- Determinant of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Determinant(M)
<H5>
Parameters:
</H5>
M - a matrix
<H5>
Description:
</H5>
Returns the determinant of a matrix M.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DiagonalMatrix(1 .. 4)
Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};
In> Determinant(%)
Out> 24;
</PRE></TR>
</TABLE>

<A NAME="Trace">

</A>
<H3>
<HR>Trace -- Trace of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Trace(M)
<H5>
Parameters:
</H5>
M - a matrix
<H5>
Description:
</H5>
Trace returns the trace of a matrix M (defined as the sum of the
elements on the diagonal of the matrix).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DiagonalMatrix(1 .. 4)
Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};
In> Trace(%)
Out> 10;
</PRE></TR>
</TABLE>

<A NAME="Inverse">

</A>
<H3>
<HR>Inverse -- Inverse of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Inverse(M)
<H5>
Parameters:
</H5>
M - a matrix
<H5>
Description:
</H5>
Inverse returns the inverse of matrix M. The determinant of M should
be non-zero. Because this function uses Determinant for calculating
the inverse of a matrix, you can supply matrices with non-numeric
matrix elements.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DiagonalMatrix({a,b,c})
Out> {{a,0,0},{0,b,0},{0,0,c}};
In> Inverse(%)
Out> {{(b*c)/(a*b*c),0,0},{0,(a*c)/(a*b*c),0},{0,0,(a*b)/(a*b*c)}};
In> Simplify(%)
Out> {{1/a,0,0},{0,1/b,0},{0,0,1/c}};
</PRE></TR>
</TABLE>

<A NAME="Minor">

</A>
<H3>
<HR>Minor -- Principal minor of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Minor(M,i,j)
<H5>
Parameters:
</H5>
M - a matrix <br>
i, j - positive integers
<H5>
Description:
</H5>

Minor returns the minor of a matrix around
the element (i,j). The minor is the determinant of the matrix
excluding the "i"-th row and "j"-th column.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> A := {{1,2,3}, {4,5,6}, {7,8,9}};
Out> {{1,2,3},{4,5,6},{7,8,9}};
In> PrettyForm(A);

/                    \
| ( 1 ) ( 2 ) ( 3 )  |
|                    |
| ( 4 ) ( 5 ) ( 6 )  |
|                    |
| ( 7 ) ( 8 ) ( 9 )  |
\                    /

Out> True;
In> Minor(A,1,2);
Out> -6;
In> Determinant({{2,3}, {8,9}});
Out> -6;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#CoFactor" TARGET="Chapters">
CoFactor
</A>
, <A HREF="ref.html#Determinant" TARGET="Chapters">
Determinant
</A>
, <A HREF="ref.html#Inverse" TARGET="Chapters">
Inverse
</A>
.<A NAME="CoFactor">

</A>
<H3>
<HR>CoFactor -- Cofactor of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
CoFactor(M,i,j)
<H5>
Parameters:
</H5>
M - a matrix <br>
i, j - positive integers
<H5>
Description:
</H5>

CoFactor returns the cofactor of a matrix around
the element (i,j). The cofactor is the minor times
(-1)^(i+j)

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> A := {{1,2,3}, {4,5,6}, {7,8,9}};
Out> {{1,2,3},{4,5,6},{7,8,9}};
In> PrettyForm(A);

/                    \
| ( 1 ) ( 2 ) ( 3 )  |
|                    |
| ( 4 ) ( 5 ) ( 6 )  |
|                    |
| ( 7 ) ( 8 ) ( 9 )  |
\                    /

Out> True;
In> CoFactor(A,1,2);
Out> 6;
In> Minor(A,1,2);
Out> -6;
In> Minor(A,1,2) * (-1)^(1+2);
Out> 6;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Minor" TARGET="Chapters">
Minor
</A>
, <A HREF="ref.html#Determinant" TARGET="Chapters">
Determinant
</A>
, <A HREF="ref.html#Inverse" TARGET="Chapters">
Inverse
</A>
.<A NAME="SolveMatrix">

</A>
<H3>
<HR>SolveMatrix -- Solve a linear system
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
SolveMatrix(M,v)
<H5>
Parameters:
</H5>
M - a matrix <br>
v - a vector
<H5>
Description:
</H5>
SolveMatrix returns the vector x that satisfies
the equation "M x = v". The determinant of M should be non-zero.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> A := {{1,2}, {3,4}};
Out> {{1,2},{3,4}};
In> v := {5,6};
Out> {5,6};
In> x := SolveMatrix(A, v);
Out> {-4,9/2};
In> A * x;
Out> {5,6};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Inverse" TARGET="Chapters">
Inverse
</A>
, <A HREF="ref.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="ref.html#PSolve" TARGET="Chapters">
PSolve
</A>
.<A NAME="CharacteristicEquation">

</A>
<H3>
<HR>CharacteristicEquation -- Characteristic polynomial of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
CharacteristicEquation(matrix,var)
<H5>
Parameters:
</H5>
matrix - a matrix <br>
var - a free variable
<H5>
Description:
</H5>
CharacteristicEquation
returns the characteristic equation of "matrix", using
"var". The zeros of this equation are the eigenvalues
of the matrix, Det(matrix-I*var);
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DiagonalMatrix({a,b,c})
Out> {{a,0,0},{0,b,0},{0,0,c}};
In> CharacteristicEquation(%,x)
Out> (a-x)*(b-x)*(c-x);
In> Expand(%,x)
Out> (b+a+c)*x^2-x^3-((b+a)*c+a*b)*x+a*b*c;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EigenValues" TARGET="Chapters">
EigenValues
</A>
, <A HREF="ref.html#EigenVectors" TARGET="Chapters">
EigenVectors
</A>
.<A NAME="EigenValues">

</A>
<H3>
<HR>EigenValues -- Eigenvalues of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
EigenValues(matrix)
<H5>
Parameters:
</H5>
matrix - a square matrix
<H5>
Description:
</H5>
EigenValues returns the eigenvalues of a matrix.
The eigenvalues x of a matrix M are the numbers such that
M*v=x*v for some vector.<BR>
It first determines the characteristic equation, and then factorizes this
equation, returning the roots of the characteristic equation
det(matrix-x*identity).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> M:={{1,2},{2,1}}
Out> {{1,2},{2,1}};
In> EigenValues(M)
Out> {3,-1};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EigenVectors" TARGET="Chapters">
EigenVectors
</A>
, <A HREF="ref.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
.<A NAME="EigenVectors">

</A>
<H3>
<HR>EigenVectors -- Eigenvectors of a matrix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
EigenVectors(matrix,eigenvalues)
Standard math library<br><H5>
Parameters:
</H5>
matrix - a square matrix <br>
 eigenvalues - list of eigenvalues as returned by EigenValues

<H5>
Description:
</H5>
EigenVectors returns a list of the eigenvectors of a matrix.
It uses the eigenvalues and the matrix to set up n equations with
n unknowns for each eigenvalue, and then calls Solve to determine
the values of each vector.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> M:={{1,2},{2,1}}
Out> {{1,2},{2,1}};
In> e:=EigenValues(M)
Out> {3,-1};
In> EigenVectors(M,e)
Out> {{-ki2/ -1,ki2},{-ki2,ki2}};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EigenValues" TARGET="Chapters">
EigenValues
</A>
, <A HREF="ref.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
.<A NAME="IsHermitean">

</A>
<H3>
<HR>IsHermitean -- Test whether a matrix is Hermitean
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsHermitean(A)
<H5>
Parameters:
</H5>
A - square matrix
<H5>
Description:
</H5>
IsHermitean(A) returns True if A is Hermitean and False
otherwise. A is a Hermitean matrix iff Conjugate(Transpose(A))=A.
For real matrices A is tested to be symmetric.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsHermitean({{0,I},{-I,0}})
Out> True;
In> IsHermitean({{0,I},{2,0}})
Out> False;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsUnitary" TARGET="Chapters">
IsUnitary
</A>
.<A NAME="IsUnitary">

</A>
<H3>
<HR>IsUnitary -- Test whether a matrix is unitary
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsUnitary(A)
<H5>
Parameters:
</H5>
A - square matrix
<H5>
Description:
</H5>
This function tries to find out if A is unitary.

Matrix A is orthogonal iff A^(-1) = Transpose(Conjugate(A)). This is 
equivalent to the fact that the columns of A build an orthonormal system 
(in respect to the scalar product defined by InProduct).

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsUnitary({{0,I},{-I,0}})
Out> True;
In> IsUnitary({{0,I},{2,0}})
Out> False;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsHermitean" TARGET="Chapters">
IsHermitean
</A>
.<p>  </P><HR><A NAME="c6">

</A>
<A HREF="refchapter6.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="refchapter6.html#Degree" TARGET="Chapters">
Degree
</A>
, <A HREF="refchapter6.html#Coef" TARGET="Chapters">
Coef
</A>
, <A HREF="refchapter6.html#Content" TARGET="Chapters">
Content
</A>
, <A HREF="refchapter6.html#PrimitivePart" TARGET="Chapters">
PrimitivePart
</A>
, <A HREF="refchapter6.html#LeadingCoef" TARGET="Chapters">
LeadingCoef
</A>
, <A HREF="refchapter6.html#Monic" TARGET="Chapters">
Monic
</A>
, <A HREF="refchapter6.html#RandomPoly" TARGET="Chapters">
RandomPoly
</A>
, <A HREF="refchapter6.html#Horner" TARGET="Chapters">
Horner
</A>
, <A HREF="refchapter6.html#ExpandBrackets" TARGET="Chapters">
ExpandBrackets
</A>
.
<H1>
Polynomials
</H1>
This chapter contains commands to manipulate
polynomials.
<A NAME="Expand">

</A>
<H3>
<HR>Expand -- Put polynomial in expanded form
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Expand(expr) <br>
Expand(expr, var) <br>
Expand(expr, varlist)

<H5>
Parameters:
</H5>
expr - a polynomial expression <br>
var - a variable <br>
varlist - a list of variables

<H5>
Description:
</H5>

This command brings a polynomial in expanded form, in which
polynomials are represented in the form c0 + c1*x + c2*x^2 + ... +
cn*x^n. In this form, it is easier to test whether a polynomial is
zero, namely by testing whether all coefficients are zero.
<p> </p>
If the polynomial "expr" contains only one variable, the first
calling sequence can be used. Otherwise, the second form should be
used which explicitly mentions that "expr" should be considered as a
polynomial in the variable "var". The third calling form can be used
for multivariate polynomials. Firstly, the polynomial "expr" is
expanded with respect to the first variable in "varlist". Then the
coefficients are all expanded with respect to the second variable, and
so on.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyPrinter("PrettyForm");

True

Out> 
In> Expand((1+x)^5);

 5        4         3         2            
x  + 5 * x  + 10 * x  + 10 * x  + 5 * x + 1

Out> 
In> Expand((1+x-y)^2, x);

 2                                2
x  + 2 * ( 1 - y ) * x + ( 1 - y ) 

Out> 
In> Expand((1+x-y)^2, {x,y});

 2                         2            
x  + ( -2 * y + 2 ) * x + y  - 2 * y + 1

Out> </PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ExpandBrackets" TARGET="Chapters">
ExpandBrackets
</A>
.<A NAME="Degree">

</A>
<H3>
<HR>Degree -- Degree of a polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Degree(expr) <br>
Degree(expr, var)
<H5>
Parameters:
</H5>

expr - a polynomial <br>
var - a variable occurring in "expr"
<H5>
Description:
</H5>

This command returns the degree of the polynomial "expr" with
respect to the variable "var". The degree is the highest power of
"var" occurring in the polynomial. If only one variable occurs in
"expr", the first calling sequence can be used. Otherwise the user
should use the second form in which the variable is explicitly
mentioned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Degree(x^5+x-1);
Out> 5;
In> Degree(a+b*x^3, a);
Out> 1;
In> Degree(a+b*x^3, x);
Out> 3;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="ref.html#Coef" TARGET="Chapters">
Coef
</A>
.<A NAME="Coef">

</A>
<H3>
<HR>Coef -- Coefficient of a polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Coef(expr, var, order)
<H5>
Parameters:
</H5>

expr - a polynomial <br>
var - a variable occurring in "expr" <br>
order - integer or list of integers
<H5>
Description:
</H5>

This command returns the coefficient of "var" to the power "order"
in the polynomial "expr". The parameter "order" can also be a list
of integers, in which case this function returns a list of
coefficients.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> e := Expand((a+x)^4,x)
Out> x^4+4*a*x^3+(a^2+(2*a)^2+a^2)*x^2+(a^2*2*a+2*a^3)*x+a^4;
In> Coef(e,a,2)
Out> 6*x^2;
In> Coef(e,a,0 .. 4)
Out> {x^4,4*x^3,6*x^2,4*x,1};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="ref.html#Degree" TARGET="Chapters">
Degree
</A>
, <A HREF="ref.html#LeadingCoef" TARGET="Chapters">
LeadingCoef
</A>
.<A NAME="Content">

</A>
<H3>
<HR>Content -- Content of a univariate polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Content(expr)
<H5>
Parameters:
</H5>
expr - univariate polynomial
<H5>
Description:
</H5>

This command determines the content of a univariate polynomial. The
content is the greatest common divisor of all the terms in the
polynomial. Every polynomial can be written as the product of the
content with the primitive part.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> c := Content(poly);
Out> 2*x;
In> pp := PrimitivePart(poly);
Out> x+2;
In> Expand(pp*c);
Out> 2*x^2+4*x;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrimitivePart" TARGET="Chapters">
PrimitivePart
</A>
, <A HREF="ref.html#Gcd" TARGET="Chapters">
Gcd
</A>
.<A NAME="PrimitivePart">

</A>
<H3>
<HR>PrimitivePart -- Primitive part of a univariate polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PrimitivePart(expr)
<H5>
Parameters:
</H5>
expr - univariate polynomial
<H5>
Description:
</H5>

This command determines the primitive part of a univariate
polynomial. The primitive part is what remains after the content (the
greatest common divisor of all the terms) is divided out. So the
product of the content and the primitive part equals the original
polynomial.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> c := Content(poly);
Out> 2*x;
In> pp := PrimitivePart(poly);
Out> x+2;
In> Expand(pp*c);
Out> 2*x^2+4*x;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Content" TARGET="Chapters">
Content
</A>
.<A NAME="LeadingCoef">

</A>
<H3>
<HR>LeadingCoef -- Leading coefficient of a polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

LeadingCoef(poly) <br>
LeadingCoef(poly, var)
<H5>
Parameters:
</H5>

poly - a polynomial <br>
var - a variable
<H5>
Description:
</H5>

This function returns the leading coefficient of "poly", regarded as
a polynomial in the variable "var". The leading coefficient is the
coefficient of the term of highest degree. If only one variable
appears in the expression "poly", it is obvious that it should be
regarded as a polynomial in this variable and the first calling
sequence may be used.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> lc := LeadingCoef(poly);
Out> 2;
In> m := Monic(poly);
Out> x^2+2*x;
In> Expand(lc*m);
Out> 2*x^2+4*x;

In> LeadingCoef(2*a^2 + 3*a*b^2 + 5, a);
Out> 2;
In> LeadingCoef(2*a^2 + 3*a*b^2 + 5, b);
Out> 3*a;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Coef" TARGET="Chapters">
Coef
</A>
, <A HREF="ref.html#Monic" TARGET="Chapters">
Monic
</A>
.<A NAME="Monic">

</A>
<H3>
<HR>Monic -- Monic part of a polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Monic(poly) <br>
Monic(poly, var)
<H5>
Parameters:
</H5>

poly - a polynomial <br>
var - a variable
<H5>
Description:
</H5>

This function returns the monic part of "poly", regarded as a
polynomial in the variable "var". The monic part of a polynomial is
the quotient of this polynomial by its leading coefficient. So the
leading coefficient of the monic part is always one. If only one
variable appears in the expression "poly", it is obvious that it
should be regarded as a polynomial in this variable and the first
calling sequence may be used.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> lc := LeadingCoef(poly);
Out> 2;
In> m := Monic(poly);
Out> x^2+2*x;
In> Expand(lc*m);
Out> 2*x^2+4*x;

In> Monic(2*a^2 + 3*a*b^2 + 5, a);
Out> a^2+(a*3*b^2)/2+5/2;
In> Monic(2*a^2 + 3*a*b^2 + 5, b);
Out> b^2+(2*a^2+5)/(3*a);</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#LeadingCoef" TARGET="Chapters">
LeadingCoef
</A>
.<A NAME="RandomPoly">

</A>
<H3>
<HR>RandomPoly -- Construct a random polynomial
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RandomPoly(var,deg,coefmin,coefmax)
<H5>
Parameters:
</H5>
var - free variable for resulting univariate polynomial <br>
deg - degree of resulting univariate polynomial <br>
coefmin - minimum value for coefficients <br>
coefmax - maximum value for coefficients

<H5>
Description:
</H5>
RandomPoly generates a random polynomial in variable "var", of
degree "deg", with integer coefficients ranging from "coefmin" to
"coefmax" (inclusive). The coefficients are uniformly distributed in
this interval, and are independent of each other.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> RandomPoly(x,3,-10,10)
Out> 3*x^3+10*x^2-4*x-6;
In> RandomPoly(x,3,-10,10)
Out> -2*x^3-8*x^2+8;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Random" TARGET="Chapters">
Random
</A>
, <A HREF="ref.html#RandomIntegerVector" TARGET="Chapters">
RandomIntegerVector
</A>
.<H3>
<HR>Div and Mod for polynomials
</H3>
Standard math library<br>

Div and Mod are also defined for polynomials.

<H5>
See Also:
</H5>
<A HREF="ref.html#Div" TARGET="Chapters">
Div
</A>
, <A HREF="ref.html#Mod" TARGET="Chapters">
Mod
</A>
.<A NAME="Horner">

</A>
<H3>
<HR>Horner -- Convert polynomial in Horner form
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Horner(expr, var)
<H5>
Parameters:
</H5>
expr - a polynomial in "var" <br>
var - a variable

<H5>
Description:
</H5>

This command turns the polynomial "expr", considered as a univariate
polynomial in "var", into Horner form. A polynomial in normal form
is an expression like<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
                                  n-1           n
c(0) + c(1) * x + ... + c(n-1) * x    + c(n) * x  </PRE></TR>
</TABLE>

If one converts this polynomial in Horner form, one gets the
equivalent expression<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
(...( c(n) * x + c(n-1) ) * x + ...  + c(1) ) * x + c(0)</PRE></TR>
</TABLE>

Both expression are equal, but the latter form gives a more
efficient way to evaluate the polynomial as  the powers have
disappeared.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In&gt expr1:=Expand((1+x)^4) 
Out&gt x^4+4*x^3+6*x^2+4*x+1 
In&gt  Horner(expr1,x) 
Out&gt (((x+4)*x+6)*x+4)*x+1 
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="ref.html#ExpandBrackets" TARGET="Chapters">
ExpandBrackets
</A>
.<A NAME="ExpandBrackets">

</A>
<H3>
<HR>ExpandBrackets -- Expand all terms
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
ExpandBrackets(expr)
<H5>
Parameters:
</H5>
expr - an expression
<H5>
Description:
</H5>

This command tries to expand all the brackets by repeatedly using the
distributive laws "a * (b+c) = a*b + a*c" and "(a+b) * c = a*c +
b*c". It goes further than <B><TT>Expand</TT></B>, in that it
expands all terms.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Expand((a-x)*(b-x),x)
Out> x^2-(b+a)*x+a*b;
In> Expand((a-x)*(b-x),{x,a,b})
Out> x^2-(b+a)*x+b*a;
In> ExpandBrackets((a-x)*(b-x))
Out> a*b-x*b+x^2-a*x;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Expand" TARGET="Chapters">
Expand
</A>
.<p>  </P><HR><A NAME="c7">

</A>
<A HREF="refchapter7.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="refchapter7.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="refchapter7.html#Length" TARGET="Chapters">
Length
</A>
, <A HREF="refchapter7.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="refchapter7.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="refchapter7.html#RandomIntegerVector" TARGET="Chapters">
RandomIntegerVector
</A>
, <A HREF="refchapter7.html#MakeVector" TARGET="Chapters">
MakeVector
</A>
, <A HREF="refchapter7.html#Select" TARGET="Chapters">
Select
</A>
, <A HREF="refchapter7.html#Nth" TARGET="Chapters">
Nth
</A>
, <A HREF="refchapter7.html#DestructiveReverse" TARGET="Chapters">
DestructiveReverse
</A>
, <A HREF="refchapter7.html#List" TARGET="Chapters">
List
</A>
, <A HREF="refchapter7.html#UnList" TARGET="Chapters">
UnList
</A>
, <A HREF="refchapter7.html#Listify" TARGET="Chapters">
Listify
</A>
, <A HREF="refchapter7.html#Concat" TARGET="Chapters">
Concat
</A>
, <A HREF="refchapter7.html#Delete" TARGET="Chapters">
Delete
</A>
, <A HREF="refchapter7.html#Insert" TARGET="Chapters">
Insert
</A>
, <A HREF="refchapter7.html#DestructiveDelete" TARGET="Chapters">
DestructiveDelete
</A>
, <A HREF="refchapter7.html#DestructiveInsert" TARGET="Chapters">
DestructiveInsert
</A>
, <A HREF="refchapter7.html#Replace" TARGET="Chapters">
Replace
</A>
, <A HREF="refchapter7.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
, <A HREF="refchapter7.html#FlatCopy" TARGET="Chapters">
FlatCopy
</A>
, <A HREF="refchapter7.html#Contains" TARGET="Chapters">
Contains
</A>
, <A HREF="refchapter7.html#Find" TARGET="Chapters">
Find
</A>
, <A HREF="refchapter7.html#Append" TARGET="Chapters">
Append
</A>
, <A HREF="refchapter7.html#DestructiveAppend" TARGET="Chapters">
DestructiveAppend
</A>
, <A HREF="refchapter7.html#RemoveDuplicates" TARGET="Chapters">
RemoveDuplicates
</A>
, <A HREF="refchapter7.html#Push" TARGET="Chapters">
Push
</A>
, <A HREF="refchapter7.html#Pop" TARGET="Chapters">
Pop
</A>
, <A HREF="refchapter7.html#PopFront" TARGET="Chapters">
PopFront
</A>
, <A HREF="refchapter7.html#PopBack" TARGET="Chapters">
PopBack
</A>
, <A HREF="refchapter7.html#Swap" TARGET="Chapters">
Swap
</A>
, <A HREF="refchapter7.html#Count" TARGET="Chapters">
Count
</A>
, <A HREF="refchapter7.html#Intersection" TARGET="Chapters">
Intersection
</A>
, <A HREF="refchapter7.html#Union" TARGET="Chapters">
Union
</A>
, <A HREF="refchapter7.html#Difference" TARGET="Chapters">
Difference
</A>
, <A HREF="refchapter7.html#FillList" TARGET="Chapters">
FillList
</A>
, <A HREF="refchapter7.html#Drop" TARGET="Chapters">
Drop
</A>
, <A HREF="refchapter7.html#Take" TARGET="Chapters">
Take
</A>
, <A HREF="refchapter7.html#Partition" TARGET="Chapters">
Partition
</A>
, <A HREF="refchapter7.html#Assoc" TARGET="Chapters">
Assoc
</A>
, <A HREF="refchapter7.html#AssocIndices" TARGET="Chapters">
AssocIndices
</A>
, <A HREF="refchapter7.html#Flatten" TARGET="Chapters">
Flatten
</A>
, <A HREF="refchapter7.html#UnFlatten" TARGET="Chapters">
UnFlatten
</A>
, <A HREF="refchapter7.html#Type" TARGET="Chapters">
Type
</A>
, <A HREF="refchapter7.html#NrArgs" TARGET="Chapters">
NrArgs
</A>
, <A HREF="refchapter7.html#BubbleSort" TARGET="Chapters">
BubbleSort
</A>
, <A HREF="refchapter7.html#Table" TARGET="Chapters">
Table
</A>
, <A HREF="refchapter7.html#TableForm" TARGET="Chapters">
TableForm
</A>
.
<H1>
List operations
</H1>

Most objects that can be of variable size are represented as lists
(linked lists internally). Yacas does implement arrays, which are
faster when the number of elements in a collection of objects doesn't
change. Operations on lists have better support in the current
system.
<A NAME="Head">

</A>
<H3>
<HR>Head -- The first element of a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Head(list)
<H5>
Parameters:
</H5>
list - a list
<H5>
Description:
</H5>

This function returns the first element of a list. If it is applied to
a general expression, it returns the first operand. An error is
returned if "list" is an atom.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Head({a,b,c})
Out> a;
In> Head(f(a,b,c));
Out> a;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
.<A NAME="Tail">

</A>
<H3>
<HR>Tail -- Returns a list without its first element
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Tail(list)
<H5>
Parameters:
</H5>
list - a list
<H5>
Description:
</H5>
This function returns "list" without its first element.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Tail({a,b,c})
Out> {b,c};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
.<A NAME="Length">

</A>
<H3>
<HR>Length -- The length of a list or string
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Length(object)
<H5>
Parameters:
</H5>
object - a list, array or string
<H5>
Description:
</H5>
Length returns the length of a list.
This function also works on strings and arrays.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Length({a,b,c})
Out> 3;
In> Length("abcdef");
Out> 6;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="ref.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="ref.html#Nth" TARGET="Chapters">
Nth
</A>
, <A HREF="ref.html#Count" TARGET="Chapters">
Count
</A>
.<A NAME="Map">

</A>
<H3>
<HR>Map -- Apply an n-ary function to all entries in a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Map(fn, list)
<H5>
Parameters:
</H5>

fn - function to apply <br>
list - list of lists of arguments
<H5>
Description:
</H5>

This function applies "fn" to every list of arguments to be found in
"list". So the first entry of "list" should be a list containing
the first, second, third, ... argument to "fn", and the same goes
for the other entries of "list". The function can either be given as
a string or as a pure function.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> MapSingle("Sin",{a,b,c});
Out> {Sin(a),Sin(b),Sin(c)};
In> Map("+",{{a,b},{c,d}});
Out> {a+c,b+d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="ref.html#MapArgs" TARGET="Chapters">
MapArgs
</A>
.<A NAME="MapSingle">

</A>
<H3>
<HR>MapSingle -- Apply a unary function to all entries in a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
MapSingle(fn, list)
<H5>
Parameters:
</H5>

fn - function to apply <br>
list - list of arguments
<H5>
Description:
</H5>

The function "fn" is successively applied to all entries in
"list", and a list containing the respective results is
returned. The function can be given either as a string or as a pure
function. 
<p> </p>
The <B><TT>/@</TT></B> operator provides a shorthand for
<B><TT>MapSingle</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> MapSingle("Sin",{a,b,c});
Out> {Sin(a),Sin(b),Sin(c)};
In> MapSingle({{x},x^2}, {a,2,c});
Out> {a^2,4,c^2};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="ref.html#MapArgs" TARGET="Chapters">
MapArgs
</A>
, <A HREF="ref.html#/@" TARGET="Chapters">
/@
</A>
.<A NAME="RandomIntegerVector">

</A>
<H3>
<HR>RandomIntegerVector -- Generate a vector of random integers
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RandomIntegerVector(nr, from, to)
<H5>
Parameters:
</H5>

nr - number of integers to generate <br>
from - lower bound <br>
to - upper bound
<H5>
Description:
</H5>

This function generates a list with "nr" random integers. All
entries lie between "from" and "to", including the boundaries, and
are uniformly distributed in this interval.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> RandomIntegerVector(4,-3,3)
Out> {0,3,2,-2};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Random" TARGET="Chapters">
Random
</A>
, <A HREF="ref.html#RandomPoly" TARGET="Chapters">
RandomPoly
</A>
.<A NAME="MakeVector">

</A>
<H3>
<HR>MakeVector -- Vector of uniquely numbered variable names
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
MakeVector(var,n)
<H5>
Parameters:
</H5>
var - free variable<br>
n - length of the vector
<H5>
Description:
</H5>

A list of length "n" is generated. The first entry contains the
identifier "var" with the number 1 appended to it, the second entry
contains "var" with the suffix 2, and so on until the last entry
which contains "var" with the number "n" appended to it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> MakeVector(a,3)
Out> {a1,a2,a3};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#RandomIntegerVector" TARGET="Chapters">
RandomIntegerVector
</A>
, <A HREF="ref.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
.<A NAME="Select">

</A>
<H3>
<HR>Select -- Select the entries satisfying some predicate
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Select(pred, list)
<H5>
Parameters:
</H5>
pred - a predicate <br>
list - a list of elements to select from
<H5>
Description:
</H5>
<B><TT>Select</TT></B> returns a sublist of "list" which contains all
the entries for which the predicate "pred" returns
<B><TT>True</TT></B> when applied to this entry.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Select("IsInteger",{a,b,2,c,3,d,4,e,f})
Out> {2,3,4};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
, <A HREF="ref.html#Find" TARGET="Chapters">
Find
</A>
, <A HREF="ref.html#Count" TARGET="Chapters">
Count
</A>
.<A NAME="Nth">

</A>
<H3>
<HR>Nth -- Return the n-th element of a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Nth(list, n)
<H5>
Parameters:
</H5>

list - list to choose from <br>
n - index of entry to pick
<H5>
Description:
</H5>

The entry with index "n" from "list" is returned. The first entry
has index 1. It is possible to pick several entries of the list by
taking "n" to be a list of indices. 
<p> </p>
More generally, <B><TT>Nth</TT></B> returns the n-th operand of the
expression passed as first argument.
<p> </p>
An alternative but equivalent form of <B><TT>Nth(list, n)</TT></B> is
<B><TT>list[n]</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,13,19};
Out> {a,b,c,13,19};
In> Nth(lst, 3);
Out> c;
In> lst[3];
Out> c;
In> Nth(lst, {3,4,1});
Out> {c,13,a};
In> Nth(b*(a+c), 2);
Out> a+c;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Select" TARGET="Chapters">
Select
</A>
, <A HREF="ref.html#Nth" TARGET="Chapters">
Nth
</A>
.<A NAME="DestructiveReverse">

</A>
<H3>
<HR>DestructiveReverse -- Reverse a list destructively
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DestructiveReverse(list)
<H5>
Parameters:
</H5>
list - list to reverse
<H5>
Description:
</H5>
 
This command reverses "list" in place, so that the original is
destroyed. This means that any variable bound to "list" will now be
bound to the reversed list. The reversed list is also returned.
<p> </p>
Destructive commands are faster than their nondestructive
counterparts. Stangely, there is no nondestructive command to reverse
a list. Use <B><TT>FlatCopy</TT></B> and
<B><TT>DestructiveReverse</TT></B> to achieve this.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,13,19};
Out> {a,b,c,13,19};
In> revlst := DestructiveReverse(lst);
Out> {19,13,c,b,a};
In> lst;
Out> {a};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FlatCopy" TARGET="Chapters">
FlatCopy
</A>
.<A NAME="List">

</A>
<H3>
<HR>List -- Construct a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
List(expr1, expr2, ...)
<H5>
Parameters:
</H5>
expr1, expr2 - expressions making up the list
<H5>
Descriptions:
</H5>

A list is constructed whose first entry is "expr1", the second entry
is "expr2", and so on. This command is equivalent to the expression
"{expr1, expr2, ...}".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> List();
Out> {};
In> List(a,b);
Out> {a,b};
In> List(a,{1,2},d);
Out> {a,{1,2},d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#UnList" TARGET="Chapters">
UnList
</A>
, <A HREF="ref.html#Listify" TARGET="Chapters">
Listify
</A>
.<A NAME="UnList">

</A>
<H3>
<HR>UnList -- Convert a list to a function application
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
UnList(list)
<H5>
Parameters:
</H5>
list - list to be converted
<H5>
Description:
</H5>

This command converts a list to a function application. The first
entry of "list" is treated as a function, and the following entries
are the arguments to this function. So the function refered to in the
first element of "list" is applied to the other elements. 
<p> </p>
Note that "list" is evaluated before the function application is
formed, but the resulting expression is not evaluated.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> UnList({Cos, x});
Out> Cos(x);
In> UnList({f});
Out> f();
In> UnList({Taylor,x,0,5,Cos(x)});
Out> Taylor(x,0,5)Cos(x);
In> Eval(%);
Out> 1-x^2/2+x^4/24;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#List" TARGET="Chapters">
List
</A>
, <A HREF="ref.html#Listify" TARGET="Chapters">
Listify
</A>
.<A NAME="Listify">

</A>
<H3>
<HR>Listify -- Convert a function application to a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Listify(expr)
<H5>
Parameters:
</H5>
expr - expression to be converted
<H5>
Description:
</H5>

The parameter "expr" is expected to be a compound object, i.e. not
an atom. It is evaluated and then converted to a list. The first entry
in the list is the top-level operator in the evaluated expression and
the other entries are the arguments to this operator. Finally, the
list is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Listify(Cos(x));
Out> {Cos,x};
In> Listify(3*a);
Out> {*,3,a};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#List" TARGET="Chapters">
List
</A>
, <A HREF="ref.html#UnList" TARGET="Chapters">
UnList
</A>
, <A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
.<A NAME="Concat">

</A>
<H3>
<HR>Concat -- Concatenate lists
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Concat(list1, list2, ...)
<H5>
Parameters:
</H5>
list1, list2 - lists to concatenate
<H5>
Description:
</H5>

The lists "list1", "list2", ..., are evaluated and
concatenated. The resulting big list is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Concat({a,b}, {c,d});
Out> {a,b,c,d};
In> Concat({5}, {a,b,c}, {{f(x)}});
Out> {5,a,b,c,{f(x)}};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ConcatStrings" TARGET="Chapters">
ConcatStrings
</A>
, <A HREF="ref.html#:" TARGET="Chapters">
:
</A>
, <A HREF="ref.html#Insert" TARGET="Chapters">
Insert
</A>
.<A NAME="Delete">

</A>
<H3>
<HR>Delete -- Delete an element from a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Delete(list, n)
<H5>
Parameters:
</H5>

list - list from which an element should be removed <br>
n - index of the element to remove
<H5>
Description:
</H5>

This command deletes the n-th element from "list". The first
parameter should be a list, while "n" should be a positive integer
less than or equal to the length of "list". The entry with index
"n" is removed (the first entry has index 1), and the resulting list
is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Delete({a,b,c,d,e,f}, 4);
Out> {a,b,c,e,f};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#DestructiveDelete" TARGET="Chapters">
DestructiveDelete
</A>
, <A HREF="ref.html#Insert" TARGET="Chapters">
Insert
</A>
, <A HREF="ref.html#Replace" TARGET="Chapters">
Replace
</A>
.<A NAME="Insert">

</A>
<H3>
<HR>Insert -- Insert an element into a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Insert(list, n, expr)
<H5>
Parameters:
</H5>

list - list in which "expr" should be inserted <br>
n - index at which to insert <br>
expr - expression to insert in "list"
<H5>
Description:
</H5>

The expression "expr" is inserted just before the n-th entry in
"list". The first parameter "list" should be a list, while "n"
should be a positive integer less than or equal to the length of
"list" plus one. The expression "expr" is placed between the
entries in "list" with entries "n-1" and "n". There are two
border line cases: if "n" is 1, the expression "expr" is placed in
front of the list (like the <B><TT>:</TT></B> operator); if "n"
equals the length of "list" plus one, the expression "expr" is
placed at the end of the list (like <B><TT>Append</TT></B>). In any
case, the resulting list is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Insert({a,b,c,d}, 4, x);
Out> {a,b,c,x,d};
In> Insert({a,b,c,d}, 5, x);
Out> {a,b,c,d,x};
In> Insert({a,b,c,d}, 1, x);
Out> {x,a,b,c,d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#DestructiveInsert" TARGET="Chapters">
DestructiveInsert
</A>
, <A HREF="ref.html#:" TARGET="Chapters">
:
</A>
, <A HREF="ref.html#Append" TARGET="Chapters">
Append
</A>
, <A HREF="ref.html#Delete" TARGET="Chapters">
Delete
</A>
, <A HREF="ref.html#Remove" TARGET="Chapters">
Remove
</A>
.<A NAME="DestructiveDelete">

</A>
<H3>
<HR>DestructiveDelete -- Delete an element destructively from a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DestructiveDelete(list, n)
<H5>
Parameters:
</H5>

list - list from which an element should be removed <br>
n - index of the element to remove
<H5>
Description:
</H5>

This is the destructive counterpart of <B><TT>Delete</TT></B>. This
command yields the same result as the corresponding call to
<B><TT>Delete</TT></B>, but the original list is modified. So if a
variable is bound to "list", it will now be bound to the list with
the n-th entry removed. 
<p> </p>
Destructive commands run faster than their nondestructive counterparts
because the latter copy the list before they alter it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d,e,f};
Out> {a,b,c,d,e,f};
In> Delete(lst, 4);
Out> {a,b,c,e,f};
In> lst;
Out> {a,b,c,d,e,f};
In> DestructiveDelete(lst, 4);
Out> {a,b,c,e,f};
In> lst;
Out> {a,b,c,e,f};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Delete" TARGET="Chapters">
Delete
</A>
, <A HREF="ref.html#DestructiveInsert" TARGET="Chapters">
DestructiveInsert
</A>
, <A HREF="ref.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
.<A NAME="DestructiveInsert">

</A>
<H3>
<HR>DestructiveInsert -- Insert an element destructively into a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DestructiveInsert(list, n, expr)
<H5>
Parameters:
</H5>

list - list in which "expr" should be inserted <br>
n - index at which to insert <br>
expr - expression to insert in "list"
<H5>
Description:
</H5>

This is the destructive counterpart of <B><TT>Insert</TT></B>. This
command yields the same result as the corresponding call to
<B><TT>Insert</TT></B>, but the original list is modified. So if a
variable is bound to "list", it will now be bound to the list with
the expression "expr" inserted.
<p> </p>
Destructive commands run faster than their nondestructive counterparts
because the latter copy the list before they alter it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d};
Out> {a,b,c,d};
In> Insert(lst, 2, x);
Out> {a,x,b,c,d};
In> lst;
Out> {a,b,c,d};
In> DestructiveInsert(lst, 2, x);
Out> {a,x,b,c,d};
In> lst;
Out> {a,x,b,c,d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Insert" TARGET="Chapters">
Insert
</A>
, <A HREF="ref.html#DestructiveDelete" TARGET="Chapters">
DestructiveDelete
</A>
, <A HREF="ref.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
.<A NAME="Replace">

</A>
<H3>
<HR>Replace -- Replace an entry in a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Replace(list, n, expr)
<H5>
Parameters:
</H5>

list - list of which an entry should be replaced <br>
n - index of entry to replace <br>
expr - expression to replace the n-th entry with
<H5>
Description:
</H5>

The n-th entry of "list" is replaced by the expression
"expr". This is equivalent to calling <B><TT>Delete</TT></B> and
<B><TT>Insert</TT></B> in sequence. To be precise, the expression
<B><TT>Replace(list, n, expr)</TT></B> has the same result as the
expression <B><TT>Insert(Delete(list, n), n, expr)</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Replace({a,b,c,d,e,f}, 4, x);
Out> {a,b,c,x,e,f};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Delete" TARGET="Chapters">
Delete
</A>
, <A HREF="ref.html#Insert" TARGET="Chapters">
Insert
</A>
, <A HREF="ref.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
.<A NAME="DestructiveReplace">

</A>
<H3>
<HR>DestructiveReplace -- Replace an entry in a list destructively
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DestructiveReplace(list, n, expr)
<H5>
Parameters:
</H5>

list - list of which an entry should be replaced <br>
n - index of entry to replace <br>
expr - expression to replace the n-th entry with
<H5>
Description:
</H5>

This is the destructive counterpart of <B><TT>Replace</TT></B>. This
command yields the same result as the corresponding call to
<B><TT>Replace</TT></B>, but the original list is modified. So if a
variable is bound to "list", it will now be bound to the list with
the expression "expr" inserted.
<p> </p>
Destructive commands run faster than their nondestructive counterparts
because the latter copy the list before they alter it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d,e,f};
Out> {a,b,c,d,e,f};
In> Replace(lst, 4, x);
Out> {a,b,c,x,e,f};
In> lst;
Out> {a,b,c,d,e,f};
In> DestructiveReplace(lst, 4, x);
Out> {a,b,c,x,e,f};
In> lst;
Out> {a,b,c,x,e,f};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Replace" TARGET="Chapters">
Replace
</A>
, <A HREF="ref.html#DestructiveDelete" TARGET="Chapters">
DestructiveDelete
</A>
, <A HREF="ref.html#DestructiveInsert" TARGET="Chapters">
DestructiveInsert
</A>
.<A NAME="FlatCopy">

</A>
<H3>
<HR>FlatCopy -- Copy the top level of a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FlatCopy(list)
<H5>
Parameters:
</H5>
list - list to be copied
<H5>
Description:
</H5>

A copy of "list" is made and returned. The list is not recursed
into, only the first level is copied. This is useful in combination
with the destructive commands that actually modify lists in place (for
efficiency).
<H5>
Example:
</H5>

The following shows a possible way to define a command that reverses a
list nondestructively.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> reverse(l_IsList) <-- DestructiveReverse(FlatCopy(l));
Out> True;
In> lst := {a,b,c,d,e};
Out> {a,b,c,d,e};
In> reverse(lst);
Out> {e,d,c,b,a};
In> lst;
Out> {a,b,c,d,e};</PRE></TR>
</TABLE>

<A NAME="Contains">

</A>
<H3>
<HR>Contains -- Test whether a list contains a certain element
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Contains(list, expr)
<H5>
Parameters:
</H5>

list - list to examine <br>
expr - expression to look for in "list"
<H5>
Description:
</H5>

This command tests whether "list" contains the expression "expr"
as an entry. It returns <B><TT>True</TT></B> if it does and
<B><TT>False</TT></B> otherwise. Only the top level of "list" is
examined. The parameter "list" may also be a general expression, in
that case the top-level operands are tested for the occurence of
"expr".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Contains({a,b,c,d}, b);
Out> True;
In> Contains({a,b,c,d}, x);
Out> False;
In> Contains({a,{1,2,3},z}, 1);
Out> False;
In> Contains(a*b, b);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Find" TARGET="Chapters">
Find
</A>
, <A HREF="ref.html#Count" TARGET="Chapters">
Count
</A>
.<A NAME="Find">

</A>
<H3>
<HR>Find -- The index at which a certain element occurs
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Find(list, expr)
<H5>
Parameters:
</H5>

list - the list to examine <br>
expr - expression to look for in "list"
<H5>
Description:
</H5>

This commands returns the index at which the expression "expr"
occurs in "list". If "expr" occurs more than once, the lowest
index is returned. If "expr" does not occur at all,
<B><TT>-1</TT></B> is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Find({a,b,c,d,e,f}, d);
Out> 4;
In> Find({1,2,3,2,1}, 2);
Out> 2;
In> Find({1,2,3,2,1}, 4);
Out> -1;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Contains" TARGET="Chapters">
Contains
</A>
.<A NAME="Append">

</A>
<H3>
<HR>Append -- Append an entry at the end of a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Append(list, expr)
<H5>
Parameters:
</H5>

list - list to append "expr" to <br>
expr - expression to append to the list
<H5>
Description:
</H5>

The expression "expr" is appended at the end of "list" and the
resulting list is returned. 
<p> </p>
Note that due to the underlying data structure, the time it takes to
append an entry at the end of a list grows linearly with the length of
the list, while the time for prepending an entry at the beginning is
constant.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Append({a,b,c,d}, 1);
Out> {a,b,c,d,1};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Concat" TARGET="Chapters">
Concat
</A>
, <A HREF="ref.html#:" TARGET="Chapters">
:
</A>
, <A HREF="ref.html#DestructiveAppend" TARGET="Chapters">
DestructiveAppend
</A>
.<A NAME="DestructiveAppend">

</A>
<H3>
<HR>DestructiveAppend -- Destructively append an entry to a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DestructiveAppend(list, expr)
<H5>
Parameters:
</H5>

list - list to append "expr" to <br>
expr - expression to append to the list
<H5>
Description:
</H5>

This is the destructive counterpart of <B><TT>Append</TT></B>. This
command yields the same result as the corresponding call to
<B><TT>Append</TT></B>, but the original list is modified. So if a
variable is bound to "list", it will now be bound to the list with
the expression "expr" inserted.
<p> </p>
Destructive commands run faster than their nondestructive counterparts
because the latter copy the list before they alter it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d};
Out> {a,b,c,d};
In> Append(lst, 1);
Out> {a,b,c,d,1};
In> lst
Out> {a,b,c,d};
In> DestructiveAppend(lst, 1);
Out> {a,b,c,d,1};
In> lst;
Out> {a,b,c,d,1};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Concat" TARGET="Chapters">
Concat
</A>
, <A HREF="ref.html#:" TARGET="Chapters">
:
</A>
, <A HREF="ref.html#Append" TARGET="Chapters">
Append
</A>
.<A NAME="RemoveDuplicates">

</A>
<H3>
<HR>RemoveDuplicates -- Remove any duplicates from a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RemoveDuplicates(list)
<H5>
Parameters:
</H5>
list - list to act on
<H5>
Description:
</H5>

This command returns "list" after all duplicates are removed. To be
precise, the second occurence of any entry is deleted, as are the
third, the fourth, etcetera.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> RemoveDuplicates({1,2,3,2,1});
Out> {1,2,3};
In> RemoveDuplicates({a,1,b,1,c,1});
Out> {a,1,b,c};</PRE></TR>
</TABLE>

<A NAME="Push">

</A>
<H3>
<HR>Push -- Add an element on top of a stack
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Push(stack, expr)
<H5>
Parameters:
</H5>

stack - a stack (represented as a list) <br>
expr - expression to push on "stack"
<H5>
Description:
</H5>

This is part of a simple implementation of a stack, internally
represented as a list. This command pushes the expression "expr" on
top of the stack, and returns the stack afterwards.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> stack := {};
Out> {};
In> Push(stack, x);
Out> {x};
In> Push(stack, x2);
Out> {x2,x};
In> PopFront(stack);
Out> x2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Pop" TARGET="Chapters">
Pop
</A>
, <A HREF="ref.html#PopFront" TARGET="Chapters">
PopFront
</A>
, <A HREF="ref.html#PopBack" TARGET="Chapters">
PopBack
</A>
.<A NAME="Pop">

</A>
<H3>
<HR>Pop -- Remove an element from a stack
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Pop(stack, n)
<H5>
Parameters:
</H5>

stack - a stack (represented as a list) <br>
n - index of the element to remove
<H5>
Description:
</H5>

This is part of a simple implementation of a stack, internally
represented as a list. This command removes the element with index
"n" from the stack and returns this element. The top of the stack is
represented by the index 1. Invalid indices, for example indices
greater than the number of element on the stack, lead to an error.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> stack := {};
Out> {};
In> Push(stack, x);
Out> {x};
In> Push(stack, x2);
Out> {x2,x};
In> Push(stack, x3);
Out> {x3,x2,x};
In> Pop(stack, 2);
Out> x2;
In> stack;
Out> {x3,x};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Push" TARGET="Chapters">
Push
</A>
, <A HREF="ref.html#PopFront" TARGET="Chapters">
PopFront
</A>
, <A HREF="ref.html#PopBack" TARGET="Chapters">
PopBack
</A>
.<A NAME="PopFront">

</A>
<H3>
<HR>PopFront -- Remove an element from the top of a stack
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PopFront(stack)
<H5>
Parameters:
</H5>
stack - a stack (represented as a list)
<H5>
Description:
</H5>

This is part of a simple implementation of a stack, internally
represented as a list. This command removes the element on the top of
the stack and returns it. This is the last element that is pushed onto
the stack.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> stack := {};
Out> {};
In> Push(stack, x);
Out> {x};
In> Push(stack, x2);
Out> {x2,x};
In> Push(stack, x3);
Out> {x3,x2,x};
In> PopFront(stack);
Out> x3;
In> stack;
Out> {x2,x};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Push" TARGET="Chapters">
Push
</A>
, <A HREF="ref.html#Pop" TARGET="Chapters">
Pop
</A>
, <A HREF="ref.html#PopBack" TARGET="Chapters">
PopBack
</A>
.<A NAME="PopBack">

</A>
<H3>
<HR>PopBack -- Remove an element from the bottom of a stack
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PopBack(stack)
<H5>
Parameters:
</H5>
stack - a stack (represented as a list)
<H5>
Description:
</H5>

This is part of a simple implementation of a stack, internally
represented as a list. This command removes the element at the bottom
of the stack and returns this element. Of course, the stack should not
be empty.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> stack := {};
Out> {};
In> Push(stack, x);
Out> {x};
In> Push(stack, x2);
Out> {x2,x};
In> Push(stack, x3);
Out> {x3,x2,x};
In> PopBack(stack);
Out> x;
In> stack;
Out> {x3,x2};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Push" TARGET="Chapters">
Push
</A>
, <A HREF="ref.html#Pop" TARGET="Chapters">
Pop
</A>
, <A HREF="ref.html#PopFront" TARGET="Chapters">
PopFront
</A>
.<A NAME="Swap">

</A>
<H3>
<HR>Swap -- Swap two elements in a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Swap(list, i1, i2)
<H5>
Parameters:
</H5>

list - the list in which a pair of entries should be swapped <br>
i1, i2 - indices of the entries in "list" to swap
<H5>
Description:
</H5>

This command swaps the pair of entries with entries "i1" and "i2"
in "list". So the element at index "i1" ends up at index "i2"
and the entry at "i2" is put at index "i1". Both indices should be
valid to address elements in the list. Then the updated list is
returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d,e,f};
Out> {a,b,c,d,e,f};
In> Swap(lst, 2, 4);
Out> {a,d,c,b,e,f};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Replace" TARGET="Chapters">
Replace
</A>
, <A HREF="ref.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
.<A NAME="Count">

</A>
<H3>
<HR>Count -- Count the number of occurrences of an expression
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Count(list, expr)
<H5>
Parameters:
</H5>

list - the list to examine <br>
expr - expression to look for in "list"
<H5>
Description:
</H5>

This command counts the number of times that the expression "expr"
occurs in "list" and returns this number.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,b,a};
Out> {a,b,c,b,a};
In> Count(lst, a);
Out> 2;
In> Count(lst, c);
Out> 1;
In> Count(lst, x);
Out> 0;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
, <A HREF="ref.html#Select" TARGET="Chapters">
Select
</A>
, <A HREF="ref.html#Contains" TARGET="Chapters">
Contains
</A>
.<A NAME="Intersection">

</A>
<H3>
<HR>Intersection -- Return the intersection of two lists
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Intersection(l1, l2)
<H5>
Parameters:
</H5>
l1, l2 - two lists
<H5>
Description:
</H5>

The intersection of the lists "l1" and "l2" is determined and
returned. The intersection contains all elements that occur in both
lists. The entries in the result are listed in the same order as in
"l1". If an expression occurs multiple times in both "l1" and
"l2", then it will occur the same number of times in the result.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Intersection({a,b,c}, {b,c,d});
Out> {b,c};
In> Intersection({a,e,i,o,u}, {f,o,u,r,t,e,e,n});
Out> {e,o,u};
In> Intersection({1,2,2,3,3,3}, {1,1,2,2,3,3});
Out> {1,2,2,3,3};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Union" TARGET="Chapters">
Union
</A>
, <A HREF="ref.html#Difference" TARGET="Chapters">
Difference
</A>
.<A NAME="Union">

</A>
<H3>
<HR>Union -- Return the union of two lists
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Intersection(l1, l2)
<H5>
Parameters:
</H5>
l1, l2 - two lists
<H5>
Description:
</H5>

The union of the lists "l1" and "l2" is determined and
returned. The union contains all elements that occur in one or both of
the lists. In the resulting list, any element will occur only once.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Union({a,b,c}, {b,c,d});
Out> {a,b,c,d};
In> Union({a,e,i,o,u}, {f,o,u,r,t,e,e,n});
Out> {a,e,i,o,u,f,r,t,n};
In> Union({1,2,2,3,3,3}, {2,2,3,3,4,4});
Out> {1,2,3,4};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Intersection" TARGET="Chapters">
Intersection
</A>
, <A HREF="ref.html#Difference" TARGET="Chapters">
Difference
</A>
.<A NAME="Difference">

</A>
<H3>
<HR>Difference -- Return the difference of two lists
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Intersection(l1, l2)
<H5>
Parameters:
</H5>
l1, l2 - two lists
<H5>
Description:
</H5>

The difference of the lists "l1" and "l2" is determined and
returned. The difference contains all elements that occur in "l1"
but not in "l2". The order of elements in "l1" is preserved. If a
certain expression occurs "n1" times in the first list and "n2"
times in the second list, it will occur "n1-n2" times in the result
if "n1" is greater than "n2" and not at all otherwise.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Difference({a,b,c}, {b,c,d});
Out> {a};
In> Difference({a,e,i,o,u}, {f,o,u,r,t,e,e,n});
Out> {a,i};
In> Difference({1,2,2,3,3,3}, {2,2,3,4,4});
Out> {1,3,3};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Intersection" TARGET="Chapters">
Intersection
</A>
, <A HREF="ref.html#Union" TARGET="Chapters">
Union
</A>
.<A NAME="FillList">

</A>
<H3>
<HR>FillList -- Fill a list with a certain expression
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
FillList(expr, n)
<H5>
Parameters:
</H5>

expr - expression to fill the list with <br>
n - the length of the list to construct
<H5>
Description:
</H5>

This command creates a list of length "n" in which all slots contain
the expression "expr" and returns this list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FillList(x, 5);
Out> {x,x,x,x,x};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#MakeVector" TARGET="Chapters">
MakeVector
</A>
, <A HREF="ref.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
, <A HREF="ref.html#RandomIntegerVector" TARGET="Chapters">
RandomIntegerVector
</A>
.<A NAME="Drop">

</A>
<H3>
<HR>Drop -- Drop a range of elements from a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Drop(list, n) <br>
Drop(list, -n) <br>
Drop(list, {m,n})
<H5>
Parameters:
</H5>

list - list to act on <br>
n, m - positive integers describing the entries to drop
<H5>
Description:
</H5>

This command removes a sublist of "list" and returns a list
containing the remaining entries. The first calling sequence drops the
first "n" entries in "list". The second form drops the last "n"
entries. The last invocation drops the elements with indices "m"
through "n".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d,e,f,g};
Out> {a,b,c,d,e,f,g};
In> Drop(lst, 2);
Out> {c,d,e,f,g};
In> Drop(lst, -3);
Out> {a,b,c,d};
In> Drop(lst, {2,4});
Out> {a,e,f,g};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Take" TARGET="Chapters">
Take
</A>
, <A HREF="ref.html#Select" TARGET="Chapters">
Select
</A>
, <A HREF="ref.html#Remove" TARGET="Chapters">
Remove
</A>
.<A NAME="Take">

</A>
<H3>
<HR>Take -- Take a sublist from a list, dropping the rest
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Take(list, n) <br>
Take(list, -n) <br>
Take(list, {m,n})
<H5>
Parameters:
</H5>

list - list to act on <br>
n, m - positive integers describing the entries to drop
<H5>
Description:
</H5>

This command takes a sublist of "list", drops the rest, and returns
the selected sublist. The first calling sequence selects the first
"n" entries in "list". The second form takes the last "n"
entries. The last invocation selects the sublist beginning with entry
number "m" and ending with the "n"-th entry.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> lst := {a,b,c,d,e,f,g};
Out> {a,b,c,d,e,f,g};
In> Take(lst, 2);
Out> {a,b};
In> Take(lst, -3);
Out> {e,f,g};
In> Take(lst, {2,4});
Out> {b,c,d};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Drop" TARGET="Chapters">
Drop
</A>
, <A HREF="ref.html#Select" TARGET="Chapters">
Select
</A>
, <A HREF="ref.html#Remove" TARGET="Chapters">
Remove
</A>
.<A NAME="Partition">

</A>
<H3>
<HR>Partition -- Partition a list in sublists of equal length
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Partition(list, n)
<H5>
Parameters:
</H5>

list - list to partition <br>
n - length of partitions
<H5>
Description:
</H5>

This command partitions "list" into non-overlapping sublists of
length "n" and returns a list of these sublists. The first "n"
entries in "list" form the first partition, the entries from
position "n+1" upto "2n" form the second partition, and so on. If
"n" does not divide the length of "list", the remaining entries
will be thrown away. If "n" equals zero, an empty list is
returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Partition({a,b,c,d,e,f,}, 2);
Out> {{a,b},{c,d},{e,f}};
In> Partition(1 .. 11, 3);
Out> {{1,2,3},{4,5,6},{7,8,9}};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Take" TARGET="Chapters">
Take
</A>
, <A HREF="ref.html#Permutations" TARGET="Chapters">
Permutations
</A>
.<A NAME="Assoc">

</A>
<H3>
<HR>Assoc -- Return element stored in association list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Assoc(key, alist)
<H5>
Parameters:
</H5>

key - key under which element is stored <br>
alist - association list to examine
<H5>
Description:
</H5>

The association list "alist" is searched for an entry stored with
index "key". If such an entry is found, it is returned. Otherwise
the atom <B><TT>Empty</TT></B> is returned.
<p> </p>
Association lists are represented as a list of two-entry lists. The
first element in the two-entry list is the key, the second element is
the value stored under this key.
<p> </p>
The call <B><TT>Assoc(key, alist)</TT></B> can (probably more
intuitively) be accessed as <B><TT>alist[key]</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> writer := {};
Out> {};
In> writer["Iliad"] := "Homer";
Out> True;
In> writer["Henry IV"] := "Shakespeare";
Out> True;
In> writer["Ulysses"] := "James Joyce";
Out> True;
In> Assoc("Henry IV", writer);
Out> {"Henry IV","Shakespeare"};
In> Assoc("War and Peace", writer);
Out> Empty;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#AssocIndices" TARGET="Chapters">
AssocIndices
</A>
, <A HREF="ref.html#[]" TARGET="Chapters">
[]
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="AssocIndices">

</A>
<H3>
<HR>AssocIndices -- Return the keys in an association list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
AssocIndices(alist)
<H5>
Parameters:
</H5>
alist - association list to examine
<H5>
Description:
</H5>

All the keys in the association list "alist" are assembled in a list
and this list is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> writer := {};
Out> {};
In> writer["Iliad"] := "Homer";
Out> True;
In> writer["Henry IV"] := "Shakespeare";
Out> True;
In> writer["Ulysses"] := "James Joyce";
Out> True;
In> AssocIndices(writer);
Out> {"Iliad","Henry IV","Ulysses"};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Assoc" TARGET="Chapters">
Assoc
</A>
.<A NAME="Flatten">

</A>
<H3>
<HR>Flatten -- Flatten expression w.r.t. some operator
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Flatten(expression,operator)
<H5>
Parameters:
</H5>
expression - an expression <br>
 operator - string with the contents of an infix operator.

<H5>
Description:
</H5>
Flatten flattens an expression with respect to a specific
operator, converting the result into a list.
This is useful for unnesting an expression. Flatten is typically
used in simple simplification schemes.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Flatten(a+b*c+d,"+");
Out> {a,b*c,d};
In> Flatten({a,{b,c},d},"List");
Out> {a,b,c,d};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#UnFlatten" TARGET="Chapters">
UnFlatten
</A>
.<A NAME="UnFlatten">

</A>
<H3>
<HR>UnFlatten -- Inverse operation of Flatten
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
UnFlatten(list,operator,identity)
<H5>
Parameters:
</H5>
list - list of objects the operator is to work on <br>
 operator - infix operator <br>
 identity - identity of the operator

<H5>
Description:
</H5>
UnFlatten is the inverse operation of Flatten. Given
a list, it can be turned into an expression representing
for instance the addition of these elements by calling
UnFlatten with "+" as argument to operator, and 0 as
argument to identity (0 is the identity for addition, since
a+0=a). For multiplication the identity element would be 1.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> UnFlatten({a,b,c},"+",0)
Out> a+b+c;
In> UnFlatten({a,b,c},"*",1)
Out> a*b*c;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Flatten" TARGET="Chapters">
Flatten
</A>
.<A NAME="Type">

</A>
<H3>
<HR>Type -- Return the type of an expression
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Type(expr)
<H5>
Parameters:
</H5>
expr - expression to examine
<H5>
Description:
</H5>

The type of the expression "expr" is represented as a string and
returned. So, if "expr" is a list, the string <B><TT>"List"</TT></B> is returned. In general, the top-level
operator of "expr" is returned. If the argument "expr" is an atom,
the result is the empty string <B><TT>""</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Type({a,b,c});
Out> "List";
In> Type(a*(b+c));
Out> "*";
In> Type(123);
Out> "";</PRE></TR>
</TABLE>

<H5>
See Alsi:
</H5>
<A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="ref.html#NrArgs" TARGET="Chapters">
NrArgs
</A>
.<A NAME="NrArgs">

</A>
<H3>
<HR>NrArgs -- Return number of top-level arguments
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
NrArgs(expr)
<H5>
Parameters:
</H5>
expr - expression to examine
<H5>
Description:
</H5>

This function evaluates to the number of top-level arguments of the
expression "expr". The argument "expr" may not be an atom, since
that would lead to an error.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> NrArgs(f(a,b,c))
Out> 3;
In> NrArgs(Sin(x));
Out> 1;
In> NrArgs(a*(b+c));
Out> 2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Type" TARGET="Chapters">
Type
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
.<A NAME="BubbleSort">

</A>
<H3>
<HR>BubbleSort -- Sort a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
BubbleSort(list, fn)
<H5>
Parameters:
</H5>

list - list to sort <br>
fn - function used to compare element of "list"
<H5>
Description:
</H5>

This command returns "list" after it is sorted using "fn" to
compare elements. The function "fn" should accept two arguments,
which will be elements of "list", and compare them. It should return
<B><TT>True</TT></B> if in the sorted list the second argument
should come after the first one, and <B><TT>False</TT></B>
otherwise. 
<p> </p>
This function uses the so-called BubbleSort algorithm to do the
sorting. This algorithm is chosen because it is easy to implement,
though it is not particularly fast.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> BubbleSort({4,7,23,53,-2,1}, "<");
Out> {-2,1,4,7,23,53};
In> BubbleSort({4,7,23,53,-2,1}, ">");
Out> {53,23,7,4,1,-2};</PRE></TR>
</TABLE>

<A NAME="Table">

</A>
<H3>
<HR>Table -- Evaluate while some variable ranges over interval
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Table(body, var, from, to, step)
<H5>
Parameters:
</H5>

body - expression to evaluate multiple times <br>
var - variable to use as loop variable <br>
from - initial value for "var" <br>
to - final value for "var" <br>
step - step size with which "var" is incremented
<H5>
Description:
</H5>

This command generates a list of values from "body", by assigning
variable "var" values from "from" upto "to", incrementing
"step" each time. So, the variable "var" first gets the value
"from", and the expression "body" is evaluated. Then the value
"from"+"step" is assigned to "var" and the expression "body"
is again evaluated. This continues, incrementing "var" with "step"
on every iteration, until "var" exceeds "to". At that moment, all
the results are assembled in a list and this list is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Table(i!, i, 1, 10, 1);
Out> {1,2,6,24,120,720,5040,40320,362880,3628800};
In> Table(i, i, 3, 16, 4);
Out> {3,7,11,15};
In> Table(i^2, i, 10, 1, -1);
Out> {100,81,64,49,36,25,16,9,4,1};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#For" TARGET="Chapters">
For
</A>
, <A HREF="ref.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="ref.html#.." TARGET="Chapters">
..
</A>
, <A HREF="ref.html#TableForm" TARGET="Chapters">
TableForm
</A>
.<A NAME="TableForm">

</A>
<H3>
<HR>TableForm -- Print each entry in a list on a line
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
TableForm(list)
<H5>
Parameters:
</H5>
list - list to print
<H5>
Description:
</H5>

This functions writes out "list" in a nicer readable form, by
printing every element in the list on a seperate line.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> TableForm(Table(i!, i, 1, 10, 1));
1
 2
 6
 24
 120
 720
 5040
 40320
 362880
 3628800
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Table" TARGET="Chapters">
Table
</A>
.<p>  </P><HR><A NAME="c8">

</A>
<A HREF="refchapter8.html#:" TARGET="Chapters">
:
</A>
, <A HREF="refchapter8.html#@" TARGET="Chapters">
@
</A>
, <A HREF="refchapter8.html#/@" TARGET="Chapters">
/@
</A>
, <A HREF="refchapter8.html#.." TARGET="Chapters">
..
</A>
.
<H1>
Functional operators
</H1>

These operators can help the user to program in the style of
functional programming languages like Miranda and Haskell.
<A NAME=":">

</A>
<H3>
<HR>: -- Prepend item to list, or concatenate strings
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
item : list (prec. 7) <br>
string1 : string2 (prec. 7)
<H5>
Parameters:
</H5>
item - an item to be prepended to a list <br>
list - a list <br>
string1 - a string <br>
string2 - a string 

<H5>
Description:
</H5>
The first form prepends "item" as the first entry to the list
"list". The second form concatenates the strings "string1" and
"string2".
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> a:b:c:{}
Out> {a,b,c};
In> "This":"Is":"A":"String"
Out> "ThisIsAString";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Concat" TARGET="Chapters">
Concat
</A>
, <A HREF="ref.html#ConcatStrings" TARGET="Chapters">
ConcatStrings
</A>
.<A NAME="@">

</A>
<H3>
<HR>@ -- Apply a function
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
fn @ arglist (prec. 60)
<H5>
Parameters:
</H5>
fn - function to apply <br>
arglist - single argument, or a list of arguments
<H5>
Description:
</H5>

This function is a shorthand for <B><TT>Apply</TT></B>. It applies the
function "fn" to the argument(s) in "arglist" and returns the
result. The first parameter "fn" can either be a string containing
the name of a function or a pure function.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> "Sin" @ a
Out> Sin(a);
In> {{a},Sin(a)} @ a
Out> Sin(a);
In> "f" @ {a,b}
Out> f(a,b);
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Apply" TARGET="Chapters">
Apply
</A>
.<A NAME="/@">

</A>
<H3>
<HR>/@ -- Apply a function to all entries in a list
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
fn /@ list (prec. 60)
<H5>
Parameters:
</H5>
fn - function to apply <br>
list - list of arguments
<H5>
Description:
</H5>

This function is a shorthand for <B><TT>MapSingle</TT></B>. It
successively applies the function "fn" to all the entries in
"list" and returns a list contains the results. The parameter "fn"
can either be a string containing the name of a function or a pure
function.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> "Sin" /@ {a,b}
Out> {Sin(a),Sin(b)};
In> {{a},Sin(a)*a} /@ {a,b}
Out> {Sin(a)*a,Sin(b)*b};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="ref.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="ref.html#MapArgs" TARGET="Chapters">
MapArgs
</A>
.<A NAME="..">

</A>
<H3>
<HR>.. -- Construct a list of consecutive integers
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
n .. m (prec. 60)
<H5>
Parameters:
</H5>
n - integer. the first entry in the list <br>
m - integer, the last entry in the list 

<H5>
Description:
</H5>
This command returns the list "{n, n+1, n+2, ..., m}". If "m" is
smaller than "n", the empty list is returned. Note that the
<B><TT>..</TT></B> operator should be surrounded by spaces to keep the
parser happy, if "n" is a number. So one should write <B><TT>1
.. 4</TT></B> instead of <B><TT>1..4</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 1 .. 4
Out> {1,2,3,4};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Table" TARGET="Chapters">
Table
</A>
.<p>  </P><HR><A NAME="c9">

</A>
<A HREF="refchapter9.html#MaxEvalDepth" TARGET="Chapters">
MaxEvalDepth
</A>
, <A HREF="refchapter9.html#Hold" TARGET="Chapters">
Hold
</A>
, <A HREF="refchapter9.html#Eval" TARGET="Chapters">
Eval
</A>
, <A HREF="refchapter9.html#While" TARGET="Chapters">
While
</A>
, <A HREF="refchapter9.html#Until" TARGET="Chapters">
Until
</A>
, <A HREF="refchapter9.html#If" TARGET="Chapters">
If
</A>
, <A HREF="refchapter9.html#SystemCall" TARGET="Chapters">
SystemCall
</A>
, <A HREF="refchapter9.html#Function" TARGET="Chapters">
Function
</A>
, <A HREF="refchapter9.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="refchapter9.html#For" TARGET="Chapters">
For
</A>
, <A HREF="refchapter9.html#ForEach" TARGET="Chapters">
ForEach
</A>
, <A HREF="refchapter9.html#Apply" TARGET="Chapters">
Apply
</A>
, <A HREF="refchapter9.html#MagArgs" TARGET="Chapters">
MagArgs
</A>
, <A HREF="refchapter9.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="refchapter9.html#WithValue" TARGET="Chapters">
WithValue
</A>
, <A HREF="refchapter9.html#/:, /::" TARGET="Chapters">
/:, /::
</A>
, <A HREF="refchapter9.html#SetHelpBrowser" TARGET="Chapters">
SetHelpBrowser
</A>
, <A HREF="refchapter9.html#TraceStack" TARGET="Chapters">
TraceStack
</A>
, <A HREF="refchapter9.html#TraceExp" TARGET="Chapters">
TraceExp
</A>
, <A HREF="refchapter9.html#TraceRule" TARGET="Chapters">
TraceRule
</A>
.
<H1>
Control flow functions
</H1>
<A NAME="MaxEvalDepth">

</A>
<H3>
<HR>MaxEvalDepth -- Set the maximum evaluation depth
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
MaxEvalDepth(n)
<H5>
Parameters:
</H5>
n - new maximum evalution depth
<H5>
Description:
</H5>

Use this command to set the maximum evaluation depth to the integer
"n". The default value is 1000. The function <B><TT>MaxEvalDepth</TT></B> returns <B><TT>True</TT></B>.
<p> </p>
The point of having a maximum evaluation depth is to catch any
infinite recursion. For example, after the definition <B><TT>f(x) := f(x)</TT></B>, evaluating the expression <B><TT>f(x)</TT></B> would call <B><TT>f(x)</TT></B>, which would
call <B><TT>f(x)</TT></B>, etcetera. The interpreter will halt if
the maximum evaluation depth is reached. Also indirect recursion, like
the pair of definitions <B><TT>f(x) := g(x)</TT></B> and <B><TT>g(x) := f(x)</TT></B>, will be caught.
<H5>
Examples:
</H5>

An example of an infinite recursion, caught because the maximum
evaluation depth is reached.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(x) := f(x)
Out> True;
In> f(x)
Error on line 1 in file [CommandLine]
Max evaluation stack depth reached.
Please use MaxEvalDepth to increase the stack size as needed.</PRE></TR>
</TABLE>
<p> </p>
However, a long calculation may cause the maximum evaluation depth to
be reached without the presence of infinite recursion. The function <B><TT>MaxEvalDepth</TT></B> is meant for these cases. <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 10 # g(0) <-- 1;
Out> True;
In> 20 # g(n_IsPositiveInteger) <-- 2 * g(n-1);
Out> True;
In> g(1001);
Error on line 1 in file [CommandLine]
Max evaluation stack depth reached.
Please use MaxEvalDepth to increase the stack size as needed.

In> MaxEvalDepth(10000);
Out> True;
In> g(1001);
Out> 214301721437253464189685009812000362112280962341106721488750077674070210224
98722449863967576313917162551893458351062936503742905713846280871969155149397149
60786913554964846197084214921012474228375590836430609294996716388253479753511833
1087892154125829142392955373084335320859663305248773674411336138752;</PRE></TR>
</TABLE>

<A NAME="Hold">

</A>
<H3>
<HR>Hold -- Do not evaluate the argument
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Hold(expr)
<H5>
Parameters:
</H5>
expr - expression to hold
<H5>
Description:
</H5>

The expression "expr" is returned unevaluated. This is useful to
prevent the evaluation of a certain expression in a context in which
evaluation normally takes place.
<H5>
Example:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Echo({ Hold(1+1), "=", 1+1 });
 1+1 = 2 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Eval" TARGET="Chapters">
Eval
</A>
, <A HREF="ref.html#HoldArg" TARGET="Chapters">
HoldArg
</A>
.<A NAME="Eval">

</A>
<H3>
<HR>Eval -- Evaluate the argument
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Eval(expr)
<H5>
Parameters:
</H5>
expr - expression to evaluate
<H5>
Description:
</H5>

This function explicitly requests an evaluation of the expression
"expr", and returns the result of this evaluation.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a := x;
Out> x;
In> x := 5;
Out> 5;
In> a;
Out> x;
In> Eval(a);
Out> 5;</PRE></TR>
</TABLE>

The variable <B><TT>a</TT></B> is bound to <B><TT>x</TT></B>,
and <B><TT>x</TT></B> is bound to 5. Hence evaluating <B><TT>a</TT></B> will give <B><TT>x</TT></B>. Only when an extra
evaluation of <B><TT>a</TT></B> is requested, the value 5 is
returned.
<p> </p>
Note that the behaviour would be different if we had exchanged the
assignments. If the assignment <B><TT>a := x</TT></B> were given
while <B><TT>x</TT></B> had the value 5, the variable <B><TT>a</TT></B> would also get the value 5 because the assignment
operator <B><TT>:=</TT></B> evaluates the right-hand side.
<H5>
See Also:
</H5>
<A HREF="ref.html#Hold" TARGET="Chapters">
Hold
</A>
, <A HREF="ref.html#HoldArg" TARGET="Chapters">
HoldArg
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="While">

</A>
<H3>
<HR>While -- Loop while a condition is met
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
While(pred) body
<H5>
Parameters:
</H5>

pred - predicate deciding whether to keep on looping <br>
body - expression to loop over
<H5>
Description:
</H5>

Keep on evaluating "body" while "pred" evaluates to <B><TT>True</TT></B>. More precisely, <B><TT>While</TT></B>
evaluates the predicate "pred", which should evaluate to either <B><TT>True</TT></B> or <B><TT>False</TT></B>. If the result is <B><TT>True</TT></B>, the expression "body" is evaluated and then
the predicate "pred" is again evaluated. If it is still <B><TT>True</TT></B>, the expressions "body" and "pred" are again
evaluated and so on until "pred" evaluates to <B><TT>False</TT></B>. At that point, the loop terminates and <B><TT>While</TT></B>
returns <B><TT>True</TT></B>.
<p> </p>
In particular, if "pred" immediately evaluates to <B><TT>False</TT></B>, the body is never executed. <B><TT>While</TT></B> is the fundamental looping construct on which
all other loop commands are based. It is equivalent to the <B><TT>while</TT></B> command in the programming language C.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> x := 0;
Out> 0;
In> While (x! < 10^6) [ Echo({x, x!}); x++; ];
 0  1 
 1  1 
 2  2 
 3  6 
 4  24 
 5  120 
 6  720 
 7  5040 
 8  40320 
 9  362880 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Until" TARGET="Chapters">
Until
</A>
, <A HREF="ref.html#For" TARGET="Chapters">
For
</A>
.<A NAME="Until">

</A>
<H3>
<HR>Until -- Loop until a condition is met
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Until(pred) body
<H5>
Parameters:
</H5>

pred - predicate deciding whether to stop <br>
body - expression to loop over
<H5>
Description:
</H5>

Keep on evaluating "body" until "pred" becomes <B><TT>True</TT></B>. More precisely, <B><TT>Until</TT></B> first
evaluates the expression "body". Then the predicate "pred" is
evaluated, which should yield either <B><TT>True</TT></B> or <B><TT>False</TT></B>. In the latter case, the expressions "body"
and "pred" are again evaluated and this continues as long as
"pred" is <B><TT>False</TT></B>. As soon as "pred" yields <B><TT>True</TT></B>, the loop terminates and <B><TT>Until</TT></B> returns <B><TT>True</TT></B>.
<p> </p>
The main difference with <B><TT>While</TT></B> is that <B><TT>Until</TT></B> always evaluates the body at least once, but <B><TT>While</TT></B> may not evaluate the body at all. Besides, the
meaning of the predicate is reversed: <B><TT>While</TT></B> stops
if "pred" is <B><TT>False</TT></B> while <B><TT>Until</TT></B> stops if "pred" is <B><TT>True</TT></B>.  <p> </p> The command
<B><TT>Until(pred) body;</TT></B> is equivalent to <B><TT>pred; While(Not pred) body;</TT></B>. In fact, the
implementation of <B><TT>Until</TT></B> is based on the internal
command <B><TT>While</TT></B>. The <B><TT>Until</TT></B>
command can be compared to the <B><TT>do ... while</TT></B>
construct in the programming language C.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> x := 0;
Out> 0;
In> Until (x! > 10^6) [ Echo({x, x!}); x++; ];
 0  1 
 1  1 
 2  2 
 3  6 
 4  24 
 5  120 
 6  720 
 7  5040 
 8  40320 
 9  362880 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#While" TARGET="Chapters">
While
</A>
, <A HREF="ref.html#For" TARGET="Chapters">
For
</A>
.<A NAME="If">

</A>
<H3>
<HR>If -- Branch point
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>

If(pred, then) <br>
If(pred, then, else)
<H5>
Parameters:
</H5>

pred - predicate to test <br>
then - expression to evaluate if "pred" is True <br>
else - expression to evaluate if "pred" is False
<H5>
Description:
</H5>

This command implements a branch point. The predicate "pred" is
evaluated, which should result in either <B><TT>True</TT></B> or <B><TT>False</TT></B>. In the first case, the expression "then" is
evaluated and returned. If the predicate yields <B><TT>False</TT></B>, the expression "else" (if present) is evaluated and
returned. If there is no "else" branch (ie. if the first calling
sequence is used), the <B><TT>If</TT></B> expression returns <B><TT>False</TT></B>.
<H5>
Examples:
</H5>

The sign function is defined to be 1 if its argument is positive and
-1 if its argument is negative. A possible implementation is <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> mysign(x) := If (IsPositiveReal(x), 1, -1); 
Out> True;
In> mysign(Pi);
Out> 1;
In> mysign(-2.5);
Out> -1;</PRE></TR>
</TABLE>

Note that this will give incorrect results, if "x" cannot be
numerically approximated.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> mysign(a);
Out> -1;</PRE></TR>
</TABLE>

Hence a better implementation would be<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> mysign(_x)_IsNumber(N(x)) <-- If (IsPositiveReal(x), 1, -1);
Out> True;</PRE></TR>
</TABLE>

<A NAME="SystemCall">

</A>
<H3>
<HR>SystemCall -- Pass a command to the shell
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
SystemCall(str)
<H5>
Parameters:
</H5>
str - string containing the command to call
<H5>
Description:
</H5>

The command contained in the string "str" is executed by the
underlying Operating System. The return value of <B><TT>SystemCall</TT></B> is <B><TT>True</TT></B>.
<p> </p>
This command is not allowed in the body of the <B><TT>Secure</TT></B> command and will lead to an error.
<H5>
Examples:
</H5>

In a UNIX environment, the command <B><TT>SystemCall("ls")</TT></B> would list the contents of the current directory.
<H5>
See Also:
</H5>
<A HREF="ref.html#Secure" TARGET="Chapters">
Secure
</A>
.<A NAME="Function">

</A>
<H3>
<HR>Function -- Define a function
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Function("op", {arg,...}) body
<H5>
Parameters:
</H5>

op - name of the function <br>
arg - formal argument to the function <br>
body - expression compromising the body of the function
<H5>
Description:
</H5>

This command can be used to declare a simple function. It is
equivalent to the rule <B><TT>op(_arg, ...) <-- body</TT></B>. Any
previous rules associated with "op" (with the same arity) will be
discarded. More complicated function can be defined using a rule
database.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Function("FirstOf", {list})  list[1];
Out> True;
In> FirstOf({a,b,c});
Out> a;</PRE></TR>
</TABLE>

This defines a function <B><TT>FirstOf</TT></B> which returns the
first element of a list. Equivalent definitions would be <B><TT>FirstOf(_list) <-- list[1]</TT></B> or <B><TT>FirstOf(list) := list[1]</TT></B>.
<H5>
See Also:
</H5>
<A HREF="ref.html#TemplateFunction" TARGET="Chapters">
TemplateFunction
</A>
, <A HREF="ref.html#Rule" TARGET="Chapters">
Rule
</A>
, <A HREF="ref.html#RuleBase" TARGET="Chapters">
RuleBase
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="Use">

</A>
<H3>
<HR>Use -- Load a file, but not twice
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Use(name)
<H5>
Parameters:
</H5>
name - name of the file to load
<H5>
Description:
</H5>

If the file "name" has been loaded before, either by an earlier call
to <B><TT>Use</TT></B> or via the <B><TT>DefLoad</TT></B>
mechanism, nothing happens. Otherwise all expressions in the file are
read and evaluated. <B><TT>Use</TT></B> always returns <B><TT>True</TT></B>.
<P> </P>
The purpose of this function is to make sure that the file will at
least have been loaded, but is not loaded twice.
<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="ref.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
.<A NAME="For">

</A>
<H3>
<HR>For -- C-style for loop
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
For(init, pred, incr) body
<H5>
Parameters:
</H5>

init - expression for performing the initialization <br>
pred - predicate deciding whether to continue the loop <br>
incr - expression to increment the counter <br>
body - expression to loop over
<H5>
Description:
</H5>

This commands implements a C style <B><TT>for</TT></B> loop. First
of all, the expression "init" is evaluated. Then the predicate
"pred" is evaluated, which should return <B><TT>True</TT></B> or
<B><TT>False</TT></B>. Next the loop is executed as long as the
predicate yields <B><TT>True</TT></B>. One traversion of the loop
consists of the subsequent evaluations of "body", "incr", and
"pred". Finally, the value <B><TT>True</TT></B> is returned.
<p> </p>
This command is most often used in a form like <B><TT>For(i=1,
i<=10, i++) body</TT></B>, which evaluates <B><TT>body</TT></B> with
<B><TT>i</TT></B> subsequently set to 1, 2, 3, 4, 5, 6, 7, 8, 9,
and 10.
<p> </p>
The expression <B><TT>For(init, pred, incr) body</TT></B> is
equivalent to <B><TT>init; While(pred) [body; incr;]</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> For (i:=1, i<=10, i++) Echo({i, i!});
 1  1 
 2  2 
 3  6 
 4  24 
 5  120 
 6  720 
 7  5040 
 8  40320 
 9  362880 
 10  3628800 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#While" TARGET="Chapters">
While
</A>
, <A HREF="ref.html#Until" TARGET="Chapters">
Until
</A>
, <A HREF="ref.html#ForEach" TARGET="Chapters">
ForEach
</A>
.<A NAME="ForEach">

</A>
<H3>
<HR>ForEach -- Loop over all entries in list
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
ForEach(var, list) body
<H5>
Parameters:
</H5>

var - looping variable <br>
list - list of values to assign to "var" <br>
body - expression to evaluate with different values of "var"
<H5>
Description:
</H5>

The expression "body" is evaluated multiple times. The first time,
"var" has the value of the first element of "list", then it gets
the value of the second element and so on. <B><TT>ForEach</TT></B>
returns <B><TT>True</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
 In> ForEach(i,{2,3,5,7,11}) Echo({i, i!});
 2  2 
 3  6 
 5  120 
 7  5040 
 11  39916800 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#For" TARGET="Chapters">
For
</A>
.<A NAME="Apply">

</A>
<H3>
<HR>Apply -- Apply a function
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>
Apply(fn, arglist)
<H5>
Parameters:
</H5>

fn - function to apply <br>
arglist - list of arguments
<H5>
Description:
</H5>

This function applies the function "fn" to the arguments in
"arglist" and returns the result. The first parameter "fn" can
either be a string containing the name of a function  or a pure
function. Pure functions, modelled after lambda-expressions, have the
form "{varlist,body}", where "varlist" is the list of formal
parameters. Upon application, the formal paramaters are assigned the
values in "arglist" (the second parameter of <B><TT>Apply</TT></B>) and the "body" is evaluated
<p> </p>
An shorthand for <B><TT>Apply</TT></B> is provided by the <B><TT>@</TT></B> operator.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Apply("+", {5,9});
Out> 14;
In> Apply({{x,y}, x-y^2}, {Cos(a), Sin(a)});
Out> Cos(a)-Sin(a)^2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="ref.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="ref.html#@" TARGET="Chapters">
@
</A>
.<A NAME="MagArgs">

</A>
<H3>
<HR>MagArgs -- Apply a function to all top-level arguments
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
MapArgs(expr, fn)
<H5>
Parameters:
</H5>
expr - an expression to work on <br>
fn - an operation to perform on each argument
<H5>
Description:
</H5>

Every top-level argument in "expr" is substituted by the result of
applying "fn" to this argument. Here "fn" can be either the name
of a function or a pure function.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> MapArgs(f(x,y,z),"Sin");
Out> f(Sin(x),Sin(y),Sin(z));
In> MapArgs({3,4,5,6}, {{x},x^2});
Out> {9,16,25,36};</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="ref.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="ref.html#Apply" TARGET="Chapters">
Apply
</A>
.<A NAME="Subst">

</A>
<H3>
<HR>Subst -- Perform a substitution
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Subst(from, to) expr
<H5>
Parameters:
</H5>

from - expression to be substituted <br>
to - expression to substitute for "from" <br>
expr - expression in which the substitution takes place
<H5>
Description:
</H5>

This function substitutes every occurence of "from" in "expr" by
"to". This is a syntactical substitution: only places where "from"
occurs as a subexpression are affected.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Subst(x, Sin(y)) x^2+x+1;
Out> Sin(y)^2+Sin(y)+1;
In> Subst(a+b, x) a+b+c;
Out> x+c;
In> Subst(b+c, x) a+b+c;
Out> a+b+c;</PRE></TR>
</TABLE>

The explanation for the last result is that the expression <B><TT>a+b+c</TT></B> is internally stored as <B><TT>(a+b)+c</TT></B>. Hence <B><TT>a+b</TT></B> is a subexpression, but <B><TT>b+c</TT></B> is not.
<H5>
See Also:
</H5>
<A HREF="ref.html#WithValue" TARGET="Chapters">
WithValue
</A>
, <A HREF="ref.html#/:" TARGET="Chapters">
/:
</A>
.<A NAME="WithValue">

</A>
<H3>
<HR>WithValue -- Temporary assignment during an evaluation
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

WithValue(var, val, expr) <br>
WithValue({var,...}, {val,...}, expr)
<H5>
Parameters:
</H5>

var - variable to assign to <br>
val - value to be assigned to "var" <br>
expr - expression to evaluate with "var" equal to "val"
<H5>
Description:
</H5>

First, the expression "val" is assigned to the variable
"var". Then, the expression "expr" is evaluated and
returned. Finally, the assignment is reversed so that the variable 
"var" has the same value as it had before <B><TT>WithValue</TT></B> was evaluated.
<p> </p>
The second calling sequence assigns the first element in the list of
values to the first element in the list of variables, the second value
to the second variable, etcetera.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> WithValue(x, 3, x^2+y^2+1);
Out> y^2+10;
In> WithValue({x,y}, {3,2}, x^2+y^2+1);
Out> 14;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="ref.html#/:" TARGET="Chapters">
/:
</A>
.<A NAME="/:">

</A>
<A NAME="/::">

</A>
<A NAME="/:, /::">

</A>
<H3>
<HR>/:, /:: -- Local simplification rules
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

expression /: patterns (prec. 10000) <br>
expressions /:: patterns (prec. 10000)
<H5>
Parameters:
</H5>
expression - an expression <br>
patterns - a list of patterns
<H5>
Description:
</H5>
Sometimes you have an expression, and you want to use specific
simplification rules on it that are not done by default. This
can be done with the /: and the /:: operators. Suppose we have the
expression containing things like <B><TT>Ln(a*b)</TT></B>, and we want
to change these into <B><TT>Ln(a)+Ln(b)</TT></B>, the easiest way
to do this is using the /: operator, as follows:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(x)*Ln(a*b)
Out> Sin(x)*Ln(a*b);
In> % /: { Ln(_x*_y) <- Ln(x)+Ln(y) }
Out> Sin(x)*(Ln(a)+Ln(b));
</PRE></TR>
</TABLE>

A whole list of simplification rules can be built up in the list,
and they will be applied to the expression on the left hand side
of /: .
<P>

The forms the patterns can have are one of:

<P>
pattern <- replacement
<P>
{pattern,replacement}
<P>
{pattern,postpredicate,replacement} 
<P>
Note that for these local rules, <- should be used in stead of
<-- which defines a global rule.
<P>

The /: operator traverses an expression much like Subst does: top
down, trying to apply the rules from the begin of the list of
rules to the end of the list of rules. If the rules cannot be applied
to a sub-expression, it will try the sub expressions of the
expression being analyzed.
<P>
It might be necessary sometimes to use the /:: operator, which
repeatedly applies the /: operator until the result doesn't change
any more. Caution is required, since rules can contradict eachother,
and that could result in an infinite loop. To detect this situation,
just use /: repeatedly on the expression. The repetitive nature
should become apparent.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(u)*Ln(a*b) /: { Ln(_x*_y) <- Ln(x)+Ln(y) }
Out> Sin(u)*(Ln(a)+Ln(b));
In> Sin(u)*Ln(a*b) /:: { a <- 2, b <- 3 }
Out> Sin(u)*Ln(6);
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Subst" TARGET="Chapters">
Subst
</A>
.<A NAME="SetHelpBrowser">

</A>
<H3>
<HR>SetHelpBrowser -- Set the HTML browser to use for help
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
SetHelpBrowser(helpbrowser)
<H5>
Parameters:
</H5>
helpbrowser - string containing a html browser to use for help
<H5>
Description:
</H5>
This function sets the help browser you want to use to
browse the help online. It calls helpbrowser with the html
page as first argument. The default is lynx. If you want to
use a different browser by default it suffices to create a
file ~/.yacasrc. and add a line to set the browser in there.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> SetHelpBrowser("netscape")
Out> "netscape";
In> ??
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Help" TARGET="Chapters">
Help
</A>
.<A NAME="TraceStack">

</A>
<H3>
<HR>TraceStack -- Show calling stack after an error occurs
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
TraceStack(expression)
<H5>
Parameters:
</H5>
expression - an expression to evaluate
<H5>
Description:
</H5>
TraceStack shows the calling stack after an error occurred.
It shows the last few items on the stack, not to flood the screen.
These are usually the only items of interest on the stack.
This is probably by far the most useful debugging function in
Yacas. It shows the last few things it did just after an error
was generated somewhere.
<P>  </P>
For each stack frame, it shows if the function evaluated was a
built-in function or a user-defined function, and for the user-defined
function, the number of the rule it is trying whether it was evaluating
the pattern matcher of the rule, or the body code of the rule.
<P>  </P>
This functionality is not offered by default because it slows
down the evaluation code.


<H5>
Examples:
</H5>
Here is an example of a function calling itself recursively,
causing Yacas to flood its stack:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> f(x):=f(Sin(x))
Out> True;
In> TraceStack(f(2))
Debug> 982 :  f (Rule # 0 in body)
Debug> 983 :  f (Rule # 0 in body)
Debug> 984 :  f (Rule # 0 in body)
Debug> 985 :  f (Rule # 0 in body)
Debug> 986 :  f (Rule # 0 in body)
Debug> 987 :  f (Rule # 0 in body)
Debug> 988 :  f (Rule # 0 in body)
Debug> 989 :  f (Rule # 0 in body)
Debug> 990 :  f (Rule # 0 in body)
Debug> 991 :  f (Rule # 0 in body)
Debug> 992 :  f (Rule # 0 in body)
Debug> 993 :  f (Rule # 0 in body)
Debug> 994 :  f (Rule # 0 in body)
Debug> 995 :  f (User function)
Debug> 996 :  Sin (Rule # 0 in pattern)
Debug> 997 :  IsList (Internal function)
Error on line 1 in file [CommandLine]
Max evaluation stack depth reached.
Please use MaxEvalDepth to increase the stack size as needed.
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#TraceExp" TARGET="Chapters">
TraceExp
</A>
, <A HREF="ref.html#TraceRule" TARGET="Chapters">
TraceRule
</A>
.<A NAME="TraceExp">

</A>
<H3>
<HR>TraceExp -- Evaluate with tracing enabled
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
TraceExp(expr)
<H5>
Parameters:
</H5>
expr - expression to trace
<H5>
Description:
</H5>

The expression "expr" is evaluated with the tracing facility turned
on. This means that every subexpression, which is evaluated, is shown
before and after evaluation. Before evaluation, it is shown in the
forn <B><TT>TrEnter(x)</TT></B>, where <B><TT>x</TT></B>
denotes the subexpression being evaluated. After the evaluation the
line <B><TT>TrLeave(x,y)</TT></B> is printed, where <B><TT>y</TT></B> is the result of the evaluation. The indentation
shows the nesting level.
<p> </p>
Note that this command usually generates huge amounts of output. A
more specific form of tracing (eg. <B><TT>TraceRule</TT></B>) is
probably more useful  for all but very simple expressions.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> TraceExp(2+3);
  TrEnter(2+3);
    TrEnter(2);
    TrLeave(2, 2);
    TrEnter(3);
    TrLeave(3, 3);
    TrEnter(IsNumber(x));
      TrEnter(x);
      TrLeave(x, 2);
    TrLeave(IsNumber(x),True);
    TrEnter(IsNumber(y));
      TrEnter(y);
      TrLeave(y, 3);
    TrLeave(IsNumber(y),True);
    TrEnter(True);
    TrLeave(True, True);
    TrEnter(MathAdd(x,y));
      TrEnter(x);
      TrLeave(x, 2);
      TrEnter(y);
      TrLeave(y, 3);
    TrLeave(MathAdd(x,y),5);
  TrLeave(2+3, 5);
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#TraceStack" TARGET="Chapters">
TraceStack
</A>
, <A HREF="ref.html#TraceRule" TARGET="Chapters">
TraceRule
</A>
.<A NAME="TraceRule">

</A>
<H3>
<HR>TraceRule -- Turn on tracing for a particular function
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
TraceRule(templ) expr
<H5>
Parameters:
</H5>

templ - template showing the operator to trace <br>
expr - expression to evaluate with tracing on
<H5>
Description:
</H5>

The tracing facility is turned on for subexpressions of the form
"templ", and the expression "expr" is evaluated. The template
"templ" is an example of the function to trace on. Specifically, all
subexpressions with the same top-level operator and arity as "templ"
are showed. The subexpressions are displayed before (indicated with <B><TT>TrEnter</TT></B>) and after (<B><TT>TrLeave</TT></B>)
evaluation. In between, the arguments are showed before and after
evaluation (<B><TT>TrArg</TT></B>). Only function defined in
scripts can be traced.
<P>  </P>
This is useful for tracing a function that is called from within
another function. This way you can see how your function behaves
in the environment it is used in.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> TraceRule(x+y) 2+3*5+4;
    TrEnter(2+3*5+4);
      TrEnter(2+3*5);
          TrArg(2, 2);
          TrArg(3*5, 15);
      TrLeave(2+3*5, 17);
        TrArg(2+3*5, 17);
        TrArg(4, 4);
    TrLeave(2+3*5+4, 21);
Out> 21;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#TraceStack" TARGET="Chapters">
TraceStack
</A>
, <A HREF="ref.html#TraceExp" TARGET="Chapters">
TraceExp
</A>
.<p>  </P><HR><A NAME="c10">

</A>
<A HREF="refchapter10.html#&lt;" TARGET="Chapters">
&lt;
</A>
, <A HREF="refchapter10.html#&gt;" TARGET="Chapters">
&gt;
</A>
, <A HREF="refchapter10.html#&lt;=" TARGET="Chapters">
&lt;=
</A>
, <A HREF="refchapter10.html#&gt;=" TARGET="Chapters">
&gt;=
</A>
, <A HREF="refchapter10.html#!=" TARGET="Chapters">
!=
</A>
, <A HREF="refchapter10.html#=" TARGET="Chapters">
=
</A>
, <A HREF="refchapter10.html#Not" TARGET="Chapters">
Not
</A>
, <A HREF="refchapter10.html#And" TARGET="Chapters">
And
</A>
, <A HREF="refchapter10.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="refchapter10.html#IsFreeOf" TARGET="Chapters">
IsFreeOf
</A>
, <A HREF="refchapter10.html#IsZeroVector" TARGET="Chapters">
IsZeroVector
</A>
, <A HREF="refchapter10.html#IsNonObject" TARGET="Chapters">
IsNonObject
</A>
, <A HREF="refchapter10.html#IsEven" TARGET="Chapters">
IsEven
</A>
, <A HREF="refchapter10.html#IsOdd" TARGET="Chapters">
IsOdd
</A>
, <A HREF="refchapter10.html#IsFunction" TARGET="Chapters">
IsFunction
</A>
, <A HREF="refchapter10.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="refchapter10.html#IsString" TARGET="Chapters">
IsString
</A>
, <A HREF="refchapter10.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="refchapter10.html#IsList" TARGET="Chapters">
IsList
</A>
, <A HREF="refchapter10.html#IsBound" TARGET="Chapters">
IsBound
</A>
, <A HREF="refchapter10.html#IsBoolean" TARGET="Chapters">
IsBoolean
</A>
, <A HREF="refchapter10.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="refchapter10.html#IsNegativeInteger" TARGET="Chapters">
IsNegativeInteger
</A>
, <A HREF="refchapter10.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="refchapter10.html#IsPositiveInteger" TARGET="Chapters">
IsPositiveInteger
</A>
, <A HREF="refchapter10.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
, <A HREF="refchapter10.html#IsNonZeroInteger" TARGET="Chapters">
IsNonZeroInteger
</A>
, <A HREF="refchapter10.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="refchapter10.html#IsPositiveReal" TARGET="Chapters">
IsPositiveReal
</A>
, <A HREF="refchapter10.html#IsNegativeReal" TARGET="Chapters">
IsNegativeReal
</A>
, <A HREF="refchapter10.html#IsConstant" TARGET="Chapters">
IsConstant
</A>
.
<H1>
Predicates
</H1>

A predicate is a function that returns a boolean value, i.e. <B><TT>True</TT></B> or <B><TT>False</TT></B>. Predicates are
often used in patterns, For instance, a rule that only holds for a
positive integer would use a pattern like <B><TT>n_IsPositiveInteger</TT></B>.
<A NAME="&lt;">

</A>
<H3>
<HR>&lt; -- Test whether lhs is smaller than rhs
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 &lt; e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is smaller than the second one,
the result is <B><TT>True</TT></B> and it is <B><TT>False</TT></B> otherwise. If either of the expression is not numeric, after
evaluation, the expression is returned with evaluated arguments.
<p> </p>
The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. <B><TT>IsNumber</TT></B> returns <B><TT>True</TT></B>), or the
quotient of two numbers, or an infinity (i.e. <B><TT>IsInfinity</TT></B> returns <B><TT>True</TT></B>).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 2 < 5;
Out> True;
In> Cos(1) < 5;
Out> Cos(1)<5;
In> N(Cos(1)) < 5;
Out> True</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="&gt;">

</A>
<H3>
<HR>&gt; -- Test whether lhs is larger than rhs
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 &gt; e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is larger than the second one,
the result is <B><TT>True</TT></B> and it is <B><TT>False</TT></B> otherwise. If either of the expression is not numeric, after
evaluation, the expression is returned with evaluated arguments.
<p> </p>
The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. <B><TT>IsNumber</TT></B> returns <B><TT>True</TT></B>), or the
quotient of two numbers, or an infinity (i.e. <B><TT>IsInfinity</TT></B> returns <B><TT>True</TT></B>).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 2 > 5;
Out> False;
In> Cos(1) > 5;
Out> Cos(1)>5;
In> N(Cos(1)) > 5;
Out> False</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="&lt;=">

</A>
<H3>
<HR>&lt;= -- Test whether lhs is smaller or equal rhs
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 &lt;= e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is smaller than or equals the
second one, the result is <B><TT>True</TT></B> and it is <B><TT>False</TT></B> otherwise. If either of the expression is not
numeric, after evaluation, the expression is returned with evaluated
arguments. 
<p> </p>
The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. <B><TT>IsNumber</TT></B> returns <B><TT>True</TT></B>), or the
quotient of two numbers, or an infinity (i.e. <B><TT>IsInfinity</TT></B> returns <B><TT>True</TT></B>).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 2 <= 5;
Out> True;
In> Cos(1) <= 5;
Out> Cos(1)<=5;
In> N(Cos(1)) <= 5;
Out> True</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="&gt;=">

</A>
<H3>
<HR>&gt;= -- Test whether lhs is larger or equal rhs
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 &gt;= e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is larger than or equals the
second one, the result is <B><TT>True</TT></B> and it is <B><TT>False</TT></B> otherwise. If either of the expression is not
numeric, after evaluation, the expression is returned with evaluated
arguments. 
<p> </p>
The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. <B><TT>IsNumber</TT></B> returns <B><TT>True</TT></B>), or the
quotient of two numbers, or an infinity (i.e. <B><TT>IsInfinity</TT></B> returns <B><TT>True</TT></B>).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 2 >= 5;
Out> False;
In> Cos(1) >= 5;
Out> Cos(1)>=5;
In> N(Cos(1)) >= 5;
Out> False</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="!=">

</A>
<H3>
<HR>!= -- Test whether two expressions are not equal
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 != e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

Both expression are evaluated and compared. If they turn out to be
equal, the result is <B><TT>False</TT></B>. Otherwise, the result
is <B><TT>True</TT></B>.
<p> </p>
The expression <B><TT>e1 != e2</TT></B> is equivalent to <B><TT>Not(e1 = e2)</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> 1 != 2;
Out> True;
In> 1 != 1;
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#=" TARGET="Chapters">
=
</A>
.<A NAME="=">

</A>
<H3>
<HR>= -- Test whether two expressoins are equal
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
e1 = e2 (prec. 9)
<H5>
Parameters:
</H5>
e1, e2 - expressions to be compared
<H5>
Description:
</H5>

Both expression are evaluated and compared. If they turn out to be
equal, the result is <B><TT>True</TT></B>. Otherwise, the result is <B><TT>False</TT></B>. The function <B><TT>Equals</TT></B> does
the same.
<p> </p>
Note that the test is on syntactic equality, not mathematical
equality. Hence even if the result is <B><TT>False</TT></B>, the
expressions can still be (mathematically) equal; see the examples
underneath. Put otherwise, this function tests whether the two
expressions would be displayed in the same way if they were printed.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> e1 := (x+1) * (x-1);
Out> (x+1)*(x-1);
In> e2 := x^2 - 1;
Out> x^2-1;

In> e1 = e2;
Out> False;
In> Expand(e1) = e2;
Out> True;</PRE></TR>
</TABLE>

<A HREF="ref.html#!=" TARGET="Chapters">
!=
</A>
, <A HREF="ref.html#Equals" TARGET="Chapters">
Equals
</A>
.<A NAME="Not">

</A>
<H3>
<HR>Not -- Logical negation
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Not bool
<H5>
Parameters:
</H5>
bool - a boolean expression
<H5>
Description:
</H5>
Not returns the logical negation of the argument bool. If bool is
False it returns True, and if the argument is True Not returns False.
If the argument is neither True nor False it returns the entire
expression with evaluated arguments.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Not True
Out> False;
In> Not False
Out> True;
In> Not(a)
Out> Not a;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
.<A NAME="And">

</A>
<H3>
<HR>And -- Logical conjunction
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
a1 And a2  (prec. 100) <br>
And(a1,a2,a3,...,an)
<H5>
Parameters:
</H5>
a1 .. an - boolean values (True or False)
<H5>
Description:
</H5>
This function returns True if all arguments are true. The
And operation is lazy, it returns False as soon as a False argument
is found (from left to right). If an argument other than True or
False is encountered a new And expression is returned with all
arguments that didn't evaluate to True or False yet.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> True And False
Out> False;
In> And(True,True)
Out> True;
In> False And a
Out> False;
In> True And a
Out> And(a);
In> And(True,a,True,b)
Out> b And a;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
.<A NAME="Or">

</A>
<H3>
<HR>Or -- Logical disjunction
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
a1 Or a2  (prec. 101) <br>
Or(a1,a2,a3,...,an)
<H5>
Parameters:
</H5>
a1 .. an - boolean values (True or False)
<H5>
Description:
</H5>
This function returns True if an argument is encountered
that is true (scanning from left to right). The
Or operation is lazy, it returns True as soon as a True argument
is found (from left to right). If an argument other than True or
False is encountered a new Or expression is returned with all
arguments that didn't evaluate to True or False yet.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> True Or False
Out> True;
In> False Or a
Out> Or(a);
In> Or(False,a,b,True)
Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
.<A NAME="IsFreeOf">

</A>
<H3>
<HR>IsFreeOf -- Test whether expression depends on variable
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

IsFreeOf(expr, var) <br>
IsFreeOf(expr, {var, ...})
<H5>
Parameters:
</H5>

expr - expression to test <br>
var - variable to look for in "expr"
<H5>
Description:
</H5>

This function checks whether the expression "expr" (after being
evaluated) depends on the variable "var". It returns <B><TT>False</TT></B> if this is the case and <B><TT>True</TT></B>
otherwise. 
<p> </p>
The second form test whether the expression depends on <em>any</em> of
the variables named in the list. The result is <B><TT>True</TT></B> if none of the variables appear in the expression and <B><TT>False</TT></B> otherwise.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsFreeOf(Sin(x), x);
Out> False;
In> IsFreeOf(Sin(x), y);
Out> True;
In> IsFreeOf(D(x) a*x+b, x);
Out> True;
In> IsFreeOf(Sin(x), {x,y});
Out> False;</PRE></TR>
</TABLE>

The third command returns <B><TT>True</TT></B> because the
expression <B><TT>D(x) a*x+b</TT></B> evaluates to <B><TT>a</TT></B>, which does not depend on <B><TT>x</TT></B>.
<H5>
See Also:
</H5>
<A HREF="ref.html#Contains" TARGET="Chapters">
Contains
</A>
.<A NAME="IsZeroVector">

</A>
<H3>
<HR>IsZeroVector -- Test whether list contains only zeroes
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsZeroVector(list)
<H5>
Parameters:
</H5>
list - list to compare against the zero vector
<H5>
Description:
</H5>

The only argument given to <B><TT>IsZeroVector</TT></B> should be
a list. The result is <B><TT>True</TT></B> if the list contains
only zeroes and <B><TT>False</TT></B> otherwise.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsZeroVector({0, x, 0});
Out> False;
In> IsZeroVector({x-x, 1 - D(x) x});
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsList" TARGET="Chapters">
IsList
</A>
, <A HREF="ref.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
.<A NAME="IsNonObject">

</A>
<H3>
<HR>IsNonObject -- Test whether argument is not an Object()
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNonObject(expr)
<H5>
Parameters:
</H5>
expr - the expression to examine
<H5>
Description:
</H5>

This function returns <B><TT>True</TT></B> if "expr" is not of
the form <B><TT>Object(...)</TT></B> and <B><TT>False</TT></B>
otherwise.
<H5>
Bugs:
</H5>
In fact, the result is always <B><TT>True</TT></B>.
<H5>
See Also:
</H5>
<A HREF="ref.html#Object" TARGET="Chapters">
Object
</A>
.<A NAME="IsEven">

</A>
<H3>
<HR>IsEven -- Test whether integer is even
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsEven(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This function tests whether the integer "n" is even. An integer is
even if it is divisible by two. Hence the even numbers are 0, 2, 4, 6,
8, 10, etcetera, and -2, -4, -6, -8, -10, etcetera.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsEven(4);
Out> True;
In> IsEven(-1);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsOdd" TARGET="Chapters">
IsOdd
</A>
, <A HREF="ref.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
.<A NAME="IsOdd">

</A>
<H3>
<HR>IsOdd -- Test whether integer is odd
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsOdd(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This function tests whether the integer "n" is odd. An integer is
odd if it is not divisible by two. Hence the odd numbers are 1, 3, 5,
7, 9, etcetera, and -1, -3, -5, -7, -9, etcetera.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsOdd(4);
Out> False;
In> IsOdd(-1);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsEven" TARGET="Chapters">
IsEven
</A>
, <A HREF="ref.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
.<A NAME="IsFunction">

</A>
<H3>
<HR>IsFunction -- Test whether argument is a composite object
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsFunction(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is a composite object, ie. not an
atom. This includes not only obvious functions like <B><TT>f(x)</TT></B>, but also expressions like <B><TT>x+5</TT></B> and lists.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsFunction(x+5);
Out> True;
In> IsFunction(x);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="ref.html#IsList" TARGET="Chapters">
IsList
</A>
, <A HREF="ref.html#Type" TARGET="Chapters">
Type
</A>
.<A NAME="IsAtom">

</A>
<H3>
<HR>IsAtom -- Test whether argument is an atom
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsAtom(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is an atom. Numbers, strings, and
variables are all atoms.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsAtom(x+5);
Out> Falso;
In> IsAtom(5);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsFunction" TARGET="Chapters">
IsFunction
</A>
, <A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsString" TARGET="Chapters">
IsString
</A>
.<A NAME="IsString">

</A>
<H3>
<HR>IsString -- Test whether argument is an string
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsString(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is a string. A string is a text
within quotes, eg. <B><TT>"duh"</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsString("duh");
Out> True;
In> IsString(duh);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
.<A NAME="IsNumber">

</A>
<H3>
<HR>IsNumber -- Test whether argument is a number
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsNumber(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is a number. There are two kinds
of numbers, integers (like 6) and reals (like -2.75 or 6.0). Note that a
complex number is represented by the <B><TT>Complex</TT></B>
function, so <B><TT>IsNumber</TT></B> will return <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNumber(6);
Out> True;
In> IsNumber(3.25);
Out> True;
In> IsNumber(I);
Out> False;
In> IsNumber("duh");
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="ref.html#IsString" TARGET="Chapters">
IsString
</A>
, <A HREF="ref.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
, <A HREF="ref.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="ref.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="ref.html#Complex" TARGET="Chapters">
Complex
</A>
.<A NAME="IsList">

</A>
<H3>
<HR>IsList -- Test whether argument is a list
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsList(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is a list. A list is a sequence
between curly braces, like <B><TT>{2, 3, 5}</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsList({2,3,5});
Out> True;
In> IsList(2+3+5);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsFunction" TARGET="Chapters">
IsFunction
</A>
.<A NAME="IsBound">

</A>
<H3>
<HR>IsBound -- Test whether a variable is bound to a value
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
IsBound(var)
<H5>
Parameters:
</H5>
var - variable to test
<H5>
Description:
</H5>

This function tests whether the variable "var" is bound, ie. whether
it has a value. The argument "var" is not evaluated.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsBound(x);
Out> False;
In> x := 5;
Out> 5;
In> IsBound(x);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
.<A NAME="IsBoolean">

</A>
<H3>
<HR>IsBoolean -- Test whether argument is a Boolean
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsBoolean(expression)
<H5>
Parameters:
</H5>
expression - an expression
<H5>
Description:
</H5>
IsBoolean returns True if the argument is of a boolean type.
This means it has to be either True, False, or an expression involving
functions that return a boolean result, like
=, &gt, &lt, &gt=, &lt=, !=, And, Not, Or.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsBoolean(a)
Out> False;
In> IsBoolean(True)
Out> True;
In> IsBoolean(a And b)
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#True" TARGET="Chapters">
True
</A>
, <A HREF="ref.html#False" TARGET="Chapters">
False
</A>
.<A NAME="IsNegativeNumber">

</A>
<H3>
<HR>IsNegativeNumber -- Test whether argument is a negative number
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNegativeNumber(n)
<H5>
Parameters:
</H5>
n - number to test
<H5>
Description:
</H5>
<B><TT>IsNegativeNumber(n)</TT></B> evaluates to <B><TT>True</TT></B> if "n" is (strictly) negative, ie. if n<0. If "n" is not a
number, the function returns <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNegativeNumber(6);
Out> False;
In> IsNegativeNumber(-2.5);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="ref.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
, <A HREF="ref.html#IsNegativeInteger" TARGET="Chapters">
IsNegativeInteger
</A>
, <A HREF="ref.html#IsNegativeReal" TARGET="Chapters">
IsNegativeReal
</A>
.<A NAME="IsNegativeInteger">

</A>
<H3>
<HR>IsNegativeInteger -- Test whether argument is a negative integer
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNegativeInteger(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This function tests whether the integer "n" is (strictly)
negative. The negative integers are -1, -2, -3, -4, -5, etcetera. If
"n" is not a integer, the function returns <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNegativeInteger(31);
Out> False;
In> IsNegativeInteger(-2);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsPositiveInteger" TARGET="Chapters">
IsPositiveInteger
</A>
, <A HREF="ref.html#IsNonZeroInteger" TARGET="Chapters">
IsNonZeroInteger
</A>
, <A HREF="ref.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
.<A NAME="IsPositiveNumber">

</A>
<H3>
<HR>IsPositiveNumber -- Test whether argument is a positive number
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsPositiveNumber(n)
<H5>
Parameters:
</H5>
n - number to test
<H5>
Description:
</H5>
<B><TT>IsPositiveNumber(n)</TT></B> evaluates to <B><TT>True</TT></B> if "n" is (strictly) positive, ie. if n>0. If "n" is not a
number the function returns <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsPositiveNumber(6);
Out> True;
In> IsPositiveNumber(-2.5);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="ref.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
, <A HREF="ref.html#IsPositiveInteger" TARGET="Chapters">
IsPositiveInteger
</A>
, <A HREF="ref.html#IsPositiveReal" TARGET="Chapters">
IsPositiveReal
</A>
.<A NAME="IsPositiveInteger">

</A>
<H3>
<HR>IsPositiveInteger -- Test whether argument is a positive integer
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsPositiveInteger(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This function tests whether the integer "n" is (strictly) positive. The
positive integers are 1, 2, 3, 4, 5, etcetera. If "n" is not a
integer the function returns <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsPositiveInteger(31);
Out> True;
In> IsPositiveInteger(-2);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNegativeInteger" TARGET="Chapters">
IsNegativeInteger
</A>
, <A HREF="ref.html#IsNonZeroInteger" TARGET="Chapters">
IsNonZeroInteger
</A>
, <A HREF="ref.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
.<A NAME="IsNotZero">

</A>
<H3>
<HR>IsNotZero -- Test whether argument is a nonzero number
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNotZero(n)
<H5>
Parameters:
</H5>
n - number to test
<H5>
Description:
</H5>
<B><TT>IsNotZero(n)</TT></B> evaluates to <B><TT>True</TT></B> if
"n" is not zero. In case "n" is not a number, the function returns
<B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNotZero(3.25);
Out> True;
In> IsNotZero(0);
Out> False;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="ref.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="ref.html#IsNonZeroInteger" TARGET="Chapters">
IsNonZeroInteger
</A>
.<A NAME="IsNonZeroInteger">

</A>
<H3>
<HR>IsNonZeroInteger -- Test whether argument is a nonzero integer
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNonZeroInteger(n)
<H5>
Parameters:
</H5>
n - integer to test
<H5>
Description:
</H5>

This function tests whether the integer "n" is not zero. If "n" is
not an integer, the result is <B><TT>False</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNonZeroInteger(0)
Out> False;
In> IsNonZeroInteger(-2)
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsPositiveInteger" TARGET="Chapters">
IsPositiveInteger
</A>
, <A HREF="ref.html#IsNegativeInteger" TARGET="Chapters">
IsNegativeInteger
</A>
, <A HREF="ref.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
.<A NAME="IsInfinity">

</A>
<H3>
<HR>IsInfinity -- Test whether argument is an infinity
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsInfinity(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tests whether "expr" is an infinity. This is only the
case if "expr" is either <B><TT>Infinity</TT></B> or <B><TT>-Infinity</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsInfinity(10^1000);
Out> False;
In> IsInfinity(-Infinity);
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Integer" TARGET="Chapters">
Integer
</A>
.<A NAME="IsPositiveReal">

</A>
<H3>
<HR>IsPositiveReal -- Test whether argument is numerically positive
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsPositiveReal(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tries to approximate "expr" numerically. It returns <B><TT>True</TT></B> if this approximation is positive. In case no
approximation can be found, the function returns <B><TT>False</TT></B>. Note that round-off errors may cause incorrect
results.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsPositiveReal(Sin(1)-3/4);
Out> True;
In> IsPositiveReal(Sin(1)-6/7);
Out> False;
In> IsPositiveReal(Exp(x));
Out> False;</PRE></TR>
</TABLE>
The last result is because <B><TT>Exp(x)</TT></B> cannot be
numerically approximated if <B><TT>x</TT></B> is not known. Hence
Yacas can not determine the sign of this expression.
<H5>
See Also:
</H5>
<A HREF="ref.html#IsNegativeReal" TARGET="Chapters">
IsNegativeReal
</A>
, <A HREF="ref.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="IsNegativeReal">

</A>
<H3>
<HR>IsNegativeReal -- Test whether argument is numerically negative
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsNegativeReal(expr)
<H5>
Parameters:
</H5>
expr - expression to test
<H5>
Description:
</H5>

This function tries to approximate "expr" numerically. It returns <B><TT>True</TT></B> if this approximation is negative. In case no
approximation can be found, the function returns <B><TT>False</TT></B>. Note that round-off errors may cause incorrect
results.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNegativeReal(Sin(1)-3/4);
Out> False;
In> IsNegativeReal(Sin(1)-6/7);
Out> True;
In> IsNegativeReal(Exp(x));
Out> False;</PRE></TR>
</TABLE>
The last result is because <B><TT>Exp(x)</TT></B> cannot be
numerically approximated if <B><TT>x</TT></B> is not known. Hence
Yacas can not determine the sign of this expression.
<H5>
See Also:
</H5>
<A HREF="ref.html#IsPositiveReal" TARGET="Chapters">
IsPositiveReal
</A>
, <A HREF="ref.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="ref.html#N" TARGET="Chapters">
N
</A>
.<A NAME="IsConstant">

</A>
<H3>
<HR>IsConstant -- Test whether argument is constant
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsConstant(expr)
<H5>
Parameters:
</H5>
expr - some expression
<H5>
Description:
</H5>
<B><TT>IsConstant</TT></B> returns <B><TT>True</TT></B> if the
expression is some constant or a function with constant arguments. It
does this by checking that no variables are referenced in the
expression.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsConstant(Cos(x))
Out> False;
In> IsConstant(Cos(2))
Out> True;
In> IsConstant(Cos(2+x))
Out> False;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
, <A HREF="ref.html#VarList" TARGET="Chapters">
VarList
</A>
.<p>  </P><HR><A NAME="c11">

</A>
<A HREF="refchapter11.html#CanProve" TARGET="Chapters">
CanProve
</A>
.
<H1>
Propositional logic theorem prover
</H1>
<A NAME="CanProve">

</A>
<H3>
<HR>CanProve
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
CanProve(proposition)
<H5>
Parameters:
</H5>
proposition - a logical proposition
<H5>
Description:
</H5>
Yacas has a small built-in propositional logic theorem prover.
It can be invoked with a call to CanProve. <br>

An example of a proposition is 'if a implies b and b implies c then
a implies c'. Yacas supports the following operators <P>  </P>

 Not     negation, read as 'not'        <br>
 And     conjunction, read as 'and'     <br> 
 Or     disjunction, read as 'or'      <br> 
=>   implication, read as 'implies' <br> 

So the above mentioned proposition would be represented by

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>( (a=>b) And (b=>c) ) => (a=>c)
</PRE></TR>
</TABLE>

 
Yacas can prove that is correct by applying <B><TT>CanProve</TT></B>
to it:


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> CanProve(( (a=>b) And (b=>c) ) => (a=>c))
Out> True;
</PRE></TR>
</TABLE>


It does this the following way: in order to prove proposition p, it
suffices to prove that  Not p is false. It continues to simplify  Not p
using the rules <P>  </P>


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE> Not  ( Not x)      --> x        eliminate double negation
x=>y        -->  Not x  Or  y   eliminate implication
 Not (x And y)      -->  Not x  Or   Not y  De Morgan's law
 Not (x  Or  y)    -->  Not x  And   Not y  De Morgan's law
(x  And  y)  Or  z --> (x Or z) And (y Or z)  Distribution
x  Or  (y  And  z) --> (x Or y) And (x Or z)  Distribution
</PRE></TR>
</TABLE>

And the obvious other rules: 'True Or x --> True' etc.
The above rules will translate the proposition into a form

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>(p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
</PRE></TR>
</TABLE>


If any of the clauses is false, the entire expression will be false.
In the next step, clauses are scanned for situations of the form:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>(p Or Y)  And  ( Not p Or Z) --> (Y Or Z)
</PRE></TR>
</TABLE>


If this combination <B><TT>(Y Or Z)</TT></B> is empty, it is false, and
thus the entire proposition is false. <P>  </P>

As a last step, the algorithm negates the result again. This has the
added advantage of simplifying the expression further. 
    

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> CanProve(a  Or   Not a)         
Out> True;
In> CanProve(True  Or  a)       
Out> True;
In> CanProve(False  Or  a)      
Out> a;
In> CanProve(a  And   Not a)         
Out> False;
In> CanProve(a  Or b Or (a And b))     
Out> a Or b;

</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#True" TARGET="Chapters">
True
</A>
, <A HREF="ref.html#False" TARGET="Chapters">
False
</A>
, <A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
.<p>  </P><HR><A NAME="c12">

</A>
<A HREF="refchapter12.html#%" TARGET="Chapters">
%
</A>
, <A HREF="refchapter12.html#True, False" TARGET="Chapters">
True, False
</A>
, <A HREF="refchapter12.html#EndOfFile" TARGET="Chapters">
EndOfFile
</A>
, <A HREF="refchapter12.html#Infinity" TARGET="Chapters">
Infinity
</A>
, <A HREF="refchapter12.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="refchapter12.html#Undefined" TARGET="Chapters">
Undefined
</A>
.
<H1>
Constants
</H1>
<A NAME="%">

</A>
<H3>
<HR>% -- Previous result
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
%
<H5>
Parameters:
</H5>

<H5>
Description:
</H5>
% evaluates to the previous result on the command line. % is a global
variable that is bound to the previous result from the command line.
Using % will evaluate the previous result (This uses the functionality
offered by the LazyGlobal command). <p>  </p>

Typical examples are <B><TT>Simplify(%)</TT></B> and <B><TT>PrettyForm(%)</TT></B>to simplify and show the result in a nice
form respectively.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
In> PrettyForm(%)

     3    5 
    x    x  
x - -- + ---
    6    120


</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#LazyGlobal" TARGET="Chapters">
LazyGlobal
</A>
.<A NAME="True">

</A>
<A NAME="False">

</A>
<A NAME="True, False">

</A>
<H3>
<HR>True, False -- Boolean constants
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
True <br>
False
<H5>
Description:
</H5>
<B><TT>True</TT></B> and <B><TT>False</TT></B> are typically the result
of boolean expressions like <B><TT>2 &lt 3</TT></B> and <B><TT>True And False</TT></B>.

<H5>
See Also:
</H5>
<A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
.<A NAME="EndOfFile">

</A>
<H3>
<HR>EndOfFile -- End-of-file marker
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
EndOfFile
<H5>
Description:
</H5>
End of file marker when reading from file. If a file
contains the expression <B><TT>EndOfFile;</TT></B> the
operation will stop reading the file at that point.

<A NAME="Infinity">

</A>
<H3>
<HR>Infinity -- Constant representing mathematical infinity
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Infinity
<H5>
Description:
</H5>
Infinity represents infinity. It can be the result of certain
calculations.
<P>

Note that for most analytic functions Yacas understands Infinity.
Thus <B><TT>Infinity*2</TT></B> will return Infinity, and <B><TT>a &lt Infinity</TT></B> will evaluate to True.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2*Infinity
Out> Infinity;
In> 2<Infinity
Out> True;
</PRE></TR>
</TABLE>

<A NAME="Pi">

</A>
<H3>
<HR>Pi -- Mathematical constant, 3.14159...
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Pi
<H5>
Description:
</H5>
Pi represents the value of pi. When the N(..) function is used,
Pi is set to the correct value. It is probably better to use
Pi than Pi(), for simplification purposes.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(3*Pi/2)
Out> -1;
In> Pi
Out> Pi;
In> N(Pi)
Out> 3.1415926535;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sin" TARGET="Chapters">
Sin
</A>
, <A HREF="ref.html#Cos" TARGET="Chapters">
Cos
</A>
.<A NAME="Undefined">

</A>
<H3>
<HR>Undefined -- Constant signifying an undefined result
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Undefined
<H5>
Description:
</H5>
Undefined is a token that can be returned by a function when it considers
its input to be invalid. The resulting output is then undefined.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2*Infinity
Out> Infinity;
In> 0*Infinity
Out> Undefined;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Infinity" TARGET="Chapters">
Infinity
</A>
.<p>  </P><HR><A NAME="c13">

</A>
<A HREF="refchapter13.html#:=" TARGET="Chapters">
:=
</A>
, <A HREF="refchapter13.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="refchapter13.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="refchapter13.html#++" TARGET="Chapters">
++
</A>
, <A HREF="refchapter13.html#--" TARGET="Chapters">
--
</A>
, <A HREF="refchapter13.html#Object" TARGET="Chapters">
Object
</A>
, <A HREF="refchapter13.html#LazyGlobal" TARGET="Chapters">
LazyGlobal
</A>
, <A HREF="refchapter13.html#UniqueConstant" TARGET="Chapters">
UniqueConstant
</A>
.
<H1>
Variables
</H1>
<A NAME=":=">

</A>
<H3>
<HR>:= -- Assignment
</H3>
Standard math library<br><H5>
Calling sequence:
</H5>

var := exp <br>
{var, ...} := {exp, ...} <br>
var[i] := exp <br>
fn(param, ...) := exp   (all prec. 1000)
<H5>
Parameters:
</H5>

var - variable which should be assigned <br>
exp - expression to assign to the variable <br>
i - index (can be integer or string) <br>
fn - name of a function to define <br>
param - argument of the function "fn"
<H5>
Description:
</H5>

As one can see above, the <B><TT>:=</TT></B> operator can be used
in a number of ways. In all cases, some sort of assignment takes
place.
<p> </p>
The first form is the most basic one. It evaluates the expression on
the right-hand side and assigns it to the variable named on the
left-hand side. The left-hand side is not evaluated. The evaluated
expression is also returned.
<p> </p>
The second form is a small extension, which allows one to do multiple
assignments. The first entry in the list on the right-hand side is
assigned to the first variable mentionedon the left-hand side, the
second entry on the right-hand side to the second variable on the
left-hand side, etcetera. The list on the right-hand side must have at
least as many entries as the list on the left-hand side. Any excess
entries are silently ignored. The result of the expression is the list
of values that have been assigned.
<p> </p>
The third form allows one to change an entry in the list. If the index
"i" is an integer, the "i"-th entry in the list is changed to the
expression on the right-hand side. It is assumed that the length of
the list is at least "i". If the index "i" is a string, then
"var" is considered to be an associative list (sometimes called hash
table), and the key "i" is paired with the value "exp". In both
cases, the right-hand side is evaluated before the assigment and the
result of the assignment is <B><TT>True</TT></B>.
<p> </p>
The last form defines a function. For example, the assignment <B><TT>f(x) := x^2</TT></B> removes all rules associated with <B><TT>f(x)</TT></B> and defines the rule <B><TT>f(_x) <--
x^2</TT></B>. Note that the left-hand side may take a different form if
"f" is defined to be a prefix, infix or bodied function. This case
is a bit special since the right-hand side is not evaluated
immediately, but only if the function "f" is used. If this takes
time, it may be better to force an immediate evaluation with <B><TT>Eval</TT></B> (see the last example).
<H5>
Examples:
</H5>

A simple assignment:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a := Sin(x) + 3;
Out> Sin(x)+3;
In> a;
Out> Sin(x)+3;</PRE></TR>
</TABLE>
<p> </p>
Multiple assignments:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> {a,b,c} := {1,2,3};
Out> {1,2,3};
In> a;
Out> 1;
In> b+c;
Out> 5;</PRE></TR>
</TABLE>
<p> </p>
Assignment to a list:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> xs := { 1,2,3,4,5 };
Out> {1,2,3,4,5};
In> xs[3] := 15;
Out> True;
In> xs;
Out> {1,2,15,4,5};</PRE></TR>
</TABLE>
<p> </p>
Building an associative list:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> alist := {};
Out> {};
In> alist["cherry"] := "red";
Out> True;
In> alist["banana"] := "yellow";
Out> True;
In> alist["cherry"];
Out> "red";
In> alist;
Out> {{"banana","yellow"},{"cherry","red"}};</PRE></TR>
</TABLE>
<p> </p>
Defining a function:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(x) := x^2;
Out> True;
In> f(3);
Out> 9;
In> f(Sin(a));
Out> Sin(a)^2;

In> Infix("*&*",10);
Out> True;
In> x1 *&* x2 := x1/x2 + x2/x1; 
Out> True;
In> Sin(a) *&* Cos(a);
Out> Tan(1)+Cos(1)/Sin(1);
In> Clear(a);
Out> True;
In> Sin(a) *&* Exp(a);
Out> Sin(a)/Exp(a)+Exp(a)/Sin(a);</PRE></TR>
</TABLE>

<p> </p>
In the following example, it may take some time to compute the Taylor
expansion. This has to be done every time the function <B><TT>f</TT></B> is called.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(a) := Taylor(x,0,25) Sin(x);
Out> True;
In> f(1);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;
In> f(2);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;</PRE></TR>
</TABLE>
The remedy is to evaluate the Taylor expansion immediately. Now the
expansion is computed only once.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(a) := Eval(Taylor(x,0,25) Sin(x));
Out> True;
In> f(1);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;
In> f(2);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="ref.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="ref.html#[]" TARGET="Chapters">
[]
</A>
, <A HREF="ref.html#Rule" TARGET="Chapters">
Rule
</A>
, <A HREF="ref.html#Infix" TARGET="Chapters">
Infix
</A>
, <A HREF="ref.html#Eval" TARGET="Chapters">
Eval
</A>
.<A NAME="Set">

</A>
<H3>
<HR>Set -- Assignment
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Set(var, exp)
<H5>
Parameters:
</H5>

var - variable which should be assigned <br>
exp - expression to assign to the variable
<H5>
Description:
</H5>

The expression "exp" is evaluated and assigned it to the variable
named "var". The first argument is not evaluated. The value True
is returned.
<p> </p>
The statement <B><TT>Set(var, exp)</TT></B> is equivalent to <B><TT>var := exp</TT></B>, but the <B><TT>:=</TT></B> operator
has more uses like changing individual entries in a list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Set(a, Sin(x)+3);
Out> True;
In> a;
Out> Sin(x)+3;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="Clear">

</A>
<H3>
<HR>Clear -- Undo an assignment
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Clear(var, ...)
<H5>
Parameters:
</H5>
var - name of variable to be cleared
<H5>
Description:
</H5>

All assignments made to the variables listed as arguments are
undone. From now on, all these variables remain unevaluated (until a
subsequent assignment is made). The result of the expression is
True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a := 5;
Out> 5;
In> a^2;
Out> 25;

In> Clear(a);
Out> True;
In> a^2;
Out> a^2;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.Internal function<br><H5>
Calling Sequence:
</H5>
Local(var, ...)
<H5>
Parameters:
</H5>
var - name of variable to be declared as local
<H5>
Description:
</H5>

All variables in the argument list are declared as local
variables. The arguments are not evaluated. The value True is
returned.
<p> </p>
By default, all variables in Yacas are global. This means that the
variable has the same value everywhere. But sometimes it is useful to
have a private copy of some variable, either to prevent the outside
world from changing it or to prevent accidental changes to the outside
world. This can be achieved by declaring the variable local. Now only
expressions within the <B><TT>Prog</TT></B> block (or its
syntactic equivalent, the <B><TT>[  ]</TT></B> block) can access
and change it. Functions called within this block cannot access the
local copy unless this is specifically allowed with <B><TT>UnFence</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a := 3;
Out> 3;

In> [ a := 4; a; ];
Out> 4;
In> a;
Out> 4;

In> [ Local(a); a := 5; a; ];
Out> 5;
In> a;
Out> 4;</PRE></TR>
</TABLE>

In the first block, <B><TT>a</TT></B> is not declared local and
hence defaults to be a global variable. Indeed, changing the variable
inside the block also changes the value of <B><TT>a</TT></B>
outside the block. However, in the second block <B><TT>a</TT></B>
is defined to be local and now the value outside the block stays the
same, even though <B><TT>a</TT></B> is assigned the value 5 inside
the block.
<H5>
See Also:
</H5>
<A HREF="ref.html#LocalSymbols" TARGET="Chapters">
LocalSymbols
</A>
, <A HREF="ref.html#Prog" TARGET="Chapters">
Prog
</A>
, <A HREF="ref.html#[]" TARGET="Chapters">
[]
</A>
, <A HREF="ref.html#UnFence" TARGET="Chapters">
UnFence
</A>
.<A NAME="++">

</A>
<H3>
<HR>++ -- Increment variable
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
var++
<H5>
Parameters:
</H5>
var - variable to increment
<H5>
Description:
</H5>

The variable with name "var" is incremented, i.e. the number 1 is
added to it. The expression <B><TT>x++</TT></B> is equivalent to
the assignment <B><TT>x := x + 1</TT></B>, except that the
assignment returns the new value of <B><TT>x</TT></B> while <B><TT>x++</TT></B> always returns true. In this respect, Yacas' <B><TT>++</TT></B> differs from the corresponding operator in the
programming language C.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> x := 5;
Out> 5;
In> x++;
Out> True;
In> x;
Out> 6;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#--" TARGET="Chapters">
--
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="--">

</A>
<H3>
<HR>-- -- Decrement variable
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
var--
<H5>
Parameters:
</H5>
var - variable to decrement
<H5>
Description:
</H5>

The variable with name "var" is decremented, i.e. the number 1 is
subtracted from it. The expression <B><TT>x--</TT></B> is
equivalent to the assignment <B><TT>x := x - 1</TT></B>, except
that the assignment returns the new value of <B><TT>x</TT></B>
while <B><TT>x--</TT></B> always returns true. In this respect,
Yacas' <B><TT>--</TT></B> differs from the corresponding operator
in the programming language C.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> x := 5;
Out> 5;
In> x--;
Out> True;
In> x;
Out> 4;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#++" TARGET="Chapters">
++
</A>
, <A HREF="ref.html#:=" TARGET="Chapters">
:=
</A>
.<A NAME="Object">

</A>
<H3>
<HR>Object -- Create an incomplete type
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Object("pred", exp)
<H5>
Parameters:
</H5>

pred - name of the predicate to apply <br>
exp - expression on which "pred" should be applied
<H5>
Description:
</H5>

This function returns "obj" as soon as "pred" returns <B><TT>True</TT></B> when applied on "obj". This is used to declare
so-called incomplete types.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a := Object("IsNumber", x);
Out> Object("IsNumber",x);
In> Eval(a);
Out> Object("IsNumber",x);
In> x := 5;
Out> 5;
In> Eval(a);
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNonObject" TARGET="Chapters">
IsNonObject
</A>
.<A NAME="LazyGlobal">

</A>
<H3>
<HR>LazyGlobal -- Global variable is to be evaluated lazily
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
LazyGlobal(var)
<H5>
Parameters:
</H5>
var - variable (held argument)
<H5>
Description:
</H5>
LazyGlobal enforces that a global variable will re-evaluate
when used. The global variable needs to exist for this function
to work. Also, this functionality doesn't survive if Clear(var)
is called afterwards. <P>  </P>

Places where this is used include the global variables % and I.<P>  </P>

The use of lazy in the name stems from the concept of lazy evaluation.
The object the global variable is bound to will only be evaluated when
called. The LazyGlobal property only holds once: after that, the result
of evaluation is stored in the global variable, and it won't be
reevaluated again: 

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> a:=Hold(Taylor(x,0,30)Sin(x))
Out> Taylor(x,0,30)Sin(x);
In> LazyGlobal(a)
</PRE></TR>
</TABLE>


Then the first time you call a it evaluates Taylor(...) and assigns the result to a. The next time
you call a it immediately returns the result.
LazyGlobal is called for "%" each time "%" changes.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> a:=Hold(2+3)
Out> 2+3;
In> a
Out> 2+3;
In> LazyGlobal(a)
Out> True;
In> a
Out> 5;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="ref.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="ref.html#Local" TARGET="Chapters">
Local
</A>
, <A HREF="ref.html#%" TARGET="Chapters">
%
</A>
, <A HREF="ref.html#I" TARGET="Chapters">
I
</A>
.<A NAME="UniqueConstant">

</A>
<H3>
<HR>UniqueConstant -- Create a unique identifier
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
UniqueConstant()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>
This function returns a unique constant atom each time you call
it. The atom starts with a C character, and a unique number is
appended to it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> UniqueConstant() 
Out> C9 
In>  UniqueConstant() 
Out> C10 </PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#LocalSymbols" TARGET="Chapters">
LocalSymbols
</A>
.<p>  </P><HR><A NAME="c14">

</A>
<A HREF="refchapter14.html#FullForm" TARGET="Chapters">
FullForm
</A>
, <A HREF="refchapter14.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="refchapter14.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="refchapter14.html#EvalFormula" TARGET="Chapters">
EvalFormula
</A>
, <A HREF="refchapter14.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="refchapter14.html#WriteString" TARGET="Chapters">
WriteString
</A>
, <A HREF="refchapter14.html#Space" TARGET="Chapters">
Space
</A>
, <A HREF="refchapter14.html#NewLine" TARGET="Chapters">
NewLine
</A>
, <A HREF="refchapter14.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="refchapter14.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="refchapter14.html#ToFile" TARGET="Chapters">
ToFile
</A>
, <A HREF="refchapter14.html#ToString" TARGET="Chapters">
ToString
</A>
, <A HREF="refchapter14.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="refchapter14.html#LispRead" TARGET="Chapters">
LispRead
</A>
, <A HREF="refchapter14.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
, <A HREF="refchapter14.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="refchapter14.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="refchapter14.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="refchapter14.html#FindFile" TARGET="Chapters">
FindFile
</A>
, <A HREF="refchapter14.html#PatchLoad" TARGET="Chapters">
PatchLoad
</A>
, <A HREF="refchapter14.html#Nl" TARGET="Chapters">
Nl
</A>
.
<H1>
Input/Output
</H1>

This chapter contains command to use for input and output. All output
commands write to the same destination, called the "current
output". This is initially the screen, but the current output is
redirected by some commands. Similarly, most input commands
read from the "current input", which can also be redirected. The
exception to this rule are the commands for reading in script files,
which simply read  the specified file.
<A NAME="FullForm">

</A>
<H3>
<HR>FullForm -- Print an expression in LISP-format
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FullForm(expr)
<H5>
Parameters:
</H5>
expr - The expression to be printed in LISP-format
<H5>
Description:
</H5>
Evaluates "expr", and prints it in LISP-format on the current
output. It is followed by a newline. The evaluated expression is also
returned. 

This can be useful if you want to study the internal representation of
a certain expression.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> FullForm(a+b+c);
(+ (+ a b )c )
Out> a+b+c;
In> FullForm(2*I*b^2);
(* (Complex 0 2 )(^ b 2 ))
Out> Complex(0,2)*b^2;
</PRE></TR>
</TABLE>
The first example shows how the expression <B><TT>a+b+c</TT></B> is
internally represented. In the second example, <B><TT>2*I</TT></B> is
first evaluated to <B><TT>Complex(0,2)</TT></B> before the expression
is printed.
<H5>
See Also:
</H5>
<A HREF="ref.html#LispRead" TARGET="Chapters">
LispRead
</A>
, <A HREF="ref.html#Listify" TARGET="Chapters">
Listify
</A>
, <A HREF="ref.html#Unlist" TARGET="Chapters">
Unlist
</A>
.<A NAME="Echo">

</A>
<H3>
<HR>Echo -- High-level printing routine
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Echo(item) <br>
Echo(list)
<H5>
Parameters:
</H5>
item - the item to be printed <br>
list - a list of items to be printed
<H5>
Description:
</H5>
If passed a single item, Echo will evaluate it and print it to the
current output, followed by a newline. If "item" is a string, it is
printed without quotation marks. <P> </P>
If the second calling sequence is used, Echo will print all the
entries in the list subsequently to the current output, followed by a
newline. Any strings in the list are printed without quotation
marks. All other entries are followed by a space.<P> </P>
Echo always returns True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Echo(5+3);
 8 
Out> True;
In> Echo({"The square of two is ", 2*2});
The square of two is  4 
Out> True;</PRE></TR>
</TABLE>
<P> </P>
Note that one must use the second calling sequence if one wishes to
print a list:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Echo({a,b,c});
a  b  c 
Out> True;
In> Echo({{a,b,c}});
{a,b,c} 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="ref.html#WriteString" TARGET="Chapters">
WriteString
</A>
.<A NAME="PrettyForm">

</A>
<H3>
<HR>PrettyForm -- Print an expression nicely with ASCII art
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PrettyForm(expr)
<H5>
Parameters:
</H5>
expr - an expression
<H5>
Description:
</H5>
PrettyForm renders an expression in a nicer way, using ascii art.
This is generally useful when the result of a calculation is more
complex than a simple number.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Taylor(x,0,9)Sin(x)
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880;
In> PrettyForm(%)

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EvalFormula" TARGET="Chapters">
EvalFormula
</A>
, <A HREF="ref.html#PrettyPrinter" TARGET="Chapters">
PrettyPrinter
</A>
.<A NAME="EvalFormula">

</A>
<H3>
<HR>EvalFormula -- Print an evaluation nicely with ASCII art
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
EvalFormula(expr)
<H5>
Parameters:
</H5>
expr - an expression
<H5>
Description:
</H5>
Show an evaluation in a nice way, using PrettyPrinter
to show 'input = output'.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In&gt EvalFormula(Taylor(x,0,7)Sin(x)) 

                                      3    5      7 
                                     x    x      x  
Taylor( x , 0 , 7 , Sin( x ) ) = x - -- + --- - ----
                                     6    120   5040

Out&gt True 
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
.<A NAME="Write">

</A>
<H3>
<HR>Write -- Low-level printing routine
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Write(expr, ...)
<H5>
Parameters:
</H5>
expr - the expression to be printed
<H5>
Description:
</H5>

The expression "expr" is evaluated and written to the current
output. Note that Write accept an arbitrary number of arguments, all
of which are written to the current output (see second
example). Write always returns True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Write(1);
1Out> True;
In> Write(1,2);
 1 2Out> True;</PRE></TR>
</TABLE>

Write does not write a newline, so the <B><TT>Out></TT></B> prompt
immediately follows the output of Write.
<H5>
See Also:
</H5>
<A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#WriteString" TARGET="Chapters">
WriteString
</A>
.<A NAME="WriteString">

</A>
<H3>
<HR>WriteString -- Low-level printing routine for strings
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
WriteString(string)
<H5>
Parameters:
</H5>
string - the string to be printed
<H5>
Description:
</H5>

The expression "string" is evaluated and written to the current
output without quotation marks. The argument should be a
string. WriteString always returns True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Write("Hello, world!");
"Hello, world!"Out> True;
In> WriteString("Hello, world!");
Hello, world!Out> True;
</PRE></TR>
</TABLE>

This example clearly shows the difference between Write and
WriteString. Note that Write and WriteString do not write a newline,
so the <B><TT>Out></TT></B> prompt immediately follows the output.
<H5>
See Also:
</H5>
<A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
.<A NAME="Space">

</A>
<H3>
<HR>Space -- Print one or more spaces
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

Space() <br>
Space(nr)
<H5>
Parameters:
</H5>
nr - the number of spaces to print
<H5>
Description:
</H5>

The command <B><TT>Space()</TT></B> prints one space on the
current output. The second form prints "nr" spaces on the current
output. The result is always True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Space(5);
     Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="ref.html#NewLine" TARGET="Chapters">
NewLine
</A>
.<A NAME="NewLine">

</A>
<H3>
<HR>NewLine -- Print one or more newline characters
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>

NewLine() <br>
NewLine(nr)
<H5>
Parameters:
</H5>
nr - the number of newlines to print
<H5>
Description:
</H5>

The command <B><TT>NewLine()</TT></B> prints one newline character
on the current output. The second form prints "nr" newlines on the
current output. The result is always True.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> NewLine();
     
Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="ref.html#Space" TARGET="Chapters">
Space
</A>
.<A NAME="FromFile">

</A>
<H3>
<HR>FromFile -- Connect current input to a file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FromFile(name) body
<H5>
Parameters:
</H5>

name - the name of the file to read <br>
body - the command to be executed
<H5>
Description:
</H5>

The current input is connected to the file "name". Then the command
"body" is executed. Everything that the commands in "body" read
from current input, is now read from the file "name". Finally, the
file is closed and the result of evaluating "body" is returned.
<H5>
Examples:
</H5>

Suppose that the file <B><TT>foo</TT></B> contains<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
2 + 5;
</PRE></TR>
</TABLE>
 <P> </P>
Then we can have the following dialogue:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FromFile("foo") res := Read();
Out> 2+5;
In> FromFile("foo") res := ReadToken();
Out> 2;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ToFile" TARGET="Chapters">
ToFile
</A>
, <A HREF="ref.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="ref.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="ref.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
.<A NAME="FromString">

</A>
<H3>
<HR>FromString -- Connect current input to a string
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FromString(str) body;
<H5>
Parameters:
</H5>

str - a string containing the text to parse <br>
body - the command to be executed
<H5>
Description:
</H5>

The commands in "body" are executed, but everything that is read
from the current input is now read from the string "str". The
result of "body" is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FromString("2+5; this is never read") res := Read();
Out> 2+5;
In> FromString("2+5; this is never read") res := Eval(Read());
Out> 7;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#ToString" TARGET="Chapters">
ToString
</A>
, <A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="ref.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
.<A NAME="ToFile">

</A>
<H3>
<HR>ToFile -- Connect current output to a file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
ToFile(name) body
<H5>
Parameters:
</H5>

name - the name of the file to write the result to <br>
body - the command to be executed
<H5>
Description:
</H5>

The current output is connected to the file "name". Then the command
"body" is executed. Everything that the commands in "body" print
to the current output, ends up in the file "name". Finally, the
file is closed and the result of evaluating "body" is returned.
<H5>
Examples:
</H5>

Take first a look at the following command:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> [ Echo("Result:");  PrettyForm(Taylor(x,0,9) Sin(x)); ];
Result:

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

Out> True;
</PRE></TR>
</TABLE>
 <P> </P>
Now suppose one wants to send the output of this command to a
file. This can be achieved as follows:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ToFile("out") [ Echo("Result:");  PrettyForm(Taylor(x,0,9) Sin(x)); ];
Out> True;
</PRE></TR>
</TABLE>
 <P> </P>
After this command the file <B><TT>out</TT></B> contains:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE> 
Result:

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#ToString" TARGET="Chapters">
ToString
</A>
, <A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="ref.html#WriteString" TARGET="Chapters">
WriteString
</A>
, <A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="ref.html#Taylor" TARGET="Chapters">
Taylor
</A>
.<A NAME="ToString">

</A>
<H3>
<HR>ToString -- Connect current output to a string
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
ToString() body
<H5>
Parameters:
</H5>
body - the command to be executed
<H5>
Description:
</H5>

The commands in "body" are executed. Everything that is printed on
the current output, by <B><TT>Echo</TT></B> for instance, is
collected in a string and this string is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> str := ToString() \
In>        [ WriteString("The square of 8 is "); Write(8^2); ];
Out> "The square of 8 is  64";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#ToString" TARGET="Chapters">
ToString
</A>
, <A HREF="ref.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="ref.html#WriteString" TARGET="Chapters">
WriteString
</A>
.<A NAME="Read">

</A>
<H3>
<HR>Read -- Read an expression from current input
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Read()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

Read an expression from the current input, and return it unevaluated. When
the end of an input file is encountered, the token atom <B><TT>EndOfFile</TT></B> is returned.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FromString("2+5;") Read();
Out> 2+5;
In> FromString("") Read();
Out> EndOfFile;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="ref.html#LispRead" TARGET="Chapters">
LispRead
</A>
, <A HREF="ref.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
.<A NAME="LispRead">

</A>
<H3>
<HR>LispRead -- Read an expression in LISP-syntax
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
LispRead()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

Read an expression in LISP syntax from the current input, and return
it unevaluated. When the end of an input file is encountered, the
token atom <B><TT>EndOfFile</TT></B> is returned. 
<P> </P>
The expression <B><TT>a+b</TT></B> is written in LISP syntax as <B><TT>(+ a b)</TT></B>. The advantage of this syntax is that it is
less ambiguous than the infix operator grammar that Yacas uses by
default.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FromString("(+ a b)") LispRead();
Out> a+b;
In> FromString("(List (Sin x) (- (Cos x)))") LispRead();
Out> {Sin(x),-Cos(x)};
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="ref.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="ref.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
, <A HREF="ref.html#FullForm" TARGET="Chapters">
FullForm
</A>
.<A NAME="ReadToken">

</A>
<H3>
<HR>ReadToken -- Read an token from current input
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
ReadToken()
<H5>
Parameters:
</H5>
none
<H5>
Description:
</H5>

Read a token from the current input, and return it unevaluated. When
the end of an input file is encountered, the token atom <B><TT>EndOfFile</TT></B> is returned.  
<P> </P>
A token is for computer languages what a word is for human languages:
it is the smallest unit in which a command can be divided, so that the
semantics (that is the meaning) of the command is in some sense a
combination of the semantics of the tokens. Hence <B><TT>a := foo</TT></B> consists of three tokens, namely <B><TT>a</TT></B>, <B><TT>:=</TT></B>, and <B><TT>foo</TT></B>.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> FromString("a := Sin(x)") \
In>    While((tok := ReadToken()) != EndOfFile) Echo(tok);
a 
:= 
Sin 
( 
x 
) 
Out> True;</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="ref.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="ref.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="ref.html#LispRead" TARGET="Chapters">
LispRead
</A>
.<A NAME="Load">

</A>
<H3>
<HR>Load -- Evaluate all expressions in a file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Load(name)
<H5>
Parameters:
</H5>
name - name of the file to load
<H5>
Description:
</H5>

The file "name" is opened. All expressions in the file are read and
evaluated. <B><TT>Load</TT></B> always returns <B><TT>true</TT></B>.
<H5>
See Also:
</H5>
<A HREF="ref.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="ref.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="ref.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
, <A HREF="ref.html#FindFile" TARGET="Chapters">
FindFile
</A>
.<A NAME="Use">

</A>
<H3>
<HR>Use -- Load a file, but not twice
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Use(name)
<H5>
Parameters:
</H5>
name - name of the file to load
<H5>
Description:
</H5>

If the file "name" has been loaded before, either by an earlier call
to <B><TT>Use</TT></B> or via the <B><TT>DefLoad</TT></B>
mechanism, nothing happens. Otherwise all expressions in the file are
read and evaluated. <B><TT>Use</TT></B> always returns <B><TT>true</TT></B>.
<P> </P>
The purpose of this function is to make sure that the file will at
least have been loaded, but is not loaded twice.
<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="ref.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
.<A NAME="DefLoad">

</A>
<H3>
<HR>DefLoad -- Load a .def file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DefLoad(name)
<H5>
Parameters:
</H5>
name - name of the file (without <B><TT>.def</TT></B> suffix)
<H5>
Description:
</H5>

The suffix <B><TT>.def</TT></B> is appended to "name" and the
file with this name is loaded. It should contain a list of functions,
terminated by a <B><TT>}</TT></B> (end-of-list character). This
tells the system to load the file "name" as soon as the user calls
one of the functions named in the file (if not done so already). This
allows for faster startup times, since not all of the rules databases
need to be loaded, just the descriptions on which files to load for
which functions.
<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="ref.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
.<A NAME="FindFile">

</A>
<H3>
<HR>FindFile -- Find a file in the current path
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FindFile(name)
<H5>
Parameters:
</H5>
name - name of the file to find
<H5>
Description:
</H5>

The result of this command is the full path to the file that would be
opened when the command <B><TT>Load(name)</TT></B> would be
invoked. This means that the input directories are subsequently
searched for a file called "name". If such a file is not found, <B><TT>FindFile</TT></B> returns an empty string.
<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
.<A NAME="PatchLoad">

</A>
<H3>
<HR>PatchLoad -- Execute commands between &lt? and ?&gt in file
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
PatchLoad(name)
<H5>
Parameters:
</H5>
name - the file to patch
<H5>
Description:
</H5>
PatchLoad loads in a file and outputs the contents to the current
output. The file can contain blocks delimited by &lt? and ?&gt
(meaning Yacas Begin and Yacas End). The piece of text between
such delimiters is treated as a separate file with Yacas instructions,
which is then loaded and executed. All output of write statements
in that block will be written to the same current output.
<P>  </P>
This is similar to the way php works. You can have a static text file
with dynamic content generated by Yacas.

<H5>
See Also:
</H5>
<A HREF="ref.html#PatchString" TARGET="Chapters">
PatchString
</A>
, <A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
.<A NAME="Nl">

</A>
<H3>
<HR>Nl -- A newline character
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Nl()
<H5>
Description:
</H5>

This function returns a string with one element in it, namely a newline
character. This may be useful for building strings to send to some
output in the end.
<P> </P>
Note that the second letter in the name of this command is a lower
case <B><TT>L</TT></B> (from "line").
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> WriteString("First line" : Nl() : "Second line" : Nl());
First line
Second line
Out> True;</PRE></TR>
</TABLE>

<H5>
See also:
</H5>
<A HREF="ref.html#NewLine" TARGET="Chapters">
NewLine
</A>
.<p>  </P><HR><A NAME="c15">

</A>
<A HREF="refchapter15.html#SetStringMid" TARGET="Chapters">
SetStringMid
</A>
, <A HREF="refchapter15.html#StringMid" TARGET="Chapters">
StringMid
</A>
, <A HREF="refchapter15.html#String, Atom" TARGET="Chapters">
String, Atom
</A>
, <A HREF="refchapter15.html#ConcatStrings" TARGET="Chapters">
ConcatStrings
</A>
, <A HREF="refchapter15.html#LocalSymbols" TARGET="Chapters">
LocalSymbols
</A>
, <A HREF="refchapter15.html#PatchString" TARGET="Chapters">
PatchString
</A>
.
<H1>
String manipulation
</H1>
<A NAME="SetStringMid">

</A>
<H3>
<HR>SetStringMid -- Change a substring
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
SetStringMid(index,substring,string)
<H5>
Parameters:
</H5>
index - index of substring to get <br>
substring - substring to store <br>
string - string to store substring in.

<H5>
Description:
</H5>
Set (change) a part of a string. It leaves the original alone, returning
a new changed copy.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> SetStringMid(3,"XY","abcdef")
Out> "abXYef";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#StringMid" TARGET="Chapters">
StringMid
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
.<A NAME="StringMid">

</A>
<H3>
<HR>StringMid -- Retrieve a substring
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
StringMid(index,length,string)
<H5>
Parameters:
</H5>
index - index of substring to get <br>
length - length of substring to get <br>
string - string to get substring from

<H5>
Description:
</H5>
StringMid returns a part of a string. Substrings can also be
accessed using the [] operator.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> StringMid(3,2,"abcdef")
Out> "cd";
In> "abcdefg"[2 .. 4]
Out> "bcd";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#SetStringMid" TARGET="Chapters">
SetStringMid
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
.<A NAME="String">

</A>
<A NAME="Atom">

</A>
<A NAME="String, Atom">

</A>
<H3>
<HR>String, Atom -- Convert atom to string and vice versa
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Atom(string) <br>
String(atom)

<H5>
Parameters:
</H5>
atom - an atom <br>
string - a string

<H5>
Description:
</H5>

Atom(string) : 
Returns an atom with the string representation given
as the evaluated argument. Example: "Atom("foo");" returns
foo.

<P>

String is the inverse of Atom: turns atom into "atom".

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> String(a)
Out> "a";
In> Atom("a")
Out> a;
</PRE></TR>
</TABLE>

<A NAME="ConcatStrings">

</A>
<H3>
<HR>ConcatStrings -- Concatenate strings
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
ConcatStrings(strings)
<H5>
Parameters:
</H5>
strings - one or more strings
<H5>
Description:
</H5>

ConcatStrings concatenates strings. Example:
"ConcatStrings("a","b","c");" will return "abc".

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> ConcatStrings("a","b","c")
Out> "abc";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#:" TARGET="Chapters">
:
</A>
.<A NAME="LocalSymbols">

</A>
<H3>
<HR>LocalSymbols -- Create unique local symbols with given prefix
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
LocalSymbols(...)body
<H5>
Parameters:
</H5>
... - list of symbols <br>
body - expression to execute

<H5>
Description:
</H5>
Given the symbols passed as the first arguments to LocalSymbols
a set of local symbols will be created, and creates unique ones
for them, typically of the form $<symbol><number>, where
symbol was the symbol entered by the user, and number is a unique
number. This scheme was used
to such a generated symbol can not accientally be entered by a user.

<P>

This is useful in cases where a guaranteed free variable is needed,
like in the macro-like functions (For, While, etc.).

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> LocalSymbols(a,b)a+b
Out> $a6+ $b6;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#UniqueConstant" TARGET="Chapters">
UniqueConstant
</A>
.<A NAME="PatchString">

</A>
<H3>
<HR>PatchString -- Execute commands between &lt? and ?&gt in string
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
PatchString(string)
<H5>
Parameters:
</H5>
string - a string to patch
<H5>
Description:
</H5>
This function does the same as PatchLoad, but it works on a string
in stead of on the contents of a text file. See PatchLoad for more
details.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PatchString("Two plus three is &lt? Write(2+3); ?&gt ");
Out> "Two plus three is 5 ";
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PatchLoad" TARGET="Chapters">
PatchLoad
</A>
.<p>  </P><HR><A NAME="c1">

</A>
<A HREF="refprogchapter1.html#Prog" TARGET="Chapters">
Prog
</A>
, <A HREF="refprogchapter1.html#Check" TARGET="Chapters">
Check
</A>
, <A HREF="refprogchapter1.html#Prefix" TARGET="Chapters">
Prefix
</A>
, <A HREF="refprogchapter1.html#Postfix" TARGET="Chapters">
Postfix
</A>
, <A HREF="refprogchapter1.html#Bodied" TARGET="Chapters">
Bodied
</A>
, <A HREF="refprogchapter1.html#Infix" TARGET="Chapters">
Infix
</A>
, <A HREF="refprogchapter1.html#IsInfix" TARGET="Chapters">
IsInfix
</A>
, <A HREF="refprogchapter1.html#IsPrefix" TARGET="Chapters">
IsPrefix
</A>
, <A HREF="refprogchapter1.html#IsPostfix" TARGET="Chapters">
IsPostfix
</A>
, <A HREF="refprogchapter1.html#OpPrecedence" TARGET="Chapters">
OpPrecedence
</A>
, <A HREF="refprogchapter1.html#RightAssociative" TARGET="Chapters">
RightAssociative
</A>
, <A HREF="refprogchapter1.html#LeftPrecedence" TARGET="Chapters">
LeftPrecedence
</A>
, <A HREF="refprogchapter1.html#RightPrecedence" TARGET="Chapters">
RightPrecedence
</A>
, <A HREF="refprogchapter1.html#RuleBase" TARGET="Chapters">
RuleBase
</A>
, <A HREF="refprogchapter1.html#Rule" TARGET="Chapters">
Rule
</A>
, <A HREF="refprogchapter1.html#HoldArg" TARGET="Chapters">
HoldArg
</A>
, <A HREF="refprogchapter1.html#Retract" TARGET="Chapters">
Retract
</A>
, <A HREF="refprogchapter1.html#UnFence" TARGET="Chapters">
UnFence
</A>
, <A HREF="refprogchapter1.html#MacroSet" TARGET="Chapters">
MacroSet
</A>
, <A HREF="refprogchapter1.html#MacroClear" TARGET="Chapters">
MacroClear
</A>
, <A HREF="refprogchapter1.html#MacroLocal" TARGET="Chapters">
MacroLocal
</A>
, <A HREF="refprogchapter1.html#MacroRuleBase" TARGET="Chapters">
MacroRuleBase
</A>
, <A HREF="refprogchapter1.html#MacroRule" TARGET="Chapters">
MacroRule
</A>
, <A HREF="refprogchapter1.html#Secure" TARGET="Chapters">
Secure
</A>
.
<H1>
Programming
</H1>
<H3>
<HR>/* comment */
</H3>

A comment block in a source file.


<A NAME="Prog">

</A>
<H3>
<HR>Prog(...)
</H3>

Prog(...) : Evaluate the arguments in order, and return the result of the
last evaluated expression.
This is the same as the "[ ... ]" constuct, that
is, "Prog(a,b);" is the same as typing "[a;b;];" and is
very useful for writing out function bodies (the "[...]" construct
is converted into "Prog(...)" during the parsing stage)


<A NAME="Check">

</A>
<H3>
<HR>Check(predicate,"error")
</H3>

Check(predicate,"error") : 
If "predicate" doesn't evaluate to "True",
then current operation will be stopped, and execution
will jump right back to the command line, showing
"error". Use this to assure that some condition
is met during evaluation of expressions (guarding
against internal errors).


<A NAME="Prefix">

</A>
<H3>
<HR>Prefix("operator")
</H3>

Prefix("operator") : Defines a new operator for the prefix parser
to understand. This function can also be called with an additional argument
for the precedence of the prefix operator.

<A NAME="Postfix">

</A>
<H3>
<HR>Postfix("oper")
</H3>

Postfix("oper") : Defines a new operator for the postfix parser to understand.


<A NAME="Bodied">

</A>
<H3>
<HR>Bodied("oper",precedence)
</H3>

Bodied("oper",precedence) : Defines a new operator for the bodied parser to understand.



<A NAME="Infix">

</A>
<H3>
<HR>Infix("oper",precedence)
</H3>

Infix("oper",precedence) : Defines a new operator for the infix parser to understand.
"precedence" is evaluated.


<A NAME="IsInfix">

</A>
<A NAME="IsPrefix">

</A>
<A NAME="IsPostfix">

</A>
<H3>
<HR>IsInfix("str"), IsPrefix("str"), IsPostfix("str")
</H3>

Returns wether str is an infix, prefix, or postfix operator.
IsInfix("+") should return True. IsInfix("a") should return False.


<A NAME="OpPrecedence">

</A>
<H3>
<HR>OpPrecedence("str")
</H3>

Returns the precedence of the infix operator str. OpPrecedence("+")
should return 6.


<A NAME="RightAssociative">

</A>
<H3>
<HR>RightAssociative("operator")
</H3>

makes the operator right-associative. Example: RightAssociative("*")
would make multiplication right-associative. Take care not to abuse
this function, because the reverse, making an infix operator
left-associative, is not implemented.


<A NAME="LeftPrecedence">

</A>
<A NAME="RightPrecedence">

</A>
<H3>
<HR>LeftPrecedence("oper",precedence), RightPrecedence("oper",precedence)
</H3>


oper should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display a-(b-c)
correctly. a+b+c is the same as a+(b+c), but a-(b-c) is not
the same as a-b-c.


<A NAME="RuleBase">

</A>
<H3>
<HR>RuleBase("operator",{params})
</H3>

RuleBase("operator",{params}) : Define a new rules table entry for a
function "operator", with {params} as the parameter list.


<A NAME="Rule">

</A>
<H3>
<HR>Rule("operator",arity,precedence,predicate) body
</H3>

Rule("operator",arity,precedence,predicate) body : 
Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". "precedence" is checked from low to high.
The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.
Rules with a low value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.


<A NAME="HoldArg">

</A>
<H3>
<HR>HoldArg("operator",parameter)
</H3>

HoldArg("operator",parameter) : 
Specify that parameter (which should be part of
a parameter list for a function "operator") should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all RuleBase calls for this operator.


<A NAME="Retract">

</A>
<H3>
<HR>Retract("operator",arity)
</H3>

Retract("operator",arity) : Remove a rulebase with some specific arity,
if it exists at all.


<A NAME="UnFence">

</A>
<H3>
<HR>UnFence("operator",arity)
</H3>

UnFence("operator",arity) : When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and the such). The For and ForEach functions
defined in the standard packages use this, for instance.


<A NAME="MacroSet">

</A>
<A NAME="MacroClear">

</A>
<A NAME="MacroLocal">

</A>
<A NAME="MacroRuleBase">

</A>
<A NAME="MacroRule">

</A>
<H3>
<HR>MacroSet, MacroClear,MacroLocal, MacroRuleBase,MacroRule
</H3>


Same as their non-macro counterparts, except
that their arguments are evaluated before
the required action is performed. This is
useful in macro-like procedures.


<A NAME="Secure">

</A>
<H3>
<HR>Secure(body)
</H3>

Secure evaluates body in a safe environment, where file opening
and system calls are not allowed. This can protect the system
when an unsafe evaluation is done (Like a script sent over the
internet to be evaluated on a computer).

<p>  </P><HR><A NAME="c2">

</A>
<A HREF="refprogchapter2.html#MathNot" TARGET="Chapters">
MathNot
</A>
, <A HREF="refprogchapter2.html#MathAnd" TARGET="Chapters">
MathAnd
</A>
, <A HREF="refprogchapter2.html#MathOr" TARGET="Chapters">
MathOr
</A>
, <A HREF="refprogchapter2.html#BitAnd" TARGET="Chapters">
BitAnd
</A>
, <A HREF="refprogchapter2.html#BitOr" TARGET="Chapters">
BitOr
</A>
, <A HREF="refprogchapter2.html#BitXor" TARGET="Chapters">
BitXor
</A>
, <A HREF="refprogchapter2.html#Equals" TARGET="Chapters">
Equals
</A>
, <A HREF="refprogchapter2.html#LessThan" TARGET="Chapters">
LessThan
</A>
, <A HREF="refprogchapter2.html#GreaterThan" TARGET="Chapters">
GreaterThan
</A>
, <A HREF="refprogchapter2.html#ShiftLeft" TARGET="Chapters">
ShiftLeft
</A>
, <A HREF="refprogchapter2.html#ShiftRight" TARGET="Chapters">
ShiftRight
</A>
.
<H1>
Built-in functions
</H1>
<A NAME="MathNot">

</A>
<H3>
<HR>MathNot(expression)
</H3>

MathNot(expression) : 
Returns "False" if "expression" evaluates
to "True", and vice versa.


<A NAME="MathAnd">

</A>
<H3>
<HR>MathAnd(...)
</H3>

MathAnd(...) : 
Lazy and: returns True" if all args evaluate to
"True", and does this by looking at first, and then at the
second argument, until one is "False".
If one is "False" it immediately returns "False" without
evaluating the rest. This is faster, but also means that none of the
arguments should cause side effects when they are evaluated.


<A NAME="MathOr">

</A>
<H3>
<HR>MathOr(...)
</H3>

MathOr(...) : 
MathOr is the or equivalent of And. It is lazy-evaluated too.
"And(...)" and "Or(...)" do also exist. You can define
them as infix operators
yourself, so you have the choice of precedence. In the standard scripts
they are in fact declared as infix operators, so you can write
"expr1 And expr".


<A NAME="BitAnd">

</A>
<A NAME="BitOr">

</A>
<A NAME="BitXor">

</A>
<H3>
<HR>BitAnd(n,m), BitOr(n,m), BitXor(n,m)
</H3>

BitAnd(n,m), BitOr(n,m), BitXor(n,m) : return bitwise and, or and xor
of two numbers.


<A NAME="Equals">

</A>
<H3>
<HR>Equals(a,b)
</H3>

Equals(a,b) : 
Compares evaluated a and b recursively
(stepping into expressions). so "Equals(a,b)" returns
"True" if the expressions would be printed exactly
the same, and "False" otherwise.


<A NAME="LessThan">

</A>
<A NAME="GreaterThan">

</A>
<H3>
<HR>LessThan(a,b), GreaterThan(a,b)
</H3>

LessThan(a,b), GreaterThan(a,b) : 
Comparing numbers.

<H3>
<HR>Math...
</H3>


MathGcd(n,m)  (Greatest Common Divisor),
MathAdd(x,y),
MathSubtract(x,y),
MathMultiply(x,y),
MathDivide(x,y),
MathSqrt(x)  (Square root),
MathFloor(x), MathCeil(x),
MathAbs(x), MathMod(x,y),
MathExp(x), MathLog(x) (Natural logarithm),
MathPower(x,y),
MathSin(x), MathCos(x), MathTan(x),
MathArcSin(x), MathArcCos(x), MathArcTan(x),
MathDiv(x,y), MathMod(x,y) :
MathSqrt(x) (Square root),

Calculation of sin,cos,tan etc. of x. x HAS to
be a number. The reason Math is prepended to
the names is you might want to derive equivalent
non-evaluating functions. The Math... versions require the arguments
to be numbers.


<H3>
<HR>Fast...
</H3>


FastExp(x), FastLog(x) (Natural logarithm),
FastPower(x,y),
FastSin(x), FastCos(x), FastTan(x),
FastArcSin(x), FastArcCos(x), FastArcTan(x) :

Versions of these functions using the internal c version. These
should then at least be faster than the arbitrary precision versions.


<A NAME="ShiftLeft">

</A>
<A NAME="ShiftRight">

</A>
<H3>
<HR>ShiftLeft(number,bits), ShiftRight(number,bits)
</H3>

ShiftLeft(number,bits), ShiftRight(number,bits) : 
Shift number bits to left or right.


<p>  </P><HR><A NAME="c3">

</A>
<A HREF="refprogchapter3.html#DllLoad" TARGET="Chapters">
DllLoad
</A>
, <A HREF="refprogchapter3.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="refprogchapter3.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="refprogchapter3.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="refprogchapter3.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="refprogchapter3.html#StubApiCRemark" TARGET="Chapters">
StubApiCRemark
</A>
, <A HREF="refprogchapter3.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A HREF="refprogchapter3.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="refprogchapter3.html#StubApiCStruct" TARGET="Chapters">
StubApiCStruct
</A>
.
<H1>
The Yacas plugin structure
</H1>
Yacas supports dynamically loading libraries at runtime. This allows
it to interface with other libraries that support additional
functionality. For example, there could be a plugin enabling
the user to script a user interface from within Yacas, or a
specific powerful library to do numeric calculations.
<P>  </P>
The plugin feature is currently in an experimental stage. There
are some examples in the plugins/ directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The plugins/ directory
contains a README file with more details on compilation. 
<P>  </P>
In addition to the plugin structure in the Yacas engine, there is
a 'cstubgen' module (currently still in development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. the 'cstubgen' module is then
able to write out a c++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the plugins/
directory (the files ending with api.stub). The make file
makefile.plugin is configured to automatically convert these to
the required c++ files.
<P>  </P>
In addition to the c++ stub file cstubgen also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.
<P>  </P>
The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(loading DLLs is platform-dependent).
<P>  </P>
This chapter assumes the reader is comfortable programming in c++.

<A NAME="DllLoad">

</A>
<H3>
<HR>DllLoad
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DllLoad(file)
<H5>
Parameters:
</H5>
file - file name of the plugin
<H5>
Description:
</H5>
DllLoad forces Yacas to load the dynamic link library (.so file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where dlopen can find it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DllLoad("./libopengl.so");
Out> True;
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="StubApiCStart">

</A>
<H3>
<HR>StubApiCStart
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCStart()
<H5>
Parameters:
</H5>

<H5>
Description:
</H5>
To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub c++ file.
<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
.<A NAME="StubApiCShortIntegerConstant">

</A>
<H3>
<HR>StubApiCShortIntegerConstant
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCShortIntegerConstant(const,value)
<H5>
Parameters:
</H5>
const - string representing the global variable to be bound runtime <br>
       value - integer value the global should be bound to
<H5>
Description:
</H5>
define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define <br>
#define FOO 10 <br>
Then  <br>
StubApiCShortIntegerConstant("FOO","FOO") <br>
will bind the global variable FOO to the value for FOO defined in
the library header file.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
.<A NAME="StubApiCInclude">

</A>
<H3>
<HR>StubApiCInclude
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCInclude(file)
<H5>
Parameters:
</H5>
file - file to include from the library the plugin is based on
<H5>
Description:
</H5>
Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for opengl, you need to specify <br>
StubApiCInclude("&lt;GL/gl.h&gt;") <BR>
and for user include file:
StubApiCInclude("\"GL/gl.h\"") <BR>

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
.<A NAME="StubApiCFunction">

</A>
<H3>
<HR>StubApiCFunction
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCFunction(returntype,fname,args) <br>
StubApiCFunction(returntype,fname,fname2,args)

<H5>
Parameters:
</H5>

returntype - return type of library function <br>
fname - function of built-in function <br>
fname2 - (optional) function name to be used from within Yacas <br>
args - list of arguments to the function

<H5>
Description:
</H5>
This function declares a library function, along with its
calling sequence. cstubgen will then generate the c++ code
required to call this function.
<P>  </P>
Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).
<P>  </P>
If fname2 is not supplied, it will be assumed to be the same as fname.
<P>  </P>
The return types currently supported are "int", "double" and "void".

The argument values that are currently supported
are "int", "double", and "input_string".

Argument types can be specified simply as a string referring to their
type, like "int", or they can be lists with an additional element
stating the name of the variable: {"int","n"}. The variable
will then show up in the automatically generated documentation as
having the name n.

<H5>
Examples:
</H5>
To define the opengl function glVertex3d that accepts three
doubles and returns void:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCFunction("void","glVertex3d",{"double","double","double"});
</PRE></TR>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
.<A NAME="StubApiCRemark">

</A>
<H3>
<HR>StubApiCRemark
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCRemark(string)
<H5>
Parameters:
</H5>
string - remark string to be added to the documentation
<H5>
Description:
</H5>
StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a .description file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
.<A NAME="StubApiCSetEnv">

</A>
<H3>
<HR>StubApiCSetEnv
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCSetEnv(func)
<H5>
Parameters:
</H5>
func - function to call to set the environment variable
<H5>
Description:
</H5>
This function forces the plugin to call the function func, with as
argument LispEnvironment& aEnvironment. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.
<P>  </P>
There needs to ba a function in the plugin somewhere of the form 

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>static LispEnvironment* env = NULL;
void GlutSetEnv(LispEnvironment& aEnv)
{
    env = &aEnv;
}
</PRE></TR>
</TABLE>

Then calling

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCSetEnv("GlutSetEnv");

</PRE></TR>
</TABLE>

will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
.<A NAME="StubApiCFile">

</A>
<H3>
<HR>StubApiCFile
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCFile(basename)
<H5>
Parameters:
</H5>
basename - basename for the generation of the stub file
<H5>
Description:
</H5>
Generate the c++ stub file, "basename.cc", and a documentation file
named "basename.description". The descriptions are automatically
generated while adding functions and constants to the stub.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
.<A NAME="StubApiCStruct">

</A>
<H3>
<HR>StubApiCStruct
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCStruct(name) <br>
StubApiCStruct(name,freefunction)

<H5>
Parameters:
</H5>
name - name of structure <br>
freefunction - function that can be called to clean up the object

<H5>
Description:
</H5>
StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.
<P>  </P>
By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.

<H5>
Examples:
</H5>
in a library header file, define:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>typedef struct SomeStruct
{
  int a;
  int b;
} SomeStruct;
</PRE></TR>
</TABLE>
Then in the stub file you can declare this struct by calling:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCStruct("SomeStruct*")
</PRE></TR>
</TABLE>



<H5>
See Also:
</H5>
<A HREF="ref.html" TARGET="Chapters">

</A>
, <A HREF="ref.html" TARGET="Chapters">

</A>
.<p>  </P><HR><A NAME="c4">

</A>
<A HREF="refprogchapter4.html#IsGeneric" TARGET="Chapters">
IsGeneric
</A>
, <A HREF="refprogchapter4.html#GenericTypeName" TARGET="Chapters">
GenericTypeName
</A>
, <A HREF="refprogchapter4.html#ArrayCreate" TARGET="Chapters">
ArrayCreate
</A>
, <A HREF="refprogchapter4.html#ArraySize" TARGET="Chapters">
ArraySize
</A>
, <A HREF="refprogchapter4.html#ArrayGet" TARGET="Chapters">
ArrayGet
</A>
, <A HREF="refprogchapter4.html#ArraySet" TARGET="Chapters">
ArraySet
</A>
, <A HREF="refprogchapter4.html#ArrayCreateFromList" TARGET="Chapters">
ArrayCreateFromList
</A>
, <A HREF="refprogchapter4.html#ListFromArray" TARGET="Chapters">
ListFromArray
</A>
.
<H1>
Generic objects
</H1>

Generic objects are objects that are implemented in c++, but
can be accessed through the Yacas interpreter.

<A NAME="IsGeneric">

</A>
<H3>
<HR>IsGeneric(object)
</H3>

IsGeneric(object) : returns whether an object is a generic object
type.

<A NAME="GenericTypeName">

</A>
<H3>
<HR>GenericTypeName(object)
</H3>

GenericTypeName(object) : returns a string representation of
the name of a generic object. <BR>

Example: GenericTypeName(ArrayCreate(10,1)) sould return "Array".

<A NAME="ArrayCreate">

</A>
<H3>
<HR>ArrayCreate(size,init)
</H3>

Create an array the with size elements, all initialized to the
value init.

<A NAME="ArraySize">

</A>
<H3>
<HR>ArraySize(array)
</H3>

Return the size of an array (number of elements in the array).

<A NAME="ArrayGet">

</A>
<H3>
<HR>ArrayGet(array,index)
</H3>

Get the element at position index in the array passed. Arrays are treated
as base-one, so index set to 1 would return the first element. <BR>

Arrays can also be accessed through the [] operators. So
array[index] would return the same as ArrayGet(array,index).

<A NAME="ArraySet">

</A>
<H3>
<HR>ArraySet(array,index,element)
</H3>

Set the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so index set to 1 would set first element. <BR>

Arrays can also be accessed through the [] operators. So
array[index]:=element would do the same as ArraySet(array,index,element).

<A NAME="ArrayCreateFromList">

</A>
<H3>
<HR>ArrayCreateFromList(list)
</H3>

Creates an array from the contents of the list passed in.

<A NAME="ListFromArray">

</A>
<H3>
<HR>ListFromArray(array)
</H3>

Creates a list from the contents of the array passed in.

<p>  </P><HR>
</BODY>

</FONT>

</HTML>
