<HTML>
<HEAD><TITLE>Yacas users function reference</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Yacas users function reference
</H1>
<UL>
<LI>
<A HREF="ref.html#c1">
Startup configuration
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c2">
Arithmetic
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c3">
Other operations on numbers
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c4">
Calculus
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c5">
Linear Algebra
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c6">
Polynomials
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c7">
List operations
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c8">
Functional operators
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c9">
Control flow functions
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c10">
Predicates
</A>

</LI>
<UL>
<LI>
<A HREF="ref.html#c10s1">
Predicates on numbers
</A>

</LI>

</UL>
<LI>
<A HREF="ref.html#c11">
Propositional logic theorem prover
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c12">
Constants
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c13">
Variables
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c14">
Input/Output
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c1">
Programming
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c2">
Built-in functions
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c3">
The Yacas plugin structure
</A>

</LI>
<UL>

</UL>
<LI>
<A HREF="ref.html#c4">
Generic objects
</A>

</LI>
<UL>

</UL>

</UL>
<A NAME="c1">

</A>
<A HREF="refchapter1.html#DefaultDirectory" TARGET="Chapters">
DefaultDirectory
</A>
, <A HREF="refchapter1.html#PrettyPrinter" TARGET="Chapters">
PrettyPrinter
</A>
, <A HREF="refchapter1.html#Help" TARGET="Chapters">
Help
</A>
, <A HREF="refchapter1.html#HistorySize" TARGET="Chapters">
HistorySize
</A>
, <H1>
Startup configuration
</H1>
Yacas allows you to configure a few things at startup. The file
~/.yacasrc will be executed when Yacas is run. The followinf functions
can be useful when used in the ~/.yacasrc file.
<A NAME="DefaultDirectory">

</A>
<H3>
<HR>DefaultDirectory
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DefaultDirectory(path)
<H5>
Parameters:
</H5>
path - a string containing a full path where yacas script files reside
<H5>
Description:
</H5>
When loading files, yacas is also allowed to
look in the folder "path". path will be prepended
to the file name before trying to load the file.
This means that "path" should end with a forward slash (under unix-like
operating systems). <br>
Yacas first tries to load a file from the current
directory, and otherwise it tries to load from
directories defined with this function, in the
order they are defined. Note there will be at least one directory
specified at start-up time, defined during compilation. This
is the directory Yacas searches for the initialization scripts
and standard scripts.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DefaultDirectory("/home/user/myscripts/");
Out> True;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="ref.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="ref.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="ref.html#FindFile" TARGET="Chapters">
FindFile
</A>
, <A NAME="PrettyPrinter">

</A>
<H3>
<HR>PrettyPrinter
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
PrettyPrinter(printer)
<H5>
Parameters:
</H5>
printer - a string containing the name of a function that can
pretty-print an expression
<H5>
Description:
</H5>
PrettyPrinter(printer) sets up the function printer to print
out the results on the command line. <br>

This function can be reset to the internal printer with
<B><TT>PrettyPrinter()</TT></B>

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
In> PrettyPrinter("PrettyForm");

True

Out> 
In> Taylor(x,0,5)Sin(x)

     3    5 
    x    x  
x - -- + ---
    6    120

Out> 
In> PrettyPrinter();
Out> True;
In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="ref.html#Write" TARGET="Chapters">
Write
</A>
, <A NAME="Help">

</A>
<H3>
<HR>Help
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Help() <br> Help(function)
<H5>
Parameters:
</H5>
function - a string containing the name of a function to show help for
<H5>
Description:
</H5>
When help is requested by the user, by typing ?function or ??, the
functions Help() (for ??) and Help(function) (for ?function) are called.
By default, lynx is used as a browser. The help resides in the subdirectory
documentation/ under the directory the math scripts were installed in. So
the help files can be found using FindFile.
<H5>
Examples:
</H5>
To use netscape for browsing help, enter the following commands:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Help(_f) <-- SystemCall("netscape ":FindFile("documentation/ref.html"):"#":f);
Help() := SystemCall("netscape ":FindFile("documentation/books.html"));
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#SystemCall" TARGET="Chapters">
SystemCall
</A>
, <A HREF="ref.html#FindFile" TARGET="Chapters">
FindFile
</A>
, <A NAME="HistorySize">

</A>
<H3>
<HR>HistorySize
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
HistorySize(n)
<H5>
Parameters:
</H5>
n - number of lines to store in history file
<H5>
Description:
</H5>
When exiting, yacas saves the command line history to a
file ~/.yacas_history . By default it will only save the last 50
lines, to save space on the harddisk. This can be overridden with this
function. Passing -1 tells the system to save all the lines.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> HistorySize(200)
Out> True;
In> quit
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<p><HR><A NAME="c2">

</A>
<A HREF="refchapter2.html#+" TARGET="Chapters">
+
</A>
, <A HREF="refchapter2.html#-" TARGET="Chapters">
-
</A>
, <A HREF="refchapter2.html#*" TARGET="Chapters">
*
</A>
, <A HREF="refchapter2.html#/" TARGET="Chapters">
/
</A>
, <A HREF="refchapter2.html#^" TARGET="Chapters">
^
</A>
, <H1>
Arithmetic
</H1>
<A NAME="+">

</A>
<A NAME="-">

</A>
<A NAME="*">

</A>
<A NAME="/">

</A>
<A NAME="^">

</A>
<H3>
<HR>Arithmetic operations
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
x+y (precedence 6)  <br>
+x                   <br>
x-y (precedence 5)   <br>
-x                   <br>
x*y (precedence 3)   <br>
x/y (precedence 3)   <br>
x^y (precedence 2)   

<H5>
Parameters:
</H5>
x and y - some objects for which arithmetic operations are defined.
<H5>
Description:
</H5>
These are the basic arithmetic operations. They can work on integers,
rational numbers, complex numbers, vectors, matrices and lists. <br>
These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2+3
Out> 5;
In> 2*3
Out> 6;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<p><HR><A NAME="c3">

</A>
<A HREF="refchapter3.html#Div" TARGET="Chapters">
Div
</A>
, <A HREF="refchapter3.html#Mod" TARGET="Chapters">
Mod
</A>
, <A HREF="refchapter3.html#Gcd" TARGET="Chapters">
Gcd
</A>
, <A HREF="refchapter3.html#Lcm" TARGET="Chapters">
Lcm
</A>
, <A HREF="refchapter3.html#&lt;&lt;" TARGET="Chapters">
&lt;&lt;
</A>
, <A HREF="refchapter3.html#&gt;&gt;" TARGET="Chapters">
&gt;&gt;
</A>
, <A HREF="refchapter3.html#FromBase" TARGET="Chapters">
FromBase
</A>
, <A HREF="refchapter3.html#ToBase" TARGET="Chapters">
ToBase
</A>
, <A HREF="refchapter3.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="refchapter3.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A HREF="refchapter3.html#N" TARGET="Chapters">
N
</A>
, <A HREF="refchapter3.html#Rationalize" TARGET="Chapters">
Rationalize
</A>
, <A HREF="refchapter3.html#IsPrime" TARGET="Chapters">
IsPrime
</A>
, <A HREF="refchapter3.html#IsPrimePower" TARGET="Chapters">
IsPrimePower
</A>
, <A HREF="refchapter3.html#Factors" TARGET="Chapters">
Factors
</A>
, <A HREF="refchapter3.html#Factor" TARGET="Chapters">
Factor
</A>
, <A HREF="refchapter3.html#PAdicExpand" TARGET="Chapters">
PAdicExpand
</A>
, <A HREF="refchapter3.html#ContFrac" TARGET="Chapters">
ContFrac
</A>
, <A HREF="refchapter3.html#Decimal" TARGET="Chapters">
Decimal
</A>
, <A HREF="refchapter3.html#TruncRadian" TARGET="Chapters">
TruncRadian
</A>
, <H1>
Other operations on numbers
</H1>
<A NAME="Div">

</A>
<A NAME="Mod">

</A>
<H3>
<HR>Div and Mod
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Div(x,y) <br>
Mod(x,y)

<H5>
Parameters:
</H5>
x and y - integers
<H5>
Description:
</H5>
Div performs integer division and Mod returns the remainder
after division. Div and Mod are also defined for polynomials.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Div(5,3)
Out> 1;
In> Mod(5,3)
Out> 2;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="Gcd">

</A>
<H3>
<HR>Gcd
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Gcd(n,m)   <br>
Gcd(list)
<H5>
Parameters:
</H5>

n,m - integers or univariate polynomials <br>
list - a list of all integers or all univariate polynomials

<H5>
Description:
</H5>
Gcd(n,m) returns the greatest common divisor of n and m.
The gcd is the largest number that divides n and m.
The library code calls MathGcd, which is an internal function.
This function implements the binary Euclidean algorithm for
determining the greatest common divisor:


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Routine for calculating Gcd(n,m)

1) if n = m then return n
2) if both n and m are even then return 2*Gcd(n/2,m/2)
3) if exactly one of n or m (say n) is even then return Gcd(n/2,m)
4) if both n and m are odd and, say, n>m then return Gcd( (n-m)/2,m)
</PRE>
</TABLE>
This is a rather fast algorithm on computers that can efficiently shift
integers. <br>

Gcd(list), with list a list of arbitrary length
of integers, will return the greatest common divisor of all the integers
listed.
For lists Gcd uses the identity


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Gcd({a,b,c}) = Gcd(Gcd(a,b),c)
</PRE>
</TABLE>


<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Gcd(55,10)
Out> 5;
In> Gcd({60,24,120})
Out> 12;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Lcm" TARGET="Chapters">
Lcm
</A>
, <A NAME="Lcm">

</A>
<H3>
<HR>Lcm
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Lcm(n,m)
<H5>
Parameters:
</H5>
n,m - integers
<H5>
Description:
</H5>
Lcm(n,m) : returns the least common multiple of a and b.
The least common multiple L of two numbers n,m is the number L=Lcm(n,m)
for which there are two integers p,q so such that p*n=q*m=L.
This is calculated with the formula:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Lcm(n,m) = Div(n*m,Gcd(n,m))
</PRE>
</TABLE>

This means it also works
on polynomials, since Div, Gcd and multiplication are also defined
for them.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Lcm(60,24)
Out> 120;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Gcd" TARGET="Chapters">
Gcd
</A>
, <A NAME="&lt;&lt;">

</A>
<A NAME="&gt;&gt;">

</A>
<H3>
<HR>&lt;&lt; and &gt;&gt;
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
n&lt;&lt;m and n&gt;&gt;m
<H5>
Parameters:
</H5>
n,m - integers
<H5>
Description:
</H5>
These operators shift integers to the left or to the right.
They are similar to the c shift operators. These are sign-extended
shifts, so they act like multiplication or division by powers of 2.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Examples:
1&lt;&lt;10; should evaluate to 1024
-1024&gt;&gt;10; should evaluate to -1
</PRE>
</TABLE>

<A NAME="FromBase">

</A>
<A NAME="ToBase">

</A>
<H3>
<HR>FromBase and ToBase
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
FromBase(base,number) <br>
ToBase(base,number)

<H5>
Parameters:
</H5>
base - a base to write the numbers in <br>
number - a number to write out in the base representation
<H5>
Description:
</H5>
Conversion of numbers to and from base 10 numbers.<p>

These functions use the p-adic expansion capabilities of the built-in
arbitrary precision math libraries.  

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> FromBase(2,111111)
Out> 63;
In> ToBase(16,255)
Out> ff;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="Precision">

</A>
<A NAME="GetPrecision">

</A>
<H3>
<HR>Precision and GetPrecision
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Precision(n) <br>
GetPrecision()
<H5>
Parameters:
</H5>
n - required number of digits precision
           required for following calculations, in base 10.
<H5>
Description:
</H5>
Precision and GetPrecision can be used to get and set the
required number of digits of precision in base 10 in the environment.
All subsequent floating point operations will allow for at least n
digits after the decimal point.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Precision(10)
Out> True;
In> N(Sin(1))
Out> 0.8414709848;
In> Precision(20)
Out> True;
In> N(Sin(1))
Out> 0.84147098480789650665;
In> GetPrecision()
Out> 20;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A NAME="N">

</A>
<H3>
<HR>N
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
N(expression) <br>
N(expression,precision)
<H5>
Parameters:
</H5>
expression - expression to evaluate <br>
precision - precision to use
<H5>
Description:
</H5>
Normally numeric values are left as-is as long
as possible in calculations using division, or trigonometric functions
like Sin, Cos, etcetera.
N forces Yacas to calculate floating point representations
of functions whenever possible, using the current precision or the
specified precision. <p>

In addition, the variable Pi is bound to the value of pi up to the
required precision.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 1/2
Out> 1/2;
In> N(1/2)
Out> 0.5;
In> Sin(1)
Out> Sin(1);
In> N(Sin(1),10)
Out> 0.8414709848;
In> Pi
Out> Pi;
In> N(Pi,20)
Out> 3.14159265358979323846;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="ref.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A NAME="Rationalize">

</A>
<H3>
<HR>Rationalize
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Rationalize(expression)
<H5>
Parameters:
</H5>
expression - expression to rationalize
<H5>
Description:
</H5>
Rationalize scans the entire expression replacing all floating
point values into rational representations p/q for some integers p and
q, such that the division of p by q gives the original floating point
value up to the number of digits of the original floating point value. <p>

It does this by finding the smallest integer n such that
multiplying the number with 10^n is an integer. Then it divides by 10^n
again, depending on the internal gcd calculation to reduce the resulting
division of integers.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(1.234)
Out> Sin(1.234);
In> Rationalize(%)
Out> Sin(617/500);
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Precision" TARGET="Chapters">
Precision
</A>
, <A HREF="ref.html#GetPrecision" TARGET="Chapters">
GetPrecision
</A>
, <A NAME="IsPrime">

</A>
<H3>
<HR>IsPrime(n)
</H3>
IsPrime(n) : returns True if n is prime, False otherwise.
<A NAME="IsPrimePower">

</A>
<H3>
<HR>IsPrimePower(n)
</H3>
IsPrimePower(n) : returns True if there is a prime p such that
p^m = n.
<A NAME="Factors">

</A>
<A NAME="Factor">

</A>
<H3>
<HR>Factor and Factors
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Factor(x) <br>
Factors(x)
<H5>
Parameters:
</H5>
x - an integer number or univariate polynomial to factor
<H5>
Description:
</H5>
Factors decomposes integer numbers or univariate polynomials
into a product of primes or irreducible polynomials. <p>

The result of Factors is a list of lists of the form {p,n}, where each
p^n divides the original x. <p>

Factor shows the result of Factors in a nicer human readable format.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Factors(12)
Out> {{2,2},{3,1}};
In> PrettyForm(Factor(12))

 2    
2  * 3

</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="PAdicExpand">

</A>
<H3>
<HR>PAdicExpand(n,p)
</H3>

PAdicExpand returns the p-adic expansion of n:

<P>


n = a0 +a1*p +a2*p^2+...

<P>


So for instance

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PrettyForm(PAdicExpand(1234,10))

                   2     3
4 + 3 * 10 + 2 * 10  + 10 

Out> True;</PRE>
</TABLE>

This function should also work on polynomials.

<A NAME="ContFrac">

</A>
<H3>
<HR>ContFrac(x) or ContFrac(x,maxdepth)
</H3>

Return the continued fraction expansion of a floating point
number. Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PrettyForm(ContFrac(N(Pi)))

                 1             
3 + ---------------------------
                   1           
    7 + -----------------------
                     1         
        15 + ------------------
                       1       
             1 + --------------
                          1    
                 292 + --------
                       1 + rest
</PRE>
</TABLE>




<A NAME="Decimal">

</A>
<H3>
<HR>Decimal(frac)
</H3>

Decimal(frac) : return the infinite decimal representation
of a number. This function returns a list, with the first
element being the number before the decimal point and the
last element the sequence of digits that will repeat
forever. All the intermediate list elements are the initial
digits.

<P>

Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Decimal(1/22)
Out> {0,0,{4,5}};
In> N(1/22,30)
Out> 0.045454545454545454545454545454;</PRE>
</TABLE>



<A NAME="TruncRadian">

</A>
<H3>
<HR>TruncRadian
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
TruncRadian(r)
<H5>
Parameters:
</H5>
r - a radian
<H5>
Description:
</H5>
TruncRadian calculates r mod 2*Pi, returning a value
between 0 and 2*Pi. This function is used in the trigonometry
functions, just before doing the numerical calculation. It
greatly speeds up the calculation if the value passed is a big
number. <p>
The library uses the formula

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>

             /   r    \         
r - MathFloor| ------ | * 2 * Pi
             \ 2 * Pi /         


</PRE>
</TABLE>


where r and 2*Pi are calculated with twice the precision used in the
environment to make sure there is no rounding error in the significant
digits.


<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 2*Pi()
Out> 6.283185307;
In> TruncRadian(6.28)
Out> 6.28;
In> TruncRadian(6.29)
Out> 0.0068146929;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Sin" TARGET="Chapters">
Sin
</A>
, <A HREF="ref.html#Cos" TARGET="Chapters">
Cos
</A>
, <A HREF="ref.html#Tan" TARGET="Chapters">
Tan
</A>
, <p><HR><A NAME="c4">

</A>
<A HREF="refchapter4.html#Sin" TARGET="Chapters">
Sin
</A>
, <A HREF="refchapter4.html#Cos" TARGET="Chapters">
Cos
</A>
, <A HREF="refchapter4.html#Tan" TARGET="Chapters">
Tan
</A>
, <A HREF="refchapter4.html#ArcSin" TARGET="Chapters">
ArcSin
</A>
, <A HREF="refchapter4.html#ArcCos" TARGET="Chapters">
ArcCos
</A>
, <A HREF="refchapter4.html#ArcTan" TARGET="Chapters">
ArcTan
</A>
, <A HREF="refchapter4.html#Exp" TARGET="Chapters">
Exp
</A>
, <A HREF="refchapter4.html#Ln" TARGET="Chapters">
Ln
</A>
, <A HREF="refchapter4.html#Sqrt" TARGET="Chapters">
Sqrt
</A>
, <A HREF="refchapter4.html#Abs" TARGET="Chapters">
Abs
</A>
, <A HREF="refchapter4.html#Sign" TARGET="Chapters">
Sign
</A>
, <A HREF="refchapter4.html#Complex" TARGET="Chapters">
Complex
</A>
, <A HREF="refchapter4.html#Re" TARGET="Chapters">
Re
</A>
, <A HREF="refchapter4.html#Im" TARGET="Chapters">
Im
</A>
, <A HREF="refchapter4.html#I" TARGET="Chapters">
I
</A>
, <A HREF="refchapter4.html#!" TARGET="Chapters">
!
</A>
, <A HREF="refchapter4.html#Bin" TARGET="Chapters">
Bin
</A>
, <A HREF="refchapter4.html#Sum" TARGET="Chapters">
Sum
</A>
, <A HREF="refchapter4.html#Average" TARGET="Chapters">
Average
</A>
, <A HREF="refchapter4.html#Factorize" TARGET="Chapters">
Factorize
</A>
, <A HREF="refchapter4.html#Min" TARGET="Chapters">
Min
</A>
, <A HREF="refchapter4.html#Max" TARGET="Chapters">
Max
</A>
, <A HREF="refchapter4.html#IsZero" TARGET="Chapters">
IsZero
</A>
, <A HREF="refchapter4.html#IsRational" TARGET="Chapters">
IsRational
</A>
, <A HREF="refchapter4.html#Numer" TARGET="Chapters">
Numer
</A>
, <A HREF="refchapter4.html#Denom" TARGET="Chapters">
Denom
</A>
, <A HREF="refchapter4.html#Commutator" TARGET="Chapters">
Commutator
</A>
, <A HREF="refchapter4.html#Taylor" TARGET="Chapters">
Taylor
</A>
, <A HREF="refchapter4.html#InverseTaylor" TARGET="Chapters">
InverseTaylor
</A>
, <A HREF="refchapter4.html#ReversePoly" TARGET="Chapters">
ReversePoly
</A>
, <A HREF="refchapter4.html#Newton" TARGET="Chapters">
Newton
</A>
, <A HREF="refchapter4.html#D" TARGET="Chapters">
D
</A>
, <A HREF="refchapter4.html#Diverge" TARGET="Chapters">
Diverge
</A>
, <A HREF="refchapter4.html#Curl" TARGET="Chapters">
Curl
</A>
, <A HREF="refchapter4.html#Integrate" TARGET="Chapters">
Integrate
</A>
, <A HREF="refchapter4.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A HREF="refchapter4.html#RadSimp" TARGET="Chapters">
RadSimp
</A>
, <A HREF="refchapter4.html#Rationalize" TARGET="Chapters">
Rationalize
</A>
, <A HREF="refchapter4.html#Conjugate" TARGET="Chapters">
Conjugate
</A>
, <A HREF="refchapter4.html#Solve" TARGET="Chapters">
Solve
</A>
, <A HREF="refchapter4.html#SuchThat" TARGET="Chapters">
SuchThat
</A>
, <A HREF="refchapter4.html#Eliminate" TARGET="Chapters">
Eliminate
</A>
, <A HREF="refchapter4.html#PSolve" TARGET="Chapters">
PSolve
</A>
, <A HREF="refchapter4.html#Pi" TARGET="Chapters">
Pi
</A>
, <A HREF="refchapter4.html#Fibonacci" TARGET="Chapters">
Fibonacci
</A>
, <A HREF="refchapter4.html#Random" TARGET="Chapters">
Random
</A>
, <A HREF="refchapter4.html#VarList" TARGET="Chapters">
VarList
</A>
, <A HREF="refchapter4.html#Limit" TARGET="Chapters">
Limit
</A>
, <A HREF="refchapter4.html#TrigSimpCombine" TARGET="Chapters">
TrigSimpCombine
</A>
, <A HREF="refchapter4.html#LagrangeInterpolant" TARGET="Chapters">
LagrangeInterpolant
</A>
, <H1>
Calculus
</H1>
<A NAME="Sin">

</A>
<A NAME="Cos">

</A>
<A NAME="Tan">

</A>
<A NAME="ArcSin">

</A>
<A NAME="ArcCos">

</A>
<A NAME="ArcTan">

</A>
<H3>
<HR>Trigonometric functions
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Sin(x)<br>
Cos(x)<br>
Tan(x)<br>
ArcSin(x)<br>
ArcCos(x)<br>
ArcTan(x)<br>

<H5>
Parameters:
</H5>
x - some number
<H5>
Description:
</H5>
These functions represent the trigonometric functions and their
inverses. Yacas leaves them alone even if x is a number, trying to keep
the result as exact as possible. The floating point approximations of
these functions can be forced by using the N(...) functions. <p>

Yacas knows some trigonometric identities, so it can simplify to exact
results even if N is not used. This is the case when the arguments are
of the form Pi, Pi/2 etcetera.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Sin(1)
Out> Sin(1);
In> N(Sin(1),20)
Out> 0.84147098480789650665;
In> Sin(Pi/4)
Out> Sqrt(2)/2;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#N" TARGET="Chapters">
N
</A>
, <A HREF="ref.html#Pi" TARGET="Chapters">
Pi
</A>
, <A NAME="Exp">

</A>
<H3>
<HR>Exp(x)
</H3>
Exp(x) : Calculate e^x.
<A NAME="Ln">

</A>
<H3>
<HR>Ln(x)
</H3>
Ln(x) :  Calculate natural logarithm of x.
<A NAME="Sqrt">

</A>
<H3>
<HR>Sqrt(x)
</H3>
Sqrt(x) : calculate the square root of x.
<A NAME="Abs">

</A>
<A NAME="Sign">

</A>
<H3>
<HR>Abs, Sign
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Abs(x) <BR>
Sign(x)

<H5>
Parameters:
</H5>
x - a number
<H5>
Description:
</H5>
Abs(x) returns the absolute value of a number.
Abs(x)*Sign(x) should always be equal to x. Sign(x) returns 1
if the number is positive, -1 otherwise.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Abs(-2)
Out> 2;
In> Sign(-2)
Out> -1;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="Complex">

</A>
<H3>
<HR>Complex(x,y)
</H3>
This represents a complex number x+I*y.
<A NAME="Re">

</A>
<H3>
<HR>Re(z)
</H3>
Return real part of complex number z.
<A NAME="Im">

</A>
<H3>
<HR>Im(z)
</H3>
Return imaginary part of complex number z.
<A NAME="I">

</A>
<H3>
<HR>I
</H3>
This is the pure imaginary number I (for which i*I=-1).
You can type 2+I*3, which would evaluate to
Complex(2,3). Re and Im return the real and
imaginary parts of a number respectively.
<A NAME="!">

</A>
<H3>
<HR>n!
</H3>
Factorial. n! evaluates to n*(n-1)*(n-2)*....*1.
<A NAME="Bin">

</A>
<H3>
<HR>Bin(n,m)
</H3>
Bin(n,m) evaluates to n!/(n!*(n-m)!)
<A NAME="Sum">

</A>
<H3>
<HR>Sum(var,from,to,body) and Sum({list})
</H3>
Sum(var,from,to,body) :
Sum does a summation over "body", setting variable "var"
from "from" upto and including "to", incrementing it by 1 each
time.
<P>
Sum({list}) : calculate the sum of the elements in a list.
Example : Sum({1,2,3}) evaluates to 6.
<A NAME="Average">

</A>
<H3>
<HR>Average({list})
</H3>
Average({list}) : calculate the average of the elements in a list.
Example : Average({1,2,3}) evaluates to 2.
<A NAME="Factorize">

</A>
<H3>
<HR>Factorize(var,from,to,body) and Factorize({list})
</H3>
Factorize(var,from,to,body) :
Factorize does a factorization over "body", setting variable "var"
from "from" upto and including "to", incrementing it by 1 each
time.
<P>
Factorize({list}) : calculate the product of the elements in a list.
Example : Factorize({1,2,3}) evaluates to 6.
<A NAME="Min">

</A>
<A NAME="Max">

</A>
<H3>
<HR>Min(x,y), Min({...}), Max(x,y) and Max({...})
</H3>
Min and Max return the minimum and maximum value of their
arguments respectively. Min and max can either be called with
two numbers as arguments, or with a list of numbers.

<A NAME="IsZero">

</A>
<H3>
<HR>IsZero(x)
</H3>
IsZero(x) : Returns wether x is zero or not.
<A NAME="IsRational">

</A>
<H3>
<HR>IsRational(r)
</H3>
IsRational(r) : Rational numbers are anything like a/b, or 2/5.
<A NAME="Numer">

</A>
<H3>
<HR>Numer(r)
</H3>
Numer(r) : Return numerator of a rational number.
<A NAME="Denom">

</A>
<H3>
<HR>Denom(r)
</H3>
Denom(r) : Return denominator of a rational number.
<A NAME="Commutator">

</A>
<H3>
<HR>Commutator(a,b)
</H3>
Commutator(a,b) :
Return "a b - b a". For numbers and such this is
zero, for matrices in general it isn't.
<A NAME="Taylor">

</A>
<H3>
<HR>Taylor(var,var0,order)function
</H3>
Taylor(var,var0,order)function :
Return the Taylor series expansion of function "function", with
respect to variable "var", around "var=var0", upto order "order".
<A NAME="InverseTaylor">

</A>
<H3>
<HR>InverseTaylor(var,value,degree) func
</H3>
InverseTaylor(var,value,degree) func : build a taylor series expansion
of the inverse of function func, with respect to variable var around value, upto
degree. InverseTaylor uses the function ReversePoly to perform the
task.


<A NAME="ReversePoly">

</A>
<H3>
<HR>ReversePoly(f,g,var,newvar,degree)
</H3>
ReversePoly(f,g,var,newvar,degree) :

Given polynomials f(var) and h(var), determine a polynomial
h(newvar) for which h(f(var)) = g(var). The resulting polynomial
will be of degree degree. The only requirement is that the
first derivative of f should not be zero.

<P>

This function is used to determine the taylor series expansion of
a function: if g(var)=var, then h(f(var))=var, so h will be the
inverse of f.

<A NAME="Newton">

</A>
<H3>
<HR>Newton(function,variable,initial,accuracy)
</H3>
Newton(function,variable,initial,accuracy) :
Find a zero of "function", as a function of "variable",
starting around value "initial", and continuing until
the value for "variable" is maximally "accuracy" away
from the correct value.
<A NAME="D">

</A>
<H3>
<HR>D(variable)expression
</H3>
D(variable)  expression :
Calculate analytic derivative of an expression. "D(x) Sin(x);"
"Cos(x);".

The D operator is also threaded:
"D({x,y,z}) Sin(x*y)" will return {Cos(x*y)*y,Cos(x*y)*x,0}

<P>
Alternatively, you can call D with "D(variable,n)expression".
In that case the n-th derivative will be taken.
<A NAME="Diverge">

</A>
<H3>
<HR>Diverge(vector, basis)
</H3>
Diverge(vector, basis) : Calculate the divergence of
a vector.

Example: "Diverge(FillList(x*y,3),{x,y,z})" will return
{y,x,0}

<A NAME="Curl">

</A>
<H3>
<HR>Curl(vector, basis)
</H3>
Curl(vector, basis) : Calculate the curl of a vector.

Example: "Curl(FillList(x*y,3),{x,y,z})" will return
{x,-y,y-x}

<A NAME="Integrate">

</A>
<H3>
<HR>Integrate(var,from,to) body
</H3>
Integrate(var,from,to) body : integrate body over variable var=from
to var=to. Currently, only polynomials can be integrated.
<A NAME="Simplify">

</A>
<H3>
<HR>Simplify(expr)
</H3>
Simplify(expr) : Simplify tries to simplify an expression as much
as possible.
<A NAME="RadSimp">

</A>
<H3>
<HR>RadSimp
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
RadSimp(expression)
<H5>
Parameters:
</H5>
expression - an expression containing nested radicals
<H5>
Description:
</H5>
RadSimp tries to unnest nested radicals. It does this using
a simple brute force method, and tries to write it out as an
expression of the form Sqrt(e1) + Sqrt(e2) + ... .

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> RadSimp(Sqrt(9+4*Sqrt(2)))
Out> 1+Sqrt(8);
In> RadSimp(Sqrt(5+2*Sqrt(6))+Sqrt(5-2*Sqrt(6)))
Out> Sqrt(12);
In> RadSimp(Sqrt(14+3*Sqrt(3+2*Sqrt(5-12*Sqrt(3-2*Sqrt(2)))))) 
Out> 3+Sqrt(2);
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Simplify" TARGET="Chapters">
Simplify
</A>
, <A NAME="Rationalize">

</A>
<H3>
<HR>Rationalize(expr)
</H3>
Rationalize(expr) : convert every real number in expr into a rational
number.
<A NAME="Conjugate">

</A>
<H3>
<HR>Conjugate(expr)
</H3>
Conjugate(expr) : return the conjugate of expr (given that all
variables are real or integer).

<A NAME="Solve">

</A>
<H3>
<HR>Solve(expr1==expr2,variable)
</H3>
Solve(expr1==expr2,variable) :
A very simple solver. It can for now solve expressions where the variable
to be solved for only occurs once.

"Solve(a+x*y==z,x);" would evaluate to "(z-a)/y".

<P>

Solve can solve simple sets of equations. Pass the equations in a list,
as well as the variables to be solved for. The solver will then use
SuchThat, in combination with Eliminate, to simplify the equations.
This suffices for all linear equations and a large group of simple
non-linear equations.

<P>

When the variable argument receives a list of variables to solve for,
Solve returns a list of results, with each result being a solution
to the set of equations.

<A NAME="SuchThat">

</A>
<H3>
<HR>SuchThat(function,var)
</H3>

SuchThat(function,var) : try to find a simple expression for variable var,
given the equality function=0. This function basically only handles
expressions where the variable var only occurs once. It does its work
by applying the inverse of the top function, until the variable is
reached.

<A NAME="Eliminate">

</A>
<H3>
<HR>Eliminate(var,replace,function)
</H3>

Eliminate(var,replace,function) : replace all instances of
<B><TT>var</TT></B> in <B><TT>function</TT></B> with <B><TT>relpace</TT></B>
and call Simplify on the resulting expression.

<A NAME="PSolve">

</A>
<H3>
<HR>PSolve(expr,var)
</H3>
PSolve(expr) : solve expr=0 with respect to variable var, treating
it expr as a polynomial. It currently solves upto degree 2.

<A NAME="Pi">

</A>
<H3>
<HR>Pi()
</H3>
Pi() : Returns pi to the current precision.
<A NAME="Fibonacci">

</A>
<H3>
<HR>Fibonacci(n)
</H3>
Fibonacci(n) : Calculate Fibonacci number "n".
<A NAME="Random">

</A>
<H3>
<HR>Random()
</H3>
Random() : Returns a random number between 0 and 1.
<A NAME="VarList">

</A>
<H3>
<HR>VarList(expression)
</H3>
VarList(expression) : Returns a list with all the variables
"expression" depends on. Example: "VarList(Sin(x));" should
return "{x};".
<A NAME="Limit">

</A>
<H3>
<HR>Limit(variable,value) function
</H3>
Limit(variable,value)function : determine the
value "function" converges to when "variable"
goes to "value" from positive infinity.
Examples : 
"Limit(x,0) Sin(x)/x;" evaluates to "1", and 
"Limit(x,0) (Sin(x)-Tan(x))/(x^3);" evaluates to "-1/2".

<A NAME="TrigSimpCombine">

</A>
<H3>
<HR>TrigSimpCombine(expression)
</H3>
TrigSimpCombine(expression) : 
This is the module that does the trigonometric simplification:
Cos(...)*Sin(...) -> Cos(...)+Sin(...)
<P>
It also tries to simplify the resulting expression as much as possible,
trying to combine all like terms.

<A NAME="LagrangeInterpolant">

</A>
<H3>
<HR>LagrangeInterpolant({xlist},{ylist},var)
</H3>

LagrangeInterpolant({xlist},{ylist},var) :

given a set of points (x_i,y_i) with all nonzero y_i, find the
polynomial that goes through these points. The first argument
passed to the function should be the list of x_i values, the
second one should be the list of y_i values, and the third
argument should be the variable used to build up the polynomial.


<P>


This routine uses the Lagrange interpolant formula to build up the
polynomial. For three terms this is:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PrettyForm(LagrangeInterpolant(MakeVector(x,3),MakeVector(y,3),x))

y1 * ( x - x2 ) * ( x - x3 )   y2 * ( x - x1 ) * ( x - x3 ) 
---------------------------- + ---------------------------- 
 ( x1 - x2 ) * ( x1 - x3 )      ( x2 - x1 ) * ( x2 - x3 )   

  y3 * ( x - x1 ) * ( x - x2 )
+ ----------------------------
   ( x3 - x1 ) * ( x3 - x2 )  

Out> True;</PRE>
</TABLE>




<p><HR><A NAME="c5">

</A>
<A HREF="refchapter5.html#LeviCivita" TARGET="Chapters">
LeviCivita
</A>
, <A HREF="refchapter5.html#Permutations" TARGET="Chapters">
Permutations
</A>
, <A HREF="refchapter5.html#InProduct" TARGET="Chapters">
InProduct
</A>
, <A HREF="refchapter5.html#CrossProduct" TARGET="Chapters">
CrossProduct
</A>
, <A HREF="refchapter5.html#ZeroVector" TARGET="Chapters">
ZeroVector
</A>
, <A HREF="refchapter5.html#BaseVector" TARGET="Chapters">
BaseVector
</A>
, <A HREF="refchapter5.html#Identity" TARGET="Chapters">
Identity
</A>
, <A HREF="refchapter5.html#IsMatrix" TARGET="Chapters">
IsMatrix
</A>
, <A HREF="refchapter5.html#Normalize" TARGET="Chapters">
Normalize
</A>
, <A HREF="refchapter5.html#ZeroMatrix" TARGET="Chapters">
ZeroMatrix
</A>
, <A HREF="refchapter5.html#Transpose" TARGET="Chapters">
Transpose
</A>
, <A HREF="refchapter5.html#Determinant" TARGET="Chapters">
Determinant
</A>
, <A HREF="refchapter5.html#DiagonalMatrix" TARGET="Chapters">
DiagonalMatrix
</A>
, <A HREF="refchapter5.html#Trace" TARGET="Chapters">
Trace
</A>
, <A HREF="refchapter5.html#Inverse" TARGET="Chapters">
Inverse
</A>
, <A HREF="refchapter5.html#CoFactor" TARGET="Chapters">
CoFactor
</A>
, <A HREF="refchapter5.html#Minor" TARGET="Chapters">
Minor
</A>
, <A HREF="refchapter5.html#SolveMatrix" TARGET="Chapters">
SolveMatrix
</A>
, <A HREF="refchapter5.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
, <A HREF="refchapter5.html#EigenValues" TARGET="Chapters">
EigenValues
</A>
, <A HREF="refchapter5.html#EigenVectors" TARGET="Chapters">
EigenVectors
</A>
, <H1>
Linear Algebra
</H1>
<A NAME="LeviCivita">

</A>
<H3>
<HR>LeviCivita({list})
</H3>
LeviCivita({list}) :
"LeviCivita" implements the Levi Civita symbol. This is generally
useful for tensor calculus.  {list}  should be a list of integers,
and this function returns 1 if the integers are in successive order,
eg.  {1,2,3,...}  would return 1. Swapping two elements of this
list would return -1. So, LeviCivita( {2,1,3} ) would evaluate
to -1.

<A NAME="Permutations">

</A>
<H3>
<HR>Permutations({list})
</H3>
Permutations({list}) :
Permutations returns a list with all the premutations of the original
list.

<A NAME="InProduct">

</A>
<H3>
<HR>InProduct(a,b)
</H3>
InProduct(a,b) (or alternatively a . b) :
Calculate the inproduct of two vectors.

<A NAME="CrossProduct">

</A>
<H3>
<HR>CrossProduct(a,b)
</H3>
CrossProduct(a,b) (or alternatively a X b) :
Calculate the crossproduct of two three-dimensional vectors.

<A NAME="ZeroVector">

</A>
<H3>
<HR>ZeroVector(n)
</H3>
ZeroVector(n) : ZeroVector returns a list with n zeroes.

<A NAME="BaseVector">

</A>
<H3>
<HR>BaseVector(row,n)
</H3>
BaseVector(row,n) : BaseVector returns a vector with item row set to 1, the
other n-1 set to zero.


<A NAME="Identity">

</A>
<H3>
<HR>Identity(n)
</H3>
Identity(n) : Identity returns a identity matrix of dimension n x n.

<A NAME="IsMatrix">

</A>
<H3>
<HR>IsMatrix(x)
</H3>
IsMatrix(x) : Predicates checking if the object x is a matrix.

<A NAME="Normalize">

</A>
<H3>
<HR>Normalize(v)
</H3>
Normalize(v) : Return the normalized vector v.


<A NAME="ZeroMatrix">

</A>
<H3>
<HR>ZeroMatrix(n,m)
</H3>
ZeroMatrix(n,m) : Returns a matrix with n rows and m columns, all zeros.


<A NAME="Transpose">

</A>
<H3>
<HR>Transpose(M)
</H3>
Transpose(M) : Return the transpose of a matrix M.

<A NAME="Determinant">

</A>
<H3>
<HR>Determinant(M)
</H3>
Determinant(M) : Return the determinant of a matrix M.

<A NAME="DiagonalMatrix">

</A>
<H3>
<HR>DiagonalMatrix(v)
</H3>
DiagonalMatrix(v) : Return a square matrix with the elements of vector
v on the diagonal of the matrix. All other elements are zero.


<A NAME="Trace">

</A>
<H3>
<HR>Trace(M)
</H3>
Trace(M) : Return the trace of a matrix M (defined as the sum of the
elements on the diagonal of the matrix).


<A NAME="Inverse">

</A>
<H3>
<HR>Inverse(M)
</H3>
Inverse(M) : Return the inverse of matrix M. The determinant of M should
be non-zero.


<A NAME="CoFactor">

</A>
<H3>
<HR>CoFactor(M,i,j)
</H3>
CoFactor(M,i,j) : This function returns the cofactor of a matrix around
the element (i,j). The cofactor is the minor times
(-1)^(i+j)


<A NAME="Minor">

</A>
<H3>
<HR>Minor(M,i,j)
</H3>
Minor(M,i,j) : This function returns the minor of a matrix around
the element (i,j). The minor is the determinant of the matrix
excluding the ith row and jth column.


<A NAME="SolveMatrix">

</A>
<H3>
<HR>SolveMatrix(M,v)
</H3>
SolveMatrix(M,v) : This function returns the vector x that satisfies
the equation "M x = v". The determinant of M should be non-zero.


<A NAME="CharacteristicEquation">

</A>
<H3>
<HR>CharacteristicEquation(matrix,var)
</H3>
CharacteristicEquation(matrix,var) : 
calculate characteristic equation of "matrix", using
"var". The zeros os this equation are the eigenvalues
of the matrix, Det(matrix-I var);

<A NAME="EigenValues">

</A>
<H3>
<HR>EigenValues
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
EigenValues(matrix)
<H5>
Parameters:
</H5>
matrix - a square matrix
<H5>
Description:
</H5>
EigenValues returns the eigenvalues of a matrix.
The eigenvalues x of a matrix M are the numbers such that
M*v=x*v for some vector.<BR>
It first determines the characteristic equation, and then factorizes this
equation, returning the roots of the characteristic equation
det(matrix-x*identity).
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> M:={{1,2},{2,1}}
Out> {{1,2},{2,1}};
In> EigenValues(M)
Out> {3,-1};
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EigenVectors" TARGET="Chapters">
EigenVectors
</A>
, <A HREF="ref.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
, <A NAME="EigenVectors">

</A>
<H3>
<HR>EigenVectors
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
EigenVectors(matrix,eigenvalues)
Standard math library<br><H5>
Parameters:
</H5>
matrix - matrix - a square matrix <br>
 eigenvalues - list of eigenvalues as returned by EigenValues

<H5>
Description:
</H5>
EigenVectors returns a list of the eigenvectors of a matrix.
It uses the eigenvalues and the matrix to set up n equations with
n unknowns for each eigenvalue, and then calls Solve to determine
the values of each vector.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> M:={{1,2},{2,1}}
Out> {{1,2},{2,1}};
In> e:=EigenValues(M)
Out> {3,-1};
In> EigenVectors(M,e)
Out> {{-ki2/ -1,ki2},{-ki2,ki2}};
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#EigenValues" TARGET="Chapters">
EigenValues
</A>
, <A HREF="ref.html#CharacteristicEquation" TARGET="Chapters">
CharacteristicEquation
</A>
, <p><HR><A NAME="c6">

</A>
<A HREF="refchapter6.html#Expand" TARGET="Chapters">
Expand
</A>
, <A HREF="refchapter6.html#Degree" TARGET="Chapters">
Degree
</A>
, <A HREF="refchapter6.html#Coef" TARGET="Chapters">
Coef
</A>
, <A HREF="refchapter6.html#PSolve" TARGET="Chapters">
PSolve
</A>
, <A HREF="refchapter6.html#Div" TARGET="Chapters">
Div
</A>
, <A HREF="refchapter6.html#Mod" TARGET="Chapters">
Mod
</A>
, <A HREF="refchapter6.html#Content" TARGET="Chapters">
Content
</A>
, <A HREF="refchapter6.html#PrimitivePart" TARGET="Chapters">
PrimitivePart
</A>
, <A HREF="refchapter6.html#RandomPoly" TARGET="Chapters">
RandomPoly
</A>
, <A HREF="refchapter6.html#LeadingCoef" TARGET="Chapters">
LeadingCoef
</A>
, <A HREF="refchapter6.html#Monic" TARGET="Chapters">
Monic
</A>
, <A HREF="refchapter6.html#BigOh" TARGET="Chapters">
BigOh
</A>
, <H1>
Polynomials
</H1>
<A NAME="Expand">

</A>
<H3>
<HR>Expand(expr)
</H3>


Expand(expr) : expands a univariate. Example: Expand((1+x)^2)
would evaluate to 1+2*x+x^2.

If the expression depends on more than one variable, you can
specify which variable to expand to using Expand(expr,var);
Also, you can expand to multiple variables, by specifying the
order in which to expand, in a list, using Expand(expr,{varlist}).


<A NAME="Degree">

</A>
<H3>
<HR>Degree(expr) or Degree(expression, variable)
</H3>


Degree(expr) : return the degree of a polynomial. Example: <B><TT>Degree((1+x)^2);</TT></B> evaluates to 2. 
<P>
The version accepting an additional variable as an argument can be
used to get the degree of a multivariate polynomial with respect to
that variable. Example: <B><TT>Degree(a+b*x^3,a);</TT></B>returns 1.
<A NAME="Coef">

</A>
<H3>
<HR>Coef(expr,var,order)
</H3>


Coef(expr,var,order) : return the coefficient of order for expression
expr treated as a univariate with respect to the variable var.

<P>

The argument to parameter order can also be a list of integers, in
which case this function returns a list of coefficients.


<A NAME="PSolve">

</A>
<H3>
<HR>PSolve(expr,var)
</H3>


PSolve(expr,var) : solve expr=0, treating expr as a polynomial in
the variable var. The result returned is the value var should take
for expr=0 to be true. This has been implemented for polynomials
upto degree 2.


<A NAME="Div">

</A>
<H3>
<HR>Div(n,m)
</H3>


Div(n,m) : div is also defined for polynomials.


<A NAME="Mod">

</A>
<H3>
<HR>Mod(n,m)
</H3>


Mod(n,m) : mod is also defined for polynomials.

<A NAME="Content">

</A>
<H3>
<HR>Content(poly)
</H3>

Content(poly) : determine the content of a univariate polynomial.
The content is the greatest common divisor of each term in the
polynomial. The content of 2*x^2+4*x should be 2*x for instance.

<A NAME="PrimitivePart">

</A>
<H3>
<HR>PrimitivePart(poly)
</H3>

PrimitivePart(poly) : determine the primitive part of a univariate polynomial.
This is defined as PrimitivePart(poly)*Content(poly) = poly, and can
easily be checked with Expand(PrimitivePart(poly)*Content(poly))
which should be equal to Expand(poly).

<A NAME="RandomPoly">

</A>
<H3>
<HR>RandomPoly(var,deg,coefmin,coefmax)
</H3>

RandomPoly(var,deg,coefmin,coefmax) :
generate a random polynomial in variable var, of degree deg,
with coefficients ranging from coefmin to coefmax (inclusive).


<A NAME="LeadingCoef">

</A>
<H3>
<HR>LeadingCoef(poly)
</H3>

LeadingCoef(poly) : get the leading coefficient of the polynomial poly.
If there are more variables in poly, you can specify which variable
is the main one, by adding it as an argument:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> LeadingCoef(a*x^2+2,x)
Out> a;</PRE>
</TABLE>



<A NAME="Monic">

</A>
<H3>
<HR>Monic(poly)
</H3>

Monic(poly) : return the monic part of the polynomial poly.
This is poly/LeadingCoef(poly). This function also accepts
a second argument, specifying the variable of the univariate
polynomial:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f:=a*x^2+b
Out> a*x^2+b;
In> PrettyForm(Monic(f,x))

b    2
- + x 
a     

Out> True;
</PRE>
</TABLE>



<A NAME="BigOh">

</A>
<H3>
<HR>BigOh(_uv,_var,_degree)
</H3>
BigOh(poly,var,degree) : Given a polynomial poly in variable var,
drop all terms of order degree or higher.


<p><HR><A NAME="c7">

</A>
<A HREF="refchapter7.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="refchapter7.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="refchapter7.html#Length" TARGET="Chapters">
Length
</A>
, <A HREF="refchapter7.html#Nth" TARGET="Chapters">
Nth
</A>
, <A HREF="refchapter7.html#DestructiveReverse" TARGET="Chapters">
DestructiveReverse
</A>
, <A HREF="refchapter7.html#List" TARGET="Chapters">
List
</A>
, <A HREF="refchapter7.html#UnList" TARGET="Chapters">
UnList
</A>
, <A HREF="refchapter7.html#Listify" TARGET="Chapters">
Listify
</A>
, <A HREF="refchapter7.html#Concat" TARGET="Chapters">
Concat
</A>
, <A HREF="refchapter7.html#Delete" TARGET="Chapters">
Delete
</A>
, <A HREF="refchapter7.html#Insert" TARGET="Chapters">
Insert
</A>
, <A HREF="refchapter7.html#DestructiveInsert" TARGET="Chapters">
DestructiveInsert
</A>
, <A HREF="refchapter7.html#DestructiveDelete" TARGET="Chapters">
DestructiveDelete
</A>
, <A HREF="refchapter7.html#Replace" TARGET="Chapters">
Replace
</A>
, <A HREF="refchapter7.html#DestructiveReplace" TARGET="Chapters">
DestructiveReplace
</A>
, <A HREF="refchapter7.html#FlatCopy" TARGET="Chapters">
FlatCopy
</A>
, <A HREF="refchapter7.html#Contains" TARGET="Chapters">
Contains
</A>
, <A HREF="refchapter7.html#Find" TARGET="Chapters">
Find
</A>
, <A HREF="refchapter7.html#Append" TARGET="Chapters">
Append
</A>
, <A HREF="refchapter7.html#DestructiveAppend" TARGET="Chapters">
DestructiveAppend
</A>
, <A HREF="refchapter7.html#RemoveDuplicates" TARGET="Chapters">
RemoveDuplicates
</A>
, <A HREF="refchapter7.html#Push" TARGET="Chapters">
Push
</A>
, <A HREF="refchapter7.html#Pop" TARGET="Chapters">
Pop
</A>
, <A HREF="refchapter7.html#PopFront" TARGET="Chapters">
PopFront
</A>
, <A HREF="refchapter7.html#PopBack" TARGET="Chapters">
PopBack
</A>
, <A HREF="refchapter7.html#Swap" TARGET="Chapters">
Swap
</A>
, <A HREF="refchapter7.html#Count" TARGET="Chapters">
Count
</A>
, <A HREF="refchapter7.html#Intersection" TARGET="Chapters">
Intersection
</A>
, <A HREF="refchapter7.html#Union" TARGET="Chapters">
Union
</A>
, <A HREF="refchapter7.html#Difference" TARGET="Chapters">
Difference
</A>
, <A HREF="refchapter7.html#FillList" TARGET="Chapters">
FillList
</A>
, <A HREF="refchapter7.html#Drop" TARGET="Chapters">
Drop
</A>
, <A HREF="refchapter7.html#Take" TARGET="Chapters">
Take
</A>
, <A HREF="refchapter7.html#Partition" TARGET="Chapters">
Partition
</A>
, <A HREF="refchapter7.html#Assoc" TARGET="Chapters">
Assoc
</A>
, <A HREF="refchapter7.html#AssocIndices" TARGET="Chapters">
AssocIndices
</A>
, <A HREF="refchapter7.html#Flatten" TARGET="Chapters">
Flatten
</A>
, <A HREF="refchapter7.html#UnFlatten" TARGET="Chapters">
UnFlatten
</A>
, <A HREF="refchapter7.html#Type" TARGET="Chapters">
Type
</A>
, <A HREF="refchapter7.html#NrArgs" TARGET="Chapters">
NrArgs
</A>
, <A HREF="refchapter7.html#BubbleSort" TARGET="Chapters">
BubbleSort
</A>
, <A HREF="refchapter7.html#Table" TARGET="Chapters">
Table
</A>
, <A HREF="refchapter7.html#TableForm" TARGET="Chapters">
TableForm
</A>
, <A HREF="refchapter7.html#MapSingle" TARGET="Chapters">
MapSingle
</A>
, <A HREF="refchapter7.html#Map" TARGET="Chapters">
Map
</A>
, <A HREF="refchapter7.html#RandomIntegerVector" TARGET="Chapters">
RandomIntegerVector
</A>
, <A HREF="refchapter7.html#MakeVector" TARGET="Chapters">
MakeVector
</A>
, <A HREF="refchapter7.html#Select" TARGET="Chapters">
Select
</A>
, <H1>
List operations
</H1>
Most objects that can be of variable size are represented as
lists (linked lists internally). Yacas does implement arrays, which
are faster when the number of elements in a collection of objects
doesn't change. Operations on lists have better support in the current
system.
<A NAME="Head">

</A>
<H3>
<HR>Head
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Head(list)
<H5>
Parameters:
</H5>
list - a list
<H5>
Description:
</H5>
Returns the first element of a list.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Head({a,b,c})
Out> a;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
, <A NAME="Tail">

</A>
<H3>
<HR>Tail
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Tail(list)
<H5>
Parameters:
</H5>
list - a list
<H5>
Description:
</H5>
Returns a list without its first element.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Tail({a,b,c})
Out> {b,c};
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="ref.html#Length" TARGET="Chapters">
Length
</A>
, <A NAME="Length">

</A>
<H3>
<HR>Length
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Length(object)
<H5>
Parameters:
</H5>
object - a list, array or string
<H5>
Description:
</H5>
Length returns the length of a list.
This function also works on strings and arrays.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Length({a,b,c})
Out> 3;
In> Length("abcdef");
Out> 6;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Head" TARGET="Chapters">
Head
</A>
, <A HREF="ref.html#Tail" TARGET="Chapters">
Tail
</A>
, <A HREF="ref.html#Nth" TARGET="Chapters">
Nth
</A>
, <A NAME="Nth">

</A>
<H3>
<HR>Nth({list},index)
</H3>

Nth({list},index) : Returns the element in the list "{list}" at
position "index", where the first element is 1.


<A NAME="DestructiveReverse">

</A>
<H3>
<HR>DestructiveReverse({list})
</H3>

DestructiveReverse({list}) : Returns the list {list} in reverse order.
The list is reversed in place, so the original is changed into nonsense.
Use FlatCopy to avoid this.


<A NAME="List">

</A>
<H3>
<HR>List(...)
</H3>

List(...) : Returns a list with ... as its elements, after they
were evaluated. This is the same as entering "{...};".


<A NAME="UnList">

</A>
<H3>
<HR>UnList({list})
</H3>

UnList({list}) : 
Changes the list {list} into an expression specified in the
elements of the list. This means the first element
is treated as the command, and the elements following
are the arguments to that command. "{list}" is evaluated
before the operation is performed. Example: "UnList({Cos,x});"
would evaluate to "Cos(x);".


<A NAME="Listify">

</A>
<H3>
<HR>Listify(expression)
</H3>

Listify(expression) : 
Inverse of UnList: it converts the expression "expression" 
into a list. Eg. "Listify(a(b));" evaluates to "{a,b};".


<A NAME="Concat">

</A>
<H3>
<HR>Concat(...)
</H3>

Concat(...) : concatenates the lists in ... after evaluation.
Eg. "Concat({a,b},{c,d});" returns "{a,b,c,d};".


<A NAME="Delete">

</A>
<H3>
<HR>Delete({list},index)
</H3>

Delete({list},index) : 
Deletes an element at position "index" from the
list "{list}", and returns that list. "{list}" and
"index" are evaluated first. The first index in list is 1.


<A NAME="Insert">

</A>
<H3>
<HR>Insert({list},index,element)
</H3>


Evaluates arguments, and inserts "element"
in "{list}" at position "index", where position
1 means insert at the front of the existing list. The result is returned,
and the original list is left unchanged.


<A NAME="DestructiveInsert">

</A>
<H3>
<HR>DestructiveInsert({list},index,element)
</H3>

DestructiveInsert({list},index,element) : 
The Destructive... versions actually perform the operations
on the original lists. So, if
a variable is bound to a list, the list the variable points
to is actually modified. This is more efficient memory-wise
and in execution if the same variable is going to be set to
the result.


<A NAME="DestructiveDelete">

</A>
<H3>
<HR>DestructiveDelete({list},index)
</H3>

DestructiveDelete({list},index) : 
The Destructive... versions actually perform the operations
on the original lists. So, if
a variable is bound to a list, the list the variable points
to is actually modified. This is more efficient memory-wise
and in execution if the same variable is going to be set to
the result.


<A NAME="Replace">

</A>
<H3>
<HR>Replace({list},index,element)
</H3>

This replaces an element, much like calling Delete and Insert
in sequence.


<A NAME="DestructiveReplace">

</A>
<H3>
<HR>DestructiveReplace({list},index,element)
</H3>

This replaces an element, much like calling DestructiveDelete
and DestructiveInsert in sequence.


<A NAME="FlatCopy">

</A>
<H3>
<HR>FlatCopy({list})
</H3>

FlatCopy({list}) : 
Copying of the contents of a list. It is not recursed
into, only the first level is copied. This is useful
in combination with the destructive commands that actually
modify lists in place (for efficiency).



<A NAME="Contains">

</A>
<H3>
<HR>Contains({list},element)
</H3>

Contains({list},element) : 
Returns whether "{list}" contains element "element".


<A NAME="Find">

</A>
<H3>
<HR>Find(list,item)
</H3>

Find(list,item) : returns the index of item in the list.
Example: Find({a,b,c,d},c) returns 3.


<A NAME="Append">

</A>
<H3>
<HR>Append({list},element)
</H3>

Append({list},element) : 
Append an element {{I:element}} to list {{I:{list} }}.


<A NAME="DestructiveAppend">

</A>
<H3>
<HR>DestructiveAppend({list},element)
</H3>

DestructiveAppend({list},element) :
Append an element {{I:element}} to list {{I:{list} }}.


<A NAME="RemoveDuplicates">

</A>
<H3>
<HR>RemoveDuplicates({list})
</H3>

RemoveDuplicates({list}) : 
Returns a list with exactly one occurrence of each element that is
also in "{list}".


<A NAME="Push">

</A>
<H3>
<HR>Push(stack,element)
</H3>

These implement a stack (represented as a list). "Push" adds an element
in front of the list. "Pop" then removes and returns any element you
need from the list. "PopFront" and "PopBack" pop the first and last
element of the stack respectively.


<A NAME="Pop">

</A>
<H3>
<HR>Pop(stack,index)
</H3>

These implement a stack (represented as a list). "Push" adds an element
in front of the list. "Pop" then removes and returns any element you
need from the list. "PopFront" and "PopBack" pop the first and last
element of the stack respectively.


<A NAME="PopFront">

</A>
<H3>
<HR>PopFront(stack)
</H3>

These implement a stack (represented as a list). "Push" adds an element
in front of the list. "Pop" then removes and returns any element you
need from the list. "PopFront" and "PopBack" pop the first and last
element of the stack respectively.


<A NAME="PopBack">

</A>
<H3>
<HR>PopBack(stack)
</H3>

These implement a stack (represented as a list). "Push" adds an element
in front of the list. "Pop" then removes and returns any element you
need from the list. "PopFront" and "PopBack" pop the first and last
element of the stack respectively.


<A NAME="Swap">

</A>
<H3>
<HR>Swap({list},i1,i2)
</H3>

Swap({list},i1,i2) : 
Swap elements with indices "i1" and "i2" in the list "{list}".


<A NAME="Count">

</A>
<H3>
<HR>Count({list},element)
</H3>

Count({list},element) : 
Returns number of occurrences of "element" in "{list}".


<A NAME="Intersection">

</A>
<H3>
<HR>Intersection({list1},{list2})
</H3>

Intersection({list1},{list2}) : 
returns the intersection of two lists.
Example : "Intersection({a,b},{b,c});" would evaluate to "{b};".


<A NAME="Union">

</A>
<H3>
<HR>Union({list1},{list2})
</H3>

Union({list1},{list2}) : 
returns the union of two lists.
Example : "Union({a,b},{b,c});" would evaluate to "{a,b,c};".


<A NAME="Difference">

</A>
<H3>
<HR>Difference({list1},{list2})
</H3>

Difference({list1},{list2}) : 
returns the difference of two lists.


<A NAME="FillList">

</A>
<H3>
<HR>FillList(aItem, aLength)
</H3>

FillList(aItem, aLength) : create a list with length aLength,
filling it with aItem.

Example: "FillList(0,5)" returns {0,0,0,0,0}

<A NAME="Drop">

</A>
<H3>
<HR>Drop(list,which)
</H3>


 Drop( list, n ) gives 'list' with its first n elements dropped      <BR>
 Drop( list, -n ) gives 'list' with its last n elements dropped      <BR>
 Drop( list, {m,n} ) gives 'list' with elements m through n dropped  

<A NAME="Take">

</A>
<H3>
<HR>Take(list,which)
</H3>


 Take( list, n ) gives the first n elements of 'list'   <BR>
 Take( list, -n ) gives the last n elements of 'list'   <BR>
 Take( list, {m,n} ) elements m through n of 'list'


<A NAME="Partition">

</A>
<H3>
<HR>Partition( list, n )
</H3>


  Partition( list, n ) partitions 'list' into non-overlapping sublists of length n

<A NAME="Assoc">

</A>
<H3>
<HR>Assoc(key,assoclist)
</H3>


Treat assoclist as a traditional assoc list well known from Lisp, and return
the element stored with key. This functionality is probably best
accessed through the [ ] operator.


<A NAME="AssocIndices">

</A>
<H3>
<HR>AssocIndices(list)
</H3>


Return the list of keys in the associated list assoclist.


<A NAME="Flatten">

</A>
<H3>
<HR>Flatten
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
Flatten(expression,operator)
<H5>
Parameters:
</H5>
expression - an expression <br>
 operator - string with the contents of an infix operator.

<H5>
Description:
</H5>
Flatten flattens an expression with respect to a specific
operator, converting the result into a list.
This is useful for unnesting an expression. Flatten is typically
used in simple simplification schemes.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Flatten(a+b*c+d,"+");
Out> {a,b*c,d};
In> Flatten({a,{b,c},d},"List");
Out> {a,b,c,d};
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#UnFlatten" TARGET="Chapters">
UnFlatten
</A>
, <A NAME="UnFlatten">

</A>
<H3>
<HR>UnFlatten
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
UnFlatten(list,operator,identity)
<H5>
Parameters:
</H5>
list - list of objects the operator is to work on
 operator - infix operator
 identity - identity of the operator

<H5>
Description:
</H5>
UnFlatten is the inverse operation of Flatten. Given
a list, it can be turned into an expression representing
for instance the addition of these elements by calling
UnFlatten with "+" as argument to operator, and 0 as
argument to identity (0 is the identity for addition, since
a+0=a). For multiplication the identity element would be 1.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> UnFlatten({a,b,c},"+",0)
Out> a+b+c;
In> UnFlatten({a,b,c},"*",1)
Out> a*b*c;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Flatten" TARGET="Chapters">
Flatten
</A>
, <A NAME="Type">

</A>
<H3>
<HR>Type(expression)
</H3>

Type(expression) : 
Returns a string representation of the type of "expression".
"Type(Cos(x));" would evaluate to "Cos", for instance.


<A NAME="NrArgs">

</A>
<H3>
<HR>NrArgs(expression)
</H3>

NrArgs(expression) : 
Returns number of arguments in top-level function of "expression".
"NrArgs(Cos(x));" would evaluate to "1".

<A NAME="BubbleSort">

</A>
<H3>
<HR>BubbleSort({list},"compare")
</H3>

BubbleSort({list},"compare") : 
Sort the list {list}, using "compare" as the operator to compare
elements. "compare" gives the relation that should be true for
neighbouring elements in the list after sorting.


<A NAME="Table">

</A>
<H3>
<HR>Table(body,var,from,to,step)
</H3>

Table(body,var,from,to,step) : 
Generate a list of values from "body", by assigning variable "var"
values from "from" upto "to", incrementing "step" each time.


<A NAME="TableForm">

</A>
<H3>
<HR>TableForm({list})
</H3>

Tableform({list}) : 
TableForm writes out a list in a nicer readable form, eg. one line for
each element in the list.


<A NAME="MapSingle">

</A>
<H3>
<HR>MapSingle("operator",{list})
</H3>

MapSingle("operator",{list}) : 
MapSingle performs Apply on every item in {list}, returning a
list of the results.


<A NAME="Map">

</A>
<H3>
<HR>Map("operator",{lists})
</H3>

Map("operator",{lists}) : 
{lists} should be a list of lists each the same size. 
Map performs Apply on every set of items in {lists}, returning a
list of the results. Eg. Map("+",{{a,b},{c,d}}) would return {a+c,b+d}.

<A NAME="RandomIntegerVector">

</A>
<H3>
<HR>RandomIntegerVector(nr,from,to)
</H3>

RandomIntegerVector(nr,from,to) : generate a vector of random
integers p in the range [from,to] (including from and to).

<A NAME="MakeVector">

</A>
<H3>
<HR>MakeVector(var,n)
</H3>

MakeVector(var,n) : return a vector of unique numbered variable names.
Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> MakeVector(a,3)
Out> {a1,a2,a3};</PRE>
</TABLE>



<A NAME="Select">

</A>
<H3>
<HR>Select(predicate,list)
</H3>

Select(predicate,list) : return a sublist of list, containing all
elements for which the predicate returned after applying the
predicate on that list element. Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Select("IsInteger",{a,b,2,c,3,d,4,e,f})
Out> {2,3,4};</PRE>
</TABLE>



<p><HR><A NAME="c8">

</A>
<A HREF="refchapter8.html#:" TARGET="Chapters">
:
</A>
, <A HREF="refchapter8.html#@" TARGET="Chapters">
@
</A>
, <A HREF="refchapter8.html#/@" TARGET="Chapters">
/@
</A>
, <A HREF="refchapter8.html#.." TARGET="Chapters">
..
</A>
, <H1>
Functional operators
</H1>
<A NAME=":">

</A>
<H3>
<HR>item:list
</H3>

prepends an item to a list, or a string. 
Examples:
 a:b:c:{}       ->  {a,b,c} <BR>
 "hello":" ":"world" -> "hello world"

<A NAME="@">

</A>
<H3>
<HR>"oper" @ arg
</H3>

Applies an operator to arguments.
Examples:
 "Sin" @ a      ->   Sin(a)
 "Sin" @ {a,b}  ->   Sin(a,b)


<A NAME="/@">

</A>
<H3>
<HR>oper /@ arglist
</H3>

Applies an operator to arguments in a list, in a threaded manner.
Example:
 "Sin" /@ {a,b} ->   {Sin(a),Sin(b)}


<A NAME="..">

</A>
<H3>
<HR>n .. m
</H3>

returns a list of numbers from n upto m.
Example:
 1 .. 4         ->   {1,2,3,4}

<p><HR><A NAME="c9">

</A>
<A HREF="refchapter9.html#MaxEvalDepth" TARGET="Chapters">
MaxEvalDepth
</A>
, <A HREF="refchapter9.html#Hold" TARGET="Chapters">
Hold
</A>
, <A HREF="refchapter9.html#Eval" TARGET="Chapters">
Eval
</A>
, <A HREF="refchapter9.html#While" TARGET="Chapters">
While
</A>
, <A HREF="refchapter9.html#Until" TARGET="Chapters">
Until
</A>
, <A HREF="refchapter9.html#If" TARGET="Chapters">
If
</A>
, <A HREF="refchapter9.html#SystemCall" TARGET="Chapters">
SystemCall
</A>
, <A HREF="refchapter9.html#PatchString" TARGET="Chapters">
PatchString
</A>
, <A HREF="refchapter9.html#Function" TARGET="Chapters">
Function
</A>
, <A HREF="refchapter9.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="refchapter9.html#For" TARGET="Chapters">
For
</A>
, <A HREF="refchapter9.html#ForEach" TARGET="Chapters">
ForEach
</A>
, <A HREF="refchapter9.html#Apply" TARGET="Chapters">
Apply
</A>
, <A HREF="refchapter9.html#LocalSymbols" TARGET="Chapters">
LocalSymbols
</A>
, <A HREF="refchapter9.html#Subst" TARGET="Chapters">
Subst
</A>
, <A HREF="refchapter9.html#WithValue" TARGET="Chapters">
WithValue
</A>
, <A HREF="refchapter9.html#SetHelpBrowser" TARGET="Chapters">
SetHelpBrowser
</A>
, <A HREF="refchapter9.html#TraceStack" TARGET="Chapters">
TraceStack
</A>
, <A HREF="refchapter9.html#TraceExp" TARGET="Chapters">
TraceExp
</A>
, <A HREF="refchapter9.html#TraceRule" TARGET="Chapters">
TraceRule
</A>
, <H1>
Control flow functions
</H1>
<A NAME="MaxEvalDepth">

</A>
<H3>
<HR>MaxEvalDepth(n)
</H3>


Use this command to set the maximum evaluation depth. This will
catch any infinite recursion. For example, f(x):=f(x); and then
f(x) would keep on calling f(x), which would call f(x), which
would call f(x)... etcetera. The interpreter will halt if
the call is n deep. The default value is 100000.

<A NAME="Hold">

</A>
<H3>
<HR>Hold(expression)
</H3>

Hold(expression) : returns expression unevaluated.


<A NAME="Eval">

</A>
<H3>
<HR>Eval(expression)
</H3>

Eval(expression) : Re-evaluates expression.

<A NAME="While">

</A>
<H3>
<HR>While(predicate) body
</H3>

While(predicate) body : 
Keep on evaluating "body" while "predicate"
evaluates to "True". "predicate" is tested
before evaluating the body. While returns "True".

<A NAME="Until">

</A>
<H3>
<HR>Until(predicate) body
</H3>

Until repeats a statement until a predicate becomes
true. A difference with While is that the statement is evaluated
at least once, as opposed to While where the body statement is
evaluated zero or more times.

<A NAME="If">

</A>
<H3>
<HR>If(predicate,then,else)
</H3>

If(predicate,then,else) : 
If statement. If "predicate" evaluates to
"True", return result of evaluating the
"then" body, else if there is a "else" body,
return that result, otherwise return "False".

<A NAME="SystemCall">

</A>
<H3>
<HR>SystemCall(string)
</H3>

SystemCall(string) : 
This will call a command in the surrounding shell Yacas was invoked
from. SystemCall can be used to pass commands to other programs
or the operating system. 


<A NAME="PatchString">

</A>
<H3>
<HR>PatchString
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
PatchString(string)
<H5>
Parameters:
</H5>
string - a string to patch
<H5>
Description:
</H5>
This function does the same as PatchLoad, but it works on a string
in stead of on the contents of a text file. See PatchLoad for more
details.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PatchString("Two plus three is &lt? Write(2+3); ?&gt ");
Out> "Two plus three is 5 ";
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#PatchLoad" TARGET="Chapters">
PatchLoad
</A>
, <A NAME="Function">

</A>
<H3>
<HR>Function("operator",{arguments} ) body
</H3>

Function("operator",{arguments} ) body : 
Use this to declare a simple function, one that doesn't need an entire
rules data base.


<A NAME="Use">

</A>
<H3>
<HR>Use("file")
</H3>

Use("file") : 
This function loads a file if it was not already loaded with Use.

<A NAME="For">

</A>
<H3>
<HR>For(start,predicate,increment) body
</H3>

For(start,predicate,increment) body : 
Looping in a C style. "start" gets called, and then "body" as
long as "predicate" evaluates to True", evaluating
"increment" each time after body was evaluated. Returns "True".



<A NAME="ForEach">

</A>
<H3>
<HR>ForEach(item,{list}) body
</H3>

ForEach(item,{list}) body : 
This function loops over each element in {list}, assigning it to
the variable "item", and calling "body". Returns "True".


<A NAME="Apply">

</A>
<H3>
<HR>Apply("oper",{list})
</H3>

Apply("oper",{list}) : 
This function applies a operator to the arguments mentioned in the list.
Eg. "Apply("+",{2,3});" would evaluate to "5".

You can also apply pure functions, declared using the form {varlist,body}.
Example: "Apply( {{x,y},x+y} , {2,3} );" would also evaluate to 5.


<A NAME="LocalSymbols">

</A>
<H3>
<HR>LocalSymbols(...)body
</H3>

Given the symbols passed as the first arguments to LocalSymbols
a set of local symbols will be created, and creates unique ones
for them, typically of the form $<symbol><number>, where
symbol was the symbol entered by the user, and number is a unique
number. This scheme was used
to such a generated symbol can not accientally be entered by a user.
Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> LocalSymbols(a,b)a+b
Out> $a6+ $b6;</PRE>
</TABLE>


This is useful in cases where a guaranteed free variable is needed,
like in the macro-like functions (For, While, etc.).


<A NAME="Subst">

</A>
<H3>
<HR>Subst(from,to)body
</H3>


Subst replaces any occurrence of from in body with to. <BR>

Example:
  Subst(x,Sin(y)) x+x -> Sin(y)+Sin(y)

<A NAME="WithValue">

</A>
<H3>
<HR>WithValue(variable,value,expression)
</H3>

WithValue(variable,value,expression) : evaluate expression, with
variable set to value. variable and value can be lists of
variables and values.

<A NAME="SetHelpBrowser">

</A>
<H3>
<HR>SetHelpBrowser
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
SetHelpBrowser(helpbrowser)
<H5>
Parameters:
</H5>
helpbrowser - string containing a html browser to use for help
<H5>
Description:
</H5>
This function sets the help browser you want to use to
browse the help online. It calls helpbrowser with the html
page as first argument. The default is lynx. If you want to
use a different browser by default it suffices to create a
file ~/.yacasrc. and add a line to set the browser in there.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> SetHelpBrowser("netscape")
Out> "netscape";
In> ??
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="TraceStack">

</A>
<H3>
<HR>TraceStack
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
TraceStack(expression)
<H5>
Parameters:
</H5>
expression - an expression to evaluate
<H5>
Description:
</H5>
TraceStack shows the calling stack after an error occurred.
It shows the last few items on the stack, not to flood the screen.
These are usually the only items of interest on the stack.
This is probably by far the most useful debugging function in
Yacas. It shows the last few things it did just after an error
was generated somewhere.
<P>
For each stack frame, it shows if the function evaluated was a
built-in function or a user-defined function, and for the user-defined
function, the number of the rule it is trying whether it was evaluating
the pattern matcher of the rule, or the body code of the rule.
<P>
This functionality is not offered by default because it slows
down the evaluation code.


<H5>
Examples:
</H5>
Here is an example of a function calling itself recursively,
causing Yacas to flood its stack:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> f(x):=f(Sin(x))
Out> True;
In> TraceStack(f(2))
Debug> 982 :  f (Rule # 0 in body)
Debug> 983 :  f (Rule # 0 in body)
Debug> 984 :  f (Rule # 0 in body)
Debug> 985 :  f (Rule # 0 in body)
Debug> 986 :  f (Rule # 0 in body)
Debug> 987 :  f (Rule # 0 in body)
Debug> 988 :  f (Rule # 0 in body)
Debug> 989 :  f (Rule # 0 in body)
Debug> 990 :  f (Rule # 0 in body)
Debug> 991 :  f (Rule # 0 in body)
Debug> 992 :  f (Rule # 0 in body)
Debug> 993 :  f (Rule # 0 in body)
Debug> 994 :  f (Rule # 0 in body)
Debug> 995 :  f (User function)
Debug> 996 :  Sin (Rule # 0 in pattern)
Debug> 997 :  IsList (Internal function)
Error on line 1 in file [CommandLine]
Max evaluation stack depth reached.
Please use MaxEvalDepth to increase the stack size as needed.
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#TraceExp" TARGET="Chapters">
TraceExp
</A>
, <A HREF="ref.html#TraceRule" TARGET="Chapters">
TraceRule
</A>
, <A NAME="TraceExp">

</A>
<H3>
<HR>TraceExp(expression)
</H3>

TraceExp(expression) : turn on tracing facility, and evaluate
expression. This is useful for tracing the evaluation of small
routines interactively from the command line.

<A NAME="TraceRule">

</A>
<H3>
<HR>TraceRule(template)expression
</H3>

Tracerule(template)expression : turn on tracing facility given
the template, and evaluate expression. the template is an example
of the function to trace on. template=x+y would trace all additions,
showing the arguments passed in, and the result of the addition.
Only user-defined functions can be traced.
<P>
This is useful for tracing a function that is called from within
another function. This way you can see how your function behaves
in the environment it is used in.
<P>
An example invocation of TraceRule is<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In( 1 ) = TraceRule(x+y)2+3*5+4;<P></PRE>
</TABLE>
Which should then show something to the effect of <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>    ENTER:2+3*5+4<P>      ENTER:2+3*5<P>          ARG:2 <- 2<P>          ARG:3*5 <- 15<P>      LEAVE:2+3*5 -> 17<P>        ARG:2+3*5 <- 17<P>        ARG:4 <- 4<P>    LEAVE:2+3*5+4 -> 21<P>Out( 0 ) = 21;</PRE>
</TABLE>

<p><HR><A NAME="c10">

</A>
<A HREF="refchapter10.html#&lt;" TARGET="Chapters">
&lt;
</A>
, <A HREF="refchapter10.html#&gt;" TARGET="Chapters">
&gt;
</A>
, <A HREF="refchapter10.html#&lt;=" TARGET="Chapters">
&lt;=
</A>
, <A HREF="refchapter10.html#&gt;=" TARGET="Chapters">
&gt;=
</A>
, <A HREF="refchapter10.html#!=" TARGET="Chapters">
!=
</A>
, <A HREF="refchapter10.html#=" TARGET="Chapters">
=
</A>
, <A HREF="refchapter10.html#Not" TARGET="Chapters">
Not
</A>
, <A HREF="refchapter10.html#And" TARGET="Chapters">
And
</A>
, <A HREF="refchapter10.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="refchapter10.html#IsFreeOf" TARGET="Chapters">
IsFreeOf
</A>
, <A HREF="refchapter10.html#IsZeroVector" TARGET="Chapters">
IsZeroVector
</A>
, <A HREF="refchapter10.html#IsNonObject" TARGET="Chapters">
IsNonObject
</A>
, <A HREF="refchapter10.html#IsEven" TARGET="Chapters">
IsEven
</A>
, <A HREF="refchapter10.html#IsOdd" TARGET="Chapters">
IsOdd
</A>
, <A HREF="refchapter10.html#IsFunction" TARGET="Chapters">
IsFunction
</A>
, <A HREF="refchapter10.html#IsAtom" TARGET="Chapters">
IsAtom
</A>
, <A HREF="refchapter10.html#IsString" TARGET="Chapters">
IsString
</A>
, <A HREF="refchapter10.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="refchapter10.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
, <A HREF="refchapter10.html#IsList" TARGET="Chapters">
IsList
</A>
, <A HREF="refchapter10.html#IsBound" TARGET="Chapters">
IsBound
</A>
, <A HREF="refchapter10.html#IsBoolean" TARGET="Chapters">
IsBoolean
</A>
, <A HREF="refchapter10.html#IsNegativeNumber" TARGET="Chapters">
IsNegativeNumber
</A>
, <A HREF="refchapter10.html#IsNegativeInteger" TARGET="Chapters">
IsNegativeInteger
</A>
, <A HREF="refchapter10.html#IsPositiveNumber" TARGET="Chapters">
IsPositiveNumber
</A>
, <A HREF="refchapter10.html#IsPositiveInteger" TARGET="Chapters">
IsPositiveInteger
</A>
, <A HREF="refchapter10.html#IsNotZero" TARGET="Chapters">
IsNotZero
</A>
, <A HREF="refchapter10.html#IsNonZeroInteger" TARGET="Chapters">
IsNonZeroInteger
</A>
, <A HREF="refchapter10.html#IsInfinity" TARGET="Chapters">
IsInfinity
</A>
, <A HREF="refchapter10.html#IsConstant" TARGET="Chapters">
IsConstant
</A>
, <H1>
Predicates
</H1>
<A NAME="&lt;">

</A>
<H3>
<HR>x &lt; y (prec. 9)
</H3>

x < y : Return True if "x" is smaller than "y", False otherwise.


<A NAME="&gt;">

</A>
<H3>
<HR>x &gt; y (prec. 9)
</H3>

x > y : Return True if "x" is larger than "y", False otherwise.


<A NAME="&lt;=">

</A>
<H3>
<HR>x &lt;= y (prec. 9)
</H3>

x <= y : Return True if "x" is smaller than or equals "y", False otherwise.


<A NAME="&gt;=">

</A>
<H3>
<HR>x &gt;= y (prec. 9)
</H3>

x >= y : Return True if "x" is larger than or equals "y", False otherwise.


<A NAME="!=">

</A>
<H3>
<HR>x!=y (prec. 9)
</H3>

x!=y : Return True if "x" is not equal to "y", False otherwise.



<A NAME="=">

</A>
<H3>
<HR>x=y  (prec. 9)
</H3>

x=y : This operator performs the same action as Equals(x,y).
It returns True if x and y would be displayed on screen the same,
False otherwise.


<A NAME="Not">

</A>
<H3>
<HR>Not
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
Not bool
<H5>
Parameters:
</H5>
bool - a boolean expression
<H5>
Description:
</H5>
Not returns the logical negation of the argument bool. If bool is
False it returns True, and if the argument is True Not returns False.
If the argument is neither True nor False it returns the entire
expression with evaluated arguments.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Not True
Out> False;
In> Not False
Out> True;
In> Not(a)
Out> Not a;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A NAME="And">

</A>
<H3>
<HR>And
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
a1 And a2 <br>
And(a1,a2,a3,...,an)
<H5>
Parameters:
</H5>
a1 .. an - boolean values (True or False)
<H5>
Description:
</H5>
This function returns True if all arguments are true. The
And operation is lazy, it returns False as soon as a False argument
is found (from left to right). If an argument other than True or
False is encountered a new And expression is returned with all
arguments that didn't evaluate to True or False yet.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> True And False
Out> False;
In> And(True,True)
Out> True;
In> False And a
Out> False;
In> True And a
Out> And(a);
In> And(True,a,True,b)
Out> b And a;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
, <A NAME="Or">

</A>
<H3>
<HR>Or
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
a1 Or a2 <br>
Or(a1,a2,a3,...,an)
<H5>
Parameters:
</H5>
a1 .. an - boolean values (True or False)
<H5>
Description:
</H5>
This function returns True if an argument is encountered
that is true (scanning from left to right). The
Or operation is lazy, it returns True as soon as a True argument
is found (from left to right). If an argument other than True or
False is encountered a new Or expression is returned with all
arguments that didn't evaluate to True or False yet.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> True Or False
Out> True;
In> False Or a
Out> Or(a);
In> Or(False,a,b,True)
Out> True;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
, <A NAME="IsFreeOf">

</A>
<H3>
<HR>IsFreeOf(expression,variable) or IsFreeOf(expression,{varlist})
</H3>

Returns wether "expression" depends on
"variable". "expression" is evaluated beforehand.
Example: "IsFreeOf(x+y,x);" evaluates to "False".
<P>
When a list of variables is passed, IsFreeOf returns True iff the
expression is independent of all the variables listed.
"IsFreeOf(x+y,{a,b});" would return True, and "IsFreeOf(x+y,{a,x});"
would return False.

<A NAME="IsZeroVector">

</A>
<H3>
<HR>IsZeroVector(vector)
</H3>

Returns wether "vector" only contains zeroes.
"vector" should be a list.


<A NAME="IsNonObject">

</A>
<H3>
<HR>IsNonObject(x)
</H3>

IsNonObject(x) : returns true if x is not of
the form Object(...).

<A NAME="IsEven">

</A>
<A NAME="IsOdd">

</A>
<H3>
<HR>IsEven(n) and IsOdd(n)
</H3>
Returns whether the integer n is even or odd (an integer n is even
if n divided by 2 is also an integer).
<A NAME="IsFunction">

</A>
<H3>
<HR>IsFunction(expr)
</H3>

IsFunction(expr) : Predicate that checks the type of a object.
cos(a) is a function. 

<A NAME="IsAtom">

</A>
<H3>
<HR>IsAtom(expr)
</H3>

IsAtom(expr) : Predicate that checks the type of a object.
Atoms are any object that can be represented with a text string (that
is, excluding lists). 

<A NAME="IsString">

</A>
<H3>
<HR>IsString(expr)
</H3>

IsString(expr) : Predicate that checks the type of a object.
Strings have the form "string",
that is, with quotes.

<A NAME="IsNumber">

</A>
<H3>
<HR>IsNumber(expr)
</H3>

IsNumber(expr) : Predicate that checks the type of a object.
1.2 or 1 are numbers. 

<A NAME="IsInteger">

</A>
<H3>
<HR>IsInteger(expr)
</H3>

IsInteger(expr) : Predicate that checks the type of a object.
1 is a integer. 
<A NAME="IsList">

</A>
<H3>
<HR>IsList(expr)
</H3>

IsList(expr) : Predicate that checks the type of a object.
{cos,a} is a list.

<A NAME="IsBound">

</A>
<H3>
<HR>IsBound(var)
</H3>

IsBound(var) :Predicate that checks the type of a object.
IsBound checks to see if variable var is bound.

<A NAME="IsBoolean">

</A>
<H3>
<HR>IsBoolean
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsBoolean(expression)
<H5>
Parameters:
</H5>
expression - an expression
<H5>
Description:
</H5>
IsBoolean returns True if the argument is of a boolean type.
This means it has to be either True, False, or an expression involving
functions that return a boolean result, like
=, &gt, &lt, &gt=, &lt=, !=, And, Not, Or.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsBoolean(a)
Out> False;
In> IsBoolean(True)
Out> True;
In> IsBoolean(a And b)
Out> True;

</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#True" TARGET="Chapters">
True
</A>
, <A HREF="ref.html#False" TARGET="Chapters">
False
</A>
, <A NAME="c10s1">

</A>
<H2>
<HR>Predicates on numbers
</H2>
These predicates return whether the argument is a number,
and of a specific type.
<A NAME="IsNegativeNumber">

</A>
<H3>
<HR>IsNegativeNumber(n)
</H3>
<A NAME="IsNegativeInteger">

</A>
<H3>
<HR>IsNegativeInteger(n)
</H3>
<A NAME="IsPositiveNumber">

</A>
<H3>
<HR>IsPositiveNumber(n)
</H3>
<A NAME="IsPositiveInteger">

</A>
<H3>
<HR>IsPositiveInteger(n)
</H3>
<A NAME="IsNotZero">

</A>
<H3>
<HR>IsNotZero(n)
</H3>
<A NAME="IsNonZeroInteger">

</A>
<H3>
<HR>IsNonZeroInteger(n)
</H3>
<A NAME="IsInfinity">

</A>
<H3>
<HR>IsInfinity(n)
</H3>

Returns True if the argument is either Infinity or -Infinity

<A NAME="IsConstant">

</A>
<H3>
<HR>IsConstant
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
IsConstant(expression)
<H5>
Parameters:
</H5>
expression - some expression
<H5>
Description:
</H5>
IsConstant returns True if the expression is some constant
or a function with constant arguments. It does this by checking
that no variables are referenced in the expression.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> IsConstant(Cos(x))
Out> False;
In> IsConstant(Cos(2))
Out> True;
In> IsConstant(Cos(2+x))
Out> False;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#IsNumber" TARGET="Chapters">
IsNumber
</A>
, <A HREF="ref.html#IsInteger" TARGET="Chapters">
IsInteger
</A>
, <p><HR><A NAME="c11">

</A>
<A HREF="refchapter11.html#CanProve" TARGET="Chapters">
CanProve
</A>
, <H1>
Propositional logic theorem prover
</H1>
<A NAME="CanProve">

</A>
<H3>
<HR>CanProve
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
CanProve(proposition)
<H5>
Parameters:
</H5>
proposition - a logical proposition
<H5>
Description:
</H5>
Yacas has a small built-in propositional logic theorem prover.
It can be invoked with a call to CanProve. <br>

An example of a proposition is 'if a implies b and b implies c then
a implies c'. Yacas supports the following operators <p>

 Not     negation, read as 'not'        <br>
 And     conjunction, read as 'and'     <br> 
 Or     disjunction, read as 'or'      <br> 
=>   implication, read as 'implies' <br> 

So the above mentioned proposition would be represented by

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>( (a=>b) And (b=>c) ) => (a=>c)
</PRE>
</TABLE>

 
Yacas can prove that is correct by applying <B><TT>CanProve</TT></B>
to it:


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> CanProve(( (a=>b) And (b=>c) ) => (a=>c))
Out> True;
</PRE>
</TABLE>


It does this the following way: in order to prove proposition p, it
suffices to prove that  Not p is false. It continues to simplify  Not p
using the rules <p>


<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE> Not  ( Not x)      --> x        eliminate double negation
x=>y        -->  Not x  Or  y   eliminate implication
 Not (x And y)      -->  Not x  Or   Not y  De Morgan's law
 Not (x  Or  y)    -->  Not x  And   Not y  De Morgan's law
(x  And  y)  Or  z --> (x Or z) And (y Or z)  Distribution
x  Or  (y  And  z) --> (x Or y) And (x Or z)  Distribution
</PRE>
</TABLE>

And the obvious other rules: 'True Or x --> True' etc.
The above rules will translate the proposition into a form

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>(p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
</PRE>
</TABLE>


If any of the clauses is false, the entire expression will be false.
In the next step, clauses are scanned for situations of the form:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>(p Or Y)  And  ( Not p Or Z) --> (Y Or Z)
</PRE>
</TABLE>


If this combination <B><TT>(Y Or Z)</TT></B> is empty, it is false, and
thus the entire proposition is false. <p>

As a last step, the algorithm negates the result again. This has the
added advantage of simplifying the expression further. 
    

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> CanProve(a  Or   Not a)         
Out> True;
In> CanProve(True  Or  a)       
Out> True;
In> CanProve(False  Or  a)      
Out> a;
In> CanProve(a  And   Not a)         
Out> False;
In> CanProve(a  Or b Or (a And b))     
Out> a Or b;

</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#True" TARGET="Chapters">
True
</A>
, <A HREF="ref.html#False" TARGET="Chapters">
False
</A>
, <A HREF="ref.html#And" TARGET="Chapters">
And
</A>
, <A HREF="ref.html#Or" TARGET="Chapters">
Or
</A>
, <A HREF="ref.html#Not" TARGET="Chapters">
Not
</A>
, <p><HR><A NAME="c12">

</A>
<A HREF="refchapter12.html#%" TARGET="Chapters">
%
</A>
, <A HREF="refchapter12.html#True" TARGET="Chapters">
True
</A>
, <A HREF="refchapter12.html#False" TARGET="Chapters">
False
</A>
, <A HREF="refchapter12.html#EndOfFile" TARGET="Chapters">
EndOfFile
</A>
, <A HREF="refchapter12.html#Infinity" TARGET="Chapters">
Infinity
</A>
, <A HREF="refchapter12.html#Pi" TARGET="Chapters">
Pi
</A>
, <H1>
Constants
</H1>
<A NAME="%">

</A>
<H3>
<HR>%
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
%
<H5>
Parameters:
</H5>

<H5>
Description:
</H5>
% evaluates to the previous result on the command line. % is a global
variable that is bound to the previous result from the command line.
Using % will evaluate the previous result (This uses the functionality
offered by the LazyGlobal command). <p>

Typical examples are <B><TT>Simplify(%)</TT></B> and <B><TT>PrettyForm(%)</TT></B>to simplify and show the result in a nice
form respectively.

<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Taylor(x,0,5)Sin(x)
Out> x-x^3/6+x^5/120;
In> PrettyForm(%)

     3    5 
    x    x  
x - -- + ---
    6    120


</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#LazyGlobal" TARGET="Chapters">
LazyGlobal
</A>
, <A NAME="True">

</A>
<A NAME="False">

</A>
<H3>
<HR>True and False
</H3>


<B><TT>True</TT></B> and <B><TT>False</TT></B> are typically the result
of boolean expressions like <B><TT>2 &lt 3</TT></B> and <B><TT>True And False</TT></B>.
<A NAME="EndOfFile">

</A>
<H3>
<HR>EndOfFile
</H3>

EndOfFile : End of file marker when reading from file. If a file
contains the expression <B><TT>EndOfFile;</TT></B> the
operation will stop reading the file at that point.

<A NAME="Infinity">

</A>
<H3>
<HR>Infinity
</H3>


Infinity represents infinity. It can be the result of certain
calculations.
<P>

Note that for most analytic functions Yacas understands Infinity.
Thus <B><TT>Infinity*2</TT></B> will return Infinity, and <B><TT>a &lt Infinity</TT></B> will evaluate to True.

<A NAME="Pi">

</A>
<H3>
<HR>Pi
</H3>


Pi represents the value of pi. When the N(..) function is used,
Pi is set to the correct value. It is probably better to use
Pi than Pi(), for simplification purposes.


<p><HR><A NAME="c13">

</A>
<A HREF="refchapter13.html#:=" TARGET="Chapters">
:=
</A>
, <A HREF="refchapter13.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="refchapter13.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="refchapter13.html#Local" TARGET="Chapters">
Local
</A>
, <A HREF="refchapter13.html#++" TARGET="Chapters">
++
</A>
, <A HREF="refchapter13.html#--" TARGET="Chapters">
--
</A>
, <A HREF="refchapter13.html#Object" TARGET="Chapters">
Object
</A>
, <A HREF="refchapter13.html#LazyGlobal" TARGET="Chapters">
LazyGlobal
</A>
, <H1>
Variables
</H1>
<A NAME=":=">

</A>
<H3>
<HR>x:=y
</H3>

x:=y :  Assignment. The ":=" operator can be used for three different types
of assignment:

Assigning a variable: as in "x:=2;",
Defining a new function: as in "f(x):=Sin(2*x);", or
Assigning a list item a value: as in "list[i] := 2;"


<A NAME="Set">

</A>
<H3>
<HR>Set(variable, value)
</H3>

Set(variable, value) : Sets variable to evaluated value and returns "True".


<A NAME="Clear">

</A>
<H3>
<HR>Clear(...)
</H3>

Clear(...) : Makes sure variables specified in "..." are not bound
any more to a value, and returns True.


<A NAME="Local">

</A>
<H3>
<HR>Local(...)
</H3>

Local(...) :
Mark the variables in the unevaluated argument list as
local variables (local within a Prog block or a function).


<A NAME="++">

</A>
<H3>
<HR>x++
</H3>

x++ : increment the variable "x".


<A NAME="--">

</A>
<H3>
<HR>x--
</H3>

x-- : decrement the variable "x".


<A NAME="Object">

</A>
<H3>
<HR>Object("predicate",object)
</H3>

Object("predicate",object) : declaration of an
incomplete object. This function returns "object"
as soon as "predicate" returns "True" on it. 
Example: "Object("IsNumber",x);" returns itself,
where if x was an integer, it would return that
integer.

<A NAME="LazyGlobal">

</A>
<H3>
<HR>LazyGlobal
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
LazyGlobal(var)
<H5>
Parameters:
</H5>
var - variable (held argument)
<H5>
Description:
</H5>
LazyGlobal enforces that a global variable will re-evaluate
when used. The global variable needs to exist for this function
to work. Also, this functionality doesn't survive if Clear(var)
is called afterwards. <p>

Places where this is used include the global variables % and I.<p>

The use of lazy in the name stems from the concept of lazy evaluation.
The object the global variable is bound to will only be evaluated when
called. The LazyGlobal property only holds once: after that, the result
of evaluation is stored in the global variable, and it won't be reevaluated again:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> a:=Hold(Taylor(x,0,30)Sin(x))
Out> Taylor(x,0,30)Sin(x);
In> LazyGlobal(a)
</PRE>
</TABLE>


Then the first time you call a it evaluates Taylor(...) and assigns the result to a. The next time
you call a it immediately returns the result.
LazyGlobal is called for "%" each time "%" changes.


<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> a:=Hold(2+3)
Out> 2+3;
In> a
Out> 2+3;
In> LazyGlobal(a)
Out> True;
In> a
Out> 5;

</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#Set" TARGET="Chapters">
Set
</A>
, <A HREF="ref.html#Clear" TARGET="Chapters">
Clear
</A>
, <A HREF="ref.html#Local" TARGET="Chapters">
Local
</A>
, <p><HR><A NAME="c14">

</A>
<A HREF="refchapter14.html#FullForm" TARGET="Chapters">
FullForm
</A>
, <A HREF="refchapter14.html#Echo" TARGET="Chapters">
Echo
</A>
, <A HREF="refchapter14.html#PrettyForm" TARGET="Chapters">
PrettyForm
</A>
, <A HREF="refchapter14.html#Write" TARGET="Chapters">
Write
</A>
, <A HREF="refchapter14.html#WriteString" TARGET="Chapters">
WriteString
</A>
, <A HREF="refchapter14.html#Space" TARGET="Chapters">
Space
</A>
, <A HREF="refchapter14.html#NewLine" TARGET="Chapters">
NewLine
</A>
, <A HREF="refchapter14.html#FromFile" TARGET="Chapters">
FromFile
</A>
, <A HREF="refchapter14.html#FromString" TARGET="Chapters">
FromString
</A>
, <A HREF="refchapter14.html#ToString" TARGET="Chapters">
ToString
</A>
, <A HREF="refchapter14.html#Read" TARGET="Chapters">
Read
</A>
, <A HREF="refchapter14.html#LispRead" TARGET="Chapters">
LispRead
</A>
, <A HREF="refchapter14.html#ReadToken" TARGET="Chapters">
ReadToken
</A>
, <A HREF="refchapter14.html#ToFile" TARGET="Chapters">
ToFile
</A>
, <A HREF="refchapter14.html#Load" TARGET="Chapters">
Load
</A>
, <A HREF="refchapter14.html#Use" TARGET="Chapters">
Use
</A>
, <A HREF="refchapter14.html#DefLoad" TARGET="Chapters">
DefLoad
</A>
, <A HREF="refchapter14.html#FindFile" TARGET="Chapters">
FindFile
</A>
, <A HREF="refchapter14.html#PatchLoad" TARGET="Chapters">
PatchLoad
</A>
, <H1>
Input/Output
</H1>
<A NAME="FullForm">

</A>
<H3>
<HR>FullForm(expression)
</H3>

FullForm(expression) : 
Displays evaluated form of "expression", and returns it.


<A NAME="Echo">

</A>
<H3>
<HR>Echo({...})
</H3>


Echo writes the contents of the list passed to it to the current
output, and calls NewLine(). If an entry in the list is a string
it writes the string unstringified. Example:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
f(x):=x^2;
Echo({"The square of two is ",f(2)});
</PRE>
</TABLE>
which should write out "The square of two is 2" to the current
output
<A NAME="PrettyForm">

</A>
<H3>
<HR>PrettyForm(expr)
</H3>

PrettyForm shows the expression in a nicer form, closer to
the notation usually used when a human writes down an expression.
Example:

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> PrettyForm(Taylor(x,0,9)Sin(x))

     /  3 \    5     /  7 \      9  
    -\ x  /   x     -\ x  /     x   
x + ------- + --- + ------- + ------
       6      120    5040     362880

Out> True;</PRE>
</TABLE>


This is generally useful when the result of a calculation is more
complex than a simple number.


<A NAME="Write">

</A>
<H3>
<HR>Write(...)
</H3>

Write(...) : Write out the expressions contained in "..." (evaluated).


<A NAME="WriteString">

</A>
<H3>
<HR>WriteString(string)
</H3>

WriteString(string) : Writes out a literal string, which should be of
the form "string" (surrounded by quotes). The argument is evaluated.


<A NAME="Space">

</A>
<H3>
<HR>Space(nr)
</H3>

Space(nr) : Print out "nr" spaces. The "nr"
argument is optional, the default value being 1.


<A NAME="NewLine">

</A>
<H3>
<HR>NewLine(nr)
</H3>

NewLine(nr) : Print out "nr" newlines. The "nr"
argument is optional, the default value being 1.


<A NAME="FromFile">

</A>
<H3>
<HR>FromFile("file") body
</H3>

FromFile("file") body : Open "file" for reading, and execute body, returning
its result.


<A NAME="FromString">

</A>
<H3>
<HR>FromString("string") body
</H3>

FromString("string") body : use "string" to parse from when issuing
a read from file, and execute body, returning its result.


<A NAME="ToString">

</A>
<H3>
<HR>ToString() body
</H3>

ToString redirects all output (from Write or WriteString, for instance)
to a string, and returns this string.

<A NAME="Read">

</A>
<H3>
<HR>Read()
</H3>

Read() : 
Read expression from current input, and return result. When the end of an
input file is encountered, the token atom "EndOfFile" is returned.


<A NAME="LispRead">

</A>
<H3>
<HR>LispRead()
</H3>

Read() : 
Read expression from current input, and return result. When the end of an
input file is encountered, the token atom "EndOfFile" is returned.
<P>
This function is different from <B><TT>Read()</TT></B> in that it parses an expression
in lisp syntax: so you need to type <B><TT>(+ a b)</TT></B> in stead of <B><TT>a+b</TT></B>. The advantage of lisp syntax is that it is less unambiguous than the
infix operator grammar Yacas uses by default.

<A NAME="ReadToken">

</A>
<H3>
<HR>ReadToken()
</H3>

ReadToken() : Read token from current input, and return result.                          
When the end of an input file is encountered, the token
atom "EndOfFile" is returned.


<A NAME="ToFile">

</A>
<H3>
<HR>ToFile("file")
</H3>

ToFile("file") : 
Open "file" for writing, and execute body, returning its result.


<A NAME="Load">

</A>
<H3>
<HR>Load("filename")
</H3>

Load("filename") : Reads in and evaluates expressions from the file
with file name filename.

See also "Use".


<A NAME="Use">

</A>
<H3>
<HR>Use("filename")
</H3>


Use("filename") : Reads in and evaluates expressions from the file
with file name filename if it hasn't been loaded before. This function
makes sure the file will at least have been loaded, but not loaded twice.

See also "Load".


<A NAME="DefLoad">

</A>
<H3>
<HR>DefLoad("filename")
</H3>


DefLoad("filename") : Loads a file filename.def, which should have a
list of functions, terminated by a }. This tells the system to load
the file "filename" as soon as the user calls one of the functions
named in the file (if not done so already). This allows for faster
startup times, since not all of the rules databases need to be loaded,
just the descriptions on which files to load for which functions.

<A NAME="FindFile">

</A>
<H3>
<HR>FindFile(name)
</H3>

FindFile returns the file that would be opened when a Load(name)
would be invoked. It returns the full path to the file.

<A NAME="PatchLoad">

</A>
<H3>
<HR>PatchLoad
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
PatchLoad(filename)
<H5>
Parameters:
</H5>
filename - the file to patch
<H5>
Description:
</H5>
PatchLoad loads in a file and outputs the contents to the current
output. The file can contain blocks delimited by &lt? and ?&gt
(meaning Yacas Begin and Yacas End). The piece of text between
such delimiters is treated as a separate file with Yacas instructions,
which is then loaded and executed. All output of write statements
in that block will be written to the same current output.
<P>
This is similar to the way php works. You can have a static text file
with dynamic content generated by Yacas.

<H5>
See Also:
</H5>
<A HREF="ref.html#PatchString" TARGET="Chapters">
PatchString
</A>
, <A HREF="ref.html#Load" TARGET="Chapters">
Load
</A>
, <p><HR><A NAME="c1">

</A>
<A HREF="refprogchapter1.html#Atom" TARGET="Chapters">
Atom
</A>
, <A HREF="refprogchapter1.html#String" TARGET="Chapters">
String
</A>
, <A HREF="refprogchapter1.html#ConcatStrings" TARGET="Chapters">
ConcatStrings
</A>
, <A HREF="refprogchapter1.html#Prog" TARGET="Chapters">
Prog
</A>
, <A HREF="refprogchapter1.html#Check" TARGET="Chapters">
Check
</A>
, <A HREF="refprogchapter1.html#Prefix" TARGET="Chapters">
Prefix
</A>
, <A HREF="refprogchapter1.html#Postfix" TARGET="Chapters">
Postfix
</A>
, <A HREF="refprogchapter1.html#Bodied" TARGET="Chapters">
Bodied
</A>
, <A HREF="refprogchapter1.html#Infix" TARGET="Chapters">
Infix
</A>
, <A HREF="refprogchapter1.html#IsInfix" TARGET="Chapters">
IsInfix
</A>
, <A HREF="refprogchapter1.html#IsPrefix" TARGET="Chapters">
IsPrefix
</A>
, <A HREF="refprogchapter1.html#IsPostfix" TARGET="Chapters">
IsPostfix
</A>
, <A HREF="refprogchapter1.html#OpPrecedence" TARGET="Chapters">
OpPrecedence
</A>
, <A HREF="refprogchapter1.html#RightAssociative" TARGET="Chapters">
RightAssociative
</A>
, <A HREF="refprogchapter1.html#LeftPrecedence" TARGET="Chapters">
LeftPrecedence
</A>
, <A HREF="refprogchapter1.html#RightPrecedence" TARGET="Chapters">
RightPrecedence
</A>
, <A HREF="refprogchapter1.html#RuleBase" TARGET="Chapters">
RuleBase
</A>
, <A HREF="refprogchapter1.html#Rule" TARGET="Chapters">
Rule
</A>
, <A HREF="refprogchapter1.html#HoldArg" TARGET="Chapters">
HoldArg
</A>
, <A HREF="refprogchapter1.html#TryRetract" TARGET="Chapters">
TryRetract
</A>
, <A HREF="refprogchapter1.html#UnFence" TARGET="Chapters">
UnFence
</A>
, <A HREF="refprogchapter1.html#MacroSet" TARGET="Chapters">
MacroSet
</A>
, <A HREF="refprogchapter1.html#MacroClear" TARGET="Chapters">
MacroClear
</A>
, <A HREF="refprogchapter1.html#MacroLocal" TARGET="Chapters">
MacroLocal
</A>
, <A HREF="refprogchapter1.html#MacroRuleBase" TARGET="Chapters">
MacroRuleBase
</A>
, <A HREF="refprogchapter1.html#MacroRule" TARGET="Chapters">
MacroRule
</A>
, <A HREF="refprogchapter1.html#Secure" TARGET="Chapters">
Secure
</A>
, <H1>
Programming
</H1>
<A NAME="Atom">

</A>
<H3>
<HR>Atom("atom")
</H3>

Atom("atom") : 
Returns an atom with the string representation given
as the evaluated argument. Example: "Atom("foo");" returns
"foo".


<A NAME="String">

</A>
<H3>
<HR>String(atom)
</H3>

String(atom) : Inverse of Atom: turns atom into "atom".

<A NAME="ConcatStrings">

</A>
<H3>
<HR>ConcatStrings(strings)
</H3>

ConcatStrings(strings) : 
Concatenate strings. Example:
"ConcatStrings("a","b","c");" will return "abc".


<H3>
<HR>/* comment */
</H3>

A comment block in a source file.


<A NAME="Prog">

</A>
<H3>
<HR>Prog(...)
</H3>

Prog(...) : Evaluate the arguments in order, and return the result of the
last evaluated expression.
This is the same as the "[ ... ]" constuct, that
is, "Prog(a,b);" is the same as typing "[a;b;];" and is
very useful for writing out function bodies (the "[...]" construct
is converted into "Prog(...)" during the parsing stage)


<A NAME="Check">

</A>
<H3>
<HR>Check(predicate,"error")
</H3>

Check(predicate,"error") : 
If "predicate" doesn't evaluate to "True",
then current operation will be stopped, and execution
will jump right back to the command line, showing
"error". Use this to assure that some condition
is met during evaluation of expressions (guarding
against internal errors).


<A NAME="Prefix">

</A>
<H3>
<HR>Prefix("operator")
</H3>

Prefix("operator") : Defines a new operator for the prefix parser
to understand. This function can also be called with an additional argument
for the precedence of the prefix operator.

<A NAME="Postfix">

</A>
<H3>
<HR>Postfix("oper")
</H3>

Postfix("oper") : Defines a new operator for the postfix parser to understand.


<A NAME="Bodied">

</A>
<H3>
<HR>Bodied("oper",precedence)
</H3>

Bodied("oper",precedence) : Defines a new operator for the bodied parser to understand.



<A NAME="Infix">

</A>
<H3>
<HR>Infix("oper",precedence)
</H3>

Infix("oper",precedence) : Defines a new operator for the infix parser to understand.
"precedence" is evaluated.


<A NAME="IsInfix">

</A>
<A NAME="IsPrefix">

</A>
<A NAME="IsPostfix">

</A>
<H3>
<HR>IsInfix("str"), IsPrefix("str"), IsPostfix("str")
</H3>

Returns wether str is an infix, prefix, or postfix operator.
IsInfix("+") should return True. IsInfix("a") should return False.


<A NAME="OpPrecedence">

</A>
<H3>
<HR>OpPrecedence("str")
</H3>

Returns the precedence of the infix operator str. OpPrecedence("+")
should return 6.


<A NAME="RightAssociative">

</A>
<H3>
<HR>RightAssociative("operator")
</H3>

makes the operator right-associative. Example: RightAssociative("*")
would make multiplication right-associative. Take care not to abuse
this function, because the reverse, making an infix operator
left-associative, is not implemented.


<A NAME="LeftPrecedence">

</A>
<A NAME="RightPrecedence">

</A>
<H3>
<HR>LeftPrecedence("oper",precedence), RightPrecedence("oper",precedence)
</H3>


oper should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display a-(b-c)
correctly. a+b+c is the same as a+(b+c), but a-(b-c) is not
the same as a-b-c.


<A NAME="RuleBase">

</A>
<H3>
<HR>RuleBase("operator",{params})
</H3>

RuleBase("operator",{params}) : Define a new rules table entry for a
function "operator", with {params} as the parameter list.


<A NAME="Rule">

</A>
<H3>
<HR>Rule("operator",arity,precedence,predicate) body
</H3>

Rule("operator",arity,precedence,predicate) body : 
Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". "precedence" is checked from low to high.
The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.
Rules with a low value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.


<A NAME="HoldArg">

</A>
<H3>
<HR>HoldArg("operator",parameter)
</H3>

HoldArg("operator",parameter) : 
Specify that parameter (which should be part of
a parameter list for a function "operator") should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all RuleBase calls for this operator.


<A NAME="TryRetract">

</A>
<H3>
<HR>TryRetract("operator",arity)
</H3>

TryRetract("operator",arity) : Remove a rulebase with some specific arity,
if it exists at all.


<A NAME="UnFence">

</A>
<H3>
<HR>UnFence("operator",arity)
</H3>

UnFence("operator",arity) : When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and the such). The For and ForEach functions
defined in the standard packages use this, for instance.


<A NAME="MacroSet">

</A>
<A NAME="MacroClear">

</A>
<A NAME="MacroLocal">

</A>
<A NAME="MacroRuleBase">

</A>
<A NAME="MacroRule">

</A>
<H3>
<HR>MacroSet, MacroClear,MacroLocal, MacroRuleBase,MacroRule
</H3>


Same as their non-macro counterparts, except
that their arguments are evaluated before
the required action is performed. This is
useful in macro-like procedures.


<A NAME="Secure">

</A>
<H3>
<HR>Secure(body)
</H3>

Secure evaluates body in a safe environment, where file opening
and system calls are not allowed. This can protect the system
when an unsafe evaluation is done (Like a script sent over the
internet to be evaluated on a computer).

<p><HR><A NAME="c2">

</A>
<A HREF="refprogchapter2.html#MathNot" TARGET="Chapters">
MathNot
</A>
, <A HREF="refprogchapter2.html#MathAnd" TARGET="Chapters">
MathAnd
</A>
, <A HREF="refprogchapter2.html#MathOr" TARGET="Chapters">
MathOr
</A>
, <A HREF="refprogchapter2.html#BitAnd" TARGET="Chapters">
BitAnd
</A>
, <A HREF="refprogchapter2.html#BitOr" TARGET="Chapters">
BitOr
</A>
, <A HREF="refprogchapter2.html#BitXor" TARGET="Chapters">
BitXor
</A>
, <A HREF="refprogchapter2.html#Equals" TARGET="Chapters">
Equals
</A>
, <A HREF="refprogchapter2.html#LessThan" TARGET="Chapters">
LessThan
</A>
, <A HREF="refprogchapter2.html#GreaterThan" TARGET="Chapters">
GreaterThan
</A>
, <A HREF="refprogchapter2.html#ShiftLeft" TARGET="Chapters">
ShiftLeft
</A>
, <A HREF="refprogchapter2.html#ShiftRight" TARGET="Chapters">
ShiftRight
</A>
, <H1>
Built-in functions
</H1>
<A NAME="MathNot">

</A>
<H3>
<HR>MathNot(expression)
</H3>

MathNot(expression) : 
Returns "False" if "expression" evaluates
to "True", and vice versa.


<A NAME="MathAnd">

</A>
<H3>
<HR>MathAnd(...)
</H3>

MathAnd(...) : 
Lazy and: returns True" if all args evaluate to
"True", and does this by looking at first, and then at the
second argument, until one is "False".
If one is "False" it immediately returns "False" without
evaluating the rest. This is faster, but also means that none of the
arguments should cause side effects when they are evaluated.


<A NAME="MathOr">

</A>
<H3>
<HR>MathOr(...)
</H3>

MathOr(...) : 
MathOr is the or equivalent of And. It is lazy-evaluated too.
"And(...)" and "Or(...)" do also exist. You can define
them as infix operators
yourself, so you have the choice of precedence. In the standard scripts
they are in fact declared as infix operators, so you can write
"expr1 And expr".


<A NAME="BitAnd">

</A>
<A NAME="BitOr">

</A>
<A NAME="BitXor">

</A>
<H3>
<HR>BitAnd(n,m), BitOr(n,m), BitXor(n,m)
</H3>

BitAnd(n,m), BitOr(n,m), BitXor(n,m) : return bitwise and, or and xor
of two numbers.


<A NAME="Equals">

</A>
<H3>
<HR>Equals(a,b)
</H3>

Equals(a,b) : 
Compares evaluated a and b recursively
(stepping into expressions). so "Equals(a,b)" returns
"True" if the expressions would be printed exactly
the same, and "False" otherwise.


<A NAME="LessThan">

</A>
<A NAME="GreaterThan">

</A>
<H3>
<HR>LessThan(a,b), GreaterThan(a,b)
</H3>

LessThan(a,b), GreaterThan(a,b) : 
Comparing numbers.

<H3>
<HR>Math...
</H3>


MathGcd(n,m)  (Greatest Common Divisor),
MathAdd(x,y),
MathSubtract(x,y),
MathMultiply(x,y),
MathDivide(x,y),
MathSqrt(x)  (Square root),
MathFloor(x), MathCeil(x),
MathAbs(x), MathMod(x,y),
MathExp(x), MathLog(x) (Natural logarithm),
MathPower(x,y),
MathSin(x), MathCos(x), MathTan(x),
MathArcSin(x), MathArcCos(x), MathArcTan(x),
MathDiv(x,y), MathMod(x,y) :
MathSqrt(x) (Square root),

Calculation of sin,cos,tan etc. of x. x HAS to
be a number. The reason Math is prepended to
the names is you might want to derive equivalent
non-evaluating functions. The Math... versions require the arguments
to be numbers.


<H3>
<HR>Fast...
</H3>


FastExp(x), FastLog(x) (Natural logarithm),
FastPower(x,y),
FastSin(x), FastCos(x), FastTan(x),
FastArcSin(x), FastArcCos(x), FastArcTan(x) :

Versions of these functions using the internal c version. These
should then at least be faster than the arbitrary precision versions.


<A NAME="ShiftLeft">

</A>
<A NAME="ShiftRight">

</A>
<H3>
<HR>ShiftLeft(number,bits), ShiftRight(number,bits)
</H3>

ShiftLeft(number,bits), ShiftRight(number,bits) : 
Shift number bits to left or right.


<p><HR><A NAME="c3">

</A>
<A HREF="refprogchapter3.html#DllLoad" TARGET="Chapters">
DllLoad
</A>
, <A HREF="refprogchapter3.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="refprogchapter3.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="refprogchapter3.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="refprogchapter3.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="refprogchapter3.html#StubApiCRemark" TARGET="Chapters">
StubApiCRemark
</A>
, <A HREF="refprogchapter3.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A HREF="refprogchapter3.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="refprogchapter3.html#StubApiCStruct" TARGET="Chapters">
StubApiCStruct
</A>
, <H1>
The Yacas plugin structure
</H1>
Yacas supports dynamically loading libraries at runtime. This allows
it to interface with other libraries that support additional
functionality. For example, there could be a plugin enabling
the user to script a user interface from within Yacas, or a
specific powerful library to do numeric calculations.
<p>
The plugin feature is currently in an experimental stage. There
are some examples in the plugins/ directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The plugins/ directory
contains a README file with more details on compilation. 
<p>
In addition to the plugin structure in the Yacas engine, there is
a 'cstubgen' module (currently still in development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. the 'cstubgen' module is then
able to write out a c++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the plugins/
directory (the files ending with api.stub). The make file
makefile.plugin is configured to automatically convert these to
the required c++ files.
<p>
In addition to the c++ stub file cstubgen also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.
<p>
The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(loading DLLs is platform-dependent).
<p>
This chapter assumes the reader is comfortable programming in c++.

<A NAME="DllLoad">

</A>
<H3>
<HR>DllLoad
</H3>
Internal function<br><H5>
Calling Sequence:
</H5>
DllLoad(file)
<H5>
Parameters:
</H5>
file - file name of the plugin
<H5>
Description:
</H5>
DllLoad forces Yacas to load the dynamic link library (.so file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where dlopen can find it.
<H5>
Examples:
</H5>
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> DllLoad("./libopengl.so");
Out> True;
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A NAME="StubApiCStart">

</A>
<H3>
<HR>StubApiCStart
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCStart()
<H5>
Parameters:
</H5>

<H5>
Description:
</H5>
To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub c++ file.
<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A NAME="StubApiCShortIntegerConstant">

</A>
<H3>
<HR>StubApiCShortIntegerConstant
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCShortIntegerConstant(const,value)
<H5>
Parameters:
</H5>
const - string representing the global variable to be bound runtime <br>
       value - integer value the global should be bound to
<H5>
Description:
</H5>
define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define <br>
#define FOO 10 <br>
Then  <br>
StubApiCShortIntegerConstant("FOO","FOO") <br>
will bind the global variable FOO to the value for FOO defined in
the library header file.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A NAME="StubApiCInclude">

</A>
<H3>
<HR>StubApiCInclude
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCInclude(file)
<H5>
Parameters:
</H5>
file - file to include from the library the plugin is based on
<H5>
Description:
</H5>
Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for opengl, you need to specify <br>
StubApiCInclude("&lt;GL/gl.h&gt;") <BR>
and for user include file:
StubApiCInclude("\"GL/gl.h\"") <BR>

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A NAME="StubApiCFunction">

</A>
<H3>
<HR>StubApiCFunction
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCFunction(returntype,fname,args) <br>
StubApiCFunction(returntype,fname,fname2,args)

<H5>
Parameters:
</H5>

returntype - return type of library function <br>
fname - function of built-in function <br>
fname2 - (optional) function name to be used from within Yacas <br>
args - list of arguments to the function

<H5>
Description:
</H5>
This function declares a library function, along with its
calling sequence. cstubgen will then generate the c++ code
required to call this function.
<p>
Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).
<p>
If fname2 is not supplied, it will be assumed to be the same as fname.
<p>
The return types currently supported are "int", "double" and "void".

The argument values that are currently supported
are "int", "double", and "input_string".

Argument types can be specified simply as a string referring to their
type, like "int", or they can be lists with an additional element
stating the name of the variable: {"int","n"}. The variable
will then show up in the automatically generated documentation as
having the name n.

<H5>
Examples:
</H5>
To define the opengl function glVertex3d that accepts three
doubles and returns void:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCFunction("void","glVertex3d",{"double","double","double"});
</PRE>
</TABLE>

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A NAME="StubApiCRemark">

</A>
<H3>
<HR>StubApiCRemark
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCRemark(string)
<H5>
Parameters:
</H5>
string - remark string to be added to the documentation
<H5>
Description:
</H5>
StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a .description file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A NAME="StubApiCSetEnv">

</A>
<H3>
<HR>StubApiCSetEnv
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCSetEnv(func)
<H5>
Parameters:
</H5>
func - function to call to set the environment variable
<H5>
Description:
</H5>
This function forces the plugin to call the function func, with as
argument LispEnvironment& aEnvironment. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.
<p>
There needs to ba a function in the plugin somewhere of the form 

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>static LispEnvironment* env = NULL;
void GlutSetEnv(LispEnvironment& aEnv)
{
    env = &aEnv;
}
</PRE>
</TABLE>

Then calling

<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCSetEnv("GlutSetEnv");

</PRE>
</TABLE>

will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCFile" TARGET="Chapters">
StubApiCFile
</A>
, <A NAME="StubApiCFile">

</A>
<H3>
<HR>StubApiCFile
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCFile(basename)
<H5>
Parameters:
</H5>
basename - basename for the generation of the stub file
<H5>
Description:
</H5>
Generate the c++ stub file, "basename.cc", and a documentation file
named "basename.description". The descriptions are automatically
generated while adding functions and constants to the stub.

<H5>
See Also:
</H5>
<A HREF="ref.html#StubApiCStart" TARGET="Chapters">
StubApiCStart
</A>
, <A HREF="ref.html#StubApiCShortIntegerConstant" TARGET="Chapters">
StubApiCShortIntegerConstant
</A>
, <A HREF="ref.html#StubApiCInclude" TARGET="Chapters">
StubApiCInclude
</A>
, <A HREF="ref.html#StubApiCFunction" TARGET="Chapters">
StubApiCFunction
</A>
, <A HREF="ref.html#StubApiCSetEnv" TARGET="Chapters">
StubApiCSetEnv
</A>
, <A NAME="StubApiCStruct">

</A>
<H3>
<HR>StubApiCStruct
</H3>
Standard math library<br><H5>
Calling Sequence:
</H5>
StubApiCStruct(name) <br>
StubApiCStruct(name,freefunction)

<H5>
Parameters:
</H5>
name - name of structure <br>
freefunction - function that can be called to clean up the object

<H5>
Description:
</H5>
StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.
<p>
By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.

<H5>
Examples:
</H5>
in a library header file, define:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>typedef struct SomeStruct
{
  int a;
  int b;
} SomeStruct;
</PRE>
</TABLE>
Then in the stub file you can declare this struct by calling:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>StubApiCStruct("SomeStruct*")
</PRE>
</TABLE>



<H5>
See Also:
</H5>
<A HREF="ref.html" TARGET="Chapters">

</A>
, <A HREF="ref.html" TARGET="Chapters">

</A>
, <p><HR><A NAME="c4">

</A>
<A HREF="refprogchapter4.html#IsGeneric" TARGET="Chapters">
IsGeneric
</A>
, <A HREF="refprogchapter4.html#GenericTypeName" TARGET="Chapters">
GenericTypeName
</A>
, <A HREF="refprogchapter4.html#ArrayCreate" TARGET="Chapters">
ArrayCreate
</A>
, <A HREF="refprogchapter4.html#ArraySize" TARGET="Chapters">
ArraySize
</A>
, <A HREF="refprogchapter4.html#ArrayGet" TARGET="Chapters">
ArrayGet
</A>
, <A HREF="refprogchapter4.html#ArraySet" TARGET="Chapters">
ArraySet
</A>
, <A HREF="refprogchapter4.html#ArrayCreateFromList" TARGET="Chapters">
ArrayCreateFromList
</A>
, <A HREF="refprogchapter4.html#ListFromArray" TARGET="Chapters">
ListFromArray
</A>
, <H1>
Generic objects
</H1>

Generic objects are objects that are implemented in c++, but
can be accessed through the Yacas interpreter.

<A NAME="IsGeneric">

</A>
<H3>
<HR>IsGeneric(object)
</H3>

IsGeneric(object) : returns whether an object is a generic object
type.

<A NAME="GenericTypeName">

</A>
<H3>
<HR>GenericTypeName(object)
</H3>

GenericTypeName(object) : returns a string representation of
the name of a generic object. <BR>

Example: GenericTypeName(ArrayCreate(10,1)) sould return "Array".

<A NAME="ArrayCreate">

</A>
<H3>
<HR>ArrayCreate(size,init)
</H3>

Create an array the with size elements, all initialized to the
value init.

<A NAME="ArraySize">

</A>
<H3>
<HR>ArraySize(array)
</H3>

Return the size of an array (number of elements in the array).

<A NAME="ArrayGet">

</A>
<H3>
<HR>ArrayGet(array,index)
</H3>

Get the element at position index in the array passed. Arrays are treated
as base-one, so index set to 1 would return the first element. <BR>

Arrays can also be accessed through the [] operators. So
array[index] would return the same as ArrayGet(array,index).

<A NAME="ArraySet">

</A>
<H3>
<HR>ArraySet(array,index,element)
</H3>

Set the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so index set to 1 would set first element. <BR>

Arrays can also be accessed through the [] operators. So
array[index]:=element would do the same as ArraySet(array,index,element).

<A NAME="ArrayCreateFromList">

</A>
<H3>
<HR>ArrayCreateFromList(list)
</H3>

Creates an array from the contents of the list passed in.

<A NAME="ListFromArray">

</A>
<H3>
<HR>ListFromArray(array)
</H3>

Creates a list from the contents of the array passed in.

<p><HR>
</BODY>

</FONT>

</HTML>
