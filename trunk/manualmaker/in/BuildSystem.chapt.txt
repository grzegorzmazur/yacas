		The Yacas build system

	    Introduction

*A build system

This chapter describes the build system of Yacas. So here you will
find what happens when you give the {configure} or the {make} command,
and how to change this. It will concentrate on Unix systems; other
architectures are briefly covered in the final section.

As the Yacas build system is built on the GNU autotools suite, which
contains both {automake} and {autoconf}, we will start with a short
description of this package. Then we will turn to the various
components of Yacas: the program itself, the script files, the
documentation, the test suite, and so on. 

As explained in the {INSTALL} file, building Yacas requires the
following steps.
*	(This step is only necessary if building from CVS.) Start by
running the {makemake} script. This executes the {automake} and
{autoconf} programs. 
*	Then the {configure} script should be run.
*	Finally, Yacas can be built by giving the {make} command.

Both {configure} and {make} accept many options. Some of them are
explained below.


	    The GNU autotools suite

*A build system!autotools
*A autotools

The GNU autotools suite is a collection of applications to streamline
the build system of other programs, like Yacas. Its two main goals are
to present a consistent build procedure to users, and to assist
developers in tackling portability problems.

One important thing to keep in mind is that the autotools suite needs
only to be installed on the developers' systems, not on the users'
system (here, "users" refers to the people who are compiling Yacas). 

*A build system!libtool
*A libtool

The autotools suite consists of a number of utilities. These are
developed separately, but are designed to be used together. They are
*	{automake}. Its main goal is to produce a {Makefile.in} file
from a high-level description in the {Makefile.am} file. The
{configure} script generated by {autoconf} will later transform it in
a {Makefile}. The generated Makefiles are portable and contain all the
targets specified in the GNU Coding Standards document, like {all},
{install} and {clean}.
*	{autoconf}. Its main goal is to produce the {configure} script.
When Yacas is built, this script gathers information from the user's
system, like the operating system and the location of certain programs
used by the Yacas build system. This information is used in turn by the
Makefiles.
*	{libtool}. This utility provides a portable interface for
building and using shared libraries. It is currently not used by Yacas.
However, it is thought that the plug-in system may profit from it, so
this may change.

*A build system!makemake
*A makemake
Usually, developers never need to run these tools directly, as the
Makefiles contain the necessary commands. When the Makefiles are not
present, which occurs for instance when installing afresh from the CVS
repository, the {makemake} script in the root of the Yacas source tree
can (and probably should) be used to invoke {automake} and {autoconf} in
the right order and with the correct flags.

In the following two sections, the {automake} and {autoconf} utilities
are shortly explained. In both cases, the reader is referred to the
documentation included in the {autotools} suite for more
information. Another useful source of information is 
<i>GNU Autoconf, Automake, and Libtool</i> 
by Gary V. Vaughan, Ben Elliston, Tom Tromey and
Ian Lance, which is published by New Riders. An online version is
available from <*http://sources.redhat.com/autobook*>.


	    The automake tool

*A build system!automake
*A automake

Automake is a tool to generate standard-compliant Makefiles. More
precisely, {automake} uses the information in {Makefile.am} to produce a
{Makefile.in} file, which will be turned into a {Makefile} by the
{configure} script generated by the {autoconf} utility.

The {Makefile.am} file contains the definition of certain macros that
are used by {automake}. The rest of the {Makefile.am} file is copied
verbatim to the generated {Makefile.in} file.

The most important macros which are used by {automake} are the
so-called <i>primaries</i>. These list the files that make up the Yacas
package. For instance, in the {src} directory, the file {Makefile.am}
contains the following line
	 bin_PROGRAMS = yacas
This is an example of the {PROGRAMS} primary, and says that the
directory contains a program called {yacas}. Hence it will be built if
the {make all} command is executed, it will be installed at 
{make install}, etcetera. Other useful primaries are {SCRIPTS} for
executable scripts, {HEADERS} for header files, {LIBRARIES} for static
libraries, and {DATA} for all files which are just copied verbatim at
installation time (this includes Yacas scripts).

The {bin} prefix in the example above says that {yacas} should be
installed in the binary directory, as determined by the {configure}
script. By default, this is the directory {/usr/local/bin}. There are
also prefixes for the other directories, as well as some prefixes with
different meanings: the {noinst} prefix says that the specified file
need not be installed, and the {check} prefix says that the file is
only needed when testing.

There are also so-called <i>associated variables</i>. The same
{Makefile.am} contains the following variables associated to the Yacas
executable:
	yacas_SOURCES = yacasmain.cpp commandline.cpp \
	      unixcommandline.cpp stdcommandline.cpp
	yacas_LDADD = libyacas.a libyacasplatform.a \
	      @NUMBERS_LIB@ @NUMBERS_LDFLAGS@ 
These lines tell that the executable is built from four source files
(yacasmain.cpp, commandline.cpp, unixcommandline.cpp and stdcommandline.cpp)
and two static libraries (libyacas.a and libyacasplatform.a). The
{@NUMBERS_LIB@} and {@NUMBERS_LDFLAGS@} symbols are defined when the
{configure} script is run, as explained in the next section. They
contain the names of additional libraries to link in.

From the information contained in these lines, {automake} can
construct the necessary commands to go in the final {Makefile}.
Unfortunately not everything is supported that well. For instance,
Yacas comes with its own documentation system, which is of course not
supported by {automake}. This has to be handled by {Makefile} rules in
the traditional way.

The Makefiles produced by {automake} and {autoconf} support not only
building, testing, and installing the package, but also rolling the
tar-ball for release (use {make dist} for this, as explained in the
section <i>Targets for make</i>). In the above example, {automake} can
figure out that {yacasmain.cpp} should be included in the
distribution. This does not always work. For example, {automake} does
not understand the Yacas documentation system, so there is no way it
can figure out what files to include in the distribution. To solve
this problem, the {EXTRA_DIST} variable is introduced. The developer
should list all files to be included in the distribution that
{automake} does not know about here.

We currently assume {automake} version 1.4 or later. Note that version
1.5 breaks backward compatibility and should be avoided. Version 1.6
contains some useful additions, like the {nobase} prefix and the
possibility to define new prefixes, so at a certain point we may
require version 1.6.

For more information about {automake}, the reader is referred to the
documentation that comes with the package.


	    The autoconf tool

*A build system!autoconf
*A autoconf

Autoconf is a tool to generate portable shell scripts which the user
can run to configure the package (in our case Yacas) for his/her
system. It reads the file {configure.in} and produces the {configure}
script. The latter script can be run by the user to prepare for
building Yacas.

The {configure.in} file consists of standard shell code, interspersed
with special macros defined by the {autoconf} package. These can be
recognized by the {AC_} prefix.

As the {configure.in} file only rarely needs to be changed, we will
only describe the {autoconf} tool by one example. As explained in the
previous section, <i>The automake tool</i>, the symbols
{@NUMBERS_LIB@} and {@NUMBERS_LDFLAGS@} are used in the {Makefile.in}
to link a library with basic numerical routines into the Yacas
executable. This gives the user the option to choose between two
libraries: the GNU multi-precision arithmetic (GNU MP) library and a
library provided by the Yacas team.  

This effect is achieved by the following fragment of {configure.in}.

	AC_ARG_ENABLE(gmp, [  --enable-gmp    ... ])
	if test "$enable_gmp" = "yes" ; then
	    AC_CHECK_LIB(gmp, __gmpz_init, \
	                 have_gmp=yes, have_gmp=no)
	    if test "$have_gmp" = "no" ; then
	       	AC_MSG_ERROR([GNU MP library not found])
	    fi
	    NUMBERS_LIB="libgmpnumbers.a"
	    NUMBERS_LDFLAGS="-lgmp -lm"
	else
	    NUMBERS_LIB="libyacasnumbers.a"
	    NUMBERS_LDFLAGS="-lm"
	fi
	AC_SUBST(NUMBERS_LIB)
	AC_SUBST(NUMBERS_LDFLAGS)

The first line tells the {configure} script to accept an extra option,
{enable-gmp}. If this option is invoked by the user, then first it is
checked that the GNU MP library is available - if this is not the
case, the configuration terminates with an error. Now the
{NUMBERS_LIB} and {NUMBERS_LDFLAGS} shell variables are set to
suitable values. The penultimate line says that the value of the
{NUMBERS_LIB} shell variable should be substituted for the {@NUMBER_LIB@}
symbol in the {Makefile.in}. The meaning of the last line is left as
an exercise for the reader.

This end the brief description of {autoconf}. For more information,
the reader is referred to the documentation that comes with the
package.

We currently assume {autoconf} version 2.13 or later.


	    The configure script

*A build system!configure
*A configuration

The {configure} script is run by the user to prepare the Yacas package
for the build and installation process. It examines the user's system
and the options passed to the script by the user, and generates
suitable Makefiles. Furthermore, it generates {yacas.spec} which is
used to build a package in Red Hat's {.rpm} format, and the C header
file {config.h}.

A nice feature is the possibility to build in a different directory
than the source directory by simply running {configure} from that
directory. This not only prevents the source directory from being
cluttered up by object files and so on, but it also enables the user
to build for different architectures in different directories, and
perhaps most importantly, it lets us build Yacas from a CD containing
the source.

A list of options accepted by the {configure} script can be retrieved
by invoking it with the {help} option
	./configure --help
The most important is the {prefix} option, which influences where
everything will be installed. The default is {/usr/local}, meaning
that for instance the yacas executable is installed as
{/usr/local/bin/yacas}. To change this in {/usr/bin/yacas}, invoke the
script as follows
	./configure --prefix=/usr
Other options to {configure} enable the user to fine-tune the location
where the various files should be installed.

We will not describe the common {configure} options which are shared
by all packages, but will restrict ourselves to the options
exclusively used by Yacas.
*	{enable-gmp}. Use the GNU multi-precision arithmetic library
(GNU MP), available from <*http://www.swox.com/gmp*>, instead of the
library provided by the Yacas team. For this to work, the GNU MP
library must of course be installed.

The following three options pertain to extensive documentation that
comes with Yacas. By default, only HTML documentation is generated. 
*	{disable-html-doc}. Do not generate documentation in HTML
format.
*	{enable-ps-doc}. Generate documentation in PostScript
format. This requires the latex suite.
*	{enable-pdf-doc}. Generate documentation in PDF format. This
also requires the latex suite. 

Then there are three options describing where to install various parts
of the Yacas package.
*	{with-script-dir=DIR}. Install the Yacas script files, which
have extension {.ys}, in the specified directory. By default, the
script files are installed in {DATADIR/yacas}, where {DATADIR}
defaults to {PREFIX/share}. In turn, {PREFIX} refers to the value of
the {prefix} option described above; the default value is
{/usr/local}. The conclusion is that the script files by default end
up in {/usr/local/yacas/share}.
*	{with-html-dir=DIR}. This specifies where to install the HTML
documentation for the Yacas package. The default is a subdirectory
named {documentation} of the directory in which the Yacas script files
are installed.
*	{with-ps-dir=DIR}. Where to install the PostScript and PDF
documentation. This defaults to the same directory as for the
documentation in HTML format.


	    Targets for make

*A build system!targets for make
*A make!targets

One of the advantages of using the autotool suite to generate
Makefiles, is that the resulting Makefiles support a variety of
targets. Here is a partial list of them.
*	{all}. This is the default target, so instead of {make all}
one can just type {make}. It builds the executables, which includes
{yacas}, and the documentation. By default, only documentation in HTML
format will be built, but this can be changed by the {configure} script.
*	{install}. Compile the executables, and install them together
with the libraries, Yacas scripts, and documentation so that the Yacas
program can be run. 
*	{install-strip}. Same as {install}, but also strip the debug
information from the installed executables.
*	{uninstall}. Remove the installed files.
*	{clean}. Delete files that are created during the build
process, for instance {.o} files.
*	{distclean}. Delete files that are created during either the
configuration or the build process. This leaves only the files in that
were included in the distribution. 
*	{dist}. Create a tar-ball (a gzipped tar archive) ready for
distribution. 
*	{check} (or its synonym {test}). Test whether Yacas works correctly.
*	{installcheck}. Test whether Yacas is installed correctly. The
difference with the {check} target is that that one tests the
<i>built</i> version of Yacas, while the {installcheck} target tests
the <i>installed</i> version.
*	{distcheck}. Check whether Yacas is ready for
distribution. This creates a tar-ball, unpacks it in a different
directory, compiles Yacas, installs it in a temporary directory, and
finally checks that the installed version works correctly.
*	{debug}. This is not a standard target. It builds a version of
Yacas suitable for debugging. It does not respect the settings of the
{configure} script.


	    The Yacas executable

*A build system!executable

The main executable is called {yacas} and resides in the {src}
directory. The build process is pretty straightforward. Three static
libraries are used: {libyacas}, {libyacasplatform}, and a library for
arbitrary precision arithmetics. For the last library, the user can
choose between the GNU MP library or a library distributed with Yacas
using the {enable-gmp} option of the {configure} script.

The {src} directory contains furthermore the source for the
{libcyacas} library (see <i>Embedding Yacas into a c or c++ application</i>)
and the {testnum} executable. 

At installation time, not only the {yacas} executable is installed but
also the static libraries and the header files. This is also to enable
developers to embed Yacas in their own programs.


	    The Yacas script files

*A build system!Yacas scripts
*A scripts!installation

The Yacas script files with extension {ys} can be found in the
{scripts} directory and its "repository" subdirectories. From the
point of view of the build system, this is an extremely simple
directory: all script files and {.def} files are listed in the
{SCRIPTFILES} variable in {Makefile.am}, and they should be copied
when installing. During this installation, the directory structure
should be preserved.

There is one exception here: the {packages.ys} file, which contains a
full list of all {.def} files, is automatically generated.


	    The documentation

*A build system!documentation
*A documentation!building

The documentation system for Yacas is explained in the section
<i>Preparing and maintaining Yacas documentation</i>. 

The documentation is generated from plain text source files with the
{txt} extension in the {manualmaker/in} directory. The source files
are converted to Yacas code by the {txt2yacasdoc.pl} script. The
resulting code is processed by the Yacas interpreter, resulting in the
HTML documentation.

To generate documents in PostScript and PDF format, the {book2TeX.sh}
script is included. This script converts the plain text source files
to $TeX$ files. They can then be processed by the standard $TeX$
tools.

By default, only HTML documents are generated. To change this, use the 
{disable-html-doc}, {enable-ps-doc} and {enable-pdf-doc} options
accepted by the {configure} script. The {with-html-dir} and
{with-ps-dir} options can be used to tell where the documentation
should be installed.

*A Wester's benchmark

At the moment, the {Makefile.am} for the documentation is rather
messy. For this reason, we do not describe it in detail. Instead, we
just point out some special features:
*	The Yacas interpreter is needed to generate the documentation.
*	The section <i>Full listing of core function</i> in the
programmer's reference book is generated from the Yacas source by the
{api2txt.pl} script.
*	The Yacas code from the section 
<i>M. Wester's CAS benchmark and Yacas</i>, built from
{wester-1994.chapt.txt}, is extracted with the {book2ys.sh}
script. This code is used for testing (see below).
*	All the scripts described can be found in the {manmake}
directory. 


	    The test suite

*A build system!test suite
*A testing Yacas

The Yacas distribution contains a (hopefully comprehensive) test
suite, which can be used to check whether Yacas is (still) functioning
correctly. The command {make check} tests the latest compiled version
of Yacas. To test the executable that is installed on your system, use
the command {make installcheck}.

The {yts} files in the {tests} directory contain the tests for
different subsystems of Yacas. For instance, the file {arithmetic.yts}
contains tests for the basic arithmetic functions; the first test is
to check that {3+2} evaluates to {5}. 

When the {make check} command is given, a shell script with the name
{test-built-yacas} is generated. This script successively runs all the
tests listed in the {TESTFILES} variable through the Yacas executable
in the build tree. The tests that take a long time are put at the end
of the list, so that these tests are performed last. The output of the
tests is collected in the file {testresult.txt}. The string {******}
(six stars) in the output signals failure of the test; if this string
does not occur, the tests are considered to be passed.

The procedure for the {make installcheck} command is the same, except
that the generated shell script is now called {test-installed-yacas}.
This script runs all the tests through the installed Yacas executable.

*A Wester's benchmark

A special case is the last test, which goes through the problems put
forward by Michael Wester (see the section 
<i>M. Wester's CAS benchmark and Yacas</i>). The commands for this
tests are not in a {yts} file in the {tests} directory, but are
extracted from the documentation (see the section <i>The documentation</i>,
immediately above).


	    Other components

This section lists the components of the Yacas distributions that have
not yet been described. 
*	The {yacas-client} script (see the section <i>Client/server usage</i>
in the book <i>Getting started with Yacas</i>) resides in the root of
the distribution. This script is copied during installation.
*	The directory {colorcode} contains a program constructing
colorful HTML files listing the contests of the Yacas script files. At
the moment, this program does not function quite correctly. This
program is compiled, but not installed.
*	The directory {docs} contains various files in for the
website. The file {yacaslogo.gif} is also used in the HTML
documentation of Yacas, therefore this file is copied in the
appropriate directory during installation.
*	The directory {ramscripts} contains a program which reads in
the scripts in the {scripts} directory, and outputs the c++ source
code you need to include just after the {CYacas} environment object
has been constructed to stdout. This program is compiled but not
installed. 

The build system does not perform any actions for the following
components of Yacas. 
*	The directory {YacasNotebook} contains Emacs lisp files to aid
in interacting with Yacas from within Emacs. 
*	The directory {compile} contains the experimental Yacas
compiler.
*	The directory {embed} contains examples showing how to embed
Yacas in one's own application; see the section 
<i>Embedding Yacas into a c or c++ application</i>.
*	The directory {epoc} contains the support for the EPOC
device. See the file {README.EPOC} in the root of the distribution for
details. 
*	The directory {plugins} contains files showing how to build
plugins, which can be dynamically loaded into Yacas. See the section 
<i>Creating plugins for Yacas</i> for details.
*	The directory {proteus} contains an experimental
implementation of a graphical interface to Yacas. 


	    Non-Unix architectures

*A build system!BeOS
*A build system!MS Windows
*A build system!Psion
*A build system!Macintosh
*A build system!EPOC
*A BeOS
*A Microsoft Windows
*A Psion
*A Macintosh
*A EPOC

Until now, we have only talked about the support for building Yacas on
Unix-like systems. Here are pointers to descriptions of the support
for other architectures. Some architectures may sometimes be trailing
behind.
*	{BeOS}. Use the file {src/makefile.beos} for this, as
described in {README.beos}.
*	{EPOC}. Support for this device is contained in the {epoc}
directory. The details are explained in the {README.EPOC} file.
*	{Macintosh}. The Mac port is maintained at
<*http://homepage.mac.com/yacas*>.
*	{MS Windows}. The files {yacas.dsw} and {yacas.dsp} contain
support for MSDevStudio c++ 6.0. Alternatively, look in the
{README.Win32} file. 
*	{Psion Series}. Use the file {epocyacasconsole.mmp}.

