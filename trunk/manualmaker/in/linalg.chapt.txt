
			Linear Algebra

*INTRO This chapter describes the commands for doing linear
algebra. They can be used to manipulate vectors, represented as lists,
and matrices, represented as lists of lists.

*CMD LeviCivita --- The totally anti-symmetric Levi Civita tensor

*STD

*CALL

LeviCivita(list)

*PARMS

list - a list of integers 1 .. n in some order

*DESC

"LeviCivita" implements the Levi Civita symbol. This is generally
useful for tensor calculus.  {list}  should be a list of integers,
and this function returns 1 if the integers are in successive order,
eg.  {1,2,3,...}  would return 1. Swapping two elements of this
list would return -1. So, LeviCivita( {2,1,3} ) would evaluate
to -1.

*E.G.

	In> LeviCivita({1,2,3})
	Out> 1;
	In> LeviCivita({2,1,3})
	Out> -1;
	In> LeviCivita({2,2,3})
	Out> 0;

*SEE Permutations

*CMD Permutations --- Form all permutations of a list

*STD

*CALL

Permutations(list)

*PARMS

list - a list of elements

*DESC

Permutations returns a list with all the permutations of
the original list.

*E.G.

	In> Permutations({a,b,c})
	Out> {{a,b,c},{a,c,b},{c,a,b},{b,a,c},{b,c,a},{c,b,a}};

*SEE LeviCivita

*CMD InProduct --- Inner product of vectors

*STD

*CALL

InProduct(a,b)

a . b  (prec. 3)

*PARMS

a, b - vectors of equal length

*DESC

The inner product of the two vectors "a" and "b" is returned. The
vectors need to have the same size.

*E.G.

	In> {a,b,c} . {d,e,f};
	Out> a*d+b*e+c*f;

*SEE CrossProduct

*CMD CrossProduct --- Outer product of vectors

*STD

*CALL

CrossProduct(a,b)

a X b  (prec. 3)

*PARMS

a, b - three-dimensional vectors

*DESC

The outer product (also called the cross product) of the vectors "a"
and "b" is returned. The result is perpendicular to both "a" and
"b" and its length is the product of the lengths of the vectors.
Both "a" and "b" have to be three-dimensional.

*E.G.

	In> {a,b,c} X {d,e,f};
	Out> {b*f-c*e,c*d-a*f,a*e-b*d};

*SEE InProduct

*CMD ZeroVector --- Create a vector with all zeroes

*STD

*CALL

ZeroVector(n)

*PARMS

n - length of the vector to return

*DESC

This command returns a vector of length "n", filled with zeroes.

*E.G.

	In> ZeroVector(4)
	Out> {0,0,0,0};

*SEE BaseVector, ZeroMatrix, IsZeroVector

*CMD BaseVector --- Base vector

*STD

*CALL

BaseVector(k, n)

*PARMS

k - index of the base vector to construct

n - dimension of the vector

*DESC

This command returns the "k"-th base vector of dimension "n". This
is a vector of length "n" with all zeroes except for the "k"-th
entry, which contains a 1.

*E.G.

	In> BaseVector(2,4)
	Out> {0,1,0,0};

*SEE ZeroVector, Identity

*CMD Identity --- Identity matrix

*STD

*CALL

Identity(n)

*PARMS

n - size of the matrix

*DESC

This commands returns the identity matrix of size "n" by "n". This
matrix has ones on the diagonal while the other entries are zero.

*E.G.

	In> Identity(3)
	Out> {{1,0,0},{0,1,0},{0,0,1}};

*SEE BaseVector, ZeroMatrix, DiagonalMatrix

*CMD ZeroMatrix --- Matrix filled with zeroes

*STD

*CALL

ZeroMatrix(n, m)

*PARMS

n - number of rows

m - number of columns

*DESC

This command returns a matrix with "n" rows and "m" columns,
completely filled with zeroes.

*E.G.

	In> ZeroMatrix(3,4)
	Out> {{0,0,0,0},{0,0,0,0},{0,0,0,0}};

*SEE ZeroVector, Identity

*CMD DiagonalMatrix --- Construct a diagonal matrix

*STD

*CALL

DiagonalMatrix(d)

*PARMS

d - list of values to put on the diagonal

*DESC

This command constructs a diagonal matrix, that is a square matrix
whose off-diagonal entries are all zero. The elements of the vector
"d" are put on the diagonal.

*E.G.

	In> DiagonalMatrix(1 .. 4)
	Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};

*SEE Identity, ZeroMatrix

*CMD IsMatrix --- Test whether argument is a matrix

*STD

*CALL

IsMatrix(M)

*PARMS

M - a mathematical object

*DESC

IsMatrix returns True if M is a matrix, False otherwise. Something is
considered to be a matrix if it is a list and all the entries of this
list are lists themselves.

*E.G.

	In> IsMatrix(ZeroMatrix(3,4))
	Out> True;
	In> IsMatrix(ZeroVector(4))
	Out> False;
	In> IsMatrix(3)
	Out> False;

*SEE IsVector

*CMD Normalize --- Normalize a vector

*STD

*CALL

Normalize(v)

*PARMS

v - a vector

*DESC

Return the normalized vector of v: a vector going in the same
direction but with length 1.

*E.G.

	In> Normalize({3,4})
	Out> {3/5,4/5};
	In> % . %
	Out> 1;

*SEE InProduct, CrossProduct

*CMD Transpose --- Transpose of a matrix

*STD

*CALL

Transpose(M)

*PARMS

M - a matrix

*DESC

Transpose returns the transpose of a matrix M. Because matrices are
just lists of lists, this is a useful operation too for lists.

*E.G.

	In> Transpose({{a,b}})
	Out> {{a},{b}};

*CMD Determinant --- Determinant of a matrix

*STD

*CALL

Determinant(M)

*PARMS

M - a matrix

*DESC

Returns the determinant of a matrix M.

*E.G.

	In> DiagonalMatrix(1 .. 4)
	Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};
	In> Determinant(%)
	Out> 24;

*CMD Trace --- Trace of a matrix

*STD

*CALL

Trace(M)

*PARMS

M - a matrix

*DESC

Trace returns the trace of a matrix M (defined as the sum of the
elements on the diagonal of the matrix).

*E.G.

	In> DiagonalMatrix(1 .. 4)
	Out> {{1,0,0,0},{0,2,0,0},{0,0,3,0},{0,0,0,4}};
	In> Trace(%)
	Out> 10;

*CMD Inverse --- Inverse of a matrix

*STD

*CALL

Inverse(M)

*PARMS

M - a matrix

*DESC

Inverse returns the inverse of matrix M. The determinant of M should
be non-zero. Because this function uses Determinant for calculating
the inverse of a matrix, you can supply matrices with non-numeric
matrix elements.

*E.G.

	In> DiagonalMatrix({a,b,c})
	Out> {{a,0,0},{0,b,0},{0,0,c}};
	In> Inverse(%)
	Out> {{(b*c)/(a*b*c),0,0},{0,(a*c)/(a*b*c),0},{0,0,(a*b)/(a*b*c)}};
	In> Simplify(%)
	Out> {{1/a,0,0},{0,1/b,0},{0,0,1/c}};

*CMD Minor --- Principal minor of a matrix

*STD

*CALL

Minor(M,i,j)

*PARMS

M - a matrix

i, j - positive integers

*DESC

Minor returns the minor of a matrix around
the element (i,j). The minor is the determinant of the matrix
excluding the "i"-th row and "j"-th column.

*E.G.

	In> A := {{1,2,3}, {4,5,6}, {7,8,9}};
	Out> {{1,2,3},{4,5,6},{7,8,9}};
	In> PrettyForm(A);
	
	/                    \
	| ( 1 ) ( 2 ) ( 3 )  |
	|                    |
	| ( 4 ) ( 5 ) ( 6 )  |
	|                    |
	| ( 7 ) ( 8 ) ( 9 )  |
	\                    /
	
	Out> True;
	In> Minor(A,1,2);
	Out> -6;
	In> Determinant({{2,3}, {8,9}});
	Out> -6;

*SEE CoFactor, Determinant, Inverse

*CMD CoFactor --- Cofactor of a matrix

*STD

*CALL

CoFactor(M,i,j)

*PARMS

M - a matrix

i, j - positive integers

*DESC

CoFactor returns the cofactor of a matrix around
the element (i,j). The cofactor is the minor times
$(-1)^(i+j)$.

*E.G.

	In> A := {{1,2,3}, {4,5,6}, {7,8,9}};
	Out> {{1,2,3},{4,5,6},{7,8,9}};
	In> PrettyForm(A);
	
	/                    \
	| ( 1 ) ( 2 ) ( 3 )  |
	|                    |
	| ( 4 ) ( 5 ) ( 6 )  |
	|                    |
	| ( 7 ) ( 8 ) ( 9 )  |
	\                    /
	
	Out> True;
	In> CoFactor(A,1,2);
	Out> 6;
	In> Minor(A,1,2);
	Out> -6;
	In> Minor(A,1,2) * (-1)^(1+2);
	Out> 6;

*SEE Minor, Determinant, Inverse

*CMD SolveMatrix --- Solve a linear system

*STD

*CALL

SolveMatrix(M,v)

*PARMS

M - a matrix

v - a vector

*DESC

SolveMatrix returns the vector x that satisfies
the equation "M x = v". The determinant of M should be non-zero.

*E.G.

	In> A := {{1,2}, {3,4}};
	Out> {{1,2},{3,4}};
	In> v := {5,6};
	Out> {5,6};
	In> x := SolveMatrix(A, v);
	Out> {-4,9/2};
	In> A * x;
	Out> {5,6};

*SEE Inverse, Solve, PSolve

*CMD CharacteristicEquation --- Characteristic polynomial of a matrix

*STD

*CALL

CharacteristicEquation(matrix,var)

*PARMS

matrix - a matrix

var - a free variable

*DESC

CharacteristicEquation
returns the characteristic equation of "matrix", using
"var". The zeros of this equation are the eigenvalues
of the matrix, Det(matrix-I*var);

*E.G.

	In> DiagonalMatrix({a,b,c})
	Out> {{a,0,0},{0,b,0},{0,0,c}};
	In> CharacteristicEquation(%,x)
	Out> (a-x)*(b-x)*(c-x);
	In> Expand(%,x)
	Out> (b+a+c)*x^2-x^3-((b+a)*c+a*b)*x+a*b*c;

*SEE EigenValues, EigenVectors

*CMD EigenValues --- Eigenvalues of a matrix

*STD

*CALL

EigenValues(matrix)

*PARMS

matrix - a square matrix

*DESC

EigenValues returns the eigenvalues of a matrix.
The eigenvalues x of a matrix M are the numbers such that
M*v=x*v for some vector.

It first determines the characteristic equation, and then factorizes this
equation, returning the roots of the characteristic equation
det(matrix-x*identity).

*E.G.

	In> M:={{1,2},{2,1}}
	Out> {{1,2},{2,1}};
	In> EigenValues(M)
	Out> {3,-1};

*SEE EigenVectors, CharacteristicEquation

*CMD EigenVectors --- Eigenvectors of a matrix

*STD

*CALL

EigenVectors(matrix,eigenvalues)

*STD

*PARMS

matrix - a square matrix

eigenvalues - list of eigenvalues as returned by EigenValues

*DESC

EigenVectors returns a list of the eigenvectors of a matrix.
It uses the eigenvalues and the matrix to set up n equations with
n unknowns for each eigenvalue, and then calls Solve to determine
the values of each vector.

*E.G.

	In> M:={{1,2},{2,1}}
	Out> {{1,2},{2,1}};
	In> e:=EigenValues(M)
	Out> {3,-1};
	In> EigenVectors(M,e)
	Out> {{-ki2/ -1,ki2},{-ki2,ki2}};

*SEE EigenValues, CharacteristicEquation

*CMD IsHermitean --- Test whether a matrix is Hermitean

*STD

*CALL

IsHermitean(A)

*PARMS

A - square matrix

*DESC

IsHermitean(A) returns True if A is Hermitean and False
otherwise. A is a Hermitean matrix iff Conjugate(Transpose(A))=A.
For real matrices A is tested to be symmetric.

*E.G.

	In> IsHermitean({{0,I},{-I,0}})
	Out> True;
	In> IsHermitean({{0,I},{2,0}})
	Out> False;

*SEE IsUnitary

*CMD IsUnitary --- Test whether a matrix is unitary

*STD

*CALL

IsUnitary(A)

*PARMS

A - square matrix

*DESC

This function tries to find out if A is unitary.

Matrix A is orthogonal iff $A^(-1)$ = Transpose(Conjugate($A$)). This is
equivalent to the fact that the columns of A build an orthonormal system
(in respect to the scalar product defined by InProduct).

*E.G.

	In> IsUnitary({{0,I},{-I,0}})
	Out> True;
	In> IsUnitary({{0,I},{2,0}})
	Out> False;

*SEE IsHermitean

