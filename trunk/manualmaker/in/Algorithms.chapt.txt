			Arbitrary precision numerical algorithms

*INTRO This chapter documents some numerical algorithms used in Yacas for exact
integer calculations as well as for multiple precision floating-point
calculations, gives brief descriptions of the non-trivial algorithms and
estimates of the computational cost.


		Basic arithmetic

Currently, Yacas uses either internal math (the {yacasnumbers} library) or the
GNU multiple precision library {gmp}. The algorithms for basic arithmetic in
the internal math mode are currently rather slow compared with {gmp}. If $P$ is
the number of digits of precision, then multiplication and division take
$M(P)=O(P^2)$ operations in the internal math. Much faster algorithms
(Karatsuba / Toom-Cook / FFT multiplication, Newton-Raphson division etc.) are
implemented in {gmp} where at large precision $M(P)=O(P*Ln(P))$. In the
computation cost estimations of this chapter we shall assume that $M(P)$ is at
least linear in $P$. 

Warning: calculations with internal math with precision exceeding 10,000 digits are currently impractically slow.

		Adaptive plotting

The adaptive plotting routine {Plot2D'adaptive} uses a simple algorithm
to select the optimal grid to approximate a function $f(x)$. The same algorithm
for adaptive grid refinement could be used for numerical integration. The
idea is that plotting and numerical integration require the same kind of
detailed knowledge about the behavior of the function.

The algorithm first splits the interval into a specified initial number of
equal subintervals, and then repeatedly splits each subinterval in half
until the function is well enough approximated by the resulting grid. The
integer parameter {depth} gives the maximum number of binary splittings for
a given initial interval; thus, at most $2^depth$ additional grid points
will be generated. The function {Plot2D'adaptive} should return a list of
pairs of points {{{x1,y1}, {x2,y2}, ...}} to be used directly for plotting.

*	 1.  Given an interval ($a$, $c$), we split
         it in half, $b:=(a+c)/2$ and first compute $f(x)$ at five grid
         points $x=a$, $(a+b)/2$, $b$, $(b+c)/2$, $c$. 
*	 2. If currently $depth <= 0$, return this list of 5 points and
         values because we cannot refine the grid any more.
*	 3. Otherwise we check that the function does not change sign too
         rapidly. The formal criterion is that among these 5 points there are always
         at least 2 consecutive points of equal sign. Checking is done by
         the following procedure: Mark the sequence of signs of the values
         $f(x)$ at the 5 grid points, e.g. "0, +, -, +, +". Here "0" stands
         for zero. Then, for each pair of consecutive signs, write "1" if
         the signs are different and "0" otherwise. If one of the signs is
         0, then also write "0". E.g. we get the sequence of 4 bits "0, 1,
         1, 0". Each "1" stands for a sign change. Then, for each pair of
         consecutive bits, write the logical AND of these bits. E.g.: 0, 1,
         0. Each "1" now signifies that two sign changes occurred, one
         right after another. If we have all "0" now, then the sign changes
         are "slow enough". Otherwise they are not "slow enough". We can
         compute the logical OR of these 3 bits to test this. In our
         example we get 1. This means that we have a sign change that is
         too rapid.
         If the sign is not changing "slow enough" within the interval
         [a,c], then we need to refine the grid; go to step 5. Otherwise,
         go to step 4.
*	 4. Check that the function values are smooth enough through the
         interval. Smoothness is controlled by a parameter $epsilon$. The
         meaning of the parameter $epsilon$ is the relative error of the
         approximation of the integral by the quadratures. A good heuristic
         value of $epsilon$ is 1/(the number of pixels on the screen)
         because it means that no pixels will be missing in the area under
         the graph. We compute the Newton-Cotes and the Simpson quadratures
         for $ Integrate(x,a,c) f(x) $ using these 5 points. The Simpson
         coefficients are: (1, 4, 2, 4, 1)/3; and the Newton-Cotes
         coefficients are: (14, 64, 24, 64, 14)/45. Difference between the
         quadratures has coefficients (-1, 4, -6, 4, -1)/45. If the
         abs. value of the difference between these quadratures is less
         than $epsilon$ * (abs. value of the Simpson quadrature), then we
         are done and we return the list of 5 points and values.
*	 5. Otherwise we need to refine the grid. We compute
         {Plot2D'adaptive} recursively for the two halves of the interval,
         i.e. for ($a$,$b$) and ($b$,$c$); we pass the midpoint values as
         necessary and decrease {depth} by 1. The resulting lists are
         concatenated (excepting the double value at point $b$) and
         returned.

This algorithm works well if the initial number of points and the {depth}
parameter are large enough. The initial number of points is passed as the
option {points} and is 20 by default; the default {depth} is 5.

The meaning of quadrature coefficients is that the integral is approximated as

$$Integrate(x,a[1],a[n]) f(x) <=> h*Sum(i,1,n,f(a[i])*c[i])$$

where $h:=a[2]-a[1]$ is the grid step, $a[i]$ are the grid points, and
$c[i]$ are the quadrature coefficients. These coefficients are independent
of the function $f(x)$ that needs to be integrated, and one can precompute
them in advance for any grid $a[i]$ (not necessarily with constant step
$h=a[i]-a[i-1]$). The Newton-Cotes and the Simpson coefficients are for
grids with a constant step.

*INCLUDE algorithms-elemfunc.chapt
*INCLUDE algorithms-specfunc.chapt

			Symbolic algebra algorithms

*INCLUDE algorithms-integration.chapt
