			Arbitrary precision numerical algorithms

*INTRO This chapter documents some numerical algorithms used in Yacas for exact
integer calculations as well as for multiple precision floating-point
calculations, gives brief descriptions of the non-trivial algorithms and
estimates of the computational cost. Most of the algorithms are taken from referenced literature; the remaining algorithms were developed by us.


		Basic arithmetic

Currently, Yacas uses either internal math (the {yacasnumbers} library) or the
GNU multiple precision library {gmp}. The algorithms for basic arithmetic in
the internal math mode are currently rather slow compared with {gmp}. If $P$ is
the number of digits of precision, then multiplication and division take
$M(P)=O(P^2)$ operations in the internal math. (Of course, multiplication and division by a short integer takes time linear in $P$.) Much faster algorithms for long multiplication
(Karatsuba / Toom-Cook / FFT, Newton-Raphson division etc.) are
implemented in {gmp} where at large precision $M(P)=O(P*Ln(P))$. In the
computation cost estimations of this chapter we shall assume that $M(P)$ is at
least linear in $P$. 

Warning: calculations with internal math with precision exceeding 10,000 digits are currently impractically slow.

In some algorithms it is necessary to compute the integer parts of expressions such as $a*Ln(b)/Ln(10)$ or $a*Ln(10)/Ln(2)$ where $a$, $b$ are short integers of order $O(P)$. Such expressions are frequently needed to estimate the number of terms in the Taylor series or similar parameters of the algorithms. In these cases, it is important that the result is not underestimated but it would be wasteful to compute $Ln(10)/Ln(2)$ in floating point only to discard most of that information by taking the integer part of say $1000*Ln(10)/Ln(2)$. It is more efficient to approximate such constants from above by short rational numbers, for example, $Ln(10)/Ln(2) < 28738/8651$ and $Ln(2) < 7050/10171$. The error of such an approximation will be small enough for practical purposes. The function {NearRational} can be used to find optimal rational approximations. The function {IntLog} (see below) efficiently computes the integer part of a logarithm in integer base. If more precision is desired in calculating $Ln(a)/Ln(b)$ for integer $a$, $b$, one can compute $IntLog(a^k,b)$ for some integer $k$ and then divide by $k$.

		Prime numbers: the Miller-Rabin algorithm and its improvements

Primality is tested by the function {IsPrime} that implements the
Miller-Rabin algorithm (initial implementation and documentation
supplied by Christian Obrecht). This algorithm is deterministic for
"small" numbers and probabilistic for large numbers. In other words, it
could sometimes flag a number as prime when in fact the number is
composite; but the probability for this to happen can be made extremely
small. The basic reference is M. O. Rabin, 
<i>Probabilistic algorithm for testing primality</i>,
J. Number Theory 12 (1980), 128.
We also implemented some improvements suggested by J. H. Davenport,
<i>Primality testing revisited</i>, Proc. ISSAC 1992, p. 123.

The idea of the Miller-Rabin algorithm is to improve the Fermat primality test. If $n$ is prime, then for any $x$ we have $Gcd(n,x)=1$. Then by Fermat's "little theorem", $x^(n-1):=Mod(1,n)$. (This is really a simple statement; if $n$ is prime, then $n-1$ nonzero remainders modulo $n$: 1, 2, ..., $n-1$ form a cyclic multiplicative group.) Therefore we pick some "base" integer $x$ and compute $Mod(x^(n-1), n)$; this is a quick computation even if $n$ is large. If this value is not equal to $1$ for some base $x$, then $n$ is definitely not prime. However, we cannot test <i>every</i> base $x<n$; instead we test only some $x$, so it may happen that we miss the right values of $x$ that would expose the non-primality of $n$. So Fermat's test sometimes fails, i.e. says that $n$ is prime when it is in fact not a prime. Also there are infinitely many integers called "Carmichael numbers" which are not prime but pass the Fermat test for every base.

The Miller-Rabin algorithm improves on this by using the property that for prime $n$ there are no nontrivial square roots of unity in the ring of integers modulo $n$ (this is Lagrange's theorem). In other words, if $x^2:=Mod(1,n)$ for some $x$, then $x$ must be equal to $1$ or $-1$ modulo $n$. (Note that $n-1$ is equal to $-1$ modulo $n$, so $n-1$ is a trivial square root of unity modulo $n$.) In fact, if $n$ is prime, there must be no divisors of $1$ at all, i.e. no numbers $x$ and $y$, not equal to $1$ or $-1$ modulo $n$, such that $x*y:=Mod(1,n)$. If we find such $x$, $y$, then $Gcd(x,n)>1$ or $Gcd(y,n)>1$ and $n$ is not prime.

We can check that $n$ is odd before applying any primality test. (A quick test $n^2:=Mod(1,24)$ guarantees that $n$ is not divisible by $2$ or $3$.) Then we note that in Fermat's test, the power $n-1$ is certainly a composite number because $n-1$ is even. So if we first find the largest power of $2$ in $n-1$ and decompose $n-1=2^r*q$ with $q$ odd, then $x^(n-1):=Mod(a^(2^r),n)$ where $a:=Mod(x^q,n)$. (Here $r>=1$ since $n$ is odd.) In other words, the number $Mod(x^(n-1),n)$ is obtained by repeated squaring of the number $a$ that we can easily find. We get a sequence of $r$ repeated squares: $a$, $a^2$, ..., $a^(2^r)$. 
The last element of this sequence must be $1$ if $n$ passes the Fermat test. (If it does not pass, $n$ must be a composite number.) If $n$ passed the Fermat test, the previous element of the sequence of squares is a square root of unity modulo $n$. We can check whether this square root is non-trivial (i.e. not equal to $1$ or $-1$ modulo $n$). If it is non-trivial, then $n$ definitely cannot be a prime. If it is trivial and equal to $1$, we can check the preceding element, and so on. If an element is equal to $-1$, we cannot say anything, i.e. the test passes ($n$ is "probably a prime").
 
This procedure can be summarized like this:

*	1. Find the largest power of $2$ in $n-1$ and an odd number $q$ such that $n-1=2^r*q$.
*	2. Select the "base number" $x<n$. Compute the sequence $a:=Mod(x^q,n)$, $a^2$, $a^4$, ..., $a^(2^r)$ by repeated squaring modulo $n$. This sequence contains at least two elements since $r>=1$.
*	3. If $a=1$ or $a=n-1$, the test passes on the base number $x$. Otherwise, the test passes if at least one of the elements of the sequence is equal to $n-1$ and fails if none of them are equal to $n-1$. 
This simplified procedure works because the first element that is equal to $1$ <i>must</i> be preceded by a $-1$, or else we'd found a root of unity.

A practical application of this procedure needs to select particular base numbers. 
It is advantageous (according to Pomerance et al., Math. Comp. 35 (1980), 1003) to choose <i>prime</i> numbers $b$ as bases, because for a composite base $b=p*q$, if $n$ is a strong pseudoprime for both $p$ and $q$, then it is very probable that $n$ is a strong pseudoprime also for $b$, so composite bases rarely give new information.

Here are some more formal definitions. An odd integer $n$ is called <i>strongly-probably-prime</i> for base $b$ if
$b^q:=Mod(1,n)$
or
$b^(q*2^i):=Mod(n-1,n)$ for some $i$ such that $0 <= i < r$,
where $q$ and $r$ are such that $q$ is odd and $n-1 = q*2^r$.

An additional check suggested by Davenport is activated if $r>2$ (i.e. if $n:=Mod(1,4)$ which is true for only 1/2 of all odd numbers). If $i>=1$ is found such that $b^(q*2^i):=Mod(n-1,n)$, then $b^(q*2^(i-1))$ is a square root of $-1$ modulo $n$. If $n$ is prime, there may be only two different square roots of $-1$. Therefore we should store the set of found values of roots; if there are more than two such roots, then we have found roots $s1$, $s2$ of $-1$ such that $0!=Mod(s1+s2+1,n)$. Then $s1^2-s2^2:=Mod(0,n)$ and $n$ is definitely composite because e.g. $Gcd(s1+s2,n)>1$. This check costs very little computational effort but guards against some strong pseudoprimes.

Yet another small improvement comes from the paper of Damgard and Landrock. They found that the strong primality test sometimes (rarely) passes on composite numbers $n$ for more than $1/8$ of all bases $x<n$ if $n$ is such that either $3*n+1$ or $8*n+1$ is a perfect square. It's easy to show that if $n$ is a large enough prime number, then neither $3*n+1$, nor $8*n+1$, nor any $s*n+1$ with small integer $s$ can be a perfect square. (If $s*n+1=r^2$, then $s*n=(r-1)*(r+1)$.) Testing for a perfect square is quick and does not slow down the routine very much. This is however not implemented in Yacas because it seems that perfect squares are rare enough for this improvement not to be very significant.

If an integer is not "strongly-probably-prime" for a given base $b$, then it is
a composite number. However, the reciprocal is false, i.e. "strongly-probably-prime" numbers can actually be composite. Composite strongly-probably-prime numbers for
base $b$ are called <i>strong pseudoprimes</i> for base $b$. There is a theorem that if $n$ is
composite, then among all numbers $b$ such that $1 < b < n$, at most one fourth
are such that $n$ is a strong pseudoprime for base $b$.

For numbers less than $B=34155071728321$, exhaustive computations have shown
that there are no strong pseudoprimes simultaneously for bases 2, 3, 5, 7, 11, 13
and 17. This leads to a very simple and quick way to check whether a number is
prime, provided it is smaller than $B$.
If $n >= B$, the Rabin-Miller method consists in checking if $n$ is
strongly-probably-prime for $k$ base numbers $b$.
The base numbers are chosen to be consecutive "weak pseudoprimes" that are easy to generate (see below the function {NextPseudoPrime}).

In the implemented routine {RabinMiller}, the number of bases $k$ is chosen to
make the probability of erroneously passing the test $p < 10^(-25)$. (Note that
this is <i>not</i> the same as the probability to give an incorrect answer,
because all numbers that do not pass the test are definitely composite.) The
probability for the test to pass mistakenly on a given number is found as
follows. Suppose the number of bases $k$ is fixed. Then the probability for a
given composite number to pass the test is less than $p[f]=4^(-k)$. The
probability for a given number $n$ to be prime is roughly $p[p]=1/Ln(n)$ and to
be composite $p[c]=1-1/Ln(n)$. Prime numbers never fail the test. Therefore, the probability for the test to pass is $p[f]*p[c]+p[p]$ and the probability for pass erroneously is
$$ p = (p[f]*p[c])/(p[f]*p[c]+p[p]) < Ln(n)*4^(-k) $$.
To make $p<epsilon$, it is enough to select $k=1/Ln(4)*(Ln(n)-Ln(epsilon))$.

Before calling {MillerRabin}, the function {IsPrime} performs two quick
checks: first, for $n>=4$ it checks that $n^2:=Mod(1,24)$ (all primes larger than 4 must satisfy this); second, for $n>257$, it
checks that $n$ does not contain small prime factors $p<=257$. This is
checked by evaluating the GCD of $n$ with the product of all primes up
to 257. The computation of GCD is very quick and saves time in case a
small prime factor is present.

There are also a function {NextPrime(n)} that returns the smallest prime number larger than {n}. This function uses a sequence 5,7,11,13,... generated by the function {NextPseudoPrime} that contains numbers not divisible by 2 or 3 (but perhaps divisible by 5,7,...). {NextPseudoPrime} is very fast because it does not perform a full primality test.

		Factorization of integers

Factorization of integers is implemented by functions {Factor} and {Factors}. Both functions try to find all prime factors of a given integer $n$. (Before doing this, the primality checking algorithm is used to detect whether $n$ is a prime number.)
Factorization consists of repeatedly finding a factor, i.e. an integer $f$ such that $Mod(n, f)=0$, and dividing $n$ by $f$.

First we determine whether the number $n$ contains "small" prime
factors $p<=257$. A quick test is to find the GCD of $n$ and the
product of all primes up to $257$: if the GCD is greater than 1, then
$n$ has at least one small prime factor. (The product of primes is
precomputed.) If this is the case, the trial division algorithm is
used: $n$ is divided by all prime numbers $p<=257$ until a factor is
found. {NextPseudoPrime} is used to generate the sequence of candidate
divisors $p$.

After separating small prime factors, we test whether the number $n$ is an integer power of a prime number, i.e. whether $n=p^s$ for some prime number $p$ and an integer $s>=1$. This is tested by the following algorithm. We already know that $n$ is not prime and that $n$ does not contain any small prime factors up to 257. Therefore if $n=p^s$, then $p>257$ and $2<=s<s[0]=Ln(n)/Ln(257)$. In other words, we only need to look for powers not greater than $s[0]$. This number can be approximated by the "integer logarithm" of $n$ in base 257 (routine {IntLog (n, 257)}).

Now we need to check whether $n$ is of the form $p^s$ for $s=2$, 3, ..., $s[0]$. Note that if for example $n=p^24$ for some $p$, then the square root of $n$ will already be an integer, $n^(1/2)=p^12$. Therefore it is enough to test whether $n^(1/s)$ is an integer for all <i>prime</i> values of $s$ up to $s[0]$, and then we will definitely discover whether $n$ is a power of some other integer.
The testing is performed using the integer square root function {IntNthRoot} which quickly computes the integer part of $n$-th root of an integer number. If we discover that $n$ has an integer root $p$ of order $s$, we have to check that $p$ itself is a prime power (we use the same algorithm recursively). The number $n$ is a prime power if and only if $p$ is itself a prime power. If we find no integer roots of orders $s<=s[0]$, then $n$ is not a prime power.

If the number $n$ is not a prime power, the Pollard "rho" algorithm is applied (J. Pollard, <i>Monte Carlo methods for index computation mod p</i>, Mathematics of Computation, volume 32, pages
918-924, 1978). The Pollard "rho" algorithm takes an irreducible polynomial, e.g. $p(x)=x^2+1$ and builds a sequence of integers $x[k+1]:=Mod(p(x[k]),n)$, starting from $x[0]=2$. For each $k$, the value $x[2*k]-x[k]$ is attempted as possibly containing a common factor with $n$. The GCD of $x[2*k]-x[k]$ with $n$ is computed, and if $Gcd(x[2*k]-x[k],n)>1$, then that GCD value divides $n$.

The idea behind the "rho" algorithm is to generate an effectively
random sequence of trial numbers $t[k]$ that may have a common factor
with $n$. The efficiency of this algorithm is determined by the size of
the smallest factor $p$ of $n$. Suppose $p$ is the smallest prime
factor of $n$ and suppose we generate a random sequence of integers
$t[k]$ such that $1<=t[k]<n$. It is clear that, on the average, a
fraction $1/p$ of these integers will be divisible by $p$. Therefore
(if $t[k]$ are truly random) we should need on the average $p$ tries
until we find $t[k]$ which is accidentally divisible by $p$. In
practice, of course, we do not use a truly random sequence and the
number of tries before we find a factor $p$ may be significantly
different from $p$. The quadratic polynomial seems to help reduce the
number of tries in most cases.

But the Pollard "rho" algorithm may actually enter an infinite loop
when the sequence $x[k]$ repeats itself without giving any factors of
$n$. For example, the unmodified "rho" algorithm starting from $x[0]=2$
loops on the number 703. The loop is detected by comparing $x[2*k]$ and
$x[k]$. When these two quantities become equal to each other for the
first time, the loop may not yet have occurred so the value of GCD is
set to 1 and the sequence is continued. But when the equality of
$x[2*k]$ and $x[k]$ occurs many times, it indicates that the algorithm
has entered a loop. A solution is to randomly choose a different
starting number $x[0]$ when a loop occurs and try factoring again, and
keep trying new random starting numbers between 1 and $n$ until a
non-looping sequence is found. The current implementation stops after
100 restart attempts and prints an error message, "failed to factorize
number".

A better (and faster) integer factoring algorithm is needed.

Modern factoring algorithms are all probabilistic (i.e. they do not
guarantee a particular finishing time) and fall into three categories:
*	1. Methods that work well (i.e. quickly) if there is a relatively
small factor $p$ (even if $n$ itself is large). Pollard's "rho"
algorithm belongs to this category. The fastest in this category is
Lenstra's elliptic curves method (ECM).
*	2. Methods that work equally well regardless of the size of factors
(but slower with larger $n$). These are the continued fractions method
and the various "sieve" methods. The best is the "General Number Field
Sieve" (GNFS) but it is quite a complicated algorithm requiring
operations with high-order algebraic numbers. The next best one is the
"Multiple Polynomial Quadratic Sieve" (MPQS).
*	3. Methods that are suitable only for numbers of special
"interesting" form, e.g. Fermat numbers $2^(2^k)-1$ or generally
numbers of the form $r^s+a$ where $s$ is large but $r$ and $a$ are very
small integers. The best method seems to be again the Special Number
Field Sieve.

		Adaptive plotting

The adaptive plotting routine {Plot2D'adaptive} uses a simple algorithm
to select the optimal grid to approximate a function $f(x)$. The same algorithm
for adaptive grid refinement could be used for numerical integration. The
idea is that plotting and numerical integration require the same kind of
detailed knowledge about the behavior of the function.

The algorithm first splits the interval into a specified initial number of
equal subintervals, and then repeatedly splits each subinterval in half
until the function is well enough approximated by the resulting grid. The
integer parameter {depth} gives the maximum number of binary splittings for
a given initial interval; thus, at most $2^depth$ additional grid points
will be generated. The function {Plot2D'adaptive} should return a list of
pairs of points {{{x1,y1}, {x2,y2}, ...}} to be used directly for plotting.

The recursive bisection algorithm goes like this:

*	 1.  Given an interval ($a$, $c$), we split
it in half, $b:=(a+c)/2$ and first compute $f(x)$ at five grid
points $a$, $a[1]:=(a+b)/2$, $b$, $b[1]:=(b+c)/2$, $c$. 
*	 2. If currently $depth <= 0$, return this list of 5 points and
values because we cannot refine the grid any more.
*	 3. Otherwise check that the function does not change sign too
rapidly on the interval. The formal criterion is that among these 5 points there are always
at least 2 consecutive points of equal sign. Checking is done by
the following procedure: Mark the sequence of signs of the values
$f(x)$ at the 5 grid points, e.g. "0, +, -, +, +". Here "0" stands
for zero. Then, for each pair of consecutive signs, write "1" if
the signs are different and "0" otherwise. If one of the signs is
0, then also write "0". E.g. we get the sequence of 4 bits "0, 1,
1, 0". Each "1" stands for a sign change. Then, for each pair of
consecutive bits, write the logical AND of these bits. E.g.: 0, 1,
0. Each "1" now signifies that two sign changes occurred, one
right after another. If we have all "0" now, then the sign changes
are "slow enough". Otherwise they are not "slow enough". We can
compute the logical OR of these 3 bits to test this. In our
example we get 1. This means that we have a sign change that is
too rapid.
If the sign is not changing "slow enough" within the interval
[a,c], then we need to refine the grid; go to step 5. Otherwise,
go to step 4.
*	 4. Check that the function values are smooth enough through the
interval. Smoothness is controlled by a parameter $epsilon$. The
meaning of the parameter $epsilon$ is the (relative) error of the
numerical approximation of the integral of $f(x)$ by the grid. A good heuristic
value of $epsilon$ is 1/(the number of pixels on the screen)
because it means that no pixels will be missing in the area under
the graph. However, for this to work we need to make sure that we are actually computing the area <i>under</i> the graph; so we define $g(x):=f(x)-f[0]$ where $f[0]$ is the minimum of the values of $f(x)$ on the five grid points $a$, $a[1]$, $b$, $b[1]$, and $c$; the function $g(x)$ is nonnegative and has minimum value of 0. Then we compute two different Newton-Cotes quadratures
for $ Integrate(x,b,b[1]) g(x) $ using these five points. (Asymmetric
quadratures are chosen to avoid running into an accidental symmetry of the
function; the first quadrature uses points $a$, $a[1]$, $b$, $b[1]$ and the second
quadrature uses $b$, $b[1]$, $c$.) If the
absolute value of the difference between these quadratures is less
than $epsilon$ * (value of the second quadrature), then we
are done and we return the list of these five points and values.
*	 5. Otherwise we need to refine the grid. We compute
{Plot2D'adaptive} recursively for the two halves of the interval,
i.e. for ($a$,$b$) and ($b$,$c$); we pass the midpoint values as
necessary and decrease {depth} by 1. We also multiply $epsilon$ by 2 because we need to maintain constant <i>absolute</i> precision and this means that the relative error for the two subintervals can be twice as large. The resulting two lists for the two subintervals are
concatenated (excluding the double value at point $b$) and
returned.

This algorithm works well if the initial number of points and the {depth}
parameter are large enough.

Singularities in the function are handled by the step 3. Namely, the algorithm checks whether the function returns a non-number (e.g. {Infinity}) and if so, the sign change is always considered to be "too rapid". Thus, the intervals immediately adjacent to the singularity will be plotted at the highest allowed refinement level. When plotting the resulting data, the singular points are simply not printed the data file and the plotting programs do not have any problems.

The meaning of Newton-Cotes quadrature coefficients is that an integral is approximated as

$$(Integrate(x,a[0],a[n]) f(x)) <=> h*Sum(k,0,n,c[k]*f(a[k]))$$,
where $h:=a[1]-a[0]$ is the grid step, $a[k]$ are the grid points, and
$c[k]$ are the quadrature coefficients. These coefficients are independent
of the function $f(x)$ and can be precomputed
in advance for any grid $a[k]$ (not necessarily with constant step
$h=a[k]-a[k-1]$).
The Newton-Cotes coefficients $c[k]$ for
grids with a constant step $h$ can be found, for example, by solving a system of equations,
$$Sum(k, 0, n, c[k]*k^p) = n^(p+1)/(p+1)$$
for $p=0$, 1, ..., $n$. This system of equations means that the coefficients $c[k]$ correctly approximate the integrals of functions $f(x)=x^p$ over the interval (0,$n$).

The solution of this system always exists and gives quadrature coefficients as rational numbers. For example, the Simpson quadrature $c[0]=1/6$, $c[1]=2/3$, $c[2]=1/6$ is obtained with $n=2$.

In the same way it is possible to find quadratures for the integral over a subinterval rather than over the whole interval of $x$. In the current implementation of the adaptive plotting algorithm, two quadratures are used: the 3-point quadrature ($n=2$) and the 4-point quadrature ($n=3$) for the integral over the first subinterval, $Integrate(x,a[0],a[1]) f(x)$. Their coefficients are ($5/12$, $2/3$, $-1/12$) and ($3/8$, $19/24$, $-5/24$, $1/24$). 

*INCLUDE algorithms-elemfunc.chapt
*INCLUDE algorithms-specfunc.chapt


			Symbolic algebra algorithms

*INCLUDE algorithms-multivar.chapt

*INCLUDE algorithms-integration.chapt

*INCLUDE SturmSequences.chapt
