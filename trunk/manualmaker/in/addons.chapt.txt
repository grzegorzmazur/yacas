			Platform-dependent packages

*INTRO Certain facilities have been developed for use on the Unix platform,
which is currently the main development platform for Yacas. These packages are described in this chapter.

*CMD GetYacasPID --- obtain Yacas process number
*UNIX
*CALL
	GetYacasPID()

*DESC
Returns an integer containing the process number (PID) of the Yacas session.

Requires: a Unix shell.

*CMD ShowPS --- view equations graphically
*UNIX
*CALL
	ShowPS(expr)

*PARMS
{expr} -- any expression (not evaluated)

*DESC
Exports a Yacas expression to $LaTeX$, generates a Postscript file and shows it in a viewer. The free viewer {gv} must be available on the Unix shell path. An alternative viewer can be specified by assigning to the global variable PSViewCommand.

Requires: a Unix shell, {latex}, {dvips}, {gv} or another Postscript viewer.

*EG
	In> [ PSViewCommand := "ghostview"; \
	  ShowPS(x+2*Sin(x)); ]
	Expression exported as /tmp/yacas-tmp
	file-28802.tex
	Out> True;

*CMD MakeFunctionPlugin --- compile numerical functions into plugins
*UNIX
*CALL
	MakeFunctionPlugin("name", body)

*PARMS

{"name"} -- string, name of a new function

{body} -- expression, function of arguments, must evaluate to a function of some variables. 

*DESC

Compiles an external plugin library that computes a user-defined numerical
function and dynamically loads it into Yacas, enabling a new function called
"name".

Requires: a Unix shell, a compiler named {c++} with ELF {.so} support, Yacas
headers in {FindFile("")/include}; current directory must be writable.

The {body} expression must be a {CForm()}-exportable function of the arguments and may contain numerical constants. {Pi} is allowed and will be converted to
floating-point.

All arguments and the return value of the function are assumed
to be double precision real numbers. The result of passing a non-numerical argument will be an unevaluated expression.
	
	Example:
	
	In> MakeFunctionPlugin("f1", {x,y}, Sin(x/y))
	Function f1(x,y) loaded from
	plugins.tmp/libf1_plugin_cc.so
	Out> True;
	In> f1(2,3)
	Out> 0.618369803069736989620253;
	In> f1(x,5)
	Out> f1(x,5);

The function creates the following files in subdirectory {plugins.tmp/} of current directory:
*	{f1_plugin.h}, {f1_plugin.cc} -- C++ code of the plugin; the function in the above example is implemented in C++ as
	double f1_plugin_cc(double x, double y)
	  { return sin(x/y); }
*	{f1_plugin.stub} -- Yacas-language stub
*	{f1_plugin_api.cc} -- Yacas-generated C++ stub
*	{f1_plugin_api.description} - Yacas-generated documentation
*	{f1_plugin.compile} -- command line to compile
*	{libf1_plugin_cc.so} -- compiled plugin
Note that all files have names matching "{*_plugin*}".

After creating these files, {MakeFunctionPlugin()} will:
*	1. Run a {c++} compiler command; if compilation fails, all error messages will appear on the screen;
*	1. Load resulting .so object with {DllLoad()};
*	1. Print an information message on success.

If you call {MakeFunctionPlugin()} repeatedly to define a function with the same name, old files will be overwritten and old libraries will be unloaded with {DllUnload()}.

*SEE DllLoad, DllUnload, DllEnumerate


*CMD GnuPlot --- plot functions of one variable
*UNIX
*CALL
	GnuPlot(x1, x2, numpoints, function)
	GnuPlot(x1, x2, numpoints, {expression_list}

*PARMS

{x1}, {x2} -- interval in which to plot the function

{numpoints} -- number of points in the interval

{function} -- unevaluated expression containing a variable

{expression_list} -- list of functions to plot

*DESC

Requires {gnuplot} software. Calls the {gnuplot} plotting program to plot a
graph of the given function in the given range, using {numpoints} equally
spaced points. Creates data files {gnuplot.in} and {gnudata.in} in the {plot.tmp/} subdirectory of the current
working directory, so you can use those files to prepare better graphs. If several functions are to be plotted at once, it creates files {gnudata.in1}, {gnudata.in2} etc.

Most frequently encountered problem: the {function} parameter <i>must</i>
evaluate to an expression that contains a variable. Test your function for
this! If you have defined some {f(x)} which accepts a number but does not
accept an undefined variable, {GnuPlot()} will fail to plot it. Use
{NFunction()} to overcome this difficulty.

*EG

	In> f(x) := Cos(( Abs(Pi/x))^1.5);
	Out> True;
	In> GnuPlot(-1, 1, 101, f(x) );
	GnuPlot: created file gnuplot.tmp/gnudata.in
	Out> True;
We find that 101 is not enough points to accurately represent this function. However, calculations with more points would take a long time. To speed up the calculation, compile this function online:

	In> MakeFunctionPlugin("f1", f(x));
	Function f1(x) loaded from plugins.tmp/
	libf1_plugin_cc.so
	Out> True;
	In> GnuPlot(-1, 1, 10001, f1(x))
	GnuPlot: created file gnuplot.tmp/gnudata.in
	Out> True;

*SEE NFunction, MakeFunctionPlugin

*CMD Version --- Show version of Yacas
*CORE
*CALL
	Version()

*DESC

The function {Version()} returns a string representing the version of the currently running Yacas interpreter.

*E.G.

	In> Version()
	Out> "1.0.48rev3";
	In> LessThan(Version(), "1.0.47")
	Out> False;
	In> GreaterThan(Version(), "1.0.47")
	Out> True;

The last two calls show that the {LessThan} and {GreaterThan}
functions can be used for comparing version numbers. This 
method is only guaranteed, however, if the version is always expressed
in the form {d.d.dd} as above.

*SEE LessThan, GreaterThan


*CMD Vi --- Edit a file or function
*UNIX
*CALL
	Vi(filename);
	Vi(functionname);

*PARMS

{filename} - name of a file to edit

{functionname} - name of a function to find for editing

*DESC

{Vi} will try to edit a file, or if the argument passed is a
function, it will try to edit the file the function is defined in.
It will try to do so by invoking the editor {vi}.

It finds the function by scanning the {*.def} files that have been
reported to the system. ({Vi} calls  {FindFunction} for this.)
If editing a function, the command will jump directly to the first
occurrence of the name of the function in the file (usually the 
beginning of a definition of a function).

For {Vi()} to be really useful, you need to start Yacas from the {scripts/} directory in the development tree. In that case, {FindFunction()} will return the filename under that directory. Otherwise,  {FindFunction()} will return a name in the systemwide installation directory (or directory specified in the {--rootdir} option).

*E.G.

	In> Vi("yacasinit.ys")
	Out> True;
	In> Vi("Sum")
	Out> True;

*SEE FindFunction
