			Platform-dependent packages

*INTRO Certain facilities have been developed for use on the Unix platform,
which is currently the main development platform for Yacas. These packages are described in this chapter.

*CMD GetYacasPID --- obtain Yacas process number
*UNIX
*CALL
	GetYacasPID()

*DESC
Returns an integer containing the process number (PID) of the Yacas session.

Requires: a Unix shell.

*CMD ShowPS --- view equations graphically
*UNIX
*CALL
	ShowPS(expr)

*PARMS
{expr} -- any expression (not evaluated)

*DESC
Exports a Yacas expression to $LaTeX$, generates a Postscript file and shows it in a viewer. The free viewer {gv} must be available on the Unix shell path. An alternative viewer can be specified by assigning to the global variable PSViewCommand.

Requires: a Unix shell, {latex}, {dvips}, {gv} or another Postscript viewer.

*EG
	In> [ PSViewCommand := "ghostview"; \
	  ShowPS(x+2*Sin(x)); ]
	Expression exported as /tmp/yacas-tmp
	file-28802.tex
	Out> True;

*CMD MakeFunctionPlugin --- compile numerical functions into plugins
*UNIX
*CALL
	MakeFunctionPlugin("name", body)

*PARMS

{"name"} -- string, name of a new function

{body} -- expression, function of arguments, must evaluate to a function of some variables. 

*DESC

Compiles an external plugin library that computes a user-defined numerical
function and dynamically loads it into Yacas, enabling a new function called
"name".

Requires: a Unix shell, a compiler named {c++} with ELF {.so} support, Yacas
headers in {FindFile("")/include}; current directory must be writable.

The {body} expression must be a {CForm()}-exportable function of the arguments and may contain numerical constants. {Pi} is allowed and will be converted to
floating-point.

All arguments and the return value of the function are assumed
to be double precision real numbers. The result of passing a non-numerical argument will be an unevaluated expression.
	
	Example:
	
	In> MakeFunctionPlugin("f1", {x,y}, Sin(x/y))
	Function f1(x,y) loaded from
	plugins.tmp/libf1_plugin_cc.so
	Out> True;
	In> f1(2,3)
	Out> 0.618369803069736989620253;
	In> f1(x,5)
	Out> f1(x,5);

The function creates the following files in subdirectory {plugins.tmp/} of current directory:
*	{f1_plugin.h}, {f1_plugin.cc} -- C++ code of the plugin; the function in the above example is implemented in C++ as
	double f1_plugin_cc(double x, double y)
	  { return sin(x/y); }
*	{f1_plugin.stub} -- Yacas-language stub
*	{f1_plugin_api.cc} -- Yacas-generated C++ stub
*	{f1_plugin_api.description} - Yacas-generated documentation
*	{f1_plugin.compile} -- command line to compile
*	{libf1_plugin_cc.so} -- compiled plugin
Note that all files have names matching "{*_plugin*}".

After creating these files, {MakeFunctionPlugin()} will:
*	1. Run a {c++} compiler command; if compilation fails, all error messages will appear on the screen;
*	1. Load resulting .so object with {DllLoad()};
*	1. Print an information message on success.

If you call {MakeFunctionPlugin()} repeatedly to define a function with the same name, old files will be overwritten and old libraries will be unloaded with {DllUnload()}.

*SEE DllLoad, DllUnload, DllEnumerate


*CMD GnuPlot --- plot functions of one variable
*UNIX
*CALL
	GnuPlot(x1, x2, numpoints, function)

*PARMS

x1, x2 -- interval in which to plot the function
numpoints -- number of points in the interval
function -- expression containing a variable

*DESC

Requires {gnuplot}. Calls the {gnuplot} plotting program to plot a graph of the given function in the given range, using {numpoints} equally spaced points. Creates data files {gnuplot.in} and {gnudata.in} in the current working directory, so you can use those files to prepare better graphs.

Most frequently encountered problem: {function} <i>must</i> evaluate to an expression that contains a variable. Test your function! If you have defined {f(x)} which only accepts a number but does not accept an undefined variable, {GnuPlot()} will fail to plot it. Use {NFunction()} to overcome this difficulty.

*EG

	In> f(x) := Cos(( Abs(Pi/x))^1.5);
	Out> True;
	In> GnuPlot(-1, 1, 101, f(x) );
	Out> True;
We find that 101 is not enough points to accurately represent this function. However, calculations with more points would take a long time. To speed up the calculation, compile this function online:

	In> MakeFunctionPlugin("f1", f(x));
	Function f1(x) loaded from plugins.tmp
	/libf1_plugin_cc.so
	Out> True;
	In> GnuPlot(-1, 1, 10001, f1(x))
	Out> True;

*SEE NFunction, MakeFunctionPlugin

