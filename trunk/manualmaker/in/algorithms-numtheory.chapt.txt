			Number theory algorithms

*INTRO This chapter describes the algorithms used for computing various number-theoretic functions.
A number-theoretic function is any function that takes integer arguments,
produces integer values, and is of interest to number theory.


		Prime numbers: the Miller-Rabin algorithm and its improvements

*A primality testing

Small prime numbers $p<=65537$ are simply stored in a precomputed table as an array of 32768 bits; the bits corresponding to prime numbers are set to 1.
This makes primality testing on small numbers very quick; the size of the table is only 4 KB.

Primality of larger numbers is tested by the function {IsPrime} that uses the
Miller-Rabin algorithm (initial implementation and documentation
supplied by Christian Obrecht). This algorithm is deterministic for
"small" numbers $n<3.4*10^13$ and probabilistic for larger numbers. In other words, it
could sometimes flag a number as prime when in fact the number is
composite; but the probability for this to happen can be made extremely
small. The basic reference is [Rabin 1980].
We also implemented some of the improvements suggested in [Davenport 1992].

*A primality testing!Fermat test
*A primality testing!Miller-Rabin algorithm

The idea of the Miller-Rabin algorithm is to improve the Fermat primality test. If $n$ is prime, then for any $x$ we have $Gcd(n,x)=1$. Then by Fermat's "little theorem", $x^(n-1):=Mod(1,n)$. (This is really a simple statement; if $n$ is prime, then $n-1$ nonzero remainders modulo $n$: 1, 2, ..., $n-1$ form a cyclic multiplicative group.) Therefore we pick some "base" integer $x$ and compute $Mod(x^(n-1), n)$; this is a quick computation even if $n$ is large. If this value is not equal to $1$ for some base $x$, then $n$ is definitely not prime. However, we cannot test <i>every</i> base $x<n$; instead we test only some $x$, so it may happen that we miss the right values of $x$ that would expose the non-primality of $n$. So Fermat's test sometimes fails, i.e. says that $n$ is prime when it is in fact not a prime. Also there are infinitely many integers called "Carmichael numbers" which are not prime but pass the Fermat test for every base.

The Miller-Rabin algorithm improves on this by using the property that for prime $n$ there are no nontrivial square roots of unity in the ring of integers modulo $n$ (this is Lagrange's theorem). In other words, if $x^2:=Mod(1,n)$ for some $x$, then $x$ must be equal to $1$ or $-1$ modulo $n$. (Note that $n-1$ is equal to $-1$ modulo $n$, so $n-1$ is a trivial square root of unity modulo $n$.) In fact, if $n$ is prime, there must be no divisors of $1$ at all, i.e. no numbers $x$ and $y$, not equal to $1$ or $-1$ modulo $n$, such that $x*y:=Mod(1,n)$. If we find such $x$, $y$, then $Gcd(x,n)>1$ or $Gcd(y,n)>1$ and $n$ is not prime.

We can check that $n$ is odd before applying any primality test. (A quick test $n^2:=Mod(1,24)$ guarantees that $n$ is not divisible by $2$ or $3$.) Then we note that in Fermat's test, the power $n-1$ is certainly a composite number because $n-1$ is even. So if we first find the largest power of $2$ in $n-1$ and decompose $n-1=2^r*q$ with $q$ odd, then $x^(n-1):=Mod(a^(2^r),n)$ where $a:=Mod(x^q,n)$. (Here $r>=1$ since $n$ is odd.) In other words, the number $Mod(x^(n-1),n)$ is obtained by repeated squaring of the number $a$ that we can easily find. We get a sequence of $r$ repeated squares: $a$, $a^2$, ..., $a^(2^r)$. 
The last element of this sequence must be $1$ if $n$ passes the Fermat test. (If it does not pass, $n$ must be a composite number.) If $n$ passed the Fermat test, the previous element of the sequence of squares is a square root of unity modulo $n$. We can check whether this square root is non-trivial (i.e. not equal to $1$ or $-1$ modulo $n$). If it is non-trivial, then $n$ definitely cannot be a prime. If it is trivial and equal to $1$, we can check the preceding element, and so on. If an element is equal to $-1$, we cannot say anything, i.e. the test passes ($n$ is "probably a prime").
 
This procedure can be summarized like this:
*	1. Find the largest power of $2$ in $n-1$ and an odd number $q$ such that $n-1=2^r*q$.
*	2. Select the "base number" $x<n$. Compute the sequence $a:=Mod(x^q,n)$, $a^2$, $a^4$, ..., $a^(2^r)$ by repeated squaring modulo $n$. This sequence contains at least two elements since $r>=1$.
*	3. If $a=1$ or $a=n-1$, the test passes on the base number $x$. Otherwise, the test passes if at least one of the elements of the sequence is equal to $n-1$ and fails if none of them are equal to $n-1$. 
This simplified procedure works because the first element that is equal to $1$ <i>must</i> be preceded by a $-1$, or else we'd found a root of unity.

A practical application of this procedure needs to select particular base numbers. 
It is advantageous (according to [Pomerance <i>et al.</i> 1980]) to choose <i>prime</i> numbers $b$ as bases, because for a composite base $b=p*q$, if $n$ is a strong pseudoprime for both $p$ and $q$, then it is very probable that $n$ is a strong pseudoprime also for $b$, so composite bases rarely give new information.

Here are some more formal definitions. An odd integer $n$ is called <i>strongly-probably-prime</i> for base $b$ if
$b^q:=Mod(1,n)$
or
$b^(q*2^i):=Mod(n-1,n)$ for some $i$ such that $0 <= i < r$,
where $q$ and $r$ are such that $q$ is odd and $n-1 = q*2^r$.

An additional check suggested by [Davenport 1992] is activated if $r>2$ (i.e. if $n:=Mod(1,4)$ which is true for only 1/2 of all odd numbers). If $i>=1$ is found such that $b^(q*2^i):=Mod(n-1,n)$, then $b^(q*2^(i-1))$ is a square root of $-1$ modulo $n$. If $n$ is prime, there may be only two different square roots of $-1$. Therefore we should store the set of found values of roots; if there are more than two such roots, then we have found roots $s1$, $s2$ of $-1$ such that $0!=Mod(s1+s2+1,n)$. Then $s1^2-s2^2:=Mod(0,n)$ and $n$ is definitely composite because e.g. $Gcd(s1+s2,n)>1$. This check costs very little computational effort but guards against some strong pseudoprimes.

Yet another small improvement comes from [Damgard <i>et al.</i> 1993].
They found that the strong primality test sometimes (rarely) passes on
composite numbers $n$ for more than $1/8$ of all bases $x<n$ if $n$ is such
that either $3*n+1$ or $8*n+1$ is a perfect square, or if $n$ is a
Carmichael number. Checking Carmichael numbers is slow, but it is easy to show that
if $n$ is a large enough prime number, then neither $3*n+1$, nor $8*n+1$,
nor any $s*n+1$ with small integer $s$ can be a perfect square. (If
$s*n+1=r^2$, then $s*n=(r-1)*(r+1)$.) Testing for a perfect square is quick
and does not slow down the routine very much. This is however not
implemented in Yacas because it seems that perfect squares are rare enough
for this improvement not to be very significant.

*A primality testing!strong pseudoprimes

If an integer is not "strongly-probably-prime" for a given base $b$, then it is
a composite number. However, the reciprocal is false, i.e. "strongly-probably-prime" numbers can actually be composite. Composite strongly-probably-prime numbers for
base $b$ are called <i>strong pseudoprimes</i> for base $b$. There is a theorem that if $n$ is
composite, then among all numbers $b$ such that $1 < b < n$, at most one fourth
are such that $n$ is a strong pseudoprime for base $b$.

For numbers less than $B=34155071728321$, exhaustive computations have shown
that there are no strong pseudoprimes simultaneously for bases 2, 3, 5, 7, 11, 13
and 17. This leads to a very simple and quick way to check whether a number is
prime, provided it is smaller than $B$.
If $n >= B$, the Rabin-Miller method consists in checking if $n$ is
strongly-probably-prime for $k$ base numbers $b$.
The base numbers are chosen to be consecutive "weak pseudoprimes" that are easy to generate (see below the function {NextPseudoPrime}).

*A primality testing!Miller-Rabin algorithm!choosing the bases

In the implemented routine {RabinMiller}, the number of bases $k$ is chosen to
make the probability of erroneously passing the test $p < 10^(-25)$. (Note that
this is <i>not</i> the same as the probability to give an incorrect answer,
because all numbers that do not pass the test are definitely composite.) The
probability for the test to pass mistakenly on a given number is found as
follows. Suppose the number of bases $k$ is fixed. Then the probability for a
given composite number to pass the test is less than $p[f]=4^(-k)$. The
probability for a given number $n$ to be prime is roughly $p[p]=1/Ln(n)$ and to
be composite $p[c]=1-1/Ln(n)$. Prime numbers never fail the test. Therefore, the probability for the test to pass is $p[f]*p[c]+p[p]$ and the probability for pass erroneously is
$$ p = (p[f]*p[c])/(p[f]*p[c]+p[p]) < Ln(n)*4^(-k) $$.
To make $p<epsilon$, it is enough to select $k=1/Ln(4)*(Ln(n)-Ln(epsilon))$.

Before calling {MillerRabin}, the function {IsPrime} performs two quick
checks: first, for $n>=4$ it checks that $n^2:=Mod(1,24)$ (all primes larger than 4 must satisfy this); second, for $n>257$, it
checks that $n$ does not contain small prime factors $p<=257$. This is
checked by evaluating the GCD of $n$ with the product of all primes up
to 257. The computation of GCD is very quick and saves time in case a
small prime factor is present.

*A {NextPrime}

There are also a function {NextPrime(n)} that returns the smallest prime number larger than {n}. 
This function uses a sequence 5,7,11,13,... generated by the function {NextPseudoPrime}.
This sequence
contains numbers not divisible by 2 or 3 (but perhaps divisible by 5,7,...). The function {NextPseudoPrime} 
is very fast because it does not perform a full primality test.

The function {NextPrime} however does check each of these pseudoprimes using {IsPrime} and finds the first prime number.


		Factorization of integers

*A factorization of integers

*A {Factor}

Factorization of integers is implemented by functions {Factor} and {Factors}. Both functions 
try to find all prime factors of a given integer $n$. (Before doing this, the primality 
checking algorithm is used to detect whether $n$ is a prime number.)
Factorization consists of repeatedly finding a factor, i.e. an 
integer $f$ such that $Mod(n, f)=0$, and dividing $n$ by $f$.

*A factorization of integers!small prime factors

First we determine whether the number $n$ contains "small" prime
factors $p<=257$. A quick test is to find the GCD of $n$ and the
product of all primes up to $257$: if the GCD is greater than 1, then
$n$ has at least one small prime factor. (The product of primes is
precomputed.) If this is the case, the trial division algorithm is
used: $n$ is divided by all prime numbers $p<=257$ until a factor is
found. {NextPseudoPrime} is used to generate the sequence of candidate
divisors $p$.

*A factorization of integers!checking for prime powers

After separating small prime factors, we test whether the number $n$ is an integer power of a prime number, i.e. whether $n=p^s$ for some prime number $p$ and an integer $s>=1$. This is tested by the following algorithm. We already know that $n$ is not prime and that $n$ does not contain any small prime factors up to 257. Therefore if $n=p^s$, then $p>257$ and $2<=s<s[0]=Ln(n)/Ln(257)$. In other words, we only need to look for powers not greater than $s[0]$. This number can be approximated by the "integer logarithm" of $n$ in base 257 (routine {IntLog(n, 257)}).

Now we need to check whether $n$ is of the form $p^s$ for $s=2$, 3, ..., $s[0]$. Note that if for example $n=p^24$ for some $p$, then the square root of $n$ will already be an integer, $n^(1/2)=p^12$. Therefore it is enough to test whether $n^(1/s)$ is an integer for all <i>prime</i> values of $s$ up to $s[0]$, and then we will definitely discover whether $n$ is a power of some other integer.
The testing is performed using the integer square root function {IntNthRoot} which quickly computes the integer part of $n$-th root of an integer number. If we discover that $n$ has an integer root $p$ of order $s$, we have to check that $p$ itself is a prime power (we use the same algorithm recursively). The number $n$ is a prime power if and only if $p$ is itself a prime power. If we find no integer roots of orders $s<=s[0]$, then $n$ is not a prime power.

*A factorization of integers!Pollard's "rho" algorithm

If the number $n$ is not a prime power, the Pollard "rho" algorithm is applied [Pollard 1978]. The Pollard "rho" algorithm takes an irreducible polynomial, e.g. $p(x)=x^2+1$ and builds a sequence of integers $x[k+1]:=Mod(p(x[k]),n)$, starting from $x[0]=2$. For each $k$, the value $x[2*k]-x[k]$ is attempted as possibly containing a common factor with $n$. The GCD of $x[2*k]-x[k]$ with $n$ is computed, and if $Gcd(x[2*k]-x[k],n)>1$, then that GCD value divides $n$.

The idea behind the "rho" algorithm is to generate an effectively
random sequence of trial numbers $t[k]$ that may have a common factor
with $n$. The efficiency of this algorithm is determined by the size of
the smallest factor $p$ of $n$. Suppose $p$ is the smallest prime
factor of $n$ and suppose we generate a random sequence of integers
$t[k]$ such that $1<=t[k]<n$. It is clear that, on the average, a
fraction $1/p$ of these integers will be divisible by $p$. Therefore
(if $t[k]$ are truly random) we should need on the average $p$ tries
until we find $t[k]$ which is accidentally divisible by $p$. In
practice, of course, we do not use a truly random sequence and the
number of tries before we find a factor $p$ may be significantly
different from $p$. The quadratic polynomial seems to help reduce the
number of tries in most cases.

But the Pollard "rho" algorithm may actually enter an infinite loop
when the sequence $x[k]$ repeats itself without giving any factors of
$n$. For example, the unmodified "rho" algorithm starting from $x[0]=2$
loops on the number $703$. The loop is detected by comparing $x[2*k]$ and
$x[k]$. When these two quantities become equal to each other for the
first time, the loop may not yet have occurred so the value of GCD is
set to 1 and the sequence is continued. But when the equality of
$x[2*k]$ and $x[k]$ occurs many times, it indicates that the algorithm
has entered a loop. A solution is to randomly choose a different
starting number $x[0]$ when a loop occurs and try factoring again, and
keep trying new random starting numbers between 1 and $n$ until a
non-looping sequence is found. The current implementation stops after
100 restart attempts and prints an error message, "failed to factorize
number".

A better (and faster) integer factoring algorithm needs to be implemented in Yacas.

*A factorization of integers!overview of algorithms

Modern factoring algorithms are all probabilistic (i.e. they do not
guarantee a particular finishing time) and fall into three categories:
*	1. Methods that work well (i.e. quickly) if there is a relatively
small factor $p$ of $n$ (even if $n$ itself is large). Pollard's "rho"
algorithm belongs to this category. The fastest in this category is
Lenstra's elliptic curves method (ECM).
*	2. Methods that work equally quickly regardless of the size of factors
(but slower with larger $n$). These are the continued fractions method
and the various "sieve" methods. The current best is the "General Number Field
Sieve" (GNFS) but it is quite a complicated algorithm requiring
operations with high-order algebraic numbers. The next best one is the
"Multiple Polynomial Quadratic Sieve" (MPQS).
*	3. Methods that are suitable only for numbers of special
"interesting" form, e.g. Fermat numbers $2^(2^k)-1$ or generally
numbers of the form $r^s+a$ where $s$ is large but $r$ and $a$ are very
small integers. The best method seems to be the "Special Number
Field Sieve" which is a faster variant of the GNFS adapted to the problem.

There is ample literature describing these algorithms.

		The Jacobi symbol

A number $m$ is a "quadratic residue modulo $n$" if there exists a number $k$ such that $k^2:=Mod(m,n)$.

The Legendre symbol ($m$/$n$) is defined as $+1$ if $m$ is a quadratic residue modulo $n$ and $-1$ if it is a non-residue.
The Legendre symbol is equal to $0$ if $m/n$ is an integer.


The Jacobi symbol $[m/n;]$ is defined as the product of the Legendre symbols of the prime factors $f[i]$ of $n=f[1]^p[1]*...*f[s]^p[s]$,
$$ [m/n;] := [m/f[1];]^p[1]*...*[m/f[s];]^p[s] $$.
(Here we used the same notation $[a/b;]$ for the Legendre and the Jacobi symbols; this is confusing but seems to be the current practice.)
The Jacobi symbol is equal to $0$ if $m$, $n$ are not mutually prime (have a common factor).
The Jacobi symbol and the Legendre symbol have values $+1$, $-1$ or $0$.

The Jacobi symbol can be efficiently computed without knowing the full factorization of the number $n$.
The currently used method is based on the following four identities for the Jacobi symbol:
*	1. $[a/1;] = 1$.
*	2. $[2/b;] = (-1)^((b^2-1)/8)$.
*	3. $[(a*b)/c;] = [a/c;]*[b/c;]$.
*	4. If $a:=Mod(b,c)$, then $[a/c;]=[b/c;]$.
*	5. If $a$, $b$ are both odd, then $[a/b;]=[b/a;] * (-1)^((a-1)*(b-1)/4)$.

Using these identities, we can recursively reduce the computation of the Jacobi symbol $[a/b;]$ to the computation of the Jacobi symbol for numbers that are on the average half as large.
This is similar to the fast "binary" Euclidean algorithm for the computation of the GCD.
The number of levels of recursion is logarithmic in the arguments $a$, $b$.

More formally, Jacobi symbol $[a/b;]$ is computed by the following algorithm.
(The number $b$ must be an odd positive integer, otherwise the result is undefined.)
*	1. If $b=1$, return $1$ and stop. If $a=0$, return $0$ and stop. Otherwise, replace $[a/b;]$ by $[Mod(a,b)/b;]$ (identity 4).
*	2. Find the largest power of $2$ that divides $a$. Say, $a=2^s*c$ where $c$ is odd.
Replace $[a/b;]$ by $[c/b;]*(-1)^(s*(b^2-1)/8)$ (identities 2 and 3).
*	3. Now that $c<b$, replace $[c/b;]$ by $[b/c;]*(-1)^((b-1)*(c-1)/4)$ (identity 5).
*	4. Continue to step 1.

Note that the arguments $a$, $b$ may be very large integers and we should avoid performing multiplications of these numbers.
We can compute $(-1)^((b-1)*(c-1)/4)$ without multiplications. This expression is equal to $1$ if either $b$ or $c$ is equal to 1 mod 4; it is equal to $-1$ only if both $b$ and $c$ are equal to 3 mod 4.
Also, $(-1)^((b^2-1)/8)$ is equal to $1$ if either $b:=1$ or $b:=7$ mod 8, and it is equal to $-1$ if $b:=3$ or $b:=5$ mod 8.
Of course, if $s$ is even, none of this needs to be computed.


		Integer partitions

*A partitions of an integer

A partition of an integer $n$ is a way of writing $n$ as the sum of positive integers, where the order of these integers is unimportant.
For example, there are 3 ways to write the number 3 in this way: $3=1+1+1$, $3=1+2$, $3=3$.
The function {PartitionsP} counts the number of such partitions. 

*A partitions of an integer!by Rademacher-Hardy-Ramanujan series

The algorithm used to compute this function uses the Rademacher-Hardy-Ramanujan (RHR) theorem.
The number of partitions $P(n)$ is equal to an infinite sum:

$$ P(n) = 1/(Pi*Sqrt(2))*Sum(k,1,Infinity, Sqrt(k)*A(k,n)*S(k,n)) $$,
where the functions $A$ and $S$ are defined as follows:

$$S(k,n) := Deriv(n) Sinh(Pi/k*Sqrt(2/3*(n-1/24)))/Sqrt(n-1/24)$$

$$ A(k,n) := Sum(l,1,k, delta(Gcd(l,k),1)*Exp(-2*Pi*I*(l*n)/k+Pi*I*B(k,l))) $$,
where $delta(x,y)$ is the Kronecker delta function (so that the summation goes only over integers $l$ which are mutually prime with $k$) and $B$ is defined by
$$ B(k,l) := Sum(j,1,k-1, j/k*(l*j/k-Floor(l*j/k)-1/2)) $$.

The first term of the series gives, at large $n$, the Hardy-Ramanujan asymptotic estimate,
$$ P(n) <> P_0(n) := 1/(4*n*Sqrt(3))*Exp(Pi*Sqrt((2*n)/3))$$.
The absolute value of each term decays quickly,
so after $O(Sqrt(n))$ terms the series gives an answer that is very close to the integer result.

There exist estimates of the error of this series, but they are complicated.
The series is sufficiently well-behaved and it is easier to determine the truncation point heuristically.
Each term of the series is either 0 (when all terms in $A(k,n)$ happen to cancel) or has a magnitude which is not very much larger than the magnitude of the previous nonzero term.
(But the series is not actually monotonic.)
In the current implementation, the series is truncated when $Abs(A(k,n)*S(n)*Sqrt(k))$ becomes smaller than $0.1$ for the first time;
in any case, the maximum number of calculated terms is $5+Sqrt(n)/2$.
One can show that asymptotically for large $n$, the required number of terms is less than $mu/Ln(mu)$, where $mu:=Pi*Sqrt((2*n)/3)$.

The floating-point precision necessary to obtain the integer result must be at least the number of digits in the first term $P_0(n)$, i.e.
$$ Prec > (Pi*Sqrt(2/3*n)-Ln(4*n*Sqrt(3)))/Ln(10) $$.
However, Yacas currently uses the fixed-point precision model.
Therefore, the current implementation divides the series by $P_0(n)$ and computes all terms to $Prec$ digits.

The RHR algorithm requires $O((n/Ln(n))^(3/2))$ operations, of which $O(n/Ln(n))$ are long multiplications at precision $Prec<>O(Sqrt(n))$ digits.

*A partitions of an integer!by recurrence relation

A simpler algorithm involves a recurrence relation
$$ P[n] = Sum(k,1,n, (-1)^(k+1)*( P[n-k*(3*k-1)/2]+P[n-k*(3*k+1)/2] ) ) $$.
The sum can be written out as
$$ P(n-1)+P(n-2)-P(n-5)-P(n-7)+... $$,
where 1, 2, 5, 7, ... is the "generalized pentagonal sequence" generated by the pairs $k*(3*k-1)/2$, $k*(3*k+1)/2$ for $k=1$, 2, ...
The recurrence starts from $P(0)=1$, $P(1)=1$.
(This is implemented as {PartitionsP'recur}.)

The sum is actually not over all $k$ up to $n$ but is truncated when the pentagonal sequence grows above $n$.
Therefore, it contains only $O(Sqrt(n))$ terms.
However, computing $P(n)$ using the recurrence relation requires computing and storing $P(k)$ for all $1<=k<=n$.
No long multiplications are necessary, but the number of long additions of numbers with $Prec<>O(Sqrt(n))$ digits is $O(n^(3/2))$.
This is asymptotically slower than the RHR algorithm if a fast multiplication is used.
With internal Yacas math, the recurrence relation is faster for $n<300$ or so,
and for larger $n$ the RHR algorithm is faster.


		Miscellaneous number-theoretic functions

*A divisors

The function {Divisors} currently returns the number of divisors an integer has, while
{DivisorsSum} returns the sum of these factors. (The current
algorithms need to factor the number.) The following theorem is used:

Let $ p[1]^k[1]* ... *p[r]^k[r] $ be the prime factorization of n, where $r$ is the
number of prime factors, and $k[r]$ is the multiplicity of $r$-th factor. Then:

$ Divisors(n) = (k[1]+1)*...*(k[r]+1) $,

$ DivisorsSum(n) = ( ((p[1]^(k[1]+1) - 1)/(p[1]-1)))*...*(p[r]^(k[r]+1)-1)/(p[r]-1) $.

*A divisors!proper

The functions {ProperDivisors} and {ProperDivisorsSum} are functions that do the above,
except they ignore the actual number {n} itself as a divisor. They are given by:

$ ProperDivisors(n) = Divisors(n) - 1 $,

$ ProperDivisorsSum(n) = DivisorsSum(n) - n $.

Another number-theoretic function is {Moebius}, which is defined as
follows: $Moebius(n)=(-1)^r$ if no factors are repeated, $Moebius(n)=0$ if
some factors are repeated, and $Moebius(n)=1$ if $n = 1$.

This again requires to factor the number completely and investigate the
properties of its factors. From
the definition, it can be seen that if $n$ is prime, then $Moebius(n) = -1 $. The predicate
{IsSquareFree(n)} then reduces to $Moebius(n)!=0$, which means no factors are repeated.


		Gaussian integers

*A Gaussian integers

A Gaussian integer is a complex number of the form $ z = a+b*I$, where $a$ and 
$b$ are ordinary (rational) integers.
*FOOT To distinguish ordinary integers from Gaussian integers, the ordinary integers (with no imaginary part) are called "rational integers".
The ring of Gaussian integers is usually
denoted by $Z[i]$ in the mathematical literature. It is an example of a ring of
algebraic integers.

The function {GaussianNorm} computes the norm $N(z)=a^2+b^2$ of $z$.
The norm
plays a fundamental role in the arithmetic of Gaussian integers, since it has
the multiplicative property:
$$ N(z.w) = N(z).N(w) $$.

A unit in a ring is an element that divides any other element in the ring. 
There are four units in the Gaussian integers: $1$, $-1$, $I$, $-I$. They are 
exactly the Gaussian integers whose norm is $1$. The predicate {IsGaussianUnit} 
tests for a Gaussian unit.

Two Gaussian integers $z$ and $w$ are "associated" is $z/w$ is a unit. 
For example, $2+I$ and $-1+2*I$ are associated. 

A Gaussian integer is called prime if it is only divisible by the units and by
its associates. It can be shown that the primes in the ring of Gaussian 
integers are:
*	1. $1+i$ and its associates.
*	2. The rational (ordinary) primes of the form $4*n+3$.
*	3. The factors $a+b*I$ of rational primes $p$ of the form $4*n+1$, whose norm is $p$. 

For example, $7$ is prime as a Gaussian integer, while $5$ is not, since
$$ 5 = (2+I)*(2-I) $$.

*A {Factors}

The ring of Gaussian integers is an example of an Euclidean ring, i.e. a ring 
where there is a division algorithm, and this makes possible to compute the 
greatest common divisor using Euclid's algorithm. This is what the function {GaussianGcd} computes. 

As a consequence, it is possible to prove a version of the  fundamental 
theorem of arithmetic for this ring: The expression of a Gaussian 
integer as a product of primes is unique, apart from the order of primes, the
presence of units, and the ambiguities between associated primes.

The function {GaussianFactors} finds this expression of a Gaussian integer 
$z$ as the product of Gaussian primes, and returns the result as a list of 
elements of the form {{p,e}} where $p$ is a Gaussian prime and $e$ is the 
corresponding exponent.

To do that, an auxiliary function called {GaussianFactorPrime} is used. This 
function finds a factor of a rational prime of the form $4*n+1$. We 
compute  $a := (2*n)!$ (mod p). By Wilson's theorem $a^2$ is congruent to
$-1$ (mod $p$), and it follows that $p$ divides $(a+I)*(a-I)=a^2+1$ in the 
Gaussian  integers. The desired factor is then the {GaussianGcd} of $a+I$ 
and $p$. If the result is $a+b*I$, then $p=a^2+b^2$. 

If $z$ is a real integer, we factor $z$ in the Gaussian integers, by first 
factoring it in the rational integers, and after that by factoring each of 
the integer prime factors in the complex integers.
 
If $z$ is not a rational integer, we find its possible Gaussian prime factors
by first factoring its norm $N(z)$ and then computing the exponent of each of 
the factors of $N(z)$ in the decomposition of $z$.

	    References for Gaussian integers

*	1. G. H. Hardy and E. M. Wright,
<i>An Introduction to the Theory of Numbers</i>. Oxford University Press (1945).
*	2. H. Pollard,
<i>The theory of Algebraic Numbers</i>. Wiley, New York (1965).




