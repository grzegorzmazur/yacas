
			Arithmetic and other operations on numbers

*INTRO Besides the usual arithmetical operations,
Yacas defines some more advanced operations on
numbers. Many of them also work on polynomials.

*CMD +, -, *, /, ^ --- arithmetic operations
*STD
*CALL
	x+y  (precedence 6)
	+x
	x-y  (precedence 5)
	-x
	x*y  (precedence 3)
	x/y  (precedence 3)
	x^y  (precedence 2)

*PARMS

{x} and {y} -- objects for which arithmetic operations are defined

*DESC

These are the basic arithmetic operations. They can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 2+3
	Out> 5;
	In> 2*3
	Out> 6;

*CMD Div, Mod --- division with remainder
*STD
*CALL
	Div(x,y)
	Mod(x,y)

*PARMS

{x}, {y} -- integers or univariate polynomials

*DESC

{Div} performs integer division and {Mod} returns the remainder after division. {Div} and
{Mod} are also defined for polynomials.

If {Div(x,y)} returns "a" and {Mod(x,y)} equals "b", then these numbers satisfy $x =a*y + b$ and $0 <= b < y$.

*E.G.

	In> Div(5,3)
	Out> 1;
	In> Mod(5,3)
	Out> 2;

*SEE Gcd, Lcm

*CMD Gcd --- greatest common divisor
*STD
*CALL
	Gcd(n,m)
	Gcd(list)

*PARMS

{n}, {m} -- integers or univariate polynomials

{list} -- a list of all integers or all univariate polynomials

*DESC

This function returns the greatest common divisor of "n" and "m".
The gcd is the largest number that divides "n" and "m".  It is
also known as the highest common factor (hcf).  The library code calls
{MathGcd}, which is an internal function.  This
function implements the "binary Euclidean algorithm" for determining the
greatest common divisor:

*HEAD	Routine for calculating {Gcd(n,m)}
	
*	1. if $n = m$ then return $n$
*	2. if both $n$ and $m$ are even then return $2*Gcd(n/2,m/2)$
*	3. if exactly one of $n$ or $m$ (say $n$) is even then return $Gcd(n/2,m)$
*	4. if both $n$ and $m$ are odd and, say, $n>m$ then return $Gcd((n-m)/2,m)$

This is a rather fast algorithm on computers that can efficiently shift
integers.

If the second calling form is used, {Gcd} will
return the greatest common divisor of all the integers or polynomials
in "list". It uses the identity
$$Gcd(a,b,c) = Gcd(Gcd(a,b),c)$$.

*E.G.

	In> Gcd(55,10)
	Out> 5;
	In> Gcd({60,24,120})
	Out> 12;

*SEE Lcm

*CMD Lcm --- least common multiple
*STD
*CALL
	Lcm(n,m)

*PARMS

{n}, {m} -- integers or univariate polynomials

*DESC

This command returns the least common multiple of "n" and "m".
The least common multiple of two numbers "n" and "m" is the lowest
number which is an integer multiple of both "n" and "m".
It is calculated with the formula
$$Lcm(n,m) = Div(n*m,Gcd(n,m))$$.

This means it also works on polynomials, since {Div}, {Gcd} and multiplication are also defined for
them.

*E.G.

	In> Lcm(60,24)
	Out> 120;

*SEE Gcd

*CMD <<, >> --- shift operators
*STD
*CALL
	n<<m
	n>>m

*PARMS

{n}, {m} -- integers

*DESC

These operators shift integers to the left or to the right.
They are similar to the C shift operators. These are sign-extended
shifts, so they act as multiplication or division by powers of 2.

*E.G.

	In> 1 << 10
	Out> 1024;
	In> -1024 >> 10
	Out> -1;

*CMD FromBase, ToBase --- conversion from/to non-decimal base
*CORE
*CALL
	FromBase(base,number)
	ToBase(base,number)

*PARMS

{base} -- integer, base to write the numbers in

{number} -- integer, number to write out in the base representation

*DESC

{FromBase} converts "number", written in base
"base", to base 10. {ToBase} converts "number",
written in base 10, to base "base".

These functions use the p-adic expansion capabilities of the built-in
arbitrary precision math libraries.

*E.G.

	In> FromBase(2,111111)
	Out> 63;
	In> ToBase(16,255)
	Out> ff;

The first command writes the binary number {111111}
in decimal base. The second command converts {255}
(in decimal base) to hexadecimal base.

*SEE PAdicExpand

*CMD Precision --- set the precision
*CORE
*CALL
	Precision(n)

*PARMS

{n} -- integer, new precision

*DESC

This command sets the number of binary digits to be used in
calculations. All subsequent floating point operations will allow for
at least "n" digits after the decimal point.

*E.G.

	In> Precision(10)
	Out> True;
	In> N(Sin(1))
	Out> 0.8414709848;
	In> Precision(20)
	Out> True;
	In> N(Sin(1))
	Out> 0.84147098480789650665;
	In> GetPrecision()
	Out> 20;

*SEE GetPrecision, N

*CMD GetPrecision --- get the current precision
*CORE
*CALL
	GetPrecision()

*DESC

This command returns the current precision, as set by {Precision}.

*E.G.

	In> GetPrecision();
	Out> 10;
	In> Precision(20);
	Out> True;
	In> GetPrecision();
	Out> 20;

*SEE Precision, N

*CMD N --- compute numerical approximation
*STD
*CALL
	N(expr)
	N(expr, prec)

*PARMS

{expr} -- expression to evaluate

{prec} -- integer, precision to use

*DESC

This function forces Yacas to give a numerical approximation to the
expression "expr", using "prec" digits if the second calling
sequence is used, and the precision as set by {SetPrecision} otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make Yacas
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ up to the required precision.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Precision, GetPrecision, Pi

*CMD Rationalize --- convert floating point numbers to fractions
*STD
*CALL
	Rationalize(expr)

*PARMS

{expr} -- an expression containing real numbers

*DESC

This command converts every real number in the expression "expr"
into a rational number. This is useful when a calculation needs to be
done on floating point numbers and the algorithm is unstable.
Converting the floating point numbers to rational numbers will force
calculations to be done with infinite precision (by using rational
numbers as representations).

It does this by finding the smallest integer $n$ such that multiplying
the number with $10^n$ is an integer. Then it divides by $10^n$ again,
depending on the internal gcd calculation to reduce the resulting
division of integers.

*E.G.

	In> {1.2,3.123,4.5}
	Out> {1.2,3.123,4.5};
	In> Rationalize(%)
	Out> {6/5,3123/1000,9/2};

*SEE IsRational

*CMD IsPrime --- test for a prime number
*STD
*CALL
	IsPrime(n)

*PARMS

{n} -- integer to test

*DESC

This command checks whether "n", which should be a positive integer,
is a prime number. A number is a prime number if it is only divisible
by 1 and itself. As a special case, 1 is not a prime number.

This function essentially checks for all integers between 2 and the
square root of "n" whether they divide "n", and hence may take a
long time for large numbers.

*E.G.

	In> IsPrime(1)
	Out> False;
	In> IsPrime(2)
	Out> True;
	In> IsPrime(10)
	Out> False;
	In> IsPrime(23)
	Out> True;
	In> Select("IsPrime", 1 .. 100)
	Out> {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,
	  53,59,61,67,71,73,79,83,89,97};

*SEE IsPrimePower, Factors

*CMD IsPrimePower --- test for a power of a prime number
*STD
*CALL
	IsPrimePower(n)

*PARMS

{n} -- integer to test

*DESC

This command tests whether "n", which should be a positive integer,
is a prime power, that is whether it is of the form $p^m$, with
"p" prime and "m" an integer.

This function essentially checks for all integers between 2 and the
square root of "n" for the largest divisor, and then tests whether
"n" is a power of this divisor. So it will take a long time for
large numbers.

*E.G.

	In> IsPrimePower(9)
	Out> True;
	In> IsPrimePower(10)
	Out> False;
	In> Select("IsPrimePower", 1 .. 50)
	Out> {2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,
	  29,31,32,37,41,43,47,49};

*SEE IsPrime, Factors

*CMD NextPrime --- generate a prime following a number
*STD
*CALL
	NextPrime(i)

*PARMS

{i} -- integer value

*DESC

The function finds the smallest prime number that is greater than the given
integer value.

The routine generates "candidate numbers" using the formula $n+2*Mod(-n,3)$
where $n$ is an odd number (this generates the sequence 5, 7, 11, 13, 17,
19, ...) and {IsPrime()} to test whether the next candidate number is in
fact prime.

*EG
	In> NextPrime(5)
	Out> 7;

*SEE IsPrime


*CMD Factors --- factorization
*STD
*CALL
	Factors(x)

*PARMS

{x} -- integer or univariate polynomial

*DESC

This function decomposes the integer number "x" into a product of
numbers. Alternatively, if "x" is a univariate polynomial, it is
decomposed in irreducible polynomials.

The factorization is returned as a list of pairs. The first member of
each pair is the factor, while the second member denotes the power to
which this factor should be raised. So the factorization
$x = p1^n1 * ... * p9^n9$
is returned as {{{p1,n1}, ..., {p9,n9}}}.

*E.G.

	In> Factors(24);
	Out> {{2,3},{3,1}};
	In> Factors(2*x^3 + 3*x^2 - 1);
	Out> {{2,1},{x+1,2},{x-1/2,1}};

*SEE Factor, IsPrime

*CMD Factor --- factorization, in pretty form
*STD
*CALL
	Factors(x)

*PARMS

{x} -- integer or univariate polynomial

*DESC

This function factorizes "x", similarly to {Factors}, but
it shows the result in a nicer human readable format.

*E.G.

	In> PrettyForm(Factor(24));
	
	 3
	2  * 3
	
	Out> True;
	In> PrettyForm(Factor(2*x^3 + 3*x^2 - 1));
	
	             2   /     1 \
	2 * ( x + 1 )  * | x - - |
	                 \     2 /
	
	Out> True;

*SEE Factors, IsPrime, PrettyForm

*CMD IntLog --- integer part of logarithm
*STD
*CALL
	IntLog(n, base)

*PARMS

{n}, {base} -- positive integers

*DESC

{IntLog} calculates the integer part of the logarithm of {n} in base {base}. The algorithm uses only integer math and may be faster than computing $$Ln(n)/Ln(base)$$ with multiple precision floating-point math and rounding off to get the integer part.

This function can also be used to quickly count the digits in a given number.

*E.G.
Count the number of bits:
	In> IntLog(257^8, 2)
	Out> 64;

Count the number of decimal digits:
	In> IntLog(321^321, 10)
	Out> 804;

*SEE IntNthRoot, Div, Mod, Ln

*CMD IntNthRoot --- integer part of $n$-th root
*STD
*CALL
	IntNthRoot(x, n)

*PARMS

{x}, {n} -- positive integers

*DESC

{IntNthRoot} calculates the integer part of the $n$-th root of $x$. The algorithm uses only integer math and may be faster than computing $x^(1/n)$ with floating-point and rounding.

This function is used to test numbers for prime powers.

*EG
	In> IntNthRoot(65537^111, 37)
	Out> 281487861809153;

*SEE IntLog, MathPower, IsPrimePower

*CMD PAdicExpand --- p-adic expansion
*STD
*CALL
	PAdicExpand(n, p)

*PARMS

{n} -- number or polynomial to expand

{p} -- base to expand in

*DESC

This command computes the p-adic expansion of "n". In other words,
"n" is expanded in powers of "p". The argument "n" can be either
an integer or a univariate polynomial. The base "p" should be of the
same type.

*E.G.

	In> PrettyForm(PAdicExpand(1234, 10));
	
	               2     3
	3 * 10 + 2 * 10  + 10  + 4
	
	Out> True;
	In> PrettyForm(PAdicExpand(x^3, x-1));
	
	                             2            3
	3 * ( x - 1 ) + 3 * ( x - 1 )  + ( x - 1 )  + 1
	
	Out> True;

*SEE Mod, ContFrac, FromBase, ToBase

*CMD ContFrac --- continued fraction expansion
*STD
*CALL
	ContFrac(x)
	ContFrac(x, depth)

*PARMS

{x} -- number or polynomial to expand in continued fractions

{depth} -- integer, maximum required depth of result

*DESC

This command returns the continued fraction expansion of {x}, which
should be either a floating point number or a polynomial. If
{depth} is not specified, it defaults to 6. The remainder is
denoted by {rest}.

This is especially useful for polynomials, since series expansions
that converge slowly will typically converge a lot faster if
calculated using a continued fraction expansion.

*E.G.

	In> PrettyForm(ContFrac(N(Pi)))
	
	             1
	--------------------------- + 3
	           1
	----------------------- + 7
	        1
	------------------ + 15
	      1
	-------------- + 1
	   1
	-------- + 292
	rest + 1

	Out> True;
	In> PrettyForm(ContFrac(x^2+x+1, 3))
	
	       x
	---------------- + 1
	         x
	1 - ------------
	       x
	    -------- + 1
	    rest + 1
	
	Out> True;

*SEE ContFracList, NearRational, GuessRational, PAdicExpand, N


*CMD ContFracList, ContFracEval --- manipulate continued fractions
*STD
*CALL
	ContFracList(frac)
	ContFracList(frac, depth)
	ContFracEval(list)
	ContFracEval(list, rest)

*PARMS

{frac} -- a number to be expanded

{depth} -- desired number of terms

{list} -- a list of coefficients

{rest} -- expression to put at the end of the continued fraction

*DESC

The function {ContFracList} computes terms of the continued fraction
representation of a rational number {frac}.  It returns a list of terms of length {depth}. If {depth} is not specified, it returns all terms.

The function {ContFracEval} converts a list of coefficients into a continued fraction expression. The optional parameter {rest} specifies the symbol to put at the end of the expansion. If it is not given, the result is the same as if {rest=0}.

*E.G.

	In> A:=ContFracList(33/7 + 0.000001)
	Out> {4,1,2,1,1,20409,2,1,13,2,1,4,1,1,3,3,2};
	In> ContFracEval(Take(A, 5))
	Out> 33/7;
	In> ContFracEval(Take(A,3), remainder)
	Out> 1/(1/(remainder+2)+1)+4;
	
*SEE ContFrac, GuessRational

*CMD GuessRational, NearRational --- find optimal rational approximations
*STD
*CALL
	GuessRational(x)
	GuessRational(x, digits)
	NearRational(x)
	NearRational(x, digits)

*PARMS

{x} -- a number to be approximated

{digits} -- desired number of decimal digits

*DESC

The functions {GuessRational(x)} and {NearRational(x)} attempt to find "optimal"
rational approximations to a given value {x}. The approximations are "optimal"
in the sense of having smallest numerators and denominators among all rational
numbers close to {x}. This is done by computing a continued fraction
representation of {x} and truncating it at a suitably chosen term.  Both
functions return a rational number which is an approximation of {x}.

Unlike the function {Rationalize()} which converts floating-point numbers to
rationals without loss of precision, the functions {GuessRational()} and
{NearRational()} are intended to find the best rational that is <i>approximately</i>
equal to a given value.

The function {GuessRational()} is useful if you have obtained a
floating-point representation of a rational number and you know
approximately how many digits its exact representation should contain.
This function takes an optional second parameter {digits} which limits
the number of decimal digits in the denominator of the resulting
rational number. If this parameter is not given, it defaults to half
the current precision. This function truncates the continuous fraction
expansion when it encounters an unusually large value (see example).
This procedure does not always give the "correct" rational number; a
rule of thumb is that the floating-point number should have at least as
many digits as the combined number of digits in the numerator and the
denominator of the correct rational number.

The function {NearRational(x)} is useful if one needs to
approximate a given value, i.e. to find an "optimal" rational number
that lies in a certain small interval around a certain value {x}. This
function takes an optional second parameter {digits} which has slightly
different meaning: it specifies the number of digits of precision of
the approximation; in other words, the difference between {x} and the
resulting rational number should be at most one digit of that
precision. The parameter {digits} also defaults to half of the current
precision.

*E.G.

Start with a rational number and obtain a floating-point approximation:
	In> x:=N(956/1013)
	Out> 0.9437314906
	In> Rationalize(x)
	Out> 4718657453/5000000000;
	In> V(GuessRational(x))
	GuessRational: using 10 terms of the
	  continued fraction
	Out> 956/1013;
	In> ContFracList(x)
	Out> {0,1,16,1,3,2,1,1,1,1,508848,3,1,2,1,2,2};
The first 10 terms of this continued fraction correspond to the correct continued fraction for the original rational number.
	In> NearRational(x)
	Out> 218/231;
This function found a different rational number closeby because the precision was not high enough.
	In> NearRational(x, 10)
	Out> 956/1013;

*SEE ContFrac, ContFracList, Rationalize

*CMD Decimal --- decimal representation of a rational
*STD
*CALL
	Decimal(frac)

*PARMS

{frac} -- a rational number

*DESC

This function returns the infinite decimal representation of a
rational number {frac}.  It returns a list, with the first element
being the number before the decimal point and the last element the
sequence of digits that will repeat forever. All the intermediate list
elements are the initial digits before the period sets in.

*E.G.

	In> Decimal(1/22)
	Out> {0,0,{4,5}};
	In> N(1/22,30)
	Out> 0.045454545454545454545454545454;

*SEE N

*CMD TruncRadian --- remainder modulo $2*Pi$
*STD
*CALL
	TruncRadian(r)

*PARMS

{r} -- a number

*DESC

{TruncRadian} calculates $Mod(r,2*Pi)$, returning a value between $0$
and $2*Pi$. This function is used in the trigonometry functions, just
before doing a numerical calculation using a Taylor series. It greatly
speeds up the calculation if the value passed is a large number.

The library uses the formula
$$TruncRadian(r) = r - Floor( r/(2*Pi) )*2*Pi$$,
where $r$ and $2*Pi$ are calculated with twice the precision used in the
environment to make sure there is no rounding error in the significant
digits.

*E.G.

	In> 2*Pi()
	Out> 6.283185307;
	In> TruncRadian(6.28)
	Out> 6.28;
	In> TruncRadian(6.29)
	Out> 0.0068146929;

*SEE Sin, Cos, Tan

*CMD Floor --- round a number downwards
*STD
*CALL
	Floor(x)

*PARMS

{x} -- a number

*DESC

This function returns the largest integer smaller than "x".

*E.G.

	In> Floor(1.1)
	Out> 1;
	In> Floor(-1.1)
	Out> -2;

*SEE Ceil, Round

*CMD Ceil --- round a number upwards
*STD
*CALL
	Ceil(x)

*PARMS

{x} -- a number

*DESC

This function returns the smallest integer larger than "x".

*E.G.

	In> Ceil(1.1)
	Out> 2;
	In> Ceil(-1.1)
	Out> -1;

*SEE Floor, Round

*CMD Round --- round a number to the nearest integer
*STD
*CALL
	Round(x)

*PARMS

{x} -- a number

*DESC

This function returns the integer closest to "x". Half-integers
(i.e. numbers of the form $n + 0.5$, with $n$ an integer) are
rounded upwards.

*E.G.

	In> Round(1.49)
	Out> 1;
	In> Round(1.51)
	Out> 2;
	In> Round(-1.49)
	Out> -1;
	In> Round(-1.51)
	Out> -2;

*SEE Floor, Ceil

*CMD Pslq --- search for integer relations between reals
*STD
*CALL
	Pslq(xlist,precision)

*PARMS

{xlist} -- list of numbers

{precision} -- required number of digits precision of calculation

*DESC

This function is an integer relation detection algorithm. This means
that, given the numbers $x[i]$ in the list "xlist", it tries
to find integer coefficients $a[i]$ such that
$a[1]*x[1]$ + ... + $a[n]*x[n] = 0$.
The list of integer coefficients is returned.

The numbers in "xlist" must evaluate to floating point numbers if
the {N} operator is applied on them.

*EG

	In> Pslq({ 2*Pi+3*Exp(1) , Pi , Exp(1) },20)
	Out> {1,-2,-3};

Note: in this example the system detects correctly that
$1 * (2*Pi+3*e) + (-2) * Pi + (-3) * e = 0$.

*SEE N
