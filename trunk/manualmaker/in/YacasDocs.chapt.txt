		Preparing and maintaining Yacas documentation

	    Introduction

*A documentation
Yacas documentation in HTML and PS/PDF formats is generated by Yacas scripts from Yacas source files. However, it is cumbersome to write those source files in the Yacas language. The scripts {txt2yacasdoc.pl},
{book2TeX.sh}, {book2ys.sh}
makes it possible to create and maintain the documentation in an easy-to-read form.

The "source" form of all documentation is maintained in a special plain text format. The format is such that it is clearly readable without any processing and is easy to edit. To compile the documents, the system processes the plain text docs with a script to prepare Yacas-language files and then runs other scripts to produce the final documentation in HTML and other formats.

The source text must be formatted in a certain fashion to delimit sections, code examples, and so on, but the format is easy enough to enter in a plain text editor. Text is marked up mostly by TAB characters, spaces, and asterisks "{*}" at the beginning of a line. The script {txt2yacasdoc.pl} converts this markup into Yacas code.

	    Organization of the Yacas documentation

*A documentation!organization
All documentation source files are kept in the subdirectory {manualmaker/in}.
During compilation, Yacas language files as well as HTML, $LaTeX$ and PS/PDF
files are automatically generated in the {manualmaker} subdirectory.
Contributors should only need to edit files in {manualmaker/in}.

Currently, documentation consists of five "books" (introductory tutorial,
programming tutorial, miscellaneous essays, user's reference manual, and
programmer's reference manual). The first three books are meant as stand-alone
texts, while the last two are "reference" books and are meant to be used
together. The Yacas {Help()} command will show a reference article from either
of the two reference books.

Books may be divided into "chapters", "sections" and "subsections". Reference
documentation contains each command description in a separate "section" which
is marked by a special {*CMD} label (see below). 

Stand-alone books are free-form, but reference books must be written with a
certain template that allows online hyperlinking. The file
{manualmaker/in/dummies} is an example template for a reference manual section.

At the beginning of each book there <i>must</i> be a book title and a short book description (labeled {*BLURB}) which does not appear in printed documentation but only in the HTML top-level book index.

At the beginning of each chapter there may be a "chapter introduction" labeled
{*INTRO} which is also a short description of the contents of that chapter. It
may be one paragraph only. Note that the chapter introduction is only really
useful for the HTML reference manual because it is the text that appears at the very top
of a reference manual section. In the HTML version of reference docs, each
chapter contains a list of all functions described in it, and this list goes
right after the first paragraph of "chapter intro". For the printed (PS/PDF) documentation the "chapter intro" is indistinguishable from any other text.

	    Formatting of source text files

*A documentation!plain text markup
Formatting of source text files uses TAB symbols; if your editor does not support them and converts them to spaces, you should convert the results back to contain real TAB symbols using the standard Unix {unexpand} utility or a custom perl script.

You may want to examine the source of this file ({manualmaker/} {in/}
{YacasDocs.chapt.txt}) to see how various features of the markup are used.
Currently the following markup is implemented:

*	Paragraphs are separated by blank lines (lines consisting of space or TAB characters or empty). Several blank lines next to each other are equivalent to one. However, TAB-indented blank lines inside a code example (see below) do not create another paragraph.

*	Book heading is quadruple TAB indented. Chapter heading is triple TAB indented. Section heading is double TAB indented. Subsection heading is indented by a TAB and 4 spaces. Headings must be within one line (but that line can be as long as needed).

*	Sample code is single TAB indented, for example:
	In> 1+2;
	
	Out> 3;
Note that empty lines in a single sample code block must be also TAB indented
or else the sample code block will be split into several sample code
paragraphs. Text immediately following a sample code block will not be made
into a separate paragraph (this currently affects paragraph indentation in
printed docs). A sample code block may be separated from the text that follows
it by an empty line.

*	If a section or chapter heading immediately follows a sample code block
(i.e. when it is the last code sample in the previous section), they
<i>must</i> be separated from the headings by an empty (unindented) line. The
reason for this is that the script will assume that everything which is at
least single-TAB indented (up to a separation between paragraphs) belongs to
one sample code block. This makes it easier to enter multiply indented sample
code: a double-TAB indentation inside a sample code block will not start a new
section. For example:
	While(x<0) [
		x:=x+1;
		Write(x);
	];

*	Ordinary text must not be indented at all. Line length is arbitrary and
linebreaks
inside
a
paragraph
are of no significance to the resulting documentation. The first symbol on a
line should not be an asterisk ({*}) because it is reserved for markup
purposes. In most cases it is okay to have an asterisk in the first position,
though, as long as it does not conflict with a markup label.
All markup labels start with an asterisk "{*}" in the first position on
a line, followed by an uppercase keyword, e.g. {*CMD} or *{INCLUDE}.
Some markup labels have arguments that follow them, and some take an
entire following paragraph as an argument and must be terminated by a
blank line.

*	Itemized text is marked by "*" in the first position, followed by TAB. For example:

	*	Item
	*	Another item

*	Enumerated text is marked by "*" followed by TAB, number and period. The number used in the source text is irrelevant because the enumerated environment of the final document will introduce its own counter. For example:
	*	0. First item
	*	0. Second item
This will produce:
*	0. First item
*	0. Second item

Note that the text of an item continues until the next itemized line is given or until end of paragraph (does not have to be all in one line).

Nesting of enumerated or itemized environments is not supported, except for fringe cases of nesting just one itemized list at the very end of an enumerated list or vice versa.

Enumerated environment is currently only implemented in $LaTeX$ docs; HTML docs render them as itemized.

*	Emphasized text (<i>italics</i>) should be surrounded by {<i>}
{</i>}. Note that the whole emphasized fragment of text must be located within a single line, or else it will not be emphasized.

*	{Typewriter font} text is surrounded by braces {{}}. The typewriter font
fragment must be within a single line and may contain no more than four nested
sets of {{}} inside. This is hopefully enough for our documentation. A
limitation of this markup is that there is no way to put a single brace in text
alone without a matching brace. This would be okay for HTML docs but it breaks
$LaTeX$ docs because braces are special in $TeX$ and because Serge was too lazy
to implement a real parser.

*	Web hyperlinks are surrounded by {<*}
{*>}. Text of the link must begin with {http://} or {ftp://}. Alternatively, a hyperlink with anchored text is made by the markup {<*}
<i>anchored text</i>{|}<i>Web URL</i>{*>}. For example:
	<*http://host.net/file.html#anchor*>
or
	<*click here|somewebpage.html*>

*A documentation!equations
*	Mathematical expressions should be typed in Yacas syntax (not in $TeX$
notation) and surrounded by dollar signs. Both delimiting dollar signs
<i>must</i> be within one line of text. For example: {$}
{x^2 + y^2 != z^2 $}
produces $x^2+y^2 != z^2$. Double dollar signs will denote a displayed
equation, like in $TeX$; both pairs of dollar signs should still be within one
line.

There is a special feature for displayed equations:
Any punctuation immediately following the second pair of dollar signs will be displayed on the same line. (This is used to get around the limitation of mathematical expressions that cannot end with a comma or a period or with another punctuation mark.) For example, the formula "{$}{$}{x^2/2}{$}{$,}" will produce $$x^2/2$$, with the comma on the same line. A formula such as "{$}x+1;{$}" will generate an error; the semicolon should be moved out of the dollar signs.

As special exceptions, one can enter the symbols "$TeX$" and "$LaTeX$"
as if they are Yacas symbols, i.e. "{$T}{eX$}" produces "$TeX$". One can also enter the name {Yacas} as "{{Yacas}}".

Mathematical expressions <i>must</i> be valid Yacas expressions, with no unbalanced
parentheses, no undefined infix operators, no hanging periods and so on, or else the Yacas script that
formats the docs will fail! (This limits the scope of mathematical formulae but
is hopefully not critical.)

Currently, when creating online HTML documentation,
mathematics is kept in Yacas notation and set in boldface font. (This may
change in the future.) Of course, $LaTeX$ typesets printed documentation with
correct mathematical symbols.

Another feature of the $LaTeX$ exporter is that it will try to show all
functions and infix operators according to their mathematical meaning, and if
no such meaning is defined in Yacas, then it will show them exactly as they are
written in Yacas. For infix operators to work, they have to be declared in the
standard library, or else an error will occur when processing the manual.

For
example, Yacas operators {=} and {==} are both represented by and equals sign
"=", the operator {:=} becomes "identically equal" ($a:=b$), and the cosmetic
operators {<>} and {<=>} become $a<>b$ and $a<=>b$. But you cannot use an
undefined infix operator such as "{:=*}".

*	To include contents of another document, use the {*INCLUDE} directive at
the beginning of a line, e.g.

	*INCLUDE ../essays/howto.chapt

Note that the included document must be a Yacas-language file, not a {.txt} file. (This will become the {IncludeFile()} call in the Yacas document -- an alias to {Load()}.)

*	Comments may be introduced by the label {*REM}. The line and the paragraph of text following {*REM} will be omitted from the documentation. An empty line should separate the {*REM} block from other text. For example,
	*REM this is
	a comment
	
	(documentation text continues)

*	Footnotes may be entered as a line containing the label {*FOOT}. Footnote text must be within one line (because a footnote does not necessarily break a paragraph).

For example, the text
	*FOOT This is an example footnote
generates the footnote
*FOOT This is an example footnote.

*	Yacas expressions may be evaluated inline by using the directive {*EVAL}. Anything that follows {*EVAL} until the end of the line will be evaluated as a Yacas expression. If this expression prints something (e.g. via {Write}), the output will be inserted into the text (as is). The resulting value of the expression will also be inserted, unless the expression evaluates to {True}. The Yacas expression <i>must</i> be on one line.

For example,
	*EVAL "Yacas version: " : Version()
will insert the string `
*EVAL "Yacas version: " : Version()
' into the manual.

	    Formatting text for the reference manual

*A documentation!reference manual markup
The formatting explained in the previous section is enough to create most of the user guide and tutorial documentation. The script {txt2yacasdoc.pl} also implements some additional markup features to help create the reference manual.

A typical reference manual subsection documenting a certain function may look like this in plain text:

	*CMD PrintList --- print list with padding
	*STD
	*CALL
		{PrintList}(list)
		{PrintList}(list, padding);
	
	*PARMS
	{list} -- a list to be printed
	
	{padding} -- (optional) a string
	
	*DESC
	Prints {list} and inserts the {padding} ...
	
	*E.G.
	
		In> PrintList({a,b,{c, d}}, " .. ")
		Out> " a ..  b .. { c ..  d}";
	
	*SEE Write, WriteString
Compare this with the reference manual section on the function {PrintList} to see how this plain text markup is rendered in the finished documentation.

Notes:
*	Some labels have parameters while other labels do not; labels that do not have parameters must be put alone on a line.
*	The {*STD} label is for functions defined in the standard library and the {*CORE} label is for built-in functions defined in the Yacas core engine. In addition, {*UNIX}, {*MSWIN} and {*MAC} can be used to label Un*x, MS Wind*ws and Macint*sh-specific add-on functions.
*	There must be <i>some</i> whitespace separating a markup label such as {*} and the following text. Either TAB characters or ordinary spaces work equally well.
*	The comma-space combination "{, }" is mandatory in label argument lists (but can have several spaces after a comma). Lists of commands are used by the {*CMD} and {*SEE} labels.
*	Characters {<} and {>} are of special significance to both HTML and $TeX$ and should be always escaped either by braces {{}} or by dollar signs, as appropriate.
*	In the "examples" section, there may be just one example, in which case the alternative label "{*EG}" could be used instead of "{*E.G.}". This will currently generate the word "Example:" instead of "Examples:" in the documentation.
*	In a subsection there may be either one function documented or several at once: for example, it may make sense to document {Sin}, {Cos} and {Tan} together. In this case, all function names should be simply listed in the {*CMD} header, for example:

	*CMD Sin, Cos, Tan --- Trigonometric ...

In addition to these labels, there are the following tags:

*	{*INTRO} to denote a "reference chapter
introduction" corresponding to the {ChapterIntro()} function
*	{*BLURB} for the short book
summary (it enters the HTML book index and the front page of the $LaTeX$ docs)
*	 {*A} to manually
create an HTML anchor in a reference manual section and an index entry in the printed docs (see below for more details on indexing)
*	{*HEAD}
to create a small heading ({Topical()}).
The {*HEAD} tag might be useful for lowest-level headings. For instance,
	*PARMS
results in the same text as
	*HEAD Parameters:

Usage of the {*A} tag currently does not directly affect the appearance
of the HTML docs, since the anchor tags {<a></a>} are invisible. In the
printed $LaTeX$ docs, this tag can be used to manually add index
entries. The {*CMD} tag generates all necessary HTML anchors for
commands in the reference manual, so only non-command index entries
need to be manually entered.

The {*INTRO} and {*BLURB} tags only work for one paragraph. There must be no
empty line between {*INTRO}/{*BLURB} and that paragraph. Also, there must be no
empty line between the "blurb" and the book title (for technical reasons).
There must be one and only one "blurb" paragraph in a "book" and no more than
one "chapter intro" paragraph per chapter.

This markup should be sufficient for creating reference documentation in plain text.

	    Indexing the documentation books

*A documentation!indexing
It is not difficult to automatically generate an alphabetically sorted
index for the books. An "index entry" is a piece of text that does not
appear in the book where it is entered, but instead is printed in the
alphabetical list at the end of the text with the relevant page number.

Currently the following facilities are provided for indexing:

*	1. The label {*CMD} automatically adds index entries for all commands it describes. In this way, the printed reference manual automatically has every documented command listed in the index.
*	2. The label {*A} can be used to add an index entry by hand. An index entry can be any text that is admissible in the documentation (on one line). Preferably it should be something concise and something that users will want to look up and can't easily locate in the table of contents.

After $LaTeX$ generates a "raw" index file {*.idx}, the {makeindex}
utility is used to post-process and sort the index into the {.ind}
file. If you do not have {makeindex} on your system, the book indices
will not be generated.

Note that {makeindex} is not always friendly to special
(non-alphanumeric) characters. For example, it uses the symbol {!} to
separate index topics, which may conflict with Yacas commands. In other
words, document index must be tested and sometimes debugged.

In the HTML docs, the index is currently not generated on a separate
page, although HTML anchors are inserted in the text. The reference
manual uses the HTML anchors to provide online help through the {?}
command.

An index entry may be a "topic" with "subtopics", which usually appears in book indices like this:
	gnus, 51
	   tame, 51
	   wild, 52-341
This effect can be achieved with the {!} topic separator:
	*A gnus
	*A gnus!tame
	*A gnus!wild
This is a special feature of {makeindex}.

Currently, it is possible to include a command or an equation into an index entry, for example,
	*A {InterestingCommand}
	*A calculation of $Sqrt(x)$
But this may sometimes conflict with the topic separator.

	    Summary of mark-up labels

*A documentation!summary of markup
Mark-up labels <i>must</i> appear as first characters on a line. The following mark-up labels are currently defined:


Labels that affect only the current line:

*	{*A} <i>anchor</i> -- insert anchor and index entry
*	{*BOOK} <i>title</i> -- start a book, give title
*	{*EVAL} <i>statement</i> -- evaluate inline as a {Yacas} statement and insert results
*	{*HEAD} <i>heading</i> -- lowest-level heading (lower than subsection)
*	{*FOOT} <i>text</i> -- insert a footnote
*	{*INCLUDE} <i>filename</i> -- include another documentation file

Labels that affect a subsequent paragraph (and must be separated by an empty line from what follows):

*	{*BLURB} -- short summary of the book (must immediately precede the {*BOOK} label)
*	{*INTRO} -- chapter introduction (significant for HTML only)
*	{*REM} -- documentation comment

Special labels for the reference manual that accept several arguments on the same line:

*	{*CMD} or {*FUNC} -- command name and one-line description
*	{*SEE} -- "See also"

Special labels without arguments that generate headings for the reference manual:

*	{*STD} -- "Standard library"
*	{*UNIX} -- "Unix-specific"
*	{*MSWIN} -- "MS Windows-specific"
*	{*MAC} -- "Macintosh-specific"
*	{*CORE} -- "Core function"
*	{*CALL} -- "Calling format"
*	{*PARMS} -- "Parameters"
*	{*DESC} -- "Description"
*	{*E.G.} -- "Examples"
*	{*EG} -- "Example"

	    Debugging the manual

*A documentation!markup debugging
Sometimes the manual compilation {make} or {make texdocs} will break after you edit the plaintext manual sources. This can happen for one of these reasons:
*	1. A math syntax error. You have used a mathematical formula that does not evaluate to a Yacas expression. Unbalanced parentheses, invalid infix operators such as {>-}, or forgotten punctuation inside the formula such as {x+1:} are the most frequent culprits. This will break both HTML and $TeX$ manual formats.
*	2. The HTML format compiles but the $TeX$ does not ({latex} never finishes, i.e. it shows an error message which you do not see because it is redirected to {/dev/null} and waits for your input). This means that the generated $TeX$ code is incorrect. You probably forgot to balance braces {{}} or something more subtle happened.
*	3. Some mark-up which should not be split between lines was
unintentionally split by reformatting paragraphs in a text editor. This will sometimes not break the compilation but will always give undesired results.

In case of a math syntax error, the documentation exporter cannot print the paragraph where the error occurred, but it usually prints the preceding paragraph. Currently, the easiest way to locate the error is to generate the {.tex} output and look at it, e.g.:
	make ref.book.tex; less ref.book.tex
The last line in the {.tex} file must be {\end{document}}. If it is not, then the last portion of the text you see in the {.tex} file is the text directly before the paragraph where the error occurred. Most probably, there is a malformatted math formula in the next paragraph of your plaintext source.

If the last line is  {\end{document}} but {latex} does not finish, you will have to run {latex} by hand, e.g.
	latex ref.book.tex
and look at the error message(s) it prints.

	    Using the script {txt2yacasdoc.pl}

The script {txt2yacasdoc.pl} is used to transform plain text markup into the
Yacas language. The script acts as a stream filter:

	perl txt2yacasdoc.pl < file.txt \
	  > file.chapt

In this example, {file.txt} contains some formatted plain text (source text) and the resulting file {file.chapt} will be produced in Yacas-language documentation format.

There is a single option for {txt2yacasdoc}:

	perl txt2yacasdoc.pl -debug < file.txt \
	  > file.chapt
This option is to be used for debugging, i.e. when the resulting file does not
compile in Yacas. The effect of this option is to introduce more breaks
between text strings in the generated file, so that the {Text()} function is
called more often. It is then easier to locate the source of the problem in the
Yacas-language file (Yacas will tell you the last line in the Yacas-language
file at which a syntax error occurred). This option is largely obsolete because
the {Text()} function is called frequently enough by default.
See below for hints about finding syntax errors in documentation when the manual does not compile.


	    {book2TeX}: preparing typeset documentation

The script {book2TeX.sh} prepares a $TeX$ file out of a Yacas-language documentation book. Usage is similar to {book2txt.sh}, except that only one file is processed at a time and the file must be a "book", not just a "chapter". For example:
	book2TeX.sh intro.book intro.book.tex
will create a $LaTeX$-formatted version of the introductory tutorial.
The $LaTeX$ file can be processed with standard tools, for example
	latex intro.book.tex
	dvips -o intro.book.ps intro.book dvi
will prepare a Postscript version, while
	pdflatex intro.book.tex
will prepare a PDF version.

To generate printed docs, it is necessary to run {latex} (at least)
three times in a row. This is because at first {latex} does not know
how much space will be taken by the table of contents and the index, so
the page numbers are all off by a few pages. Only on the second run
{latex} generates correct page numbers for the TOC (the {.aux} file)
and for the index (the {.idx} file). After this the index file has to
be processed by the {makeindex} routine to sort it, and the third
{latex} run is needed to actually insert the correct TOC and the
processed index into the final document.

The shell commands in {book2txt.sh} execute the following Yacas commands:
	Use("book2TeX.ys");
	ToFile("file.chapt.tex")
	  Load("file.chapt");
This requires that the Yacas script {book2TeX.ys} be available in the current directory. The shell script {book2TeX.sh} assumes that {book2TeX.ys} is stored in the same directory as {book2TeX.sh} and that the Yacas executable is available in the directory {../src/}. Alternatively, the command line of the Yacas executable can be specified by the {-run} option. For example, the {Makefile} runs {book2TeX.sh} like this:
	book2TeX.sh -run "yacas-dir/src/yacas --rootdir
	  yacas-dir/scripts" file.book file.book.tex
Note that the entire Yacas command line is given in quotes.

*A documentation!$TeX$ problems
Not all features of Yacas documentation are compatible with $TeX$ typesetting. To prevent errors, documentation source should avoid certain things. In general, it is a good idea to check the typeset appearance of documentation, since it helps detect errors.

For example, the symbols {%}, {{ }}, {< >}, {#}, {\}, {_} and {&} are special to $TeX$. They should not normally be used in plain text; it is okay to use them in "typerwriter" text (within braces {{}}) or code samples -- but <i>not</i> in section or chapter heads, because it makes it difficult to export to $TeX$ correctly. $TeX$ commands may be entered but will not be correctly rendered in HTML online documentation.

*A documentation!lines too wide
Sometimes fixed-font text will hang over the right edge of the printed
page. A workaround is to break the fixed-font text into shorter
fragments or to rephrase the text.

Another concern is that code examples (TAB-indented blocks) are typeset
in a fixed-width font and may not fit into the width of the page. To
avoid this, the lines in the code examples should not be longer than
about 50 characters.

The current implementation uses a "report" style which allows chapters, sections, subsections and includes an automatically generated table of contents and an index.
The standard 10 point font and two-column format are used to save space (and trees).

Some complicated mathematical expressions may not correctly render in $TeX$.
This is because Yacas uses its internal function {TeXForm()} to transform Yacas
expressions to $TeX$.  Mathematical expressions are entered in the plain text
documentation source using Yacas syntax, then transformed to a special
non-evaluating call {TeXMath()} in the Yacas-language documentation, which
formats into HTML using a {Write()} call or into $TeX$ using a {TeXForm()}
call, as necessary. Testing should be performed on documentation before
releasing it. The most stringent limitation is that the expression between
dollar signs should evaluate in Yacas (preferably to itself) and not cause syntax
errors. In case of doubt, check that the expression evaluates without errors
and then try to use {TeXForm} on that expression and see if that evaluates
without errors as well. For example, expressions such as {x=+1} will cause a syntax error and this will break the compilation of the manual (both HTML and $TeX$).

	    {book2ys}: extracting Yacas code from books

*A documentation!embedded code
{book2ys.sh} is a shell script that extracts Yacas code examples from a documentation chapter into a separate file. Usage is similar to {book2TeX.sh}. For example, the benchmarking test code {wester.yts} can be automatically extracted from the corresponding essay chapter by the command
	sh ../manmake/book2ys.sh wester-1994.chapt
After this command, the file {wester-1994.ys} is created. Note that {wester-1994.chapt} is in Yacas language and is itself a generated file.

Using this script, one can write documentation and code together, a la "literate programming".

To prepare a documentation chapter in such a way that code extraction is possible, one only needs to make sure that all code examples in the chapter will become a correct sequence of Yacas expressions when cut out and written sequentially into a file. So, for instance, semicolons at the end of each statement are required. The script {book2ys} will <i>not</i> export example Yacas session code with "{In>}" and "{Out>}" prompts but it will export all other example code.

See the source file {wester-1994.chapt.txt} to get a feeling of how the source documentation is formatted to allow completely automatic code extraction. Note that the printed documentation will be in twocolumn format, and therefore it is necessary to split lines that are too long.

	    {book2txt}: Conversion of existing documentation to plain text

(Note: as of version 1.0.49, all Yacas documentation is converted to plaintext format. This section is left for reference only.)

Currently, most but not all of the Yacas documentation markup functionality is
implemented in the simple plaintext filter; also, documentation includes some
extra HTML files. However, almost all of the reasonable markup needed to write
documentation is present. Therefore it is possible to maintain most of the
documentation in the plain text format described above. To convert existing
Yacas documentation back to the plain text format, a script
{book2txt.ys}/{book2txt.sh} can be used.

By using a command such as
	book2txt.sh file.chapt
one can create a source text file {file.chapt.txt} corresponding to the Yacas documentation file {file.chapt}. For example:

	12:51pm scriabin> book2txt.sh intro.book
	[editvi.ys] [gnuplot.ys] 
	True;
	Out> True;
	Quitting...
	File 'intro.book.txt' was created.
	12:51pm scriabin>

In the above example, the shell commands in {book2txt.sh} executed the following Yacas commands,
	Use("book2txt.ys");
	ToFile("file.chapt.txt")
	  Load("file.chapt");
This requires that the Yacas script {book2txt.ys} be available in the current directory. The shell script {book2txt.sh} assumes that {book2txt.ys} is stored in the same directory as {book2txt.sh}.

Of course, it is possible that some features of Yacas documentation were not implemented in the script and in that case the resulting file must be edited by hand. But the purpose of the {book2txt} script is exactly this: to make a plain text source file to be edited and maintained.

Several files can be converted at once, for example:
	book2txt.sh f1.chapt f2.chapt file3.book
Each file is processed by an independent Yacas session. Any errors of processing are printed on the screen.

