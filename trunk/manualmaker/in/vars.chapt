
Chapter() "Variables";

CmdDescription(":=", "Assignment");
StandardLib();

Topical() "Calling sequence";
Text() "
var := exp <br>
{var, ...} := {exp, ...} <br>
var[i] := exp <br>
fn(param, ...) := exp   (all prec. 1000)";

Topical() "Parameters";
Text() "
var - variable which should be assigned <br>
exp - expression to assign to the variable <br>
i - index (can be integer or string) <br>
fn - name of a function to define <br>
param - argument of the function \"fn\"";

Topical() "Description";
Text() "
As one can see above, the " : HtmlTerm(":=") : " operator can be used
in a number of ways. In all cases, some sort of assignment takes
place.
<p> </p>
The first form is the most basic one. It evaluates the expression on
the right-hand side and assigns it to the variable named on the
left-hand side. The left-hand side is not evaluated. The evaluated
expression is also returned.
<p> </p>
The second form is a small extension, which allows one to do multiple
assignments. The first entry in the list on the right-hand side is
assigned to the first variable mentionedon the left-hand side, the
second entry on the right-hand side to the second variable on the
left-hand side, etcetera. The list on the right-hand side must have at
least as many entries as the list on the left-hand side. Any excess
entries are silently ignored. The result of the expression is the list
of values that have been assigned.
<p> </p>
The third form allows one to change an entry in the list. If the index
\"i\" is an integer, the \"i\"-th entry in the list is changed to the
expression on the right-hand side. It is assumed that the length of
the list is at least \"i\". If the index \"i\" is a string, then
\"var\" is considered to be an associative list (sometimes called hash
table), and the key \"i\" is paired with the value \"exp\". In both
cases, the right-hand side is evaluated before the assigment and the
result of the assignment is " : HtmlTerm("True") : ".
<p> </p>
The last form defines a function. For example, the assignment " :
HtmlTerm("f(x) := x^2") : " removes all rules associated with " :
HtmlTerm("f(x)") : " and defines the rule " : HtmlTerm("f(_x) <--
x^2") : ". Note that the left-hand side may take a different form if
\"f\" is defined to be a prefix, infix or bodied function. This case
is a bit special since the right-hand side is not evaluated
immediately, but only if the function \"f\" is used. If this takes
time, it may be better to force an immediate evaluation with " :
HtmlTerm("Eval") : " (see the last example)."; 

Topical() "Examples";
Text() "
A simple assignment:" : HtmlCommand("
In> a := Sin(x) + 3;
Out> Sin(x)+3;
In> a;
Out> Sin(x)+3;") :
"<p> </p>
Multiple assignments:" : HtmlCommand("
In> {a,b,c} := {1,2,3};
Out> {1,2,3};
In> a;
Out> 1;
In> b+c;
Out> 5;") : 
"<p> </p>
Assignment to a list:" : HtmlCommand("
In> xs := { 1,2,3,4,5 };
Out> {1,2,3,4,5};
In> xs[3] := 15;
Out> True;
In> xs;
Out> {1,2,15,4,5};") :
"<p> </p>
Building an associative list:" : HtmlCommand("
In> alist := {};
Out> {};
In> alist[\"cherry\"] := \"red\";
Out> True;
In> alist[\"banana\"] := \"yellow\";
Out> True;
In> alist[\"cherry\"];
Out> \"red\";
In> alist;
Out> {{\"banana\",\"yellow\"},{\"cherry\",\"red\"}};") :
"<p> </p>
Defining a function:" : HtmlCommand("
In> f(x) := x^2;
Out> True;
In> f(3);
Out> 9;
In> f(Sin(a));
Out> Sin(a)^2;

In> Infix(\"*&*\",10);
Out> True;
In> x1 *&* x2 := x1/x2 + x2/x1; 
Out> True;
In> Sin(a) *&* Cos(a);
Out> Tan(1)+Cos(1)/Sin(1);
In> Clear(a);
Out> True;
In> Sin(a) *&* Exp(a);
Out> Sin(a)/Exp(a)+Exp(a)/Sin(a);") : "
<p> </p>
In the following example, it may take some time to compute the Taylor
expansion. This has to be done every time the function " :
HtmlTerm("f") : " is called." : HtmlCommand("
In> f(a) := Taylor(x,0,25) Sin(x);
Out> True;
In> f(1);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;
In> f(2);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;") :
"The remedy is to evaluate the Taylor expansion immediately. Now the
expansion is computed only once." : HtmlCommand("
In> f(a) := Eval(Taylor(x,0,25) Sin(x));
Out> True;
In> f(1);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;
In> f(2);
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880-x^11/39916800+x^13/6227020800-x^15/1307
674368000+x^17/355687428096000-x^19/121645100408832000+x^21/51090942171709440000
-x^23/25852016738884976640000+x^25/15511210043330985984000000;");

Topical() "See Also";
SeeAlso({"Set", "Clear", "[]", "Rule", "Infix", "Eval"});



CmdDescription("Set", "Assignment");
BuiltIn();

Topical() "Calling Sequence";
Text() "Set(var, exp)";

Topical() "Parameters";
Text() "
var - variable which should be assigned <br>
exp - expression to assign to the variable";

Topical() "Description";
Text() "
The expression \"exp\" is evaluated and assigned it to the variable
named \"var\". The first argument is not evaluated. The value True
is returned.
<p> </p>
The statement " : HtmlTerm("Set(var, exp)") : " is equivalent to " :
HtmlTerm("var := exp") : ", but the " : HtmlTerm(":=") : " operator
has more uses like changing individual entries in a list.";

Topical() "Examples";
Text() HtmlCommand("
In> Set(a, Sin(x)+3);
Out> True;
In> a;
Out> Sin(x)+3;");

Topical() "See Also";
SeeAlso({"Clear", ":="});



CmdDescription("Clear", "Undo an assignment");
BuiltIn();

Topical() "Calling Sequence";
Text() "Clear(var, ...)";

Topical() "Parameters";
Text() "var - name of variable to be cleared";

Topical() "Description";
Text() "
All assignments made to the variables listed as arguments are
undone. From now on, all these variables remain unevaluated (until a
subsequent assignment is made). The result of the expression is
True."; 

Topical() "Examples";
Text() HtmlCommand("
In> a := 5;
Out> 5;
In> a^2;
Out> 25;

In> Clear(a);
Out> True;
In> a^2;
Out> a^2;");

Topical() "See Also";
SeeAlso({"Set", ":="});



CmDDescription("Local", "Declare local variables");
BuiltIn();

Topical() "Calling Sequence";
Text() "Local(var, ...)";

Topical() "Parameters";
Text() "var - name of variable to be declared as local";

Topical() "Description";
Text() "
All variables in the argument list are declared as local
variables. The arguments are not evaluated. The value True is
returned.
<p> </p>
By default, all variables in Yacas are global. This means that the
variable has the same value everywhere. But sometimes it is useful to
have a private copy of some variable, either to prevent the outside
world from changing it or to prevent accidental changes to the outside
world. This can be achieved by declaring the variable local. Now only
expressions within the " : HtmlTerm("Prog") : " block (or its
syntactic equivalent, the " : HtmlTerm("[  ]") : " block) can access
and change it. Functions called within this block cannot access the
local copy unless this is specifically allowed with " :
HtmlTerm("UnFence") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> a := 3;
Out> 3;

In> [ a := 4; a; ];
Out> 4;
In> a;
Out> 4;

In> [ Local(a); a := 5; a; ];
Out> 5;
In> a;
Out> 4;") : "
In the first block, " : HtmlTerm("a") : " is not declared local and
hence defaults to be a global variable. Indeed, changing the variable
inside the block also changes the value of " : HtmlTerm("a") : "
outside the block. However, in the second block " : HtmlTerm("a") : "
is defined to be local and now the value outside the block stays the
same, even though " : HtmlTerm("a") : " is assigned the value 5 inside
the block.";

Topical() "See Also";
SeeAlso({"LocalSymbols", "Prog", "[]", "UnFence"});



CmdDescription("++", "Increment variable");
StandardLib();

Topical() "Calling Sequence";
Text() "var++";

Topical() "Parameters";
Text() "var - variable to increment";

Topical() "Description";
Text() "
The variable with name \"var\" is incremented, i.e. the number 1 is
added to it. The expression " : HtmlTerm("x++") : " is equivalent to
the assignment " : HtmlTerm("x := x + 1") : ", except that the
assignment returns the new value of " : HtmlTerm("x") : " while " :
HtmlTerm("x++") : " always returns true. In this respect, Yacas' " :
HtmlTerm("++") : " differs from the corresponding operator in the
programming language C.";

Topical() "Examples";
Text() HtmlCommand("
In> x := 5;
Out> 5;
In> x++;
Out> True;
In> x;
Out> 6;");

Topical() "See Also";
SeeAlso({"--", ":="});



CmdDescription("++", "Decrement variable");
StandardLib();

Topical() "Calling Sequence";
Text() "var--";

Topical() "Parameters";
Text() "var - variable to decrement";

Topical() "Description";
Text() "
The variable with name \"var\" is decremented, i.e. the number 1 is
subtracted from it. The expression " : HtmlTerm("x--") : " is
equivalent to the assignment " : HtmlTerm("x := x - 1") : ", except
that the assignment returns the new value of " : HtmlTerm("x") : "
while " : HtmlTerm("x--") : " always returns true. In this respect,
Yacas' " : HtmlTerm("--") : " differs from the corresponding operator
in the programming language C.";

Topical() "Examples";
Text() HtmlCommand("
In> x := 5;
Out> 5;
In> x--;
Out> True;
In> x;
Out> 4;");

Topical() "See Also";
SeeAlso({"++", ":="});



CmdDescription("Object", "Create an incomplete type");
StandardLib();

Topical() "Calling Sequence";
Text() "Object(\"pred\", exp)";

Topical() "Parameters";
Text() "
pred - name of the predicate to apply <br>
exp - expression on which \"pred\" should be applied";

Topical() "Description";
Text() "
This function returns \"obj\" as soon as \"pred\" returns " :
HtmlTerm("True") : " when applied on \"obj\". This is used to declare
so-called incomplete types.";

Topical() "Examples";
Text() HtmlCommand("
In> a := Object(\"IsNumber\", x);
Out> Object(\"IsNumber\",x);
In> Eval(a);
Out> Object(\"IsNumber\",x);
In> x := 5;
Out> 5;
In> Eval(a);
Out> 5;");

Topical() "See Also";
SeeAlso({"IsNonObject"});



CmdDescription("LazyGlobal", "Global variable is to be evaluated lazily");
BuiltIn();
Topical()"Calling Sequence";
Text()"LazyGlobal(var)";

Topical()"Parameters";
Text()"var - variable (held argument)";

Topical()"Description";
Text()"LazyGlobal enforces that a global variable will re-evaluate
when used. The global variable needs to exist for this function
to work. Also, this functionality doesn't survive if Clear(var)
is called afterwards. <P>  </P>

Places where this is used include the global variables % and I.<P>  </P>

The use of lazy in the name stems from the concept of lazy evaluation.
The object the global variable is bound to will only be evaluated when
called. The LazyGlobal property only holds once: after that, the result
of evaluation is stored in the global variable, and it won't be
reevaluated again: 

":HtmlCommand(
"In> a:=Hold(Taylor(x,0,30)Sin(x))
Out> Taylor(x,0,30)Sin(x);
In> LazyGlobal(a)
"):"

Then the first time you call a it evaluates Taylor(...) and assigns the result to a. The next time
you call a it immediately returns the result.
LazyGlobal is called for \"%\" each time \"%\" changes.";

Topical()"Examples";
Text()
HtmlCommand(
"In> a:=Hold(2+3)
Out> 2+3;
In> a
Out> 2+3;
In> LazyGlobal(a)
Out> True;
In> a
Out> 5;");

Topical()"See Also"; 
SeeAlso({"Set","Clear","Local","%","I"});



CmdDescription("UniqueConstant", "Create a unique identifier");
StandardLib();

Topical()"Calling Sequence";
Text() "UniqueConstant()";

Topical() "Parameters";
Text() "none";

Topical()"Description";
Text()"This function returns a unique constant atom each time you call
it. The atom starts with a C character, and a unique number is
appended to it.";

Topical()"Examples";
Text()
HtmlCommand("
In> UniqueConstant() 
Out> C9 
In>  UniqueConstant() 
Out> C10 ");

Topical() "See Also";
SeeAlso({"LocalSymbols"});


