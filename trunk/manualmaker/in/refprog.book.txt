*BLURB 
A reference of functions accessible from within Yacas.
This reference contains all functions that might be useful
when programming in Yacas.
				Yacas programmer's function reference

			Programming

*INTRO This chapter describes functions useful for writing Yacas scripts.

*CMD	/*, */, // --- comments
*CORE
*CALL
	/* comment */
	// comment

*DESC

Introduce a comment block in a source file, similar to C++ comments.
{//} makes everything until the end of the line a comment, while {/*} and {*/} may delimit a multi-line comment.

*E.G.

	a+b; // get result
	a + /* add them */ b;

*CMD Prog, [, ] --- block of statements
*CORE
*CALL
	Prog(statement1, statement2, ...)
	[ statement1; statement2; ... ]

*PARMS

statement1, statement2 -- expressions

*DESC

The {Prog()} and the {[ ... ]} constuct have the same effect: they evaluate all
arguments in order and return the result of the last evaluated expression.

{Prog(a,b);} is the same as typing {[a;b;];} and is very useful for writing out
function bodies. The {[...]} construct is a syntactically nicer version of the
{Prog()} call; it is converted into {Prog(...)} during the parsing stage.



*CMD Check --- report errors
*CORE
*CALL
	Check(predicate,"error text")

*PARMS

{predicate} -- expression returning {True} or {False}

*DESC
If {predicate} doesn't evaluate to {True},
then current operation will be stopped, and execution
will jump right back to the command line, showing
{error text}. Use this to assure that some condition
is met during evaluation of expressions (guarding
against internal errors).

*CMD Bodied, Infix, Postfix, Prefix --- define function syntax
*CORE
*CALL
	Bodied("op", precedence)
	Infix("op")
	Infix("op", precedence)
	Postfix("op")
	Prefix("op")
	Prefix("op", precedence)

*PARMS

{"op"} -- string, the name of a function

{precedence} -- nonnegative integer (evaluated)

*DESC

Declares a function for the parser to understand as a bodied, infix, postfix,
or prefix operator. Function name can be any string but meaningful usage would
require it to be either made up entirely of letters or entirely of non-letter
characters (such as "+", ":" etc.). Precedence can be specified (will be 0 by
default).

*E.G.
	In> YY x := x+1;
	CommandLine(1) : Error parsing expression
	
	In> Prefix("YY", 2)
	Out> True;
	In> YY x := x+1;
	Out> True;
	In> YY YY 2*3
	Out> 12;
	In> Infix("##", 5)
	Out> True;
	In> a ## b ## c
	Out> a##b##c;

*SEE IsBodied, OpPrecedence



*CMD IsBodied, IsInfix, IsPostfix, IsPrefix --- check for function syntax
*CORE
*CALL
	IsBodied("op")
	IsInfix("op")
	IsPostfix("op")
	IsPrefix("op")

*PARMS

{"op"} -- string, the name of a function

*DESC

Check whether the function with given name "op" has been declared as a
"bodied", infix, postfix, or prefix operator, and  return {True} or {False}.

*E.G.

	In> IsInfix("+");
	Out> True;
	In> IsBodied("While");
	Out> True;
	In> IsBodied("Sin");
	Out> False;

*SEE Bodied, OpPrecedence

*CMD OpPrecedence, OpLeftPrecedence, OpRightPrecedence --- get operator precedence
*CORE
*CALL
	OpPrecedence("op")
	OpLeftPrecedence("op")
	OpRightPrecedence("op")

*PARMS

{"op"} -- string, the name of a function

*DESC

Returns the precedence of the function named "op" which should have been declared as a bodied function or an infix, postfix, or prefix operator. Generates an error message if the string str does not represent a type of function that can have precedence.

For infix operators, right precedence can differ from left precedence. Bodied functions and prefix operators cannot have left precedence, while postfix operators cannot have right precedence; for these operators, there is only one value of precedence.

*E.G.
	In> OpPrecedence("+")
	Out> 6;
	In> OpLeftPrecedence("!")
	Out> 0;



*CMD RightAssociative --- declare associativity
*CORE
*CALL
	RightAssociative("op")

*PARMS

{"op"} -- string, the name of a function

*DESC
This makes the operator right-associative. Example:
	RightAssociative("*")
would make multiplication right-associative. Take care not to abuse this
function, because the reverse, making an infix operator left-associative, is
not implemented. (All infix operators are by default left-associative until
they are declared to be right-associative.)

*SEE OpPrecedence


*CMD LeftPrecedence, RightPrecedence --- set operator precedence
*CORE
*CALL
	LeftPrecedence("op",precedence)
	RightPrecedence("op",precedence)

*PARMS

{"op"} -- string, the name of a function

{precedence} -- nonnegative integer

*DESC

{"op"} should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display expressions like {a-(b-c)}
correctly. Thus, {a+b+c} is the same as {a+(b+c)}, but {a-(b-c)} is not
the same as {a-b-c}.

Note that the left and right precedence of an infix operator does not affect the way Yacas interprets expressions typed by the user. You cannot make Yacas parse {a-b-c} as {a-(b-c)} unless you declare the operator "{-}" to be right-associative.

*SEE OpPrecedence, OpLeftPrecedence, OpRightPrecedence, RightAssociative

*CMD RuleBase --- define function name
*CORE
*CALL
	RuleBase("operator",{params})

*DESC
Define a new rules table entry for a
function "operator", with {params} as the parameter list.

*CMD Rule --- define rule

*CALL
	Rule("operator", arity,
	  precedence, predicate) body

*DESC
Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". The "precedence" goes from low to high: rules with low precedence will be applied first.
The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.
Rules with a low value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.

*CMD HoldArg --- mark argument as not evaluated
*CORE
*CALL
	HoldArg("operator",parameter)

*PARMS

{"operator"} -- string, name of a function

{parameter} -- atom, symbolic name of parameter

*DESC
Specify that parameter should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all {RuleBase} calls for this operator.

The {parameter} must be an atom from the list of symbolic arguments used when calling {RuleBase}.

*SEE RuleBase, HoldArgNr, RuleBaseArgList

*CMD Retract --- erase rules for a function
*CORE
*CALL
	Retract("operator",arity)

*DESC

Remove a rulebase with some specific arity, if it exists at all. This will make
Yacas forget all rules defined for a given function. Rules for functions with
the same name but different arities are not affected.

Assignment {:=} of a function does this to the function being (re)defined.

*CMD UnFence --- change local variable scope for a function
*CORE
*CALL
	UnFence("operator",arity)

*DESC

When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and such).

The standard library functions {For} and {ForEach} use {UnFence()}.

*CMD HoldArgNr --- specify argument as not evaluated
*STD
*CALL
	HoldArgNr("function", arity, argNum)

*PARMS
{"function"} -- string, function name

{arity}, {argNum} -- positive integers

*DESC

Declares the argument numbered {argNum} of the function named {"function"} with
specified {arity} to be unevaluated ("held"). Useful if you don't know symbolic
names of parameters, for instance, when the function was not declared using an
explicit {RuleBase} call. Otherwise you could use {HoldArg()}.

*SEE HoldArg, RuleBase


*CMD RuleBaseArgList --- obtain list of arguments
*CORE
*CALL
	RuleBaseArgList("operator", arity)

*PARMS
{"operator"} -- string, name of function

{arity} -- integer

*DESC

Returns a list of atoms, symbolic parameters specified in the {RuleBase()} call
for the function named {"operator"} with the specific {arity}.

*SEE RuleBase, HoldArgNr, HoldArg


*CMD MacroSet, MacroClear, MacroLocal, MacroRuleBase, MacroRule --- define rules in functions

*DESC

These functions have the same effect as their non-macro counterparts, except
that their arguments are evaluated before the required action is performed.
This is useful in macro-like procedures or in functions that need to define new
rules based on parameters.

Make sure that the arguments of {Macro}... commands evaluate to expressions that would normally be used in the non-macro versions!

*SEE Set, Clear, Local, RuleBase, Rule

*CMD Back-quoting --- Lisp back-quoting, macro expansion
*CORE
*CALL
	`(expression)

*PARMS

{expression} - expression containing {@var} pairs to substitute the value of variable {var}

*DESC

Back-quoting is a powerful mechanism where variables get expanded
inside an expression, and the expression then gets evaluated.
To invoke this functionality, a back-quote {`} needs to be placed
in front of an expression. If the {@var} pair is in place of a function 
the function is replaced.

One way to view back-quoting is to view it as a parametric expression
generator. {@var} pairs get substituted with the value of th variable
{var}. 

This operation is relatively slow since a new expression is built
before it is evaluated, but it is a powerful mechanism nonetheless,
allowing for great simplifications.

*E.G.

	In> Decl(f1,f2) := \
	In>     `(@f1(x_IsNumber) <-- N(@f2(x)));
	Out> True;
	In> Decl(nSin,Sin)
	Out> True;
	In> Sin(1)
	Out> Sin(1);
	In> nSin(1)
	Out> 0.8414709848;

The above example defines a function that automatically evaluates to a
number as soon as the argument is a number (a lot of functions 
do this only when inside a {N(...)} section).

	In> SetF(var,func,value) := \
	In>     `(Set(@var,@func(@value)));
	Out> True;
	In> SetF(a,Sin,x)
	Out> True;
	In> a
	Out> Sin(x);

The above example assigns {func(value)} to variable {var}.


*SEE MacroSet, MacroLocal, MacroRuleBase

*CMD SetExtraInfo, GetExtraInfo --- annotate objects with additional information
*CORE
*CALL
	SetExtraInfo(expr,tag)
	GetExtraInfo(expr)

*PARMS

{expr} - any expression

{tag} - tag information (any other expression)

*DESC

Sometimes it is useful to be able to add extra tag information to "annotate"
objects or to label them as having certain "properties". The functions
{SetExtraInfo} and {GetExtraInfo} enable this.

The function {SetExtraInfo} returns the tagged expression, leaving
the original expression alone. This means there is a common pitfall:
be sure to assign the returned value to a variable, or the tagged
expression is lost when the temporary object is destroyed.

The original expression is left unmodified, and the tagged expression
returned, in order to keep the atomic objects small. To tag an
object, a new type of object is created from the old object, with
one added property (the tag). The tag can be any expression whatsoever.

The function {GetExtraInfo(x)} retrieves this tag expression from an object
{x}. If an object has no tag, it looks the same as if it had a tag with value
{False}.

No part of the Yacas core uses tags in a way that is visible to the outside
world, so for specific purposes a programmer can devise a format to use for tag
information. Association lists (hashes) are a natural fit for this, although it
is not required and a tag can be any object (except the atom {False} because it
is indistinguishable from having no tag information). Using association lists
is highly advised since it is most likely to be the format used by other parts
of the library, and one needs to avoid clashes with other library code.
Typically, an object will either have no tag or a tag which is an associative
list (perhaps empty). A script that uses tagged objects will check whether an
object has a tag and if so, will add or modify certain entries of the
association list, preserving any other tag information.

Note that {FlatCopy()} currently does <i>not</i> copy the tag information (see
examples).

*E.G.

	In> a:=2*b
	Out> 2*b;
	In> a:=SetExtraInfo(a,{{"type","integer"}})
	Out> 2*b;
	In> a
	Out> 2*b;
	In> GetExtraInfo(a)
	Out> {{"type","integer"}};
	In> GetExtraInfo(a)["type"]
	Out> "integer";
	In> c:=a
	Out> 2*b;
	In> GetExtraInfo(c)
	Out> {{"type","integer"}};
	In> c
	Out> 2*b;
	In> d:=FlatCopy(a);
	Out> 2*b;
	In> GetExtraInfo(d)
	Out> False;

*SEE Assoc, :=

*CMD GarbageCollect --- do garbage collection on unused memory
*CORE
*CALL
	GarbageCollect()

*DESC

{GarbageCollect()} garbage-collects unused memory. The Yacas system
uses a reference counting system for most objects, so this call
is usually not necessary. 

Reference counting refers to bookkeeping where in each object a 
counter is held, keeping track of the number of parts in the system 
using that object. When this count drops to zero, the object is 
automatically removed. Reference counting is not the fastest way
of doing garbage collection, but it can be implemented in a very
clean way with very little code.

Among the most important objects that are not reference counted are
the strings. {GarbageCollect()} collects these and disposes of them
when they are not used any more. 

{GarbageCollect()} is useful when doing a lot of text processing,
to clean up the text buffers. It is not highly needed, but it keeps
memory use low.

*CMD CurrentFile, CurrentLine --- show current file and line of input
*CORE
*CALL
	CurrentFile()
	CurrentLine()

*DESC

The functions {CurrentFile()} and {CurrentLine()} return a string
with the file name of the current file and the current line 
of input respectively.

These functions are most useful in batch file calculations, where
there is a need to determine at which line an error occurred. It is
easy to define a function 

	tst() := Echo({CurrentFile(),CurrentLine()});

which can then be spread out over the input file at various places,
to see how far the interpreter reaches before an error occurs.

*SEE Echo


*CMD FindFunction --- find the file where a function is defined
*CORE
*CALL
	FindFunction(function)

*PARMS

function - string, the name of a function

*DESC

This function is useful for quickly finding the file where a standard library
function is defined. It is likely to only be useful for developers. The
function {FindFunction()} scans the {.def} files that were loaded at start-up.
This means that functions that were not defined in {.def} files, but were loaded
directly, will not be found with {FindFunction()}.

*E.G.

	In> FindFunction("Sum")
	Out> "sums.rep/code.ys";
	In> FindFunction("Integrate")
	Out> "integrate.rep/code.ys";

*SEE Vi

*CMD Secure --- guard the host OS
*CORE
*CALL
	Secure(body)

*DESC

{Secure} evaluates body in a "safe" environment, where file opening
and system calls are not allowed. This can protect the system
when an unsafe evaluation is done, e.g. a script sent over the
Internet to be evaluated on a remote computer.

*SEE SystemCall

			Built-in (core) functions

*INTRO
Yacas comes with a small core of built-in functions and a large library of
user-defined functions. Some of these core functions are documented in this
chapter.

It is important for a developer to know which functions are built-in and cannot
be redefined or {Retract}-ed. Also, core functions may be somewhat faster to
execute than functions defined in the script library. All core functions are
listed in the file {yacasapi.cpp} in the {src/} subdirectory of the Yacas
source tree. The declarations typically look like this:
	SetCommand(LispSubtract, "MathSubtract");
Here {LispSubtract} is the Yacas internal name for the function and {MathSubtract} is the name visible to the Yacas language.
Built-in bodied functions and infix operators are declared in the same file.

		Full listing of core functions

The following Yacas functions are currently declared in {yacasapi.cpp}
as core functions:


*INCLUDE yacasapi.chapt



*CMD MathNot --- built-in logical "not"
*CORE
*CALL
	MathNot(expression)

*DESC

Returns "False" if "expression" evaluates
to "True", and vice versa.

*CMD MathAnd --- built-in logical "and"

*CALL
	MathAnd(...)

Lazy logical {And}: returns {True} if all args evaluate to
{True}, and does this by looking at first, and then at the
second argument, until one is {False}.
If one of the arguments is {False}, {And} immediately returns {False} without
evaluating the rest. This is faster, but also means that none of the
arguments should cause side effects when they are evaluated.

*CMD MathOr --- built-in logical "or"
*CORE
*CALL
	MathOr(...)

{MathOr} is the basic logical "or" function. Similarly to {And}, it is
lazy-evaluated. {And(...)} and {Or(...)} do also exist, defined in the script
library. You can redefine them as infix operators yourself, so you have the
choice of precedence. In the standard scripts they are in fact declared as
infix operators, so you can write {expr1 And expr}.

*CMD BitAnd, BitOr, BitXor --- bitwise arithmetic
*CORE
*CALL
	BitAnd(n,m)
	BitOr(n,m)
	BitXor(n,m)

*DESC
These functions return bitwise "and", "or" and "xor"
of two numbers.

*CMD Equals --- check equality
*CORE
*CALL
	Equals(a,b)

*DESC
Compares evaluated {a} and {b} recursively
(stepping into expressions). So "Equals(a,b)" returns
"True" if the expressions would be printed exactly
the same, and "False" otherwise.

*CMD GreaterThan, LessThan --- arithmetic predicates
*CORE
*CALL
	LessThan(a,b), GreaterThan(a,b)

*DESC
Comparing numbers.

*CMD Math... --- arbitrary-precision math functions
*CORE
*CALL
MathGcd(n,m)  (Greatest Common Divisor),
MathAdd(x,y),
MathSubtract(x,y),
MathMultiply(x,y),
MathDivide(x,y),
MathSqrt(x)  (square root),
MathFloor(x), MathCeil(x),
MathAbs(x), MathMod(x,y),
MathExp(x), MathLog(x) (natural logarithm),
MathPower(x,y),
MathSin(x), MathCos(x), MathTan(x),
MathArcSin(x), MathArcCos(x), MathArcTan(x),
MathDiv(x,y), MathMod(x,y)

*DESC

Calculation of sin, cos, tan and other mathematical functions.
The argument <i>must</i>
be a number. The reason {Math} is prepended to
the names is you might want to derive equivalent
non-evaluating functions. The {Math}... versions require the arguments
to be numbers.

*CMD Fast... --- double-precision math functions
*CORE
*CALL

FastExp(x), FastLog(x) (natural logarithm),
FastPower(x,y),
FastSin(x), FastCos(x), FastTan(x),
FastArcSin(x), FastArcCos(x), FastArcTan(x)

*DESC
Versions of these functions using the internal C++ version. These
should then at least be faster than the arbitrary precision versions.

*CMD ShiftLeft, ShiftRight --- built-in bit shifts
*CORE
*CALL
	ShiftLeft(expr,bits)
	ShiftRight(expr,bits)

*DESC

Shift bits to the left or to the right.


			The Yacas plugin structure

*INTRO
Yacas supports dynamically loading libraries at runtime. This chapter describes functions for working with plugins.


The plugin feature allows Yacas to interface with other libraries that support
additional functionality. For example, there could be a plugin enabling the
user to script a user interface from within Yacas, or a specific powerful
library to do numeric calculations.

The plugin feature is currently in an experimental stage. There
are some examples in the {plugins/} directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The {plugins/} directory
contains a {README} file with more details on compilation.

In addition to the plugin structure in the Yacas engine, there is
a module {cstubgen} (currently still under development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. The module {cstubgen} is then
able to write out a C++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the {plugins/}
directory (the files ending with api.stub). The file
{makefile.plugin} is configured to automatically convert these to
the required C++ files. See also an essay on plugins for a worked-out example.

In addition to the C++ stub file, {cstubgen} also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.

The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(Loading DLLs is platform-dependent).

This chapter assumes the reader is comfortable programming in C++.


*CMD DllLoad, DllUnload, DllEnumerate --- manipulate plugins
*CORE
*CALL
	DllLoad(file)
	DllUnload(file)
	DllEnumerate()

*PARMS
{file} - file name of the plugin

*DESC

{DllLoad} forces Yacas to load the dynamic link library ({.so} file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where {dlopen} can find it.

{DllUnload} unloads a dynamic link library previously loaded with
{DllLoad}. Note the dll file name has to be exactly the same,
or the system will not be able to determine which dll to unload.
It will scan all the dll files, and delete the first one found
to exactly match, and return silently if it didn't find the dll.
{DllUnload} always returns {True}.

{DllEnumerate()} returns a list with all loaded dynamic link libraries.

*E.G.

	In> DllLoad("./libopengl.so");
	Out> True;

*SEE

*CMD StubApiCStart --- start of C++ plugin API
*STD
*CALL
	StubApiCStart()

*DESC

To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub C++ file.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCShortIntegerConstant --- declare integer constant in plugin
*STD
*CALL
	StubApiCShortIntegerConstant(const,value)

*PARMS

{const} - string representing the global variable to be bound runtime

{value} - integer value the global should be bound to

*DESC

define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define
	#define FOO 10
Then
	StubApiCShortIntegerConstant("FOO","FOO")
will bind the global variable FOO to the value for FOO defined in
the library header file.

*SEE StubApiCStart, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv



*CMD StubApiCInclude --- declare include file in plugin
*STD
*CALL
	StubApiCInclude(file)

*PARMS

{file} - file to include from the library the plugin is based on

*DESC

Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for OpenGL, you need to specify
	StubApiCInclude("\<GL/gl.h\>")
and for user include file:
	StubApiCInclude("\"GL/gl.h\"")

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCFunction --- declare C++ function in plugin
*STD
*CALL
	StubApiCFunction(returntype,fname,args)
	StubApiCFunction(returntype,fname,
	  fname2,args)

*PARMS

returntype - return type of library function

fname - function of built-in function

fname2 - (optional) function name to be used from within Yacas

args - list of arguments to the function

*DESC

This function declares a library function, along with its
calling sequence. cstubgen will then generate the C++ code
required to call this function.

Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).

If fname2 is not supplied, it will be assumed to be the same as fname.

The return types currently supported are "{int}", "{double}" and "{void}".

The argument values that are currently supported
are "{int}", "{double}", and "{input_string}".

Argument types can be specified simply as a string referring to their
type, like {"int"}, or they can be lists with an additional element
stating the name of the variable: {{"int","n"}}. The variable
will then show up in the automatically generated documentation as
having the name "n".

*E.G.

To define an OpenGL function {glVertex3d} that accepts three
doubles and returns void:

	StubApiCFunction("void","glVertex3d",
	  {"double","double","double"});

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFile, StubApiCSetEnv

*CMD StubApiCRemark --- documentation string in plugin
*STD
*CALL
	StubApiCRemark(string)

*PARMS

{string} - comment string to be added to the documentation

*DESC

StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a {.description} file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv, StubApiCFile

*CMD StubApiCSetEnv --- access Yacas environment in plugin
*STD
*CALL
	StubApiCSetEnv(func)

*PARMS

{func} - name of the function to call to set the environment variable

*DESC

This function forces the plugin to call the function func, with as
argument {LispEnvironment&} {aEnvironment}. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.

There needs to ba a function in the plugin somewhere of the form

	static LispEnvironment* env = NULL;
	void GlutSetEnv(LispEnvironment& aEnv)
	{
	    env = &aEnv;
	}

Then calling
	StubApiCSetEnv("GlutSetEnv");
will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile

*CMD StubApiCFile --- set file name for plugin API
*STD
*CALL
	StubApiCFile(basename)

*PARMS

{basename} - name for the generation of the stub file

*DESC

Generate the C++ stub file, "basename.cc", and a documentation file
named "basename.description". The descriptions are automatically
generated while adding functions and constants to the stub.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv

*CMD StubApiCStruct --- declare C struct in plugin
*STD
*CALL
	StubApiCStruct(name)
	StubApiCStruct(name,freefunction)

*PARMS

{name} - name of structure

{freefunction} - function that can be called to clean up the object

*DESC

StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.

By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.

*E.G.

In a library header file, define:

	typedef struct SomeStruct
	{
	  int a;
	  int b;
	} SomeStruct;
Then in the stub file you can declare this struct by calling:

	StubApiCStruct("SomeStruct*")

*SEE StubApiCFunction


			Generic objects

*INTRO Generic objects are objects that are implemented in C++, but
can be accessed through the Yacas interpreter.

*CMD IsGeneric --- check for generic object
*CORE
*CALL
	IsGeneric(object)

*DESC
Returns {True} if an object is of a generic object
type.

*CMD GenericTypeName --- get type name
*CORE
*CALL
	GenericTypeName(object)

*DESC
Returns a string representation of
the name of a generic object.

EG

	In> GenericTypeName(ArrayCreate(10,1))
	Out> "Array";

*CMD ArrayCreate --- create array
*CORE
*CALL
	ArrayCreate(size,init)

*DESC
Creates an array with {size} elements, all initialized to the
value {init}.

*CMD ArraySize --- get array size
*CORE
*CALL
	ArraySize(array)

*DESC
Returns the size of an array (number of elements in the array).

*CMD ArrayGet --- fetch array element
*CORE
*CALL
	ArrayGet(array,index)

*DESC
Returns the element at position index in the array passed. Arrays are treated
as base-one, so {index} set to 1 would return the first element.

Arrays can also be accessed through the {[]} operators. So
{array[index]} would return the same as {ArrayGet(array, index)}.

*CMD ArraySet --- set array element
*CORE
*CALL
	ArraySet(array,index,element)

*DESC
Sets the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so {index} set to 1 would set first element.

Arrays can also be accessed through the {[]} operators. So
{array[index] := element} would do the same as {ArraySet(array, index,element)}.

*CMD ArrayCreateFromList --- convert list to array
*CORE
*CALL
	ArrayCreateFromList(list)

*DESC
Creates an array from the contents of the list passed in.

*CMD ListFromArray --- convert array to list
*CORE
*CALL
	ListFromArray(array)

*DESC
Creates a list from the contents of the array passed in.



			The Yacas test suite

*INTRO This chapter describes commands used for verifying correct performance
of Yacas.

Yacas comes with a test suite which can be found in
the directory {tests/}. Typing 
	make test
on the command line after Yacas was built will run the test.
This test can be run even before {make install}, as it only 
uses files in the local directory of the Yacas source tree.
The default extension for test scripts is {.yts} (Yacas test script).

The verification commands described in this chapter only  display the
expressions that do not evaluate correctly. Errors do not terminate the
execution of the Yacas script that uses these testing commands, since they are
meant to be used in test scripts.


*CMD Verify, TestYacas, LogicVerify --- Verifying equivalence of two expressions
*STD
*CALL
	Verify(question,answer)
	TestYacas(question,answer)
	LogicVerify(question,answer)

*PARMS

{question} - expression to check for

{answer} - expected result after evaluation

*DESC

The commands {Verify}, {TestYacas}, {LogicVerify} can be used to verify that an
expression is <I>equivalent</I> to  a correct answer after evaluation. All
three commands return {True} or {False}.

For most calculations, the demand that two expressions
are <I>equal</I> syntactically is too stringent. The 
Yacas system might change at various places in the future,
but $ 1+x $ would still be equivalent, from a mathematical
point of view, to $ x+1 $.

The general problem of deciding that two expressions $ a $ and $ b $
are equivalent, which is the same as saying that $ a-b=0 $ , 
is generally hard to decide on. The following commands solve
this problem by having domain-specific comparisons.

The comparison commands do the following comparison types:

*	{Verify} - verify for literal equality. 
This is the fastest and simplest comparison, and can be 
used for testing that an expression simplifies to for instance $ 2 $.
*	{TestYacas} - compare two expressions after simplification for 
multivariate polynomials. If the two arguments are equivalent
multivariate polynomials, this test succeeds. {TestYacas} uses {Simplify()}.
*	{LogicVerify} - Perform a test by using {CanProve} to verify that from 
{question} the expression {answer} follows. This test command is 
used for testing the logic theorem prover in Yacas.

*E.G.

	In> Verify(1+2,3)
	Out> True;
	In> Verify(x*(1+x),x^2+x)
	******************
	x*(x+1) evaluates to x*(x+1) which differs
	  from x^2+x
	******************
	Out> False;
	In> TestYacas(x*(1+x),x^2+x)
	Out> True;
	In> Verify(a And c Or b And Not c,a Or b)
	******************
	 a And c Or b And Not c evaluates to  a And c
	  Or b And Not c which differs from  a Or b
	******************
	Out> False;
	In> LogicVerify(a And c Or b And Not c,a Or b)
	Out> True;
	In> LogicVerify(a And c Or b And Not c,b Or a)
	Out> True;

*SEE Simplify, CanProve, KnownFailure


*CMD KnownFailure --- Mark a test as a known failure
*STD
*CALL
	KnownFailure(test)

*PARMS

{test} - expression that should return False on failure

*DESC

The command {KnownFailure} marks a test as known to fail
by displaying a message to that effect on screen. 

This might be used by developers when they have no time
to fix the defect, but do not wish to alarm users who download
Yacas and type {make test}.

*E.G.

	In> KnownFailure(Verify(1,2))
	Known failure:
	******************
	 1 evaluates to  1 which differs from  2
	******************
	Out> False;
	In> KnownFailure(Verify(1,1))
	Known failure:
	Failure resolved!
	Out> True;

*SEE Verify, TestYacas, LogicVerify

*CMD RoundTo --- Round a real-valued result to a set number of digits
*STD
*CALL
	RoundTo(number,precision)

*PARMS

{number} - number to round off

{precision} - precision to use for round-off

*DESC

The function {RoundTo} rounds a floating point number to a
specified precision, allowing for testing for correctness
using the {Verify} command.

*E.G.

	In> N(RoundTo(Exp(1),30),30)
	Out> 2.71828182110230114951959786552;
	In> N(RoundTo(Exp(1),20),20)
	Out> 2.71828182796964237096;

*SEE Verify, VerifyArithmetic, VerifyDiv



*CMD VerifyArithmetic, VerifyDiv --- Special purpose arithmetic verifiers
*STD
*CALL
	VerifyArithmetic(x,n,m)
	RandVerifyArithmetic(n)
	VerifyDiv(u,v)

*PARMS

{x}, {n}, {m}, {u}, {v} - integer arguments

*DESC

The commands {VerifyArithmetic} and {VerifyDiv} test a 
mathematic equality which should hold, testing that the
result returned by the system is mathematically correct
according to a mathematically provable theorem.

{VerifyArithmetic} verifies for an arbitrary set of numbers
$ x $, $ n $ and $ m $ that

$$ (x^n-1)*(x^m-1) = x^(n+m)-(x^n)-(x^m)+1 $$

The left and right side represent two ways to arrive at the
same result, and so an arithmetic module actually doing the
calculation does the calculation in two different ways. 
The result should be exactly equal.

{RandVerifyArithmetic(n)} calls {VerifyArithmetic()} {n} times, with
random values.

{VerifyDiv(u,v)} checks that 

$$ u = v*Div(u,v) + Mod(u,v) $$


*E.G.

	In> VerifyArithmetic(100,50,60)
	Out> True;
	In> RandVerifyArithmetic(4)
	Out> True;
	In> VerifyDiv(x^2+2*x+3,x+1)
	Out> True;
	In> VerifyDiv(3,2)
	Out> True;

*SEE Verify


