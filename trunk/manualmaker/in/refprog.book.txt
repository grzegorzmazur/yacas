
				Yacas programmer's function reference


			Programming

*CMD	/*, */, // --- comments
*CORE
*CALL

	/* comment */
	// comment

*DESC

Introduce a comment block in a source file, similar to C++ comments.
{//} makes everything until the end of the line a comment, while {/*} and {*/} may delimit a multi-line comment.

*E.G.

	a+b; // get result
	a + /* add them */ b;

*CMD Prog, [, ] --- block of statements
*CORE
*CALL

	Prog(statement1, statement2, ...)
	[ statement1; statement2; ... ]

*PARMS

statement1, statement2 -- expressions

*DESC

The {Prog()} and the {[ ... ]} constuct have the same effect: they evaluate all
arguments in order and return the result of the last evaluated expression.

{Prog(a,b);} is the same as typing {[a;b;];} and is very useful for writing out
function bodies. The {[...]} construct is a syntactically nicer version of the
{Prog()} call; it is converted into {Prog(...)} during the parsing stage.



*CMD Check --- report errors
*CORE
*CALL
	Check(predicate,"error text")

*PARMS

predicate -- expression returning {True} or {False}

*DESC
If {predicate} doesn't evaluate to {True},
then current operation will be stopped, and execution
will jump right back to the command line, showing
{error text}. Use this to assure that some condition
is met during evaluation of expressions (guarding
against internal errors).

*CMD Bodied, Infix, Postfix, Prefix --- define function syntax
*CORE
*CALL
	Bodied("op", precedence)
	Infix("op")
	Infix("op", precedence)
	Postfix("op")
	Prefix("op")
	Prefix("op", precedence)

*PARMS

"op" -- string, the name of a function

precedence -- nonnegative integer (evaluated)

*DESC
Declares a function for the parser to understand as a bodied, infix, postfix, or prefix operator. Function name can be any string but meaningful usage would require it to be either made up entirely of letters or entirely of non-letter characters (such as "+", ":" etc.). Precedence can be specified (will be 0 by default).

*E.G.
	In> YY x := x+1;
	CommandLine(1) : Error parsing expression
	
	In> Prefix("YY", 2)
	Out> True;
	In> YY x := x+1;
	Out> True;
	In> YY YY 2*3
	Out> 12;
	In> Infix("##", 5)
	Out> True;
	In> a ## b ## c
	Out> a##b##c;

*SEE IsBodied, OpPrecedence



*CMD IsBodied, IsInfix, IsPostfix, IsPrefix --- check for function syntax
*CORE
*CALL
	IsBodied("op")
	IsInfix("op")
	IsPostfix("op")
	IsPrefix("op")

*PARMS

"op" -- string, the name of a function

*DESC
Check whether the function with given name "op" has been declared as a "bodied", infix, postfix, or prefix operator, and  return {True} or {False}.

*E.G.

	In> IsInfix("+");
	Out> True;
	In> IsBodied("While");
	Out> True;
	In> IsBodied("Sin");
	Out> False;

*SEE Bodied, OpPrecedence

*CMD OpPrecedence, OpLeftPrecedence, OpRightPrecedence --- get operator precedence
*CORE
*CALL
	OpPrecedence("op")
	OpLeftPrecedence("op")
	OpRightPrecedence("op")

*PARMS

"op" -- string, the name of a function

*DESC
Returns the precedence of the function named "op" which should have been declared as a bodied function or an infix, postfix, or prefix operator. Generates an error message if the string str does not represent a type of function that can have precedence.

For infix operators, right precedence can differ from left precedence. Bodied functions and prefix operators cannot have left precedence, while postfix operators cannot have right precedence; for these operators, there is only one value of precedence.

*E.G.
	In> OpPrecedence("+")
	Out> 6;
	In> OpLeftPrecedence("!")
	Out> 0;



*CMD RightAssociative --- declare associativity
*CORE
*CALL
	RightAssociative("op")

*PARMS

"op" -- string, the name of a function

This makes the operator right-associative. Example:

	RightAssociative("*")
would make multiplication right-associative. Take care not to abuse
this function, because the reverse, making an infix operator
left-associative, is not implemented.

*SEE OpPrecedence


*CMD LeftPrecedence, RightPrecedence --- set operator precedence
*CORE
*CALL
	LeftPrecedence("op",precedence)
	RightPrecedence("op",precedence)

*PARMS

"op" -- string, the name of a function

precedence -- nonnegative integer

*DESC

"op" should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display a-(b-c)
correctly. Thus, a+b+c is the same as a+(b+c), but a-(b-c) is not
the same as a-b-c.

*CMD RuleBase --- define function name
*CORE
*CALL
	RuleBase("operator",{params})

*DESC
Define a new rules table entry for a
function "operator", with {params} as the parameter list.

*CMD Rule --- define rule

*CALL
	Rule("operator", arity,
	  precedence, predicate) body

*DESC
Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". The "precedence" goes from low to high: rules with low precedence will be applied first.
The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.
Rules with a low value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.

*CMD HoldArg --- mark argument as not evaluated
*CORE
*CALL
	HoldArg("operator",parameter)

*PARMS

"operator" -- string, name of a function
parameter -- atom, symbolic name of parameter

*DESC
Specify that parameter should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all {RuleBase} calls for this operator.

The {parameter} must be an atom from the list of symbolic arguments used when calling {RuleBase}.

*SEE RuleBase, HoldArgNr, RuleBaseArgList

*CMD Retract --- erase rules for a function
*CORE
*CALL
Retract("operator",arity)

Remove a rulebase with some specific arity,
if it exists at all.

*CMD UnFence --- change local variable scope for a function
*CORE
*CALL
UnFence("operator",arity)

*DESC
When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and the such). The standard library functions {For} and {ForEach} use {UnFence()}.

*CMD HoldArgNr --- specify argument as not evaluated
*STD
*CALL
	HoldArgNr("function", arity, argNum)

*PARMS
"function" -- string, function name

arity, argNum -- positive integers

*DESC

Declares the argument number {argNum} of the function named {"function"} with specified {arity} to be unevaluated. Useful if you don't know symbolic names of parameters, for instance, when the function was not declared using an explicit {RuleBase} call.

*SEE HoldArg, RuleBase


*CMD RuleBaseArgList --- obtain list of arguments
*CORE
*CALL
	RuleBaseArgList("operator", arity)

*PARMS
"operator" -- string, name of function

arity -- integer

*DESC

Returns a list of atoms, symbolic parameters specified in the {RuleBase()} call for the function named {"operator"} with the specific {arity}.

*SEE RuleBase, HoldArgNr, HoldArg


*CMD MacroSet, MacroClear, MacroLocal, MacroRuleBase, MacroRule --- manipulate symbols

Same as their non-macro counterparts, except
that their arguments are evaluated before
the required action is performed. This is
useful in macro-like procedures.


*CMD Back-quoting --- Back-quoting, macro expansion
*CORE
*CALL
	`(expression)

*PARMS

{expression} - expression containing {@var} pairs to substitute the value of variable {var}

*DESC

Back-quoting is a powerful mechanism where variables get expanded
inside an expression, and the expression then gets evaluated.
To invoke this functionality, a back-quote {`} needs to be placed
in front of an expression. If the {@var} pair is in place of a function 
the function is replaced.

One way to view back-quoting is to view it as a parametric expression
generator. {@var} pairs get substituted with the value of th variable
{var}. 

This operation is relatively slow since a new expression is built
before it is evaluated, but it is a powerful mechanism nonetheless,
allowing for great simplifications.

*E.G.

	In> Decl(f1,f2) := \
	In>     `(@f1(x_IsNumber) <-- N(@f2(x)));
	Out> True;
	In> Decl(nSin,Sin)
	Out> True;
	In> Sin(1)
	Out> Sin(1);
	In> nSin(1)
	Out> 0.8414709848;

The above example defines a function that automatically evaluates to a
number as soon as the argument is a number (a lot of functions 
do this only when inside a {N(...)} section).

	In> SetF(var,func,value) := \
	In>     `(Set(@var,@func(@value)));
	Out> True;
	In> SetF(a,Sin,x)
	Out> True;
	In> a
	Out> Sin(x);

The above example assigns {func(value)} to variable {var}.


*SEE MacroSet, MacroLocal, MacroRuleBase

*CMD SetExtraInfo, GetExtraInfo --- Annotate objects with additional tag information
*CORE
*CALL
	SetExtraInfo(expression,tag)
	GetExtraInfo(expression)

*PARMS

{expression} - expression to tag
{tag} - tag information

*DESC

Sometimes it is useful to be able to add extra annotational tag information
to objects. The functions {SetExtraInfo} and {GetExtraInfo} enable this.

The function {SetExtraInfo} returns the tagged expression, leaving
the original expression alone. This means there is a common gotcha:
be sure to assign the returned value to a variable, or the tagged
expression is lost.

The original expression is left alone, and the tagged expression
returned, in order to keep the atomic objects small. To tag an
object, a new type of object is created from the old object, with
one added property: a tag.

No part of Yacas uses tags in a way that is visible to the outside
world, so for specific programs, a programmer can devise a format
to use for tagging information. Association lists are a natural fit
for this, but it is not required. The tag is free-form, although
using association lists is highly advised since it is most likely
to be the format used by other parts of the system, making the code
compatible with other parts.

*E.G.

	In> a:=2*b
	Out> 2*b;
	In> a:=SetExtraInfo(a,{{"type","integer"}})
	Out> 2*b;
	In> a
	Out> 2*b;
	In> GetExtraInfo(a)
	Out> {{"type","integer"}};
	In> GetExtraInfo(a)["type"]
	Out> "integer";
	In> c:=a
	Out> 2*b;
	In> GetExtraInfo(c)
	Out> {{"type","integer"}};
	In> c
	Out> 2*b;

*SEE Assoc

*CMD GarbageCollect --- Do garbage collection on unused memory
*CORE
*CALL
	GarbageCollect()

*DESC

{GarbageCollect()} garbage-collects unused memory. The Yacas system
uses a reference counting system for most objects, so this call
is usually not necessary. 

Reference counting refers to bookkeeping where in each object a 
counter is held, keeping track of the number of parts in the system 
using that object. When this count drops to zero, the object is 
automatically removed. Reference counting is not the fastest way
of doing garbage collection, but it can be implemented in a very
clean way with very little code.

Among the most important objects that are not reference counted are
the strings. {GarbageCollect()} collects these and disposes of them
when they are not used any more. 

{GarbageCollect()} is useful when doing a lot of text processing,
to clean up the text buffers. It is not highly needed, but it keeps
memory use low.

*CMD CurrentFile, CurrentLine --- Show current file and line of input
*CORE
*CALL
	CurrentFile()
	CurrentLine()

*DESC

The functions {CurrentFile()} and {CurrentLine()} return a string
with the file name of the current file, and the current line 
of input respectively.

These functions are most useful in batch file calculations, where
there is a need to determine at which line an error occurred. It is
easy to define a function 

	tst() := Echo({CurrentFile(),CurrentLine()});

which can then be spread out over the input file at various places,
to see how far the interpreter reaches before an error occurs.

*SEE Echo


*CMD FindFunction --- Find the file where a function is defined
*CORE
*CALL
	FindFunction(function)

*PARMS

function - string, the name of a function

*DESC

This function is useful for quickly finding the file where a standard library
function is defined. It is likely to only be useful for developers. The
function {FindFunction()} scans the {.def} files that were loaded at start-up.
This means that functions that were not defined in {.def} files, but were loaded
directly, will not be found with {FindFunction()}.

*E.G.

	In> FindFunction("Sum")
	Out> "sums.rep/code.ys";
	In> FindFunction("Integrate")
	Out> "integrate.rep/code.ys";

*SEE Vi

*CMD Secure --- guard the host OS
*CORE
*CALL
	Secure(body)

*DESC

{Secure} evaluates body in a "safe" environment, where file opening
and system calls are not allowed. This can protect the system
when an unsafe evaluation is done, e.g. a script sent over the
Internet to be evaluated on a remote computer.


			Built-in (core) functions

*INTRO Yacas comes with a small core of built-in functions and a large library
of user-defined functions. It is important for a developer to know which
functions are built-in and cannot be redefined or {Retract}-ed. All core
functions are listed in the file {yacasapi.cpp} in the {src/} subdirectory of
the Yacas source tree. The declarations typically look like this:

	SetCommand(LispSubtract, "MathSubtract");
Here {LispSubtract} is the Yacas internal name for the function and {MathSubtract} is the name visible to the Yacas language.

Built-in bodied functions and infix operators are declared in the same file.


*CMD MathNot --- built-in logical "not"
*CORE
*CALL
	MathNot(expression)

*DESC

Returns "False" if "expression" evaluates
to "True", and vice versa.

*CMD MathAnd --- built-in logical "and"

*CALL
	MathAnd(...)

Lazy logical {And}: returns {True} if all args evaluate to
{True}, and does this by looking at first, and then at the
second argument, until one is {False}.
If one of the arguments is {False}, {And} immediately returns {False} without
evaluating the rest. This is faster, but also means that none of the
arguments should cause side effects when they are evaluated.

*CMD MathOr --- built-in logical "or"
*CORE
*CALL

	MathOr(...)

{MathOr} is the basic logical "or" function. Similarly to {And}, it is lazy-evaluated.
{And(...)} and {Or(...)} do also exist. You can define
them as infix operators
yourself, so you have the choice of precedence. In the standard scripts
they are in fact declared as infix operators, so you can write
{expr1 And expr}.

*CMD BitAnd, BitOr, BitXor --- bitwise arithmetic
*CORE
*CALL
BitAnd(n,m), BitOr(n,m), BitXor(n,m)

BitAnd(n,m), BitOr(n,m), BitXor(n,m) : return bitwise and, or and xor
of two numbers.

*CMD Equals --- check equality
*CORE
*CALL
	Equals(a,b)

*DESC
Compares evaluated {a} and {b} recursively
(stepping into expressions). So "Equals(a,b)" returns
"True" if the expressions would be printed exactly
the same, and "False" otherwise.

*CMD GreaterThan, LessThan --- arithmetic predicates
*CORE
*CALL
	LessThan(a,b), GreaterThan(a,b)

*DESC
Comparing numbers.

*CMD Math... --- arbitrary-precision math functions
*CORE
*CALL
MathGcd(n,m)  (Greatest Common Divisor),
MathAdd(x,y),
MathSubtract(x,y),
MathMultiply(x,y),
MathDivide(x,y),
MathSqrt(x)  (square root),
MathFloor(x), MathCeil(x),
MathAbs(x), MathMod(x,y),
MathExp(x), MathLog(x) (natural logarithm),
MathPower(x,y),
MathSin(x), MathCos(x), MathTan(x),
MathArcSin(x), MathArcCos(x), MathArcTan(x),
MathDiv(x,y), MathMod(x,y)

*DESC

Calculation of sin, cos, tan and other mathematical functions.
The argument <i>must</i>
be a number. The reason {Math} is prepended to
the names is you might want to derive equivalent
non-evaluating functions. The {Math}... versions require the arguments
to be numbers.

*CMD Fast... --- double-precision math functions
*CORE
*CALL

FastExp(x), FastLog(x) (Natural logarithm),
FastPower(x,y),
FastSin(x), FastCos(x), FastTan(x),
FastArcSin(x), FastArcCos(x), FastArcTan(x) :

*DESC
Versions of these functions using the internal C version. These
should then at least be faster than the arbitrary precision versions.

*CMD ShiftLeft, ShiftRight --- built-in bit shifts
*CORE
*CALL
	ShiftLeft(expr,bits)
	ShiftRight(expr,bits)

*DESC

Shift bits to the left or to the right.


			The Yacas plugin structure

*INTRO
Yacas supports dynamically loading libraries at runtime. This allows
it to interface with other libraries that support additional
functionality. For example, there could be a plugin enabling
the user to script a user interface from within Yacas, or a
specific powerful library to do numeric calculations.

The plugin feature is currently in an experimental stage. There
are some examples in the plugins/ directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The plugins/ directory
contains a README file with more details on compilation.

In addition to the plugin structure in the Yacas engine, there is
a 'cstubgen' module (currently still in development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. the 'cstubgen' module is then
able to write out a C++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the plugins/
directory (the files ending with api.stub). The make file
makefile.plugin is configured to automatically convert these to
the required C++ files.

In addition to the C++ stub file cstubgen also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.

The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(loading DLLs is platform-dependent).

This chapter assumes the reader is comfortable programming in C++.


*CMD DllLoad, DllUnload, DllEnumerate --- manipulate plugins
*CORE
*CALL
	DllLoad(file)
	DllUnload(file)
	DllEnumerate()

*PARMS
file - file name of the plugin

*DESC

DllLoad forces Yacas to load the dynamic link library (.so file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where dlopen can find it.

DllUnload unloads a dynamic link library previously loaded with
DllLoad. Note the dll file name has to be exactly the same,
or the system will not be able to determine which dll to unload.
It will scan all the dll files, and delete the first one found
to exactly match, and return silently if it didn't find the dll.
DllUnload always returns True.

DllEnumerate() returns a list with all loaded dynamic link libraries.

*E.G.

	In> DllLoad("./libopengl.so");
	Out> True;

*SEE

*CMD StubApiCStart --- start of C++ plugin API
*STD
*CALL

StubApiCStart()

*PARMS

*DESC

To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub C++ file.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCShortIntegerConstant --- declare integer constant in plugin
*STD
*CALL

StubApiCShortIntegerConstant(const,value)

*PARMS

const - string representing the global variable to be bound runtime

value - integer value the global should be bound to

*DESC

define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define
	#define FOO 10
Then
	StubApiCShortIntegerConstant("FOO","FOO")
will bind the global variable FOO to the value for FOO defined in
the library header file.

*SEE StubApiCStart, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv



*CMD StubApiCInclude --- declare include file in plugin
*STD
*CALL
	StubApiCInclude(file)

*PARMS

file - file to include from the library the plugin is based on

*DESC

Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for opengl, you need to specify
	StubApiCInclude("\<GL/gl.h\>")
and for user include file:
	StubApiCInclude("\"GL/gl.h\"")

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCFunction --- declare C++ function in plugin
*STD
*CALL
	StubApiCFunction(returntype,fname,args)
	StubApiCFunction(returntype,fname,
	  fname2,args)

*PARMS

returntype - return type of library function

fname - function of built-in function

fname2 - (optional) function name to be used from within Yacas

args - list of arguments to the function

*DESC

This function declares a library function, along with its
calling sequence. cstubgen will then generate the C++ code
required to call this function.

Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).

If fname2 is not supplied, it will be assumed to be the same as fname.

The return types currently supported are "{int}", "{double}" and "{void}".

The argument values that are currently supported
are "{int}", "{double}", and "{input_string}".

Argument types can be specified simply as a string referring to their
type, like "int", or they can be lists with an additional element
stating the name of the variable: {{"int","n"}}. The variable
will then show up in the automatically generated documentation as
having the name "n".

*E.G.

To define the opengl function {glVertex3d} that accepts three
doubles and returns void:

	StubApiCFunction("void","glVertex3d",
	  {"double","double","double"});

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFile, StubApiCSetEnv

*CMD StubApiCRemark --- documentation string in plugin
*STD
*CALL
	StubApiCRemark(string)

*PARMS

string - remark string to be added to the documentation

*DESC

StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a .description file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv, StubApiCFile

*CMD StubApiCSetEnv --- access Yacas environment in plugin
*STD
*CALL
	StubApiCSetEnv(func)

*PARMS

func - function to call to set the environment variable

*DESC

This function forces the plugin to call the function func, with as
argument {LispEnvironment&} {aEnvironment}. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.

There needs to ba a function in the plugin somewhere of the form

	static LispEnvironment* env = NULL;
	void GlutSetEnv(LispEnvironment& aEnv)
	{
	    env = &aEnv;
	}

Then calling
	StubApiCSetEnv("GlutSetEnv");
will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile

*CMD StubApiCFile --- set file name for plugin API
*STD
*CALL

StubApiCFile(basename)

*PARMS

basename - basename for the generation of the stub file

*DESC

Generate the C++ stub file, "basename.cc", and a documentation file
named "basename.description". The descriptions are automatically
generated while adding functions and constants to the stub.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv

*CMD StubApiCStruct --- declare C struct in plugin
*STD
*CALL

StubApiCStruct(name)

StubApiCStruct(name,freefunction)

*PARMS

name - name of structure

freefunction - function that can be called to clean up the object

*DESC

StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.

By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.

*E.G.

In a library header file, define:

	typedef struct SomeStruct
	{
	  int a;
	  int b;
	} SomeStruct;
Then in the stub file you can declare this struct by calling:

	StubApiCStruct("SomeStruct*")

*SEE


			Generic objects

Generic objects are objects that are implemented in C++, but
can be accessed through the Yacas interpreter.

*CMD IsGeneric --- check for generic object
*CORE
*CALL
IsGeneric(object)

IsGeneric(object) : returns whether an object is a generic object
type.

*CMD GenericTypeName --- get type name
*CORE
*CALL
GenericTypeName(object)

GenericTypeName(object) : returns a string representation of
the name of a generic object.

Example: GenericTypeName(ArrayCreate(10,1)) sould return "Array".

*CMD ArrayCreate --- create array
*CORE
*CALL
ArrayCreate(size,init)

Create an array the with size elements, all initialized to the
value init.

*CMD ArraySize --- get array size
*CORE
*CALL
ArraySize(array)

Return the size of an array (number of elements in the array).

*CMD ArrayGet --- fetch array element
*CORE
*CALL
ArrayGet(array,index)

Get the element at position index in the array passed. Arrays are treated
as base-one, so index set to 1 would return the first element.

Arrays can also be accessed through the [] operators. So
array[index] would return the same as ArrayGet(array,index).

*CMD ArraySet --- set array element
*CORE
*CALL
ArraySet(array,index,element)

Set the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so index set to 1 would set first element.

Arrays can also be accessed through the [] operators. So
array[index]:=element would do the same as ArraySet(array,index,element).

*CMD ArrayCreateFromList --- convert list to array
*CORE
*CALL
ArrayCreateFromList(list)

Creates an array from the contents of the list passed in.

*CMD ListFromArray --- convert array to list
*CORE
*CALL
ListFromArray(array)

Creates a list from the contents of the array passed in.



			The Yacas test suite

*INTRO Yacas comes with a test suite which can be found in
the directory {tests/}. Typing 

	make test

on the command line after Yacas was built will run the test.
This test can be run even before {make install}, as it only 
uses files in the local directory of the Yacas source tree.
The default extension for test scripts is {.yts}, (Yacas test script).

The verification commands described in this chapter only 
display the expressions that don't match. They don't terminate
the current execution, and they don't return a value representing
success and failure, since they are meant to be used in test
scripts.


*CMD Verify, TestYacas, LogicVerify --- Verifying equivalence of two expressions
*STD
*CALL
	Verify(question,answer)
	TestYacas(question,answer)
	LogicVerify(question,answer)

*PARMS

{question} - expression to check for

{answer} - expected result after evaluation

*DESC

The commands {Verify}, {TestYacas}, {LogicVerify} can be
used to verify that an expression is <I>equivalent</I> to 
a correct answer after evaluation. 

For most calculations, the demand that two expressions
are <I>equal</I> syntactically is too stringent. The 
Yacas system might change at various places in the future,
but $ 1+x $ would still be equivalent, from a mathematical
point of view, to $ x+1 $.

The general problem of deciding that two expressions $ a $ and $ b $
are equivalent, which is the same as saying that $ a-b=0 $ , 
is generally hard to decide on. The following commands solve
this by having domain-specific comparisons.

The comparison commands do the following comparison types:

*	{Verify} - verify for literal equality. 
This is the fastest and simplest comparison, and can be 
used for testing that an expression simplifies to for instance $ 2 $.
*	{TestYacas} - compare two expressions after simplification for 
multivariate polynomials. If the two arguments are equivalent
multivariate polynomials, this test succeeds.
*	{LogicVerify} - Perform a test by using {CanProve} to verify that from 
{question} the expression {answer} follows. This test command is 
used for testing the logic theorem prover in Yacas.

*E.G.

	In> Verify(1+2,3)
	Out> True;
	In> Verify(x*(1+x),x^2+x)
	******************
	x*(x+1) evaluates to x*(x+1) which differs from x^2+x
	******************
	Out> False;
	In> TestYacas(x*(1+x),x^2+x)
	Out> True;
	In> Verify(a And c Or b And Not c,a Or b)
	******************
	 a And c Or b And Not c evaluates to  a And c Or b And Not c which differs from  a Or b
	******************
	Out> False;
	In> LogicVerify(a And c Or b And Not c,a Or b)
	Out> True;
	In> LogicVerify(a And c Or b And Not c,b Or a)
	Out> True;

*SEE Simplify, CanProve, KnownFailure


*CMD KnownFailure --- Mark a test as a known failure
*STD
*CALL
	KnownFailure(test)

*PARMS

{test} - test command that should fail

*DESC

The command {KnownFailure} marks a test as known to fail
by displaying a message to that effect on screen. 

This might be used by a developer when he doesn't have time
to fix the defect, but doesn't wish to alarm users who download
Yacas and type {make test}.

*E.G.

	In> KnownFailure(Verify(1,2))
	Known failure:
	******************
	 1 evaluates to  1 which differs from  2
	******************
	Out> False;
	In> KnownFailure(Verify(1,1))
	Known failure:
	Failure resolved!
	Out> True;

*SEE Verify, TestYacas, LogicVerify

*CMD RoundTo --- Round a real-valued result to a set number of digits
*STD
*CALL
	RoundTo(number,precision)

*PARMS

{number} - number to round off

{precision} - precision to use for round-off

*DESC

The function {RoundTo} rounds a floating point number to a
specified precision, allowing for testing for correctness
using the {Verify} command.

*E.G.

	In> N(RoundTo(Exp(1),30),30)
	Out> 2.71828182110230114951959786552;
	In> N(RoundTo(Exp(1),20),20)
	Out> 2.71828182796964237096;

*SEE Verify



	VerifyArithmetic
	VerifyDiv



*CMD VerifyArithmetic, VerifyDiv --- Special purpose arithmetic verifiers
*STD
*CALL
	VerifyArithmetic(x,n,m)
	RandVerifyArithmetic(n)
	VerifyDiv(u,v)

*PARMS

{x}, {n}, {m}, {u}, {v} - integer arguments

*DESC

The commands {VerifyArithmetic} and {VerifyDiv} test a 
mathematic equality which should hold, testing that the
result returned by the system is mathematically correct
according to a mathematically provable theorem.

VerifyArithmetic verifies for an arbitrary set of numbers
$ x $, $ n $ and $ m $ that

$$ (x^n-1)*(x^m-1) = x^(n+m)-(x^n)-(x^m)+1 $$

The left and right side represent two ways to arrive at the
same result, and so an arithmetic module actually doing the
calculation does the calculation in two different ways. 
The result should be exactly equal.

RandVerifyArithmetic calls VerifyArithmetic {n} times, with
random values.

VerifyDiv checks that 

$$ u = v*Div(u,v) + Rem(u,v) $$


*E.G.

	In> VerifyArithmetic(100,50,60)
	Out> True;
	In> RandVerifyArithmetic(4)
	Out> True;
	In> VerifyDiv(x^2+2*x+3,x+1)
	Out> True;
	In> VerifyDiv(3,2)
	Out> True;

*SEE Verify


