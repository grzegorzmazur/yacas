*BLURB 
This is the second part of the Yacas function reference.
This reference contains functions that might be useful
for programming in Yacas.
				Yacas programmer's function reference

			Programming

*INTRO This chapter describes functions useful for writing Yacas scripts.

*CMD	/*, */, // --- comments
*CORE
*CALL
	/* comment */
	// comment

*DESC

Introduce a comment block in a source file, similar to C++ comments.
{//} makes everything until the end of the line a comment, while {/*} and {*/} may delimit a multi-line comment.

*E.G.

	a+b; // get result
	a + /* add them */ b;

*CMD Prog, [, ] --- block of statements
*CORE
*CALL
	Prog(statement1, statement2, ...)
	[ statement1; statement2; ... ]

*PARMS

{statement1}, {statement2} -- expressions

*DESC

The {Prog} and the {[ ... ]} construct have the same effect: they evaluate all
arguments in order and return the result of the last evaluated expression.

{Prog(a,b);} is the same as typing {[a;b;];} and is very useful for writing out
function bodies. The {[ ... ]} construct is a syntactically nicer version of the
{Prog} call; it is converted into {Prog(...)} during the parsing stage.



*CMD Bodied, Infix, Postfix, Prefix --- define function syntax
*CORE
*CALL
	Bodied("op", precedence)
	Infix("op")
	Infix("op", precedence)
	Postfix("op")
	Postfix("op", precedence)
	Prefix("op")
	Prefix("op", precedence)

*PARMS

{"op"} -- string, the name of a function

{precedence} -- nonnegative integer (evaluated)

*DESC

Declares a function for the parser to understand as a bodied, infix, postfix,
or prefix operator. Function name can be any string but meaningful usage would
require it to be either made up entirely of letters or entirely of non-letter
characters (such as "+", ":" etc.). Precedence can be specified (will be 0 by
default).

*E.G.
	In> YY x := x+1;
	CommandLine(1) : Error parsing expression
	
	In> Prefix("YY", 2)
	Out> True;
	In> YY x := x+1;
	Out> True;
	In> YY YY 2*3
	Out> 12;
	In> Infix("##", 5)
	Out> True;
	In> a ## b ## c
	Out> a##b##c;

*SEE IsBodied, OpPrecedence



*CMD IsBodied, IsInfix, IsPostfix, IsPrefix --- check for function syntax
*CORE
*CALL
	IsBodied("op")
	IsInfix("op")
	IsPostfix("op")
	IsPrefix("op")

*PARMS

{"op"} -- string, the name of a function

*DESC

Check whether the function with given name "op" has been declared as a
"bodied", infix, postfix, or prefix operator, and  return {True} or {False}.

*E.G.

	In> IsInfix("+");
	Out> True;
	In> IsBodied("While");
	Out> True;
	In> IsBodied("Sin");
	Out> False;
	In> IsPostfix("!");
	Out> True;

*SEE Bodied, OpPrecedence

*CMD OpPrecedence, OpLeftPrecedence, OpRightPrecedence --- get operator precedence
*CORE
*CALL
	OpPrecedence("op")
	OpLeftPrecedence("op")
	OpRightPrecedence("op")

*PARMS

{"op"} -- string, the name of a function

*DESC

Returns the precedence of the function named "op" which should have been declared as a bodied function or an infix, postfix, or prefix operator. Generates an error message if the string str does not represent a type of function that can have precedence.

For infix operators, right precedence can differ from left precedence. Bodied functions and prefix operators cannot have left precedence, while postfix operators cannot have right precedence; for these operators, there is only one value of precedence.

*E.G.
	In> OpPrecedence("+")
	Out> 6;
	In> OpLeftPrecedence("!")
	Out> 0;



*CMD RightAssociative --- declare associativity
*CORE
*CALL
	RightAssociative("op")

*PARMS

{"op"} -- string, the name of a function

*DESC
This makes the operator right-associative. For example:
	RightAssociative("*")
would make multiplication right-associative. Take care not to abuse this
function, because the reverse, making an infix operator left-associative, is
not implemented. (All infix operators are by default left-associative until
they are declared to be right-associative.)

*SEE OpPrecedence


*CMD LeftPrecedence, RightPrecedence --- set operator precedence
*CORE
*CALL
	LeftPrecedence("op",precedence)
	RightPrecedence("op",precedence)

*PARMS

{"op"} -- string, the name of a function

{precedence} -- nonnegative integer

*DESC

{"op"} should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display expressions like {a-(b-c)}
correctly. Thus, {a+b+c} is the same as {a+(b+c)}, but {a-(b-c)} is not
the same as {a-b-c}.

Note that the left and right precedence of an infix operator does not affect the way Yacas interprets expressions typed by the user. You cannot make Yacas parse {a-b-c} as {a-(b-c)} unless you declare the operator "{-}" to be right-associative.

*SEE OpPrecedence, OpLeftPrecedence, OpRightPrecedence, RightAssociative

*CMD RuleBase --- define function with a fixed number of arguments
*CORE
*CALL
	RuleBase(name,params)

*PARMS

{name} -- string, name of function

{params} -- list of arguments to function

*DESC
Define a new rules table entry for a
function "name", with {params} as the parameter list. Name can be
either a string or simple atom.

In the context of the transformation rule declaration facilities
this is a useful function in that it allows the stating of argument
names that can he used with HoldArg.

Functions can be overloaded: the same function can be defined
with different number of arguments.


*SEE MacroRuleBase, RuleBaseListed, MacroRuleBaseListed, HoldArg, Retract



*CMD RuleBaseListed --- define function with variable number of arguments
*CORE
*CALL
	RuleBaseListed("name", params)

*PARMS

{"name"} -- string, name of function

{params} -- list of arguments to function

*DESC

The command {RuleBaseListed} defines a new function. It essentially works the
same way as {RuleBase}, except that it declares a new function with a variable
number of arguments. The list of parameters {params} determines the smallest
number of arguments that the new function will accept. If the number of
arguments passed to the new function is larger than the number of parameters in
{params}, then the last argument actually passed to the new function will be a
list containing all the remaining arguments.

A function defined using {RuleBaseListed} will appear to have the arity equal
to the number of parameters in the {param} list, and it can accept any number
of arguments greater or equal than that. As a consequence, it will be impossible to define a new function with the same name and with a greater arity.

The function body will know that the function is passed more arguments than the
length of the {param} list, because the last argument will then be a list. The
rest then works like a {RuleBase}-defined function with a fixed number of
arguments. Transformation rules can be defined for the new function as usual.


*E.G.

The definitions

	RuleBaseListed("f",{a,b,c})
	10 # f(_a,_b,{_c,_d}) <--
	  Echo({"four args",a,b,c,d});
	20 # f(_a,_b,c_IsList) <--
	  Echo({"more than four args",a,b,c});
	30 # f(_a,_b,_c) <-- Echo({"three args",a,b,c});
give the following interaction:

	In> f(A)
	Out> f(A);
	In> f(A,B)
	Out> f(A,B);
	In> f(A,B,C)
	three args A B C 
	Out> True;
	In> f(A,B,C,D)
	four args A B C D 
	Out> True;
	In> f(A,B,C,D,E)
	more than four args A B {C,D,E} 
	Out> True;
	In> f(A,B,C,D,E,E)
	more than four args A B {C,D,E,E} 
	Out> True;

The function {f} now appears to occupy all arities greater than 3:

	In> RuleBase("f", {x,y,z,t});
	CommandLine(1) : Rule base with this arity
	  already defined


*SEE RuleBase, Retract, Echo


*CMD Rule --- define a rewrite rule
*CORE
*CALL
	Rule("operator", arity,
	  precedence, predicate) body
*PARMS

{"operator"} -- string, name of function

{arity}, {precedence} -- integers

{predicate} -- function returning boolean

{body} -- expression, body of rule

*DESC

Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". The "precedence" goes from low to high: rules with low precedence will be applied first.

The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.

Rules with a low precedence value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.

*CMD HoldArg --- mark argument as not evaluated
*CORE
*CALL
	HoldArg("operator",parameter)

*PARMS

{"operator"} -- string, name of a function

{parameter} -- atom, symbolic name of parameter

*DESC
Specify that parameter should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all {RuleBase} calls for this operator.
"operator" can be a string or atom specifying the 
function name.

The {parameter} must be an atom from the list of symbolic 
arguments used when calling {RuleBase}.

*SEE RuleBase, HoldArgNr, RuleBaseArgList

*CMD Retract --- erase rules for a function
*CORE
*CALL
	Retract("function",arity)

*PARMS
{"function"} -- string, name of function

{arity} -- positive integer

*DESC

Remove a rulebase for the function named {"function"} with the specific {arity}, if it exists at all. This will make
Yacas forget all rules defined for a given function. Rules for functions with
the same name but different arities are not affected.

Assignment {:=} of a function does this to the function being (re)defined.

*SEE RuleBaseArgList, RuleBase, :=

*CMD UnFence --- change local variable scope for a function
*CORE
*CALL
	UnFence("operator",arity)

*PARMS
{"operator"} -- string, name of function

{arity} -- positive integers

*DESC

When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and such).

The standard library functions {For} and {ForEach} use {UnFence}.

*CMD HoldArgNr --- specify argument as not evaluated
*STD
*CALL
	HoldArgNr("function", arity, argNum)

*PARMS
{"function"} -- string, function name

{arity}, {argNum} -- positive integers

*DESC

Declares the argument numbered {argNum} of the function named {"function"} with
specified {arity} to be unevaluated ("held"). Useful if you don't know symbolic
names of parameters, for instance, when the function was not declared using an
explicit {RuleBase} call. Otherwise you could use {HoldArg}.

*SEE HoldArg, RuleBase


*CMD RuleBaseArgList --- obtain list of arguments
*CORE
*CALL
	RuleBaseArgList("operator", arity)

*PARMS
{"operator"} -- string, name of function

{arity} -- integer

*DESC

Returns a list of atoms, symbolic parameters specified in the {RuleBase} call
for the function named {"operator"} with the specific {arity}.

*SEE RuleBase, HoldArgNr, HoldArg


*CMD MacroSet, MacroClear, MacroLocal, MacroRuleBase, MacroRuleBaseListed, MacroRule --- define rules in functions
*CORE
*DESC

These functions have the same effect as their non-macro counterparts, except
that their arguments are evaluated before the required action is performed.
This is useful in macro-like procedures or in functions that need to define new
rules based on parameters.

Make sure that the arguments of {Macro}... commands evaluate to expressions that would normally be used in the non-macro versions!

*SEE Set, Clear, Local, RuleBase, Rule, Backquoting

*A {`}
*CMD Backquoting --- macro expansion (LISP-style backquoting)
*CORE
*CALL
	`(expression)

*PARMS

{expression} -- expression containing "{@var}" combinations to substitute the value of variable "{var}"

*DESC

Backquoting is a macro substitution mechanism. A backquoted {expression}
is evaluated in two stages: first, variables prefixed by {@} are evaluated
inside an expression, and second, the new expression is evaluated.

To invoke this functionality, a backquote {`} needs to be placed in front of
an expression. Parentheses around the expression are needed because the
backquote binds tighter than other operators.

The expression should contain some variables (assigned atoms) with the special
prefix operator {@}. Variables prefixed by {@} will be evaluated even if they
are inside function arguments that are normally not evaluated (e.g. functions
declared with {HoldArg}). If the {@var} pair is in place of a function name,
e.g. "{@f(x)}", then at the first stage of evaluation the function name itself
is replaced, not the return value of the function (see example); so at the
second stage of evaluation, a new function may be called.

One way to view backquoting is to view it as a parametric expression
generator. {@var} pairs get substituted with the value of the variable {var}
even in contexts where nothing would be evaluated. This effect can be also
achieved using {UnList} and {Hold} but the resulting code is much more
difficult to read and maintain.

This operation is relatively slow since a new expression is built
before it is evaluated, but nonetheless backquoting is a powerful mechanism
that sometimes allows to greatly simplify code.

*E.G.

This example defines a function that automatically evaluates to a number as
soon as the argument is a number (a lot of functions  do this only when inside
a {N(...)} section).

	In> Decl(f1,f2) := \
	In>   `(@f1(x_IsNumber) <-- N(@f2(x)));
	Out> True;
	In> Decl(nSin,Sin)
	Out> True;
	In> Sin(1)
	Out> Sin(1);
	In> nSin(1)
	Out> 0.8414709848;

This example assigns the expression {func(value)} to variable {var}. Normally
the first argument of {Set} would be unevaluated.

	In> SetF(var,func,value) := \
	In>     `(Set(@var,@func(@value)));
	Out> True;
	In> SetF(a,Sin,x)
	Out> True;
	In> a
	Out> Sin(x);


*SEE MacroSet, MacroLocal, MacroRuleBase, Hold, HoldArg

*A object properties
*CMD SetExtraInfo, GetExtraInfo --- annotate objects with additional information
*CORE
*CALL
	SetExtraInfo(expr,tag)
	GetExtraInfo(expr)

*PARMS

{expr} -- any expression

{tag} -- tag information (any other expression)

*DESC

Sometimes it is useful to be able to add extra tag information to "annotate"
objects or to label them as having certain "properties". The functions
{SetExtraInfo} and {GetExtraInfo} enable this.

The function {SetExtraInfo} returns the tagged expression, leaving
the original expression alone. This means there is a common pitfall:
be sure to assign the returned value to a variable, or the tagged
expression is lost when the temporary object is destroyed.

The original expression is left unmodified, and the tagged expression
returned, in order to keep the atomic objects small. To tag an
object, a new type of object is created from the old object, with
one added property (the tag). The tag can be any expression whatsoever.

The function {GetExtraInfo(x)} retrieves this tag expression from an object
{x}. If an object has no tag, it looks the same as if it had a tag with value
{False}.

No part of the Yacas core uses tags in a way that is visible to the outside
world, so for specific purposes a programmer can devise a format to use for tag
information. Association lists (hashes) are a natural fit for this, although it
is not required and a tag can be any object (except the atom {False} because it
is indistinguishable from having no tag information). Using association lists
is highly advised since it is most likely to be the format used by other parts
of the library, and one needs to avoid clashes with other library code.
Typically, an object will either have no tag or a tag which is an associative
list (perhaps empty). A script that uses tagged objects will check whether an
object has a tag and if so, will add or modify certain entries of the
association list, preserving any other tag information.

Note that {FlatCopy} currently does <i>not</i> copy the tag information (see
examples).

*E.G.

	In> a:=2*b
	Out> 2*b;
	In> a:=SetExtraInfo(a,{{"type","integer"}})
	Out> 2*b;
	In> a
	Out> 2*b;
	In> GetExtraInfo(a)
	Out> {{"type","integer"}};
	In> GetExtraInfo(a)["type"]
	Out> "integer";
	In> c:=a
	Out> 2*b;
	In> GetExtraInfo(c)
	Out> {{"type","integer"}};
	In> c
	Out> 2*b;
	In> d:=FlatCopy(a);
	Out> 2*b;
	In> GetExtraInfo(d)
	Out> False;

*SEE Assoc, :=

*CMD GarbageCollect --- do garbage collection on unused memory
*CORE
*CALL
	GarbageCollect()

*DESC

{GarbageCollect} garbage-collects unused memory. The Yacas system
uses a reference counting system for most objects, so this call
is usually not necessary. 

Reference counting refers to bookkeeping where in each object a 
counter is held, keeping track of the number of parts in the system 
using that object. When this count drops to zero, the object is 
automatically removed. Reference counting is not the fastest way
of doing garbage collection, but it can be implemented in a very
clean way with very little code.

Among the most important objects that are not reference counted are
the strings. {GarbageCollect} collects these and disposes of them
when they are not used any more. 

{GarbageCollect} is useful when doing a lot of text processing,
to clean up the text buffers. It is not highly needed, but it keeps
memory use low.


*CMD FindFunction --- find the library file where a function is defined
*CORE
*CALL
	FindFunction(function)

*PARMS

{function} -- string, the name of a function

*DESC

This function is useful for quickly finding the file where a standard library
function is defined. It is likely to only be useful for developers. The
function {FindFunction} scans the {.def} files that were loaded at start-up.
This means that functions that are not listed in {.def} files will not be found with {FindFunction}.

*E.G.

	In> FindFunction("Sum")
	Out> "sums.rep/code.ys";
	In> FindFunction("Integrate")
	Out> "integrate.rep/code.ys";

*SEE Vi

*CMD Secure --- guard the host OS
*CORE
*CALL
	Secure(body)

*PARMS

{body} -- expression

*DESC

{Secure} evaluates {body} in a "safe" environment, where files cannot be opened
and system calls are not allowed. This can help protect the system
when e.g. a script is sent over the
Internet to be evaluated on a remote computer, which is potentially unsafe.

*SEE SystemCall

			Arbitrary-precision numerical programming

*INTRO This chapter contains functions that help programming numerical calculations with arbitrary precision.

*CMD MultiplyNum --- optimized numerical multiplication
*STD
*CALL
	MultiplyNum(x,y)
	MultiplyNum(x,y,z,...)
	MultiplyNum({x,y,z,...})

*PARMS

{x}, {y}, {z} -- integer, rational or floating-point numbers to multiply

*DESC
The function {MultiplyNum} is used to speed up multiplication of floating-point numbers with rational numbers. Suppose we need to compute $(p/q)*x$ where $p$, $q$ are integers and $x$ is a floating-point number. At high precision, it is faster to multiply $x$ by an integer $p$ and divide by an integer $q$ than to compute $p/q$ to high precision and then multiply by $x$. The function  {MultiplyNum} performs this optimization.

The function accepts any number of arguments (not less than two) or a list of numbers. The result is always a floating-point number (even if {Numeric} is not set).

*SEE MathMultiply

*CMD CachedConstant --- precompute multiple-precision constants
*STD
*CALL
	CachedConstant(cache, Cname, Cfunc)

*PARMS
{cache} -- atom, name of the cache

{Cname} -- atom, name of the constant

{Cfunc} -- expression that evaluates the constant

*DESC

This function is used to create precomputed multiple-precision values of
constants. Caching these values will save time if they are frequently used.

The call to {CachedConstant} defines a new function named {Cname()} that
returns the value of the constant at given precision. If the precision is
increased, the value will be recalculated as necessary, otherwise calling {Cname()} will take very little time.

The parameter {Cfunc} must be an expression that can be evaluated and returns
the value of the desired constant at the current precision. (Most arbitrary-precision mathematical functions do this by default.)

The associative list {cache} contains elements of the form {{Cname, prec, value}}, as illustrated in the example. If this list does not exist, it will be created.

This mechanism is currently used by {N()} to precompute the values of $Pi$ and $gamma$.
The name of the cache for {N()} is {CacheOfConstantsN}.
The code in the function {N()} assigns unevaluated calls to {Pi()} and {gamma()} to the atoms {Pi} and {gamma} and declares them {LazyGlobal}.
The result is that the constants will be recalculated only when they are used in the expression under {N()}.
In other words, the code in {N()} does the equivalent of
	Pi := Hold(Pi());
	gamma := Hold(gamma());
	LazyGlobal(Pi);
	LazyGlobal(gamma);
After this, evaluating an expression such as {1/2+gamma} will call the function {gamma()} but not the function {Pi()}.

*EG

	In> CachedConstant( my'cache, Ln2, LnNum(2) )
	Out> 0.6931471806;
	In> Ln2
	Out> Ln2;
	In> Ln2()
	Out> 0.6931471806;
	In> [ Precision(20); V( Ln2() ); ]
	CachedConstant: Info: constant Ln2 is being
	  recalculated at precision 20 
	Out> 0.69314718055994530942;
	In> my'cache
	Out> {{"Ln2",20,0.69314718055994530942}};


*SEE N, Pi(), Precision, gamma

*CMD NewtonNum --- low-level optimized Newton's iterations
*STD
*CALL
	NewtonNum(func, x0, prec0, order)
	NewtonNum(func, x0, prec0)
	NewtonNum(func, x0)

*PARMS

{func} -- a function specifying the iteration sequence

{x0} -- initial value (must be close enough to the root)

{prec0} -- initial precision (at least 4, default 5)

{order} -- convergence order (typically 2 or 3, default 2)

*DESC

This function is an optimized interface for computing Newton's
iteration sequences for numerical solution of equations in arbitrary precision.

{NewtonNum} will iterate the given function starting from the initial
value, until the sequence converges within current precision.
Initially, up to 5 iterations at the initial precision {prec0} is
performed (the low precision is set for speed). The initial value {x0}
must be close enough to the root so that the initial iterations
converge. If the sequence does not produce even a single correct digit
of the root after these initial iterations, an error message is
printed. The default value of the initial precision is 5.

The {order} parameter should give the convergence order of the scheme.
Normally, Newton iteration converges quadratically (so the default
value is {order}=2) but some schemes converge faster and you can speed
up this function by specifying the correct order. (Caution: if you give
{order}=3 but the sequence is actually quadratic, the result will be
silently incorrect. It is safe to use {order}=2.)

*REM
The verbose option {V} can be used to monitor the convergence. The
achieved exact digits should roughly form a geometric progression.

*EG

	In> Precision(20)
	Out> True;
	In> NewtonNum({{x}, x+Sin(x)}, 3, 5, 3)
	Out> 3.14159265358979323846;

*SEE Newton

*CMD SumTaylorNum --- optimized numerical evaluation of Taylor series
*STD
*CALL
	SumTaylorNum(x, NthTerm, order)
	SumTaylorNum(x, NthTerm, TermFactor, order)

*PARMS

{NthTerm} -- a function specifying $n$-th coefficient of the series

{x} -- number, value of the expansion variable

{TermFactor} -- a function specifying the ratio of $n$-th term to the previous one

{order} -- power of $x$ in the last term

*DESC

{SumTaylorNum} computes a Taylor series $Sum(k,0,n,a[k]*x^k)$
numerically. This function allows very efficient computations of
functions given by Taylor series, although some tweaking of the
parameters is required for good results.

The coefficients $a[k]$ of the Taylor series are given as functions of one integer variable ($k$). It is convenient to pass them to {SumTaylorNum} as closures.
For example, if a function {a(k)} is defined, then
	SumTaylorNum(x, {{k}, a(k)}, n)
computes the series $Sum(k, 0, n, a(k)*x^k)$.

Often a simple relation between successive coefficients $a[k-1]$,
$a[k]$ of the series is available; usually they are related by a
rational factor. In this case, the second form of {SumTaylorNum} should
be used because it will compute the series faster. The function
{TermFactor} applied to an integer $k>=1$ must return the ratio
$a[k]$/$a[k-1]$. (If possible, the function {TermFactor} should return
a rational number and not a floating-point number.) The function
{NthTerm} must also be given, but the current implementation only calls
{NthTerm(0)} and obtains all other coefficients by using {TermFactor}.

The algorithm is described in the essays. The number of terms {order}+1
must be specified and a sufficiently high precision must be set in
advance to achieve the desired accuracy.

*EG

To compute 20 digits of $Exp(1)$ using the Taylor series, one needs 21
digits of working precision and 21 terms of the series: 

	In> Precision(21)
	Out> True;
	In> SumTaylorNum(1, {{k},1/k!}, {{k},1/k}, 21)
	Out> 2.71828182845904523535;
	In> RoundTo(N(Ln(%)),20)
	Out> 1;


*SEE Taylor

			Error reporting

*INTRO
This chapter contains commands useful for reporting errors to the user.

*CMD Check --- report "hard" errors
*CORE
*CALL
	Check(predicate,"error text")

*PARMS

{predicate} -- expression returning {True} or {False}

{"error text"} -- string to print on error

*DESC
If {predicate} does not evaluate to {True},
the current operation will be stopped, the string {"error text"} will be printed, and control will be returned immediately to the command line. This facility can be used to assure that some condition
is satisfied during evaluation of expressions (guarding
against critical internal errors).

A "soft" error reporting facility that does not stop the execution is provided by the function {Assert}.

*EG

	In> [Check(1=0,"bad value"); Echo(OK);]
	In function "Check" : 
	CommandLine(1) : "bad value"

Note that {OK} is not printed.

*SEE Assert

*CMD Assert --- signal "soft" custom error
*STD
*CALL
	Assert("str", expr) pred
	Assert("str") pred
	Assert() pred
(bodied function, precedence 60000)
*PARMS

{pred} -- predicate to check

{"str"} -- string to classify the error

{expr} -- expression, error object

*DESC

{Assert} is a global error reporting mechanism. It can be used to check for
errors and report them. An error is considered to occur when the predicate
{pred} evaluates to anything except {True}. In this case, the function returns
{False} and an error object is created and posted to the global error tableau.
Otherwise the function returns {True}.

Unlike the "hard" error function {Check}, the function {Assert} does not stop
the execution of the program.

The error object consists of the string {"str"} and an arbitrary
expression {expr}. The string should be used to classify the kind of error that
has occurred, for example "domain" or "format". The error object can be any expression that might be useful for handling the error later;
for example, a list of erroneous values and explanations.
The association list of error objects is currently the global
variable {ErrorTableau}.

If the parameter {expr} is missing, {Assert} substitutes {True}. If both optional parameters {"str"} and {expr} are missing, {Assert} creates an error of class {"generic"}.

Errors can be handled by a
custom error handler in the portion of the code that is able to handle a certain class of
errors. The functions {IsError}, {GetError} and {ClearError} can be used.

Normally, all errors posted to the error tableau during evaluation of an expression should
be eventually printed to the screen. This is the behavior of prettyprinters
{DefaultPrint}, {Print}, {PrettyForm} and {TeXForm}; they call {DumpErrors} after evaluating the expression.

*E.G.

	In> Assert("bad value", "must be zero") 1=0
	Out> False;
	In> Assert("bad value", "must be one") 1=1
	Out> True;
	In> IsError()
	Out> True;
	In> IsError("bad value")
	Out> True;
	In> IsError("bad file")
	Out> False;
	In> GetError("bad value");
	Out> "must be zero";
	In> DumpErrors()
	Error: bad value: must be zero
	Out> True;
No more errors left:
	In> IsError()
	Out> False;
	In> DumpErrors()
	Out> True;

*SEE IsError, DumpErrors, Check, GetError, ClearError, ClearErrors

*CMD DumpErrors, ClearErrors --- simple error handlers
*STD
*CALL
	DumpErrors()
	ClearErrors()

*DESC

{DumpErrors} is a simple error handler for the global error reporting mechanism. It prints all errors posted using {Assert} and clears the error tableau.

{ClearErrors} is a trivial error handler that does nothing except it clears the tableau.

*SEE Assert, IsError

*CMD IsError --- check for custom error
*STD
*CALL
	IsError()
	IsError("str")

*PARMS

{"str"} -- string to classify the error

*DESC

{IsError()} returns {True} if any custom errors have been reported using {Assert}.
The second form takes a parameter {"str"} that designates the class of the
error we are interested in. It returns {True} if any errors of the given class
{"str"} have been reported.

*SEE GetError, ClearError, Assert, Check


*CMD GetError, ClearError --- custom errors handlers
*STD
*CALL
	GetError("str")
	ClearError("str")

*PARMS

{"str"} -- string to classify the error

*DESC

These functions can be used to create a custom error handler.

{GetError} returns the error object if a custom error of class {"str"} has been
reported using {Assert}, or {False} if no errors of this class have been
reported.

{ClearError("str")} deletes the same error object that is returned by
{GetError("str")}. It deletes at most one error object. It returns {True} if an
object was found and deleted, and {False} otherwise.


*E.G.

	In> x:=1
	Out> 1;
	In> Assert("bad value", {x,"must be zero"}) x=0
	Out> False;
	In> GetError("bad value")
	Out> {1, "must be zero"};
	In> ClearError("bad value");
	Out> True;
	In> IsError()
	Out> False;

*SEE IsError, Assert, Check, ClearErrors

*CMD CurrentFile, CurrentLine --- show current file and line of input
*CORE
*CALL
	CurrentFile()
	CurrentLine()

*DESC

The functions {CurrentFile} and {CurrentLine} return a string
with the file name of the current file and the current line 
of input respectively.

These functions are most useful in batch file calculations, where
there is a need to determine at which line an error occurred.
One can define a function 

	tst() := Echo({CurrentFile(),CurrentLine()});
which can then be inserted into the input file at various places,
to see how far the interpreter reaches before an error occurs.

*SEE Echo


			Built-in (core) functions

*INTRO
Yacas comes with a small core of built-in functions and a large library of
user-defined functions. Some of these core functions are documented in this
chapter.




It is important for a developer to know which functions are built-in and cannot
be redefined or {Retract}-ed. Also, core functions may be somewhat faster to
execute than functions defined in the script library. All core functions are
listed in the file {yacasapi.cpp} in the {src/} subdirectory of the Yacas
source tree. The declarations typically look like this:

	SetCommand(LispSubtract, "MathSubtract");
Here {LispSubtract} is the Yacas internal name for the function and {MathSubtract} is the name visible to the Yacas language.
Built-in bodied functions and infix operators are declared in the same file.

*CMD MathNot --- built-in logical "not"
*CORE
*CALL
	MathNot(expression)

*DESC

Returns "False" if "expression" evaluates
to "True", and vice versa.

*CMD MathAnd --- built-in logical "and"

*CALL
	MathAnd(...)

*DESC
Lazy logical {And}: returns {True} if all args evaluate to
{True}, and does this by looking at first, and then at the
second argument, until one is {False}.
If one of the arguments is {False}, {And} immediately returns {False} without
evaluating the rest. This is faster, but also means that none of the
arguments should cause side effects when they are evaluated.

*CMD MathOr --- built-in logical "or"
*CORE
*CALL
	MathOr(...)

{MathOr} is the basic logical "or" function. Similarly to {And}, it is
lazy-evaluated. {And(...)} and {Or(...)} do also exist, defined in the script
library. You can redefine them as infix operators yourself, so you have the
choice of precedence. In the standard scripts they are in fact declared as
infix operators, so you can write {expr1 And expr}.

*CMD BitAnd, BitOr, BitXor --- bitwise arithmetic
*CORE
*CALL
	BitAnd(n,m)
	BitOr(n,m)
	BitXor(n,m)

*DESC
These functions return bitwise "and", "or" and "xor"
of two numbers.

*CMD Equals --- check equality
*CORE
*CALL
	Equals(a,b)

*DESC
Compares evaluated {a} and {b} recursively
(stepping into expressions). So "Equals(a,b)" returns
"True" if the expressions would be printed exactly
the same, and "False" otherwise.

*CMD GreaterThan, LessThan --- comparison predicates
*CORE
*CALL
	LessThan(a,b), GreaterThan(a,b)

*PARMS
{a}, {b} -- numbers or strings
*DESC
Comparing numbers or strings (lexicographically).

*EG
	In> LessThan(1,1)
	Out> False;
	In> LessThan("a","b")
	Out> True;


*A {MathExp}
*A {MathLog}
*A {MathPower}
*A {MathSin}
*A {MathCos}
*A {MathTan}
*A {MathArcSin}
*A {MathArcCos}
*A {MathArcTan}
*A {MathGcd}
*A {MathAdd}
*A {MathSubtract}
*A {MathMultiply}
*A {MathDivide}
*A {MathSqrt}
*A {MathFloor}
*A {MathCeil}
*A {MathAbs}
*A {MathMod}
*A {MathDiv}
*CMD Math... --- arbitrary-precision math functions
*CORE
*CALL
*REM these are not made into code examples to save space

MathGcd(n,m)  (Greatest Common Divisor),
MathAdd(x,y),
MathSubtract(x,y),
MathMultiply(x,y),
MathDivide(x,y),
MathSqrt(x)  (square root),
MathFloor(x), MathCeil(x),
MathAbs(x),
MathExp(x), MathLog(x) (natural logarithm),
MathPower(x,y),
MathSin(x), MathCos(x), MathTan(x),
MathArcSin(x), MathArcCos(x), MathArcTan(x),
MathDiv(x,y), MathMod(x,y)

*DESC

Calculation of sin, cos, tan and other mathematical functions.
The argument <i>must</i>
be a number. The reason for the prefix {Math} is that
the library needs to define equivalent
non-numerical functions for symbolic computations, such as {Exp}, {Sin} and so on.

*A {FastExp}
*A {FastLog}
*A {FastPower}
*A {FastSin}
*A {FastCos}
*A {FastTan}
*A {FastArcSin}
*A {FastArcCos}
*A {FastArcTan}
*CMD Fast... --- double-precision math functions
*CORE
*CALL
*REM these are not made into code examples to save space

FastExp(x), FastLog(x) (natural logarithm),
FastPower(x,y),
FastSin(x), FastCos(x), FastTan(x),
FastArcSin(x), FastArcCos(x), FastArcTan(x)

*DESC
Versions of these functions using the C++ library. These
should then at least be faster than the arbitrary precision versions.

*CMD ShiftLeft, ShiftRight --- built-in bit shifts
*CORE
*CALL
	ShiftLeft(expr,bits)
	ShiftRight(expr,bits)

*DESC

Shift bits to the left or to the right.


*CMD IsUnix --- check if running under Unix
*CORE
*CALL
	IsUnix()
*DESC
Returns {True} if Yacas has been compiled under a Unix-like environment, and {False} otherwise (i.e. Windows).

*CMD IsPromptShown --- test for the Yacas prompt option
*CORE
*CALL
	IsPromptShown()
*DESC
Returns {False} if Yacas has been started with the option to suppress the prompt, and {True} otherwise.

*CMD MathLibrary --- obtain current math library name
*CORE
*CALL
	MathLibrary()
*DESC
Returns a string that describes the currently used arbitrary-precision arithmetic library name.

Possible names are {"Internal"} and {"Gmp"}, indicating the internal math library {libyacasnumbers} and the GNU Multiple Precision library {libgmp}.

*EG
	In>  MathLibrary()
	Out> "Internal";



		Full listing of core functions

The following Yacas functions are currently declared in {yacasapi.cpp}
as core functions:
*A core functions, listing of
*REM yacasapi.chapt is generated from yacasapi.cpp

*INCLUDE yacasapi.chapt




			The Yacas plugin structure

*INTRO
Yacas supports dynamically loading libraries at runtime. This chapter describes functions for working with plugins.


The plugin feature allows Yacas to interface with other libraries that support
additional functionality. For example, there could be a plugin enabling the
user to script a user interface from within Yacas, or a specific powerful
library to do numeric calculations.

The plugin feature is currently in an experimental stage. There
are some examples in the {plugins/} directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The {plugins/} directory
contains a {README} file with more details on compilation.

In addition to the plugin structure in the Yacas engine, there is
a module {cstubgen} (currently still under development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. The module {cstubgen} is then
able to write out a C++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the {plugins/}
directory (the files ending with api.stub). The file
{makefile.plugin} is configured to automatically convert these to
the required C++ files. See also an essay on plugins for a worked-out example.

In addition to the C++ stub file, {cstubgen} also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.

The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(Loading DLLs is platform-dependent).

This chapter assumes the reader is comfortable programming in C++.


*CMD DllLoad, DllUnload, DllEnumerate --- manipulate plugins
*CORE
*CALL
	DllLoad(file)
	DllUnload(file)
	DllEnumerate()

*PARMS
{file} -- file name of the plugin

*DESC

{DllLoad} forces Yacas to load the dynamic link library ({.so} file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where {dlopen} can find it.

{DllUnload} unloads a dynamic link library previously loaded with
{DllLoad}. Note the dll file name has to be exactly the same,
or the system will not be able to determine which dll to unload.
It will scan all the dll files, and delete the first one found
to exactly match, and return silently if it didn't find the dll.
{DllUnload} always returns {True}.

{DllEnumerate} returns a list with all loaded dynamic link libraries.

*EG

	In> DllLoad("./libopengl.so");
	Out> True;

*SEE

*CMD StubApiCStart --- start of C++ plugin API
*STD
*CALL
	StubApiCStart()

*DESC

To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub C++ file.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCShortIntegerConstant --- declare integer constant in plugin
*STD
*CALL
	StubApiCShortIntegerConstant(const,value)

*PARMS

{const} -- string representing the global variable to be bound runtime

{value} -- integer value the global should be bound to

*DESC

define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define
	#define FOO 10
Then
	StubApiCShortIntegerConstant("FOO","FOO")
will bind the global variable FOO to the value for FOO defined in
the library header file.

*SEE StubApiCStart, StubApiCInclude, StubApiCFunction, StubApiCFile, StubApiCSetEnv



*CMD StubApiCInclude --- declare include file in plugin
*STD
*CALL
	StubApiCInclude(file)

*PARMS

{file} -- file to include from the library the plugin is based on

*DESC

Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for OpenGL, you need to specify
	StubApiCInclude("\<GL/gl.h\>")
and for user include file:
	StubApiCInclude("\"GL/gl.h\"")

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCFunction, StubApiCFile, StubApiCSetEnv

*CMD StubApiCFunction --- declare C++ function in plugin
*STD
*CALL
	StubApiCFunction(returntype,fname,args)
	StubApiCFunction(returntype,fname,
	  fname2,args)

*PARMS

{returntype} -- return type of new function

{fname} -- function of built-in function

{fname2} -- (optional) function name to be used from within Yacas

{args} -- list of arguments to the function

*DESC

This function declares a new library function, along with its
calling sequence. {cstubgen} will then generate the C++ code
required to call this function.

Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).

If {fname2} is not supplied, it will be assumed to be the same as fname.

The return types currently supported are "{int}", "{double}" and "{void}".

The argument values that are currently supported
are "{int}", "{double}", and "{input_string}".

Argument types can be specified simply as a string referring to their
type, like {"int"}, or they can be lists with an additional element
stating the name of the variable: {{"int","n"}}. The variable
will then show up in the automatically generated documentation as
having the name "n".

*E.G.

To define an OpenGL function {glVertex3d} that accepts three
doubles and returns void:

	StubApiCFunction("void","glVertex3d",
	  {"double","double","double"});

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFile, StubApiCSetEnv

*CMD StubApiCRemark --- documentation string in plugin
*STD
*CALL
	StubApiCRemark(string)

*PARMS

{string} -- comment string to be added to the documentation

*DESC

StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a {.description} file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.

*SEE StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv, StubApiCFile

*CMD StubApiCSetEnv --- access Yacas environment in plugin
*STD
*CALL
	StubApiCSetEnv(func)

*PARMS

{func} -- name of the function to call to set the environment variable

*DESC

This function forces the plugin to call the function func, with as
argument {LispEnvironment&} {aEnvironment}. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.

There needs to ba a function in the plugin somewhere of the form

	static LispEnvironment* env = NULL;
	void GlutSetEnv(LispEnvironment& aEnv)
	{
	    env = &aEnv;
	}
Then calling
	StubApiCSetEnv("GlutSetEnv");
will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCFile

*CMD StubApiCFile --- set file name for plugin API
*STD
*CALL
	StubApiCFile(basename)

*PARMS

{basename} -- name for the generation of the stub file

*DESC

Generate the C++ stub file, "basename.cc", and a documentation file
named "basename.description". The descriptions are automatically
generated while adding functions and constants to the stub.

*SEE StubApiCStart, StubApiCShortIntegerConstant, StubApiCInclude, StubApiCFunction, StubApiCSetEnv

*CMD StubApiCStruct --- declare C struct in plugin
*STD
*CALL
	StubApiCStruct(name)
	StubApiCStruct(name,freefunction)

*PARMS

{name} -- name of structure

{freefunction} -- function that can be called to clean up the object

*DESC

StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.

By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.

*E.G.

In a library header file, define:

	typedef struct SomeStruct
	{
	  int a;
	  int b;
	} SomeStruct;
Then in the stub file you can declare this struct by calling:

	StubApiCStruct("SomeStruct*")

*SEE StubApiCFunction


			Generic objects

*INTRO Generic objects are objects that are implemented in C++, but
can be accessed through the Yacas interpreter.

*CMD IsGeneric --- check for generic object
*CORE
*CALL
	IsGeneric(object)

*DESC
Returns {True} if an object is of a generic object
type.

*CMD GenericTypeName --- get type name
*CORE
*CALL
	GenericTypeName(object)

*DESC
Returns a string representation of
the name of a generic object.

EG

	In> GenericTypeName(ArrayCreate(10,1))
	Out> "Array";

*CMD ArrayCreate --- create array
*CORE
*CALL
	ArrayCreate(size,init)

*DESC
Creates an array with {size} elements, all initialized to the
value {init}.

*CMD ArraySize --- get array size
*CORE
*CALL
	ArraySize(array)

*DESC
Returns the size of an array (number of elements in the array).

*CMD ArrayGet --- fetch array element
*CORE
*CALL
	ArrayGet(array,index)

*DESC
Returns the element at position index in the array passed. Arrays are treated
as base-one, so {index} set to 1 would return the first element.

Arrays can also be accessed through the {[]} operators. So
{array[index]} would return the same as {ArrayGet(array, index)}.

*CMD ArraySet --- set array element
*CORE
*CALL
	ArraySet(array,index,element)

*DESC
Sets the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so {index} set to 1 would set first element.

Arrays can also be accessed through the {[]} operators. So
{array[index] := element} would do the same as {ArraySet(array, index,element)}.

*CMD ArrayCreateFromList --- convert list to array
*CORE
*CALL
	ArrayCreateFromList(list)

*DESC
Creates an array from the contents of the list passed in.

*CMD ListFromArray --- convert array to list
*CORE
*CALL
	ListFromArray(array)

*DESC
Creates a list from the contents of the array passed in.



			The Yacas test suite

*INTRO This chapter describes commands used for verifying correct performance
of Yacas.

Yacas comes with a test suite which can be found in
the directory {tests/}. Typing 
	make test
on the command line after Yacas was built will run the test.
This test can be run even before {make install}, as it only 
uses files in the local directory of the Yacas source tree.
The default extension for test scripts is {.yts} (Yacas test script).

The verification commands described in this chapter only  display the
expressions that do not evaluate correctly. Errors do not terminate the
execution of the Yacas script that uses these testing commands, since they are
meant to be used in test scripts.


*CMD Verify, TestYacas, LogicVerify --- verifying equivalence of two expressions
*STD
*CALL
	Verify(question,answer)
	TestYacas(question,answer)
	LogicVerify(question,answer)

*PARMS

{question} -- expression to check for

{answer} -- expected result after evaluation

*DESC

The commands {Verify}, {TestYacas}, {LogicVerify} can be used to verify that an
expression is <I>equivalent</I> to  a correct answer after evaluation. All
three commands return {True} or {False}.

For some calculations, the demand that two expressions
are <I>identical</I> syntactically is too stringent. The 
Yacas system might change at various places in the future,
but $ 1+x $ would still be equivalent, from a mathematical
point of view, to $ x+1 $.

The general problem of deciding that two expressions $ a $ and $ b $
are equivalent, which is the same as saying that $ a-b=0 $ , 
is generally hard to decide on. The following commands solve
this problem by having domain-specific comparisons.

The comparison commands do the following comparison types:

*	{Verify} -- verify for literal equality. 
This is the fastest and simplest comparison, and can be 
used, for example, to test that an expression evaluates to $ 2 $.
*	{TestYacas} -- compare two expressions after simplification as 
multivariate polynomials. If the two arguments are equivalent
multivariate polynomials, this test succeeds. {TestYacas} uses {Simplify}. Note: {TestYacas} currently should not be used to test equality of lists.
*	{LogicVerify} -- Perform a test by using {CanProve} to verify that from 
{question} the expression {answer} follows. This test command is 
used for testing the logic theorem prover in Yacas.

*E.G.

	In> Verify(1+2,3)
	Out> True;
	In> Verify(x*(1+x),x^2+x)
	******************
	x*(x+1) evaluates to x*(x+1) which differs
	  from x^2+x
	******************
	Out> False;
	In> TestYacas(x*(1+x),x^2+x)
	Out> True;
	In> Verify(a And c Or b And Not c,a Or b)
	******************
	 a And c Or b And Not c evaluates to  a And c
	  Or b And Not c which differs from  a Or b
	******************
	Out> False;
	In> LogicVerify(a And c Or b And Not c,a Or b)
	Out> True;
	In> LogicVerify(a And c Or b And Not c,b Or a)
	Out> True;

*SEE Simplify, CanProve, KnownFailure


*CMD KnownFailure --- Mark a test as a known failure
*STD
*CALL
	KnownFailure(test)

*PARMS

{test} -- expression that should return {False} on failure

*DESC

The command {KnownFailure} marks a test as known to fail
by displaying a message to that effect on screen. 

This might be used by developers when they have no time
to fix the defect, but do not wish to alarm users who download
Yacas and type {make test}.

*E.G.

	In> KnownFailure(Verify(1,2))
	Known failure:
	******************
	 1 evaluates to  1 which differs from  2
	******************
	Out> False;
	In> KnownFailure(Verify(1,1))
	Known failure:
	Failure resolved!
	Out> True;

*SEE Verify, TestYacas, LogicVerify

*CMD RoundTo --- Round a real-valued result to a set number of digits
*STD
*CALL
	RoundTo(number,precision)

*PARMS

{number} -- number to round off

{precision} -- precision to use for round-off

*DESC

The function {RoundTo} rounds a floating point number to a
specified precision, allowing for testing for correctness
using the {Verify} command.

*E.G.

	In> N(RoundTo(Exp(1),30),30)
	Out> 2.71828182110230114951959786552;
	In> N(RoundTo(Exp(1),20),20)
	Out> 2.71828182796964237096;

*SEE Verify, VerifyArithmetic, VerifyDiv



*CMD VerifyArithmetic, VerifyDiv --- Special purpose arithmetic verifiers
*STD
*CALL
	VerifyArithmetic(x,n,m)
	RandVerifyArithmetic(n)
	VerifyDiv(u,v)

*PARMS

{x}, {n}, {m}, {u}, {v} -- integer arguments

*DESC

The commands {VerifyArithmetic} and {VerifyDiv} test a 
mathematic equality which should hold, testing that the
result returned by the system is mathematically correct
according to a mathematically provable theorem.

{VerifyArithmetic} verifies for an arbitrary set of numbers
$ x $, $ n $ and $ m $ that
$$ (x^n-1)*(x^m-1) = x^(n+m)-(x^n)-(x^m)+1 $$.

The left and right side represent two ways to arrive at the
same result, and so an arithmetic module actually doing the
calculation does the calculation in two different ways. 
The results should be exactly equal.

{RandVerifyArithmetic(n)} calls {VerifyArithmetic} with
random values, {n} times.

{VerifyDiv(u,v)} checks that 
$$ u = v*Div(u,v) + Mod(u,v) $$.


*E.G.

	In> VerifyArithmetic(100,50,60)
	Out> True;
	In> RandVerifyArithmetic(4)
	Out> True;
	In> VerifyDiv(x^2+2*x+3,x+1)
	Out> True;
	In> VerifyDiv(3,2)
	Out> True;

*SEE Verify




*REM GNU Free Documentation License
*INCLUDE FDL.chapt
