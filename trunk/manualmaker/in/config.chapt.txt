
			Startup configuration

*INTRO
Yacas allows you to configure a few things at startup. The file
{~/.yacasrc} is written in the Yacas language and
will be executed when Yacas is run. The
following functions can be useful in the {~/.yacasrc} file.

*CMD DefaultDirectory --- add directory to path for Yacas scripts
*CORE
*CALL
	DefaultDirectory(path)

*PARMS

{path} -- a string containing a full path where yacas script files reside

*DESC

When loading files, yacas is also allowed to
look in the folder "path". {path} will be prepended
to the file name before trying to load the file.
This means that "path" should end with a forward slash (under Unix-like
operating systems).

Yacas first tries to load a file from the current
directory, and otherwise it tries to load from
directories defined with this function, in the
order they are defined. Note there will be at least one directory
specified at start-up time, defined during compilation. This
is the directory Yacas searches for the initialization scripts
and standard scripts.

*E.G.

	In> DefaultDirectory("/home/user/myscripts/");
	Out> True;

*SEE Load, Use, DefLoad, FindFile

*CMD PrettyPrinter --- set routine to use as pretty-printer

*STD

*CALL
	PrettyPrinter(printer)

*PARMS

{printer} -- a string containing the name of a function that can
"pretty-print" an expression

*DESC

This function sets up the function printer to print out the results on
the command line. This can be reset to the internal printer with {PrettyPrinter()}.

*E.G.

	In> Taylor(x,0,5)Sin(x)
	Out> x-x^3/6+x^5/120;
	In> PrettyPrinter("PrettyForm");
	
	True
	
	In> Taylor(x,0,5)Sin(x)
	
	     3    5
	    x    x
	x - -- + ---
	    6    120
	
	In> PrettyPrinter();
	Out> True;
	In> Taylor(x,0,5)Sin(x)
	Out> x-x^3/6+x^5/120;

*SEE PrettyForm, Write

*CMD Help --- get documentation for some command
*STD
*CALL
	Help()
	Help(function)

*PARMS

{function} -- a string containing the name of a function to show help for

*DESC

When help is requested by the user, by typing {?}function or {??}, the functions {Help()} (for {??}) and {Help(}function{)} (for {?}function) are called.  By default, {lynx} is used as a
browser (another recommended text-only browser is {links}). The help resides in the subdirectory {documentation/} under the directory the math scripts
were installed in. So the help files can be found using {FindFile}.

The function {Help} is auxiliary and should not be used to actually get online help.

*E.G.

To use netscape for browsing help, enter the following commands:

	Help(_f) <-- SystemCall("netscape " :
	  FindFile("documentation/ref.html"):"#":f);
	Help() := SystemCall("netscape " :
	  FindFile("documentation/books.html"));

*SEE SystemCall, FindFile

*CMD HistorySize --- set size of history file
*CORE
*CALL
	HistorySize(n)

*PARMS

{n} -- number of lines to store in history file

*DESC

When exiting, yacas saves the command line history to a
file {~/.yacas_history}. By default it will only
save the last 50 lines, to save space on the hard disk. This can be
overridden with this function. Passing -1 tells the system to save <i>all</i>
lines.

*E.G.

	In> HistorySize(200)
	Out> True;
	In> quit

*CMD Assert --- signal custom error on algorithmic failure
*STD
*CALL
	Assert(pred) "str"
	Assert(pred, "str") expr

*PARMS

{pred} -- predicate to check

{"str"} -- string to classify the error

{expr} -- expression, error object

*DESC

{Assert} is a global error reporting mechanism. It can be used to check for
errors and report them. An error is considered to occur when the predicate
{pred} evaluates to anything except {True}. In this case, the function returns
{False} and an error object is created and posted to the global error tableau.
Otherwise the function returns {True}.

Unlike the "hard" error function {Check}, the function {Assert} does not stop
the execution of the program.

The error object consists of the string {"str"} and optionally an arbitrary
expression {expr}. The string should be used to classify the kind of error that
has occurred. The association list of error objects is currently the global
variable {ErrorTableau}.

Errors can be handled using the functions {IsError} and {DumpErrors} or by a
custom error handler in the function that is able to handle a certain class of
errors. Normally, all errors posted during evaluation of an expression should
be eventually printed to the screen. This is the behavior of prettyprinters
{PrettyForm} and {TeXForm} which use {DumpErrors}.

*E.G.

	In> Assert(1=0, "bad value") "must be zero"
	Out> False;
	In> Assert(1=1, "bad value") "must be one"
	Out> True;
	In> DumpErrors()
	Error: value: must be zero
	Out> True;
	In> DumpErrors()
	Out> True;

*SEE IsError, DumpErrors, Check

*CMD DumpErrors, ClearErrors --- custom error handlers
*STD
*CALL
	DumpErrors()
	ClearErrors()

*DESC

{DumpErrors} is a simple error handler for the global error reporting mechanism. It prints all errors posted using {Assert} and clears the error tableau.

{ClearErrors} is a trivial error handler that does nothing except it clears the tableau.

*SEE Assert, IsError

*CMD IsError --- check for custom error
*STD
*CALL
	IsError()

*DESC

This predicate returns {True} if any custom errors have been reported using {Assert}.

*SEE IsError, Assert, Check
