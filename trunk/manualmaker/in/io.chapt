
Chapter()"Input/Output";

ChapterIntro("
This chapter contains command to use for input and output. All output
commands write to the same destination, called the \"current
output\". This is initially the screen, but the current output is
redirected by some commands. Similarly, most input commands
read from the \"current input\", which can also be redirected. The
exception to this rule are the commands for reading in script files,
which simply read  the specified file.");



CmdDescription("FullForm", "Print an expression in LISP-format");
BuiltIn();

Topical() "Calling Sequence";
Text() "FullForm(expr)";

Topical() "Parameters";
Text() "expr - The expression to be printed in LISP-format";

Topical() "Description";
Text() 
"Evaluates \"expr\", and prints it in LISP-format on the current
output. It is followed by a newline. The evaluated expression is also
returned. 

This can be useful if you want to study the internal representation of
a certain expression.
";

Topical() "Examples";
Text() HtmlCommand(
"In> FullForm(a+b+c);
(+ (+ a b )c )
Out> a+b+c;
In> FullForm(2*I*b^2);
(* (Complex 0 2 )(^ b 2 ))
Out> Complex(0,2)*b^2;
") :
"The first example shows how the expression ":HtmlTerm("a+b+c"):" is
internally represented. In the second example, ":HtmlTerm("2*I"):" is
first evaluated to ":HtmlTerm("Complex(0,2)"):" before the expression
is printed.";

Topical() "See Also";
SeeAlso({"LispRead", "Listify", "Unlist"});



/* Pending my bug report */
CmdDescription("Echo", "High-level printing routine");
StandardLib();

Topical() "Calling Sequence";
Text() 
"Echo(item) <br>
Echo(list)";

Topical() "Parameters";
Text()
"item - the item to be printed <br>
list - a list of items to be printed";

Topical() "Description";
Text()
"If passed a single item, Echo will evaluate it and print it to the
current output, followed by a newline. If \"item\" is a string, it is
printed without quotation marks. <P> </P>
If the second calling sequence is used, Echo will print all the
entries in the list subsequently to the current output, followed by a
newline. Any strings in the list are printed without quotation
marks. All other entries are followed by a space.<P> </P>
Echo always returns True.";

Topical() "Examples";
Text() HtmlCommand(
"In> Echo(5+3);
 8 
Out> True;
In> Echo({\"The square of two is \", 2*2});
The square of two is  4 
Out> True;") : "<P> </P>
Note that one must use the second calling sequence if one wishes to
print a list:" : 
HtmlCommand(
"In> Echo({a,b,c});
a  b  c 
Out> True;
In> Echo({{a,b,c}});
{a,b,c} 
Out> True;");

Topical() "See Also";
SeeAlso({"PrettyForm", "Write", "WriteString"});



CmdDescription("PrettyForm", "Print an expression nicely with ASCII art");
StandardLib();

Topical()"Calling Sequence";
Text()"PrettyForm(expr)";

Topical()"Parameters";
Text()"expr - an expression";

Topical()"Description";
Text()
"PrettyForm renders an expression in a nicer way, using ascii art.
This is generally useful when the result of a calculation is more
complex than a simple number.
";

Topical()"Examples";
Text()
HtmlCommand(
"In> Taylor(x,0,9)Sin(x)
Out> x-x^3/6+x^5/120-x^7/5040+x^9/362880;
In> PrettyForm(%)

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

Out> True;
");

Topical()"See Also"; 
SeeAlso({"EvalFormula","PrettyPrinter"});



CmdDescription("EvalFormula", "Print an evaluation nicely with ASCII art");
StandardLib();

Topical()"Calling Sequence";
Text() "EvalFormula(expr)";

Topical()"Parameters";
Text()"expr - an expression";

Topical()"Description";
Text()
"Show an evaluation in a nice way, using PrettyPrinter
to show 'input = output'.";

Topical()"Examples";
Text()
HtmlCommand("
In&gt EvalFormula(Taylor(x,0,7)Sin(x)) 

                                      3    5      7 
                                     x    x      x  
Taylor( x , 0 , 7 , Sin( x ) ) = x - -- + --- - ----
                                     6    120   5040

Out&gt True 
");

Topical()"See Also"; 
SeeAlso({"PrettyForm"});



CmdDescription("Write", "Low-level printing routine");
BuiltIn();

Topical() "Calling Sequence";
Text() "Write(expr, ...)";

Topical() "Parameters";
Text() "expr - the expression to be printed";

Topical() "Description";
Text() "
The expression \"expr\" is evaluated and written to the current
output. Note that Write accept an arbitrary number of arguments, all
of which are written to the current output (see second
example). Write always returns True.";

Topical() "Examples";
Text() HtmlCommand("
In> Write(1);
1Out> True;
In> Write(1,2);
 1 2Out> True;") : "
Write does not write a newline, so the " : HtmlTerm("Out>") : " prompt
immediately follows the output of Write.";

Topical() "See Also";
SeeAlso({"Echo", "WriteString"});



CmdDescription("WriteString", "Low-level printing routine for strings");
BuiltIn();

Topical() "Calling Sequence";
Text() "WriteString(string)";

Topical() "Parameters";
Text() "string - the string to be printed";

Topical() "Description";
Text() "
The expression \"string\" is evaluated and written to the current
output without quotation marks. The argument should be a
string. WriteString always returns True.";

Topical() "Examples";
Text() HtmlCommand("
In> Write(\"Hello, world!\");
\"Hello, world!\"Out> True;
In> WriteString(\"Hello, world!\");
Hello, world!Out> True;
") : "
This example clearly shows the difference between Write and
WriteString. Note that Write and WriteString do not write a newline,
so the " : HtmlTerm("Out>") : " prompt immediately follows the output.";

Topical() "See Also";
SeeAlso({"Echo", "Write"});



CmdDescription("Space", "Print one or more spaces");
StandardLib();

Topical() "Calling Sequence";
Text() "
Space() <br>
Space(nr)";

Topical() "Parameters";
Text() "nr - the number of spaces to print";

Topical() "Description";
Text() "
The command " : HtmlTerm("Space()") : " prints one space on the
current output. The second form prints \"nr\" spaces on the current
output. The result is always True.";

Topical() "Examples";
Text() HtmlCommand("
In> Space(5);
     Out> True;
");

Topical() "See Also";
SeeAlso({"Echo", "Write", "NewLine"});



CmdDescription("NewLine", "Print one or more newline characters");
StandardLib();

Topical() "Calling Sequence";
Text() "
NewLine() <br>
NewLine(nr)";

Topical() "Parameters";
Text() "nr - the number of newlines to print";

Topical() "Description";
Text() "
The command " : HtmlTerm("NewLine()") : " prints one newline character
on the current output. The second form prints \"nr\" newlines on the
current output. The result is always True.";

Topical() "Examples";
Text() HtmlCommand("
In> NewLine();
     
Out> True;
");

Topical() "See Also";
SeeAlso({"Echo", "Write", "Space"});



CmdDescription("FromFile", "Connect current input to a file");
BuiltIn();

Topical() "Calling Sequence";
Text() "FromFile(name) body";

Topical() "Parameters";
Text() "
name - the name of the file to read <br>
body - the command to be executed";

Topical() "Description";
Text() "
The current input is connected to the file \"name\". Then the command
\"body\" is executed. Everything that the commands in \"body\" read
from current input, is now read from the file \"name\". Finally, the
file is closed and the result of evaluating \"body\" is returned.";

Topical() "Examples";
Text() "
Suppose that the file " : HtmlTerm("foo") : " contains" :
HtmlCommand("
2 + 5;
") : " <P> </P>
Then we can have the following dialogue:" : HtmlCommand("
In> FromFile(\"foo\") res := Read();
Out> 2+5;
In> FromFile(\"foo\") res := ReadToken();
Out> 2;
");

Topical() "See Also";
SeeAlso({"ToFile", "FromString", "Read", "ReadToken"}); 



CmdDescription("FromString", "Connect current input to a string");
BuiltIn();

Topical() "Calling Sequence";
Text() "FromString(str) body;";

Topical() "Parameters";
Text() "
str - a string containing the text to parse <br>
body - the command to be executed";

Topical() "Description";
Text() "
The commands in \"body\" are executed, but everything that is read
from the current input is now read from the string \"str\". The
result of \"body\" is returned.";

Topical() "Examples";
Text() HtmlCommand("
In> FromString(\"2+5; this is never read\") res := Read();
Out> 2+5;
In> FromString(\"2+5; this is never read\") res := Eval(Read());
Out> 7;
");

Topical() "See Also";
SeeAlso({"ToString", "FromFile", "Read", "ReadToken"}); 



CmdDescription("ToFile", "Connect current output to a file");
BuiltIn();

Topical() "Calling Sequence";
Text() "ToFile(name) body";

Topical() "Parameters";
Text() "
name - the name of the file to write the result to <br>
body - the command to be executed";

Topical() "Description";
Text() "
The current output is connected to the file \"name\". Then the command
\"body\" is executed. Everything that the commands in \"body\" print
to the current output, ends up in the file \"name\". Finally, the
file is closed and the result of evaluating \"body\" is returned.";

Topical() "Examples";
Text() "
Take first a look at the following command:" : HtmlCommand("
In> [ Echo(\"Result:\");  PrettyForm(Taylor(x,0,9) Sin(x)); ];
Result:

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

Out> True;
") : " <P> </P>
Now suppose one wants to send the output of this command to a
file. This can be achieved as follows:" : HtmlCommand("
In> ToFile(\"out\") [ Echo(\"Result:\");  PrettyForm(Taylor(x,0,9) Sin(x)); ];
Out> True;
") : " <P> </P>
After this command the file " : HtmlTerm("out") : " contains:" :
HtmlCommand(" 
Result:

     3    5      7       9  
    x    x      x       x   
x - -- + --- - ---- + ------
    6    120   5040   362880

");

Topical() "See Also";
SeeAlso({"FromFile", "ToString", "Echo", "Write", "WriteString",
"PrettyForm", "Taylor"});  



CmdDescription("ToString", "Connect current output to a string");
BuiltIn();

Topical() "Calling Sequence";
Text() "ToString() body";

Topical() "Parameters";
Text() "body - the command to be executed";

Topical() "Description";
Text() "
The commands in \"body\" are executed. Everything that is printed on
the current output, by " : HtmlTerm("Echo") : " for instance, is
collected in a string and this string is returned.";

Topical() "Examples";
Text() HtmlCommand("
In> str := ToString() \\
In>        [ WriteString(\"The square of 8 is \"); Write(8^2); ];
Out> \"The square of 8 is  64\";
");

Topical() "See Also";
SeeAlso({"FromFile", "ToString", "Echo", "Write", "WriteString"});  



CmdDescription("Read", "Read an expression from current input");
BuiltIn();

Topical() "Calling Sequence";
Text() "Read()";

Topical() "Parameters";
Text() "none";

Topical() "Description";
Text() "
Read an expression from the current input, and return it unevaluated. When
the end of an input file is encountered, the token atom " :
HtmlTerm("EndOfFile") : " is returned.";

Topical() "Examples";
Text() HtmlCommand("
In> FromString(\"2+5;\") Read();
Out> 2+5;
In> FromString(\"\") Read();
Out> EndOfFile;
");

Topical() "See Also";
SeeAlso({"FromFile", "FromString", "LispRead", "ReadToken", "Write"});



CmdDescription("LispRead", "Read an expression in LISP-syntax");
BuiltIn();

Topical() "Calling Sequence";
Text() "LispRead()";

Topical() "Parameters";
Text() "none";

Topical() "Description";
Text() "
Read an expression in LISP syntax from the current input, and return
it unevaluated. When the end of an input file is encountered, the
token atom " : HtmlTerm("EndOfFile") : " is returned. 
<P> </P>
The expression " : HtmlTerm("a+b") : " is written in LISP syntax as "
: HtmlTerm("(+ a b)") : ". The advantage of this syntax is that it is
less ambiguous than the infix operator grammar that Yacas uses by
default."; 

Topical() "Examples";
Text() HtmlCommand("
In> FromString(\"(+ a b)\") LispRead();
Out> a+b;
In> FromString(\"(List (Sin x) (- (Cos x)))\") LispRead();
Out> {Sin(x),-Cos(x)};
");

Topical() "See Also";
SeeAlso({"FromFile", "FromString", "Read", "ReadToken", "FullForm"});



CmdDescription("ReadToken", "Read an token from current input");
BuiltIn();

Topical() "Calling Sequence";
Text() "ReadToken()";

Topical() "Parameters";
Text() "none";

Topical() "Description";
Text() "
Read a token from the current input, and return it unevaluated. When
the end of an input file is encountered, the token atom " :
HtmlTerm("EndOfFile") : " is returned.  
<P> </P>
A token is for computer languages what a word is for human languages:
it is the smallest unit in which a command can be divided, so that the
semantics (that is the meaning) of the command is in some sense a
combination of the semantics of the tokens. Hence " : HtmlTerm("a := foo")
: " consists of three tokens, namely " : HtmlTerm("a") : ", " :
HtmlTerm(":=") : ", and " : HtmlTerm("foo") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> FromString(\"a := Sin(x)\") \\
In>    While((tok := ReadToken()) != EndOfFile) Echo(tok);
a 
:= 
Sin 
( 
x 
) 
Out> True;");

Topical() "See Also";
SeeAlso({"FromFile", "FromString", "Read", "LispRead"});



CmdDescription("Load", "Evaluate all expressions in a file");
BuiltIn();

Topical() "Calling Sequence";
Text() "Load(name)";

Topical() "Parameters";
Text() "name - name of the file to load";

Topical() "Description";
Text() "
The file \"name\" is opened. All expressions in the file are read and
evaluated. " : HtmlTerm("Load") : " always returns " :
HtmlTerm("true") : ".";

Topical() "See Also";
SeeAlso({"Use", "DefLoad", "DefaultDirectory", "FindFile"});



CmdDescription("Use", "Load a file, but not twice");
BuiltIn();

Topical() "Calling Sequence";
Text() "Use(name)";

Topical() "Parameters";
Text() "name - name of the file to load";

Topical() "Description";
Text() "
If the file \"name\" has been loaded before, either by an earlier call
to " : HtmlTerm("Use") : " or via the " : HtmlTerm("DefLoad") : "
mechanism, nothing happens. Otherwise all expressions in the file are
read and evaluated. " : HtmlTerm("Use") : " always returns " :
HtmlTerm("true") : ".
<P> </P>
The purpose of this function is to make sure that the file will at
least have been loaded, but is not loaded twice.";

Topical() "See Also";
SeeAlso({"Load", "DefLoad", "DefaultDirectory"});



CmdDescription("DefLoad", "Load a .def file");
BuiltIn();

Topical() "Calling Sequence";
Text() "DefLoad(name)";

Topical() "Parameters";
Text() "name - name of the file (without " : HtmlTerm(".def") : " suffix)";

Topical() "Description";
Text() "
The suffix " : HtmlTerm(".def") : " is appended to \"name\" and the
file with this name is loaded. It should contain a list of functions,
terminated by a " : HtmlTerm("}") : " (end-of-list character). This
tells the system to load the file \"name\" as soon as the user calls
one of the functions named in the file (if not done so already). This
allows for faster startup times, since not all of the rules databases
need to be loaded, just the descriptions on which files to load for
which functions."; 

Topical() "See Also";
SeeAlso({"Load", "Use", "DefaultDirectory"});



CmdDescription("FindFile", "Find a file in the current path");
BuiltIn();

Topical() "Calling Sequence";
Text() "FindFile(name)";

Topical() "Parameters";
Text() "name - name of the file to find";

Topical() "Description";
Text() "
The result of this command is the full path to the file that would be
opened when the command " : HtmlTerm("Load(name)") : " would be
invoked. This means that the input directories are subsequently
searched for a file called \"name\". If such a file is not found, " :
HtmlTerm("FindFile") : " returns an empty string.";

Topical() "See Also";
SeeAlso({"Load", "DefaultDirectory"});



CmdDescription("PatchLoad", "Execute commands between &lt? and ?&gt in file");
BuiltIn();

Topical()"Calling Sequence";
Text()"PatchLoad(name)";

Topical()"Parameters";
Text()"name - the file to patch";

Topical()"Description";
Text()
"PatchLoad loads in a file and outputs the contents to the current
output. The file can contain blocks delimited by &lt? and ?&gt
(meaning Yacas Begin and Yacas End). The piece of text between
such delimiters is treated as a separate file with Yacas instructions,
which is then loaded and executed. All output of write statements
in that block will be written to the same current output.
<P>  </P>
This is similar to the way php works. You can have a static text file
with dynamic content generated by Yacas.
";

Topical()"See Also"; 
SeeAlso({"PatchString","Load"});



CmdDescription("Nl", "A newline character");
StandardLib();

Topical()"Calling Sequence";
Text() "Nl()";

Topical()"Description";
Text()"
This function returns a string with one element in it, namely a newline
character. This may be useful for building strings to send to some
output in the end.
<P> </P>
Note that the second letter in the name of this command is a lower
case " : HtmlTerm("L") : " (from \"line\").";

Topical() "Examples";
Text() HtmlCommand("
In> WriteString(\"First line\" : Nl() : \"Second line\" : Nl());
First line
Second line
Out> True;");

Topical() "See also";
SeeAlso({"NewLine"});





