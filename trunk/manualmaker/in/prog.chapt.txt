
			Programming

	    /* comment */

A comment block in a source file.

*AA Prog

	    Prog(...)

Prog(...) : Evaluate the arguments in order, and return the result of the
last evaluated expression.
This is the same as the "[ ... ]" constuct, that
is, "Prog(a,b);" is the same as typing "[a;b;];" and is
very useful for writing out function bodies (the "[...]" construct
is converted into "Prog(...)" during the parsing stage)

*AA Check

	    Check(predicate,"error")

Check(predicate,"error") :
If "predicate" doesn't evaluate to "True",
then current operation will be stopped, and execution
will jump right back to the command line, showing
"error". Use this to assure that some condition
is met during evaluation of expressions (guarding
against internal errors).

*AA Prefix

	    Prefix("operator")

Prefix("operator") : Defines a new operator for the prefix parser
to understand. This function can also be called with an additional argument
for the precedence of the prefix operator.

*AA Postfix

	    Postfix("oper")

Postfix("oper") : Defines a new operator for the postfix parser to understand.

*AA Bodied

	    Bodied("oper",precedence)

Bodied("oper",precedence) : Defines a new operator for the bodied parser to understand.

*AA Infix

	    Infix("oper",precedence)

Infix("oper",precedence) : Defines a new operator for the infix parser to understand.
"precedence" is evaluated.

*AA IsInfix

*AA IsPrefix

*AA IsPostfix

	    IsInfix("str"), IsPrefix("str"), IsPostfix("str")

Check whether str is an infix, prefix, or postfix operator.
IsInfix("+") should return True. IsInfix("a") should return False.

*CMD IsBodied --- Check for a bodied function

*CORE

*CALL

IsBodied(funcname)

*PARMS

funcname - a string specifying the name of a function

*DESC

The predicate will check whether the function with given name "funcname" has been declared as "bodied" and correspondingly return True or False.

*E.G.

	In> IsBodied("While");
	Out> True;
	In> IsBodied("Sin");
	Out> False;

*SEE Bodied, IsInfix, IsPrefix, IsPostfix, OpPrecedence

*AA OpPrecedence

	    OpPrecedence("str")

Returns the precedence of the function str which should have been declared a bodied function or an infix, postfix, or prefix operator. OpPrecedence("+")
currently returns 6. Generates an error message if the string str does not represent a type of function that can have precedence.

*AA RightAssociative

	    RightAssociative("operator")

makes the operator right-associative. Example: RightAssociative("*")
would make multiplication right-associative. Take care not to abuse
this function, because the reverse, making an infix operator
left-associative, is not implemented.

*AA LeftPrecedence

*AA RightPrecedence

	    LeftPrecedence("oper",precedence), RightPrecedence("oper",precedence)

oper should be an infix operator. This function call tells the
infix expression printer to bracket the left or right hand side of
the expression if its precedence is larger than precedence.

This functionality was required in order to display a-(b-c)
correctly. a+b+c is the same as a+(b+c), but a-(b-c) is not
the same as a-b-c.

*AA RuleBase

	    RuleBase("operator",{params})

RuleBase("operator",{params}) : Define a new rules table entry for a
function "operator", with {params} as the parameter list.

*AA Rule

	    Rule("operator",arity,precedence,predicate) body

Rule("operator",arity,precedence,predicate) body :
Define a rule for the function "operator" with
"arity", "precedence", "predicate" and
"body". "precedence" is checked from low to high.
The arity for a rules database equals the number of arguments. Different
rules data bases can be built for functions with the same name but with
a different number of arguments.
Rules with a low value will be tried before rules with a high value, so
a rule with precedence 0 will be tried before a rule with precedence 1.

*AA HoldArg

	    HoldArg("operator",parameter)

HoldArg("operator",parameter) :
Specify that parameter (which should be part of
a parameter list for a function "operator") should
not be evaluated before used. This will be
declared for all arities of "operator", at the moment
this function is called, so it is best called
after all RuleBase calls for this operator.

*AA Retract

	    Retract("operator",arity)

Retract("operator",arity) : Remove a rulebase with some specific arity,
if it exists at all.

*AA UnFence

	    UnFence("operator",arity)

UnFence("operator",arity) : When applied to a user function, the bodies
defined for the rules for "operator" with given
arity can see the local variables from the calling
function. This is useful for defining macro-like
procedures (looping and the such). The For and ForEach functions
defined in the standard packages use this, for instance.

*AA MacroSet

*AA MacroClear

*AA MacroLocal

*AA MacroRuleBase

*AA MacroRule

	    MacroSet, MacroClear,MacroLocal, MacroRuleBase,MacroRule

Same as their non-macro counterparts, except
that their arguments are evaluated before
the required action is performed. This is
useful in macro-like procedures.

*AA Secure

	    Secure(body)

Secure evaluates body in a safe environment, where file opening
and system calls are not allowed. This can protect the system
when an unsafe evaluation is done (Like a script sent over the
internet to be evaluated on a computer).

