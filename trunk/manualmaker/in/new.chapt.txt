		Designing modules in the Yacas scripting language

	    Introduction

For any software project where the source code grows to
a substantial amount of different modules, there needs to be
a way to define interfaces between the modules, and a way
to make sure the modules don't interact with the environment
in an unintended way. 

One hallmark of a mature programming language is that it 
supports modules, and a way to define its interface while
hiding the internals of the module. This section describes
the mechanisms for doing so in the Yacas scripting language.

	    Demonstration of the problem
 
Unintentional interactions between two modules typically happen 
when the two modules accidentally share a common "global"
resource, and there should be a mechanism to guarantee that this
will not happen.

The following piece of code is a little example that demonstrates
the problem:

	SetExpand(fn_IsString) <-- [expand:=fn;];
	ram(x_IsList)_(expand != "") <-- ramlocal(x);
	expand:="";
	ramlocal(x) := Map(expand,{x});

This little bit of code defines a function {ram} that calls the
function {Map}, passing the argument passed if it is a string, and
if the function to be mapped was set with the {SetExpand} function.
It contains the following flaws:

*	0. {expand} is a global variable with a rather generic name, one
that another module might decide to use.
*	0. {ramlocal} was intended to be used from within this module only, and
doesn't check for correctness of arguments (a small speed up optimization
that can be used for routines that get called often). As it is, it can be
called from other parts, or even the command line.
*	0. the function {ramlocal} has one parameter, named {x}, which is also
generic (and might be used in the expression passed in to the function),
and {ramlocal} calls {Map}, which calls {Eval} on the arguments. 

The above code can be entered into a file and loaded from the command
line at leisure. Now, consider the following command line interaction
after loading the file with the above code in it:

	In> ramlocal(a)         
	In function "Length" : 
	bad argument number 1 (counting from 1)
	Argument matrix[1] evaluated to a
	In function call  Length(a)
	CommandLine(1) : Argument is not a list

We called {ramlocal} here, which should not have been allowed.

	In> ram(a)
	Out> ram(a);

The function {ram} checks that the correct arguments are passed in
and that {SetExpand} was called, so it will not evaluate if these
requirements are not met. 

Here are some lines showing the functionality of this code as
it was intended to be used:

	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};

The following piece of code forces the functionality to break
by passing in an expression containing the variable {x}, which
is also used as a parameter name to {ramlocal}.

	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {{Sin(x),Sin(y),Sin(z)},Sin(y),Sin(z)};

This result is obviously wrong, comparing it to the call above.
The following shows that the global variable {expand} is exposed
to its environment:

	In> expand
	Out> "Sin";


	    Declaring resources to be local to the module

The solution to the problem is {LocalSymbols}, which changes every
symbol with a specified name to a unique name that could never
be entered by the user on the command line and guarantees that it
can never interact with the rest of the system. The following code
snippet is the same as the above, with the correct use of {LocalSymbols}:


	LocalSymbols(x,expand,ramlocal) [
	  SetExpand(fn_IsString) <-- [expand:=fn;];
	  ram(x_IsList)_(expand != "") <-- ramlocal(x);
	  expand:="";
	  ramlocal(x) := Map(expand,{x});
	];


This version of the same code declares the symbols {x}, {expand}
and {ramlocal} to be local to this module.

With this the interaction becomes a little bit more predictable:

	In> ramlocal(a)
	Out> ramlocal(a);
	In> ram(a)
	Out> ram(a);
	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};
	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {Sin(x),Sin(y),Sin(z)};
	In> expand
	Out> expand;


	    When to use and when not to use {LocalSymbols}

The {LocalSymbols} should ideally be used for every global variable,
for functions that can only be useful within the module and thus
should not be used by other parts of the system, 
and for local variables that run the risk of being passed into 
functions like {Eval}, {Apply}, {Map}, etcetera (functions that
re-evaluate expressions).

A rigorous solution to this is to make all parameters to functions
and global variables local symbols by default, but this might cause
problems when this is not required, or even wanted, behaviour.

The system will never be able to second-guess which function
calls can be exposed to the outside world, and which ones should
stay local to the system. It also goes against a design rule of Yacas:
everything is possible, but not obligatory. This is important 
at moments when functionality is not wanted, as it can be hard 
to disable functionality when the system does it automatically.

There are more caveats: if a local variable is made unique with 
{LocalSymbols}, other routines can not reach it by using the 
{UnFence} construct. This means that {LocalSymbols} is not always 
wanted. 

Also, the entire expression on which the {LocalSymbols} command works
is copied and modified before being evaluated, making loading
time a little slower. This is not a big problem, because the 
speed hit is usually during calculations, not during loading, but
it is best to keep this in mind and keep the code passed to 
{LocalSymbols} concise.
















			A do-it-yourself symbolic algebra environment (YACAS)

*HEAD by Ayal Zwi Pinkus and Serge Winitzki

	    Abstract

We describe the design and implementation of YACAS, a free computer
algebra system currently under development.  The system consists of a small
core interpreter and a library of scripts that implement computer algebra
functionality.  The interpreter provides a high-level weakly typed functional
language (the Yacas script" language) which is designed to allow users to quickly
prototype computer algebra algorithms but is applicable more widely to all
kinds of symbolic manipulation.  The language supports recursive evaluation,
conditional term rewriting of symbolic expression trees, closures (pure
functions) and delayed evaluation, dynamic creation of transformation rules,
arbitrary-precision numerical calculations, and flexible user-defined syntax
using infix notation.  The library of scripts is in development and currently
provides basic computer algebra functionality: real and complex polynomials and
elementary functions, symbolic limits, derivatives and (limited) integration,
symbolic solution of (simple) equations, and some special mathematical
functions. The main advantages of Yacas are: free (GPL) software;
cross-platform portability and small resource requirements; a flexible and
easy-to-use programming language with a comfortable and adjustable syntax; and extensibility.

		Introduction

Yacas is a small CAS which has been in development since the beginning of 1999.
The goal was to make a small system that allows to easily prototype and
research symbolic mathematics algorithms. A secondary future goal is to evolve
acas into a full-blown general purpose computer algebra system.

The main advantage of Yacas is its rich and  flexible scripting language
adapted to prototyping of symbolic manipulation algorithms.

		Basic design

Yacas consists of a "core engine", an interpreter for the Yacas scripting
language, and a library of script code. The Yacas interpreter has been
implemented in standard C++.

The design goals for Yacas are: portability, self-containment, ease of use,
code transparency, and flexibility of the core engine (lack of predefined "policies"). The system falls into the "prototype/hacker" rather than into the "axiom-algebraic" category, according to the classification of Fateman [F90].

	    Portability

Yacas is designed to be as platform-independent as possible. Yacas is written
in a subset of C++ which is supported by almost all, if not all, C++ compilers.
The platform-specific parts have been clearly separated to facilitate porting.
Even the standard C++ library is considered to be platform-specific, as there
exist  platforms without support for the standard C++ library (e.g. the
EPOC32 platform).

The primary development platform is GNU/Linux. Currently Yacas runs under
various Unix variants, Windows environments, Psion organizers (EPOC32), 
BeOS, and Apple iMacs. Creating an executable for another platform
should not be difficult for a developer. Since it is also possible to compile
all script library code into the Yacas executable, porting to embedded
platforms is possible.

	    A self-contained system

Yacas should work as a standalone package, requiring minimum support from other
operating system components. Yacas takes input and output in plain ASCII,
either interactively or in batch mode. The system comes with its own
(unoptimized) arbitrary precision arithmetic module but could be compiled to
use another arbitrary precision arithmetic library (currently linking to {gmp}
is experimentally supported). There is also an optional plugin mechanism
whereby external libraries can be linked into the system to provide extra
functionality.

Self-containment is a requirement if the program is to be easy to port. A
dependency on libraries that might not be available on other platforms would
reduce portability. On the other hand, Yacas can be compiled with a complement
of external libraries on "production" platforms.

	    Ease of use

Yacas is used mainly by executing programs written in the Yacas script
language. A design goal is to create a high-level language that allows the user
to conveniently express symbolic algorithms. A few lines of user code should go
a long way.

One major advantage of Yacas is the flexibility of its syntax. Although Yacas
works internally as a LISP-style interpreter, all user interaction is through
the Yacas script language which has a flexible infix grammar. Infix operators
are defined by the user and may contain non-alphabetic characters such as "{+}"
or "{#}". This means that the user interacts in a comfortable infix syntax,
rather than in LISP-style syntax. The user can also define such syntactic
conventions as are most convenient for a given problem.

For example, the Yacas script library defines infix operators "{+}", "{*}" and so
on with conventional precedence, so that an algebraic expression can be entered
in the familiar infix form such as

	(x+1)^2 - (y-2*z)/(y+3) + Sin(x*Pi/2)

Once such infix operators are defined, it is possible to describe new
transformation rules directly using the new syntax. This makes it easy to
develop simplification or evaluation procedures adapted to a particular
problem.

Suppose the user needs to normal-order expressions containing creation and
annihilation operators of quantum field theory. It takes about 20 lines of
Yacas script code to define an infix operation "{**}" to express non-commutative
multiplication with the appropriate commutation relations and to automatically
"normal-order" all expressions involving these symbols and other (commutative)
factors. Once the operator {**} is defined (with precedence 4),
	Infix("**", 4);
rules that express distributivity of the operation {**} with
respect to addition may look like this:
	15 # (_x + _y) ** _z <-- x ** z + y ** z;
	15 # _z ** (_x + _y) <-- z ** x + z ** y;
Here, {15 #} is a specification of rule precedence, {_x} denotes a
pattern-matching variable {x} and the expression to the right of {<--} is to be
substituted instead of a matched expression on the left hand side. Since all
transformation rules are applied recursively and there are no terminating
functions such as {Hold()}, these two lines of code are enough for the Yacas
engine to expand all brackets in any expression containing the infix operators
{**} and {+}.

Rule-based programming is not the only tool that can be used in Yacas scripts.
There are alternatives that may be more useful in some situations. For example,
the familiar {if} / {else} constructs, {While}, {For}, {ForEach} loops are
defined in the script library for the convenience of users.

Standard procedural programming patterns, such as defining functions that
return values, with code blocks and temporary local variables, are also
available. (A "function" is implemented as a new "ground term" with a single
rule defined for it.) As a result, users may freely combine rules with C-like
procedures or LISP-like recursive list processing primitives such as {Head},
{Tail}.

	    Code clarity vs. speed

Speed is obviously an important factor. One reason to use computers for
mathematical  calculations is that computers can do enormous amounts of tedious
operations in very little time. For Yacas, where a choice had to be made
between speed and clarity of code, clarity was chosen. Yacas is mainly a
prototyping system and its future maintainability is very important.

This means that special-purpose systems designed for specific types of
calculations, as well as heavily optimized industrial-strength computer algebra
systems, will outperform Yacas. Yacas supports a plugin mechanism to link specialized libraries into the system.

	    Flexible, "policy-free" engine

The Yacas system has two main components: the kernel (core interpreter) which
is written in C++, and the script library written  in the Yacas script
language.

The kernel is written in C++, and it offers sufficiently rich but basic
functionality through a limited number of core functions. This functionality
includes recursive substitutions and rewriting of symbolic expression trees,
syntax parser, and arbitrary-precision numerical computations. The core does
not include definitions of any symbolic mathematical operations and tries to be
as general and free of predefined notions or policies as possible.

The reason to implement yet another LISP-like custom language interpreter as
opposed to taking an already existing one was to have full control over the
system. While most of the features are syntactic sugar on top of a LISP 
interpreter, some features not commonly found in LISP systems were  added, such
as the system of transformation rules.

The script library contains declarations of transformation rules and function
syntax. The intention is that all symbolic manipulation algorithms, definitions
of mathematical functions and so on should be held in the script library. The
only exception so far is for a very small number of mathematical or utility
functions that are frequently used; they are compiled into the core for speed.

For example, the mathematical operator "{+}" is an infix operator defined in the
library scripts. To the kernel, this operator is on the same footing as any
other function defined by the user and can be redefined. The Yacas kernel
itself does not store any properties for this operator. Instead it relies
entirely on the script library to provide transformation rules for manipulating
expressions involving the operator "{+}". In this way, the kernel does not need
to anticipate all possible meanings of the operator "{+}" that users might need
in their calculations.

This policy-free scheme means that Yacas is highly configurable through its
scripting language. It is possible to create an entirely different symbolic
manipulation engine based on the same C++ kernel, with different syntax and
different naming  conventions, by simply using another script library instead
of the current library scripts. An example of the flexibility of the Yacas
system is a sample script {wordproblems.ys}. It contains a set of rule
definitions that make Yacas recognize simple English sentences, such as "Tom
has 3 apples" or "Jane gave an apple to Tom", as valid Yacas expressions. Yacas
can then "evaluate" these sentences to {True} or {False} according to
the semantics of the situation described in these sentences.

The "policy-free" concept extends to typing: strong typing is not required by
the kernel, but can be easily enforced by the  scripts if needed for a
particular problem. The language offers features, but does not enforce their
use.

		The Yacas kernel functionality

Yacas script is a functional language based on various ideas that seemed useful
for an implementation of CAS: list-based data structures, object properties,
and recursive functional programming (a la LISP); term rewriting [BN98] with
pattern matching somewhat along the lines of Mathematica; user-defined infix
operators a la PROLOG; delayed evaluation of expressions; and
arbitrary-precision arithmetic.  Garbage collection, reference counting and
memory management are automatic.

The kernel provides three basic data types: numbers,
strings, and atoms, and two container types: list and static array (for speed).
Atoms are implemented as strings that can be assigned values and evaluated.
Boolean values are simply atoms {True} and {False}. Association (hash) tables,
stacks, and closures (pure functions) are implemented using nested lists. In
addition, more data types might be provided by plugins. Kernel primitives are
available for arbitrary-precision arithmetic, string manipulation, array and
list access and manipulation, for basic control flow, and for defining rules.

The interpreter engine recursively evaluates expression trees according to
user-defined transformation rules from the script library. This is the only
evaluation scheme. (A {Hold()} function is also provided to stop the recursive
application of rules at a certain point and obtain an unevaluated expression.)
However, the language offers a more flexible rewriting system than one based on
a fixed set of rules.

Firstly, transformation rules in Yacas have predicates that control whether a
rule should be applied to an expression. Predicates can be any Yacas
expressions that evaluate to the atoms {True} or {False} and are functions of
the matching context (i.e. parts of the expression being matched by the rule).

Secondly, rules are assigned a precedence value (a positive integer) that
controls the order of rules to be attempted. Rules with smaller precedence are
attempted before rules with higher precedence. In the current evaluation
scheme, rules with fewer elements in the pattern are always attempted earlier
than rules with longer patters. (Thus Yacas provides somewhat better control
over the automatic recursion than the pattern-matching system of Mathematica
which does not allow for rule precedence.)

Thirdly, new rules can be defined dynamically as a side-effect of evaluation.
This means that there is no predefined "ranking alphabet" of "ground terms" (in
the terminology of [TATA99]), in other words, no fixed set of functions with
predefined arities. It is also possible to define a "rule closure" that defines
rules depending on its arguments, or to erase rules. Thus, a Yacas script
library (although it is read-only) does not represent a fixed tree rewriting
automaton. An implementation of machine learning is possible in Yacas (among
other things). For example, when the module {wordproblems.ys} "learns" from the
user input that "apple" is a countable object, it defines a new postfix
operator {apples}, so that the expression {3 apples} is later parsed as a
function {apples(3)} and evaluated according to a newly defined rule.

Fourthly, Yacas expressions can be "tagged" (assigned a "property object") and
tags can be checked by predicates in rules or used in the evaluation.

		The Yacas scripting language

The Yacas interpreter is sufficiently powerful so that the functions {While},
{For}, {ForEach}, {if}, {else} etc., as well as convenient shorthand
"...{<--}..." for defining new rules, can be defined in the script library
itself rather than in the kernel. This power is fully given to the user, since
the library scrips are on the same footing as any user-defined code. Some
library functions are intended mainly as tools available to a Yacas user to
make algorithm implementation more comfortable.

Simple transformations on expressions can be achieved using transformation
rules. For instance, if we need to expand natural logarithm, we could use the
following two rules:

	log(_x * _y) <-- log(x) + log(y);
	log(_x ^ _n) <-- n * log(x);
This would define a new symbolic function {log}, which will not be evaluated
but only transformed if one of these two rules are applicable. The symbol {_}
indicates a pattern variable that matches subexpressions.

After these two rules, the following interactive session is possible:

	In> log(a*x^2)
	
	log( a ) + 2 * log( x )
	
	Out> 

Integration of the new function {log} can be defined by adding a rule for the
{AntiDeriv} function,

	AntiDeriv(log(_x),_x) <-- x*log(x)-x;
Now Yacas can do integrations involving the newly defined {log} function, for example:

	In> Integrate(x)log(a*x^n)
	
	log( a ) * x + n * ( x * log( x ) - x ) + C18
	
	Out> 
	In> Integrate(x,B,C)log(a*x^n)
	
	log( a ) * C + n * ( C * log( C ) - C ) -
	
	( log( a ) * B + n * ( B * log( B ) - B ) )
	
	Out> 


Rules are applied when their associated patterns match and when their
predicates return {True}. Rules also have <i>precedence</i>, an integer value
to indicate which rules need to be applied first. Using these features, a
recursive implementation of the integer factorial function may look like this
in Yacas script,

	1 # Factorial(_n) _ (n=0) <-- 1;
	2 # Factorial(n_IsInteger) _ (n>0) <-- n*Factorial(n-1);

Rule-based programming can be freely combined with procedural programming when
the latter is a more appropriate method. For example, here is a function that
computes $ Mod(x^n,m) $ efficiently:

	powermod(x_IsPositiveInteger,n_IsPositiveInteger,
	         m_IsPositiveInteger) <--
	[
	  Local(result);
	  result:=1;
	  x:=Mod(x,m);
	  While(n != 0)
	  [
	     if ((n&1) = 1) [
		   result := Mod(result*x,m);
		 ];
	     x := Mod(x*x,m);
	     n := n>>1;
	  ];
	  result;
	];

Interaction with the function {powermod(x,n,m)} would then look like this:

	In> powermod(2,10,100)
	Out> 24;
	In> Mod(2^10,100)
	Out> 24;
	In> powermod(23234234,2342424234,232423424)
	Out> 210599936;

		Currently supported CAS features

Yacas comes with a base of mathematical capabilities implemented in the script
library which is currently under active development. The following section
demonstrates a few facilities already offered in the current system.

Basic calculus operations have been implemented:

	In> Limit(n,Infinity)(1+(1/n))^n
	
	Exp( 1 )
	
	Out> 
	In> Taylor(x,0,5)ArcSin(x)
	
	     3        5
	    x    3 * x 
	x + -- + ------
	    6      40  
	
	Out> 
	In> InverseTaylor(x,0,5)Sin(x)
	
	     5    3    
	3 * x    x     
	------ + -- + x
	  40     6     
	
	Out> 
	In> Integrate(x,a,b)Ln(x)+x
	
	                   2   /                    2 \
	                  b    |                   a  |
	b * Ln( b ) - b + -- - | a * Ln( a ) - a + -- |
	                  2    \                   2  /
	
	Out> 
	In> Integrate(x)1/(x^2-1)
	
	Ln( 2 * ( x - 1 ) )   Ln( 2 * ( x + 1 ) )      
	------------------- - ------------------- + C38
	         2                     2               
	
	Out> 
	In> Integrate(x)Sin(a*x)^2*Cos(b*x)
	
	Sin( b * x )   Sin( -2 * x * a + b * x )   
	------------ - ------------------------- - 
	   2 * b          4 * ( -2 * a + b )       
	
	Sin( -2 * x * a - b * x )      
	------------------------- + C39
	   4 * ( -2 * a - b )          
	
	Out> 
	In> OdeSolve(y''==4*y)
	
	C193 * Exp( -2 * x ) + C195 * Exp( 2 * x )
	
	Out> 

Solving systems of equations has been implemented using a generalized Gaussian
elimination scheme:

	In> Solve({x+y+z==6,2*x+y+2*z==10,x+3*y+z==10}, \
	In>  {x,y,z})[1]
	Out> {4-z,2,z};


A small theorem prover using a resolution principle is offered:


	In> CanProve(P Or (Not P And Not Q))
	
	Not( Q ) Or P
	
	Out> 
	In> CanProve(a > 3 And a < 2)
	
	False
	
	Out> 

Various exact and arbitrary-precision numerical algorithms have been
implemented:

	In> N(1/7,40)	// evaluate to 40 digits
	Out> 0.1428571428571428571428571428571428571428;
	In> Decimal(1/7)	// obtain decimal period
	Out> {0,{1,4,2,8,5,7}};
	In> N(LnGamma(1.234+2.345*I))	// gamma-function
	Out> Complex(-2.13255691127918,0.70978922847121);


Various domain-specific expression simplifiers can be called upon:

	In> RadSimp(Sqrt(9+4*Sqrt(2)))
	
	Sqrt( 8 ) + 1
	
	Out> 
	In> TrigSimpCombine(Sin(x)^2+Cos(x)^2)
	
	1
	
	Out> 
	In> TrigSimpCombine(Cos(x/2)^2-Sin(x/2)^2)
	
	Cos( x )
	
	Out> 
	In> GcdReduce((x^2+2*x+1)/(x^2-1),x)
	
	x + 1
	-----
	x - 1
	
	Out> 


Univariate polynomials are supported in a dense representation, 
and multivariate polynomials in a sparse representation:

	In> Factor(x^6+9*x^5+21*x^4-5*x^3-54*x^2-12*x+40)
	
	         3            2            
	( x + 2 )  * ( x - 1 )  * ( x + 5 )
	
	Out> 
	In> Apart(1/(x^2-x-2))
	
	      1               1      
	------------- - -------------
	3 * ( x - 2 )   3 * ( x + 1 )
	
	Out> 
	In> Together(%)
	
	         9         
	-------------------
	     2             
	9 * x  - 9 * x - 18
	
	Out> 
	In> Simplify(%)
	
	     1     
	----------
	 2        
	x  - x - 2
	
	Out> 


Various "syntactic sugar" features are available to more easily enter
problems to be solved:

	In> Ln(x*y) /: { Ln(_a*_b) <- Ln(a) + Ln(b) }
	
	Ln( x ) + Ln( y )
	
	Out> 
	In> Sum(x^(1 .. 5))
	
	     2    3    4    5
	x + x  + x  + x  + x 
	
	Out> 
	
	In> Select("IsPrime", 1 .. 15)
	Out> {2,3,5,7,11,13};
	
Groebner bases have been implemented:

	In> Groebner({x*(y-1),y*(x-1)})
	
	/           \
	| x * y - x |
	|           |
	| x * y - y |
	|           |
	| y - x     |
	|           |
	|  2        |
	| y  - y    |
	\           /
	
	Out> 
(From this it  follows that $ x = y $, and $ x^2 = x $ so $ x $ is $ 0 $ or $ 1
$.)

Symbolic inverses of matrices:

	In> Inverse({{a,b},{c,d}})
	
	/                                      \
	| /       d       \ /    -( b )     \  |
	| | ------------- | | ------------- |  |
	| \ a * d - b * c / \ a * d - b * c /  |
	|                                      |
	| /    -( c )     \ /       a       \  |
	| | ------------- | | ------------- |  |
	| \ a * d - b * c / \ a * d - b * c /  |
	\                                      /
	
	Out> 

This list of features is not exhaustive.


		Documentation

The documentation for the Yacas is extensive and growing every day.
Documentation is in the form of two tutorial guides (user's introduction and
programmer's introduction), a collection of essays that describe some more
advanced features in detail, and a full reference manual.

Yacas currently comes with its own document formatting conventions for writing
documentation in plain text format with a minimal markup. This text format is
automatically converted to HTML, $LaTeX$, PostScript and PDF formats. The HTML
version of the documentation is hyperlinked and is used as online help
available from the Yacas prompt.

		Future plans

The long-term goal for Yacas is to become an industrial-strength CAS and to
remain a flexible research tool for easy prototyping of various methods of
various kinds of symbolic calculations. Yacas is meant to be a repository and a
testbed for such algorithm prototypes.

The plugin structure will be fortified in the future, and a rich set of extra
additional libraries, system-specific as well as mathematics-oriented, should
be loadable from the Yacas system. The issue of speed is also continuously
being addressed. 


		References

Bibliography:

[F90] R. Fateman,
<i>On the design and construction of algebraic manipulation systems</i>,
also published as: ACM Proceedings of the ISSAC-90, Tokyo, Japan.

[BN98] F. Baader and T. Nipkow, <i>Term rewriting and all that</i>,
Cambridge University Press, 1998.

[TATA99] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison,
and M. Tommasi, <i>Tree Automata Techniques and Applications</i>, 1999, online
book: <*http://www.grappa.univ-lille3.fr/tata*>





