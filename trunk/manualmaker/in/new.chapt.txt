		Designing modules in the Yacas scripting language

	    Introduction

For any software project where the source code grows to
a substantial amount of different modules, there needs to be
a way to define interfaces between the modules, and a way
to make sure the modules don't interact with the environment
in an unintended way. 

One hallmark of a mature programming language is that it 
supports modules, and a way to define its interface while
hiding the internals of the module. This section describes
the mechanisms for doing so in the Yacas scripting language.

	    Demonstration of the problem
 
Unintentional interactions between two modules typically happen 
when the two modules accidentally share a common "global"
resource, and there should be a mechanism to guarantee that this
will not happen.

The following piece of code is a little example that demonstrates
the problem:

	SetExpand(fn_IsString) <-- [expand:=fn;];
	ram(x_IsList)_(expand != "") <-- ramlocal(x);
	expand:="";
	ramlocal(x) := Map(expand,{x});

This little bit of code defines a function {ram} that calls the
function {Map}, passing the argument passed if it is a string, and
if the function to be mapped was set with the {SetExpand} function.
It contains the following flaws:

*	0. {expand} is a global variable with a rather generic name, one
that another module might decide to use.
*	0. {ramlocal} was intended to be used from within this module only, and
doesn't check for correctness of arguments (a small speed up optimization
that can be used for routines that get called often). As it is, it can be
called from other parts, or even the command line.
*	0. the function {ramlocal} has one parameter, named {x}, which is also
generic (and might be used in the expression passed in to the function),
and {ramlocal} calls {Map}, which calls {Eval} on the arguments. 

The above code can be entered into a file and loaded from the command
line at leisure. Now, consider the following command line interaction
after loading the file with the above code in it:

	In> ramlocal(a)         
	In function "Length" : 
	bad argument number 1 (counting from 1)
	Argument matrix[1] evaluated to a
	In function call  Length(a)
	CommandLine(1) : Argument is not a list

We called {ramlocal} here, which should not have been allowed.

	In> ram(a)
	Out> ram(a);

The function {ram} checks that the correct arguments are passed in
and that {SetExpand} was called, so it will not evaluate if these
requirements are not met. 

Here are some lines showing the functionality of this code as
it was intended to be used:

	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};

The following piece of code forces the functionality to break
by passing in an expression containing the variable {x}, which
is also used as a parameter name to {ramlocal}.

	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {{Sin(x),Sin(y),Sin(z)},Sin(y),Sin(z)};

This result is obviously wrong, comparing it to the call above.
The following shows that the global variable {expand} is exposed
to its environment:

	In> expand
	Out> "Sin";


	    Declaring resources to be local to the module

The solution to the problem is {LocalSymbols}, which changes every
symbol with a specified name to a unique name that could never
be entered by the user on the command line and guarantees that it
can never interact with the rest of the system. The following code
snippet is the same as the above, with the correct use of {LocalSymbols}:


	LocalSymbols(x,expand,ramlocal) [
	  SetExpand(fn_IsString) <-- [expand:=fn;];
	  ram(x_IsList)_(expand != "") <-- ramlocal(x);
	  expand:="";
	  ramlocal(x) := Map(expand,{x});
	];


This version of the same code declares the symbols {x}, {expand}
and {ramlocal} to be local to this module.

With this the interaction becomes a little bit more predictable:

	In> ramlocal(a)
	Out> ramlocal(a);
	In> ram(a)
	Out> ram(a);
	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};
	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {Sin(x),Sin(y),Sin(z)};
	In> expand
	Out> expand;


	    When to use and when not to use {LocalSymbols}

The {LocalSymbols} should ideally be used for every global variable,
for functions that can only be useful within the module and thus
should not be used by other parts of the system, 
and for local variables that run the risk of being passed into 
functions like {Eval}, {Apply}, {Map}, etcetera (functions that
re-evaluate expressions).

A rigorous solution to this is to make all parameters to functions
and global variables local symbols by default, but this might cause
problems when this is not required, or even wanted, behaviour.

The system will never be able to second-guess which function
calls can be exposed to the outside world, and which ones should
stay local to the system. It also goes against a design rule of Yacas:
everything is possible, but not obligatory. This is important 
at moments when functionality is not wanted, as it can be hard 
to disable functionality when the system does it automatically.

There are more caveats: if a local variable is made unique with 
{LocalSymbols}, other routines can not reach it by using the 
{UnFence} construct. This means that {LocalSymbols} is not always 
wanted. 

Also, the entire expression on which the {LocalSymbols} command works
is copied and modified before being evaluated, making loading
time a little slower. This is not a big problem, because the 
speed hit is usually during calculations, not during loading, but
it is best to keep this in mind and keep the code passed to 
{LocalSymbols} concise.








		How Yacas Deals With Sets of Solutions

	    Introduction

*REM @@@@@@@@@@@@@@@@@@@@@@@@
THIS IS A DRAFT, THE FUNCTIONALITY DESCRIBED BELOW IS NOT FULLY
IMPLEMENTED YET!!! THIS IS JUST A PROPOSAL FOR HOW SOLVE MIGHT
WORK.

*HEAD (This is a draft)

Worries: 

*	need to change all code that uses Solve
*	need a lot of changes in documentation
*	arguments to solve are a bit more verbose than the previous
version: Solve({eq1,eq2},vars) versus Solve(eq1 And eq2,vars). Suddenly
things like Solve(leftlist==rightlist,vars) is not possible any more.
This has to be done with extra commands (which is ok?). It can not
stay the way it was, because lists now mean something else, a collection
of disjunct solutions.

*REM @@@@@@@@@@@@@@@@@@@@@@@@

The difference between a problem stated and a solution given is
a subtle one. From a mathematical standpoint, 

	In> Integrate(x,0,B)Cos(x)
	Out> Sin(B);

And thus

	Integrate(x,0,B)Cos(x) == Sin(B)

is a true statement. Furthermore, the left hand side is mathematically
equivalent to the right hand side. Working out the integration, to
arrive at an expression that doesn't imply integration any more is
generally perceived to be a more desirable result, even though
the two sides are equivalent mathematically.

This implies that the statement of a set of equations declaring
equalities is on a same footing as the resulting equations stating
a solution: 

$$ a*x+b==c => x==(c-b)/a $$. 

If the value of $x$ is needed, the right hand side is more desirable.

Viewed in this way, the responsibility of a {Solve} function could
be to manipulate a set of equations in such a way that a certain
piece of information can be pried from it (in this case the value
of $ x == x(a,b,c) $.

A next step is to be able to use the result returned by a {Solve}
operation. 

	    Implementation Semantics of Solve in Yacas

Suppose there is a set of variables that has a specific combination
of solutions and these solutions need to be filled in in an expression:
the {Where} operator can be used for this:

	In> x^2+y^2 Where x==2 And y==3
	Out> 13;

Solve can return one such solution tuple, or a list of tuples.
The list of equations can be passed in to Solve in exactly the same
way. Thus:

	In> Solve(eq1,var)
	Out> a1==b1;
	In> Solve(eq1 And eq2 And eq3,varlist)
	Out> {a1==b1 And a2==b2,a1==b3 And a2==b4};

These equations can be seen as simple simplification rules, the
left hand side showing the old value, and the right hand side
showing the new value. Interpreted in that way, {Where} 
is a little simplifier for expressions, using values found by Solve.

Assigning values to the variables values globally can be handled with
an expression like

	solns := Solve(equations,{var1,var2});
	{var1,var2} := Transpose({var1,var2} Where solns);

Multiple sets of values can be applied:

	In> x^2+y^2 Where {x==2 And y==2,x==3 And y==3}
	Out> {8,18};

This assigns the the variables lists of values. These variables
can then be inserted into other expressions, where threading will
fill in all the solutions, and return all possible answers.
	
Groups of equations can be combined, with

	Equations := EquationSet1 AddTo EquationSet2

or, 

	Equations := Equations AddTo Solutions;

Where {Solutions} could have been returned by {Solve}. This last
step makes explicit the fact that equations are on a same footing,
mathematically, as solutions to equations, and are just another
way of looking at a problem.

The equations returned can go farther in that multiple solutions
can be returned: if the value of $ x $ is needed and the equation
determining the value of $ x $ is $ x := Abs(a) $, then a set
of returned solutions could look like:

	Solutions := { a>=0 And x==a, a<0 And x== -a }

The semantics of this list is:

	either a >= 0 And x equals a, or
	       a < 0 And x equals -a


When more information is published, for instance the value
of $ a $ has been determined, the sequence for solving this
can look like:

	In> Solve(a==2 AddTo Solutions,{x})
	Out> x==2;

The solution {a<0 And x==-a} can not be satisfied, and thus is removed
from the list of solutions.

Introducing new information can then be done with the AddTo
operator:

	In> Solutions2 := (a==2 AddTo Solutions);
	Out> { a==2 And a>=0 And x==a, a==2
	  And a<0 And x==-a };

In the above case both solutions can not be true any more, and thus
when passing this list to {Solve}:

	In> Solve(Solutions2,{x})
	Out> x==2;

{AddTo} combines multiple equations through a tensor-product like
scheme:

	In> {A==2,c==d} AddTo {b==3 And  d==2}
	Out> {A==2 And b==3 And d==2,c==d
	  And b==3 And d==2};
	In> {A==2,c==d} AddTo {b==3, d==2}
	Out> {A==2 And b==3,A==2 And d==2,c==d
	  And b==3,c==d And d==2};

A list {a,b} means that a is a solution, OR b is a solution.
AddTo then acts as a AND operation:
	(a or b) and (c or d) => 
	(a or b) Addto (c or d) => 
	(a and c) or (a and d) or (b and c) or (b and d)


{Solve} gathers information as a list of identities. The second
argument is a hint as to what it needs to solve for. It can be a list
of variables, but also "Ode" (to solve ordinary differential equations),
"Trig" (to simplify for trigonometric identities), "Exp" to simplify
for expressions of the form $ Exp(x) $, or "Logic" to simplify
expressions containing logic. The "Logic" simplifier also should
deal with $ a > 2 And a < 0 $ which it should be able to reduce 
to {False}.

{Solve} also leaves room for an 'assume' type mechanism, where the
equations evolve to keep track of constraints. When for instance
the equation $ x == Sin(y) $ is encountered, this might result
in a solution set 

	y == ArcSin(x) And x>=-1 And x <= 1


	    Use Case Scenarios

*REM TODO@@@@ THIS SECTION IS GOING TO CONTAIN EXPLICIT EXAMPLES OF
SOLVING INTERESTING SETS OF EQUATIONS, AND SHOWING THAT THE SOLVE
SCHEME IS ACTUALLY EASY TO USE.

*HEAD To be filled in


			The Yacas internal numeric library

		Introduction

Although there are quite good free arbitrary precision arithmetic
libraries out there, {Yacas} comes with its own (default) implementation.
Other libraries can be used too, but the addition of a small native 
arithmetic library reduces dependencies on other packages.

This part describes how the arithmetic library is embedded into
{Yacas}, and how to embed other arithmetic libraries.

		The link between the interpreter and the arithmetic library

The interpreter (as of version 1.0.54) has the concept of an <i>atom</i>, an object
which has a string representation.
Numbers are also atoms and are initially entered into Yacas as strings.
As soon as a calculation needs
to be performed, the string representation is used to construct
an object representing the number, in an internal representation that
the arithmetic library can work with.

The basic layout is as follows: there is one class {BigNumber} that offers basic numerical functions,
arithmetic operations such as addition and multiplication, through a set of class methods.

Integers and floating-point numbers are handled by the same class.

The {BigNumber} class implements a particular internal representation of numbers and Yacas must be compiled to use a specific number library.
This library will be hidden behind the class {BigNumber}.
It is impossible to have several number libraries operating at the same time.
Having several libraries in the same Yacas session does not seem to be very useful;
it would also incur a lot of overhead because one would have to convert the numbers from one internal library representation to another.
To compare the performance, one can compile several copies of Yacas against different libraries.

The number object should be able to render itself back to a string,
which can then be passed back to the interpreter as a result, if so needed.

		Interface to the objects

The following code demonstrates how to use the number objects.

	// Calculate z=x+y where x=10 and y=15
	BigNumber x("10",100,10);
	BigNumber y("15",100,10);
	BigNumber z;
	z.Add(x,y,10));    
	// cast the result to a string
	LispString  str;
	z.ToString(str,10);
The behaviour is such that in the above example {z} will contain the result of adding {x} and
{y}, without modifying {x} or {y}.
This is equivalent to {z:=x+y} in Yacas.

A calculation might modify one of its arguments.
This might happen when one argument passed in is actually the 
object performing the calculation itself. For example, if a calculation

	x.Add(x,y);
were issued, the result would be assigned to {x}, and the old value of {x} is deleted.
This is equivalent to the Yacas code {x:=x+y}.
In this case a specific implementation might opt to perform the operation
estructively ("in-place"). Some operations can be performed much more efficiently in-place, without copying the arguments.
Among them are for example {Negate}, {Add}, {ShiftLeft}, {ShiftRight}.

Therefore, all class methods of {BigNumber} that allow a {BigNumber} object as an argument should behave correctly when called destructively on the same {BigNumber} object.
The result must be exactly the same as if all arguments were copied to temporary locations before performing tasks on them, with no other side-effects.
For instance, if the
specific object representing the number inside the numeric class
is shared with other objects, it should not allow the destructive
operation, as then other objects might start behaving differently.


		Interface definition of the {BigNumber} class

The basic arithmetic class {BigNumber} defines some simple arithmetic operations,
through which other more elaborate functions can be built.
Particular implementations of the multiple-precision library will be wrapped by the {BigNumber} class, and the rest of the Yacas core should only use the {BigNumber} API and should be ignorant of those implementations.

This API will not be completely exposed to Yacas scripts, because some of these functions are too low-level.
(For the functions that seem to be useful for Yacas, suggested Yacas bindings are given below.)  
Among the low-level functions, only those that are very useful for optimization will be available to the Yacas scripts.
But the full API will be available to C++ plugins, so that multiple-precision algorithms could be efficiently implemented when performance is critical.
Intermediate-level arithmetic functions such as {MathAdd}, {MathDiv}, {MathMod} and so on could be implemented either in the Yacas core or in plugins, through this low-level API.
The library scripts will be able to transform numerical expressions such as {x:=y+z} into calls of these intermediate-level functions.


*A multiple-precision facility!requirements

Here we list the basic arithmetic operations that need to be implemented by a multiple-precision class {BigNumber}.
The operations are divided into several categories for convenience.
Equivalent Yacas script code is given, as well as examples of C++ usage.

1. Input/output operations.
*	{BigNumber::SetTo} -- Construct a number from a string in given base.
The format is the standard integer, fixed-point and floating-point representations of numbers.
When the string does not contain the period character "{.}" or the exponent character "{e}" (the exponent character "{@}" should be used for $base>10$),
the result is an integer number and the precision argument is ignored.
Otherwise, the result is a floating-point number
rounded to a given number of <i>base digits</i>.
C++:
	x.SetTo("2.e-19", 100, 10);
Here we encounter a problem of ambiguous hexadecimal exponent:
	x.SetTo("2a8c.e2", 100, 16);
It is not clear whether the above number is in exponential notation or not.
But this is hopefully not a frequently encountered situation.
We assume that the exponent character for $base>10$ is "{@}" and not "{e}".
*	The same function is overloaded to construct a number from a platform number (a 32-bit integer or a double precision value).
C++:
	x.SetTo(12345); y.SetTo(-0.001);
*	{BigNumber::ToString} -- Print a number to a string in a given precision and in a given base.
The precision is given as the number of digits in the given base.
The value should be rounded to that number of significant base digits.
(Integers are printed exactly, regardless of the given precision.)
C++:
	x.ToString(buffer, 200, 16); // hexadecimal
	x.ToString(buffer, 40, 10); // decimal
*	{BigNumber::Double} -- Obtain an approximate representation of {x} as double-precision value.
(The conversion may cause overflow or underflow, in which case the result is undefined.)
C++:
	double a=x.Double();

2. Basic object manipulation. These operations, as a rule, do not need to change the numerical value of the object.
*	{BigNumber::SetTo} -- Copy a number, {x := y}.
This operation should copy the numerical value exactly, without change.
C++:
	x.SetTo(y);
*	{BigNumber::Equals} -- Compare two numbers for equality, {x = y}.
C++:
	x.Equals(y)==true;
Yacas:
	MathEquals(x,y)
Note that the values are compared arithmetically, their internal precision may differ, and integers may be compared to floats.
It is only guaranteed that {Equals} returns true for equal integers, for an integer and a floating-point number with the same integer value, and for two exactly bit-by-bit equal floating-point numbers.
Floating-point comparison may be unreliable due to roundoff error and particular internal representations.
So it may happen that after {y:=x+1;} {y:=y-1;} the comparison
	y.Equals(x)
will return {false}.
*	{BigNumber::IsInt} -- Check whether the number {x} is of integer or floating type.
(Both types are represented by the same class {BigNumber}, and we need to be able to distinguish them.)
C++:
	x.IsInt()==true;
*	{BigNumber::IsIntValue} -- Check whether the number {x} has an integer value. (Not necessarily the same as the previous function, because a floating-point type can also have an integer value.)
C++:
	x.IsIntValue()==true;
Yacas: part of the implementation of
	IsInteger(x)
*	{BigNumber::BecomeInt}, {BigNumber::BecomeFloat} -- Change the type of a number from integer to float without changing the numerical value.
The precision is either set automatically (to enough digits to hold the integer), or explicitly to a given number of bits. (Roundoff might occur.)
Change the type from float to integer, rounding off if necessary.
C++:
	x.BecomeInt(); x.BecomeFloat();
	x.BecomeFloat(100);

3. Basic arithmetic operations.
Note that here "precision" always means the number of significant <i>bits</i>, i.e. digits in the base 2, <i>not decimal digits</i>.
*	{BigNumber::LessThan} -- Compare two objects, {x<y}. Returns {true} if the numerical comparison holds, regardless of the value types (integer or float).
C++:
	x.LessThan(y)==true;
Yacas:
	LessThan(x,y)
*	{BigNumber::Floor} -- Compute the integer part of a number, {x := Floor(y)}.
This function should round toward algebraically smaller integers, as usual.
C++:
	x.Floor(y);
Yacas:
	MathFloor(x)
If there are enough digits in {x} to compute its integer part, then the result is an exact integer.
Otherwise the floating-point value {x} is returned unchanged.
*	{BigNumber::GetExactBits} -- Report the current precision of a number {x} in bits.
C++:
	prec=x.GetExactBits();
Yacas:
	GetExactBits(x)
Every floating-point number contains information about how many significant bits of mantissa it currently has.
(A particular implementation may hold more bits for convenience but they may not be guaranteed to be correct.)
Integer numbers are always exact and do not have a concept of precision.
This function is undefined on integers.
The precision of a given number is changed automatically by arithmetic operations (due to round-off errors), by conversions from strings (to the given precision), or manually by the function {Precision}.
It is not strictly guaranteed that {Precision} returns the number of correct digits.
Rather, this number of digits is intended as an upper limit of the real achieved precision and as a rough measure of round-off errors.
(It is difficult to accurately track the round-off errors accumulated after many operations, without a time-consuming interval arithmetic or another similar technique.)
*	{BigNumber::SetExactBits} -- Set the precision of a number {x} and truncate (or expand) it to a given floating-point precision of {n} bits.
This has an effect of converting the number to the floating-point type with {n} significant bits of mantissa.
(No effect on integers.)
Note that the {Floor} function is not similar to {Precision} because
1) {Floor} always converts to an integer value while {Precision} converts generally to a floating-point value,
2) {Floor} always decreases the number while {Precision} tries to find the closest approximation.
For example, if $x= -1123.38$, then {x.Precision(1)} should return {-1024.}, since that's the best one-bit floating-point approximation.
However, {Floor(-1123.38)} returns {-1124}.
C++:
	x.SetExactBits(300);
Yacas:
	SetExactBits(x, 300)
*	{BigNumber::Add} -- Add two numbers, {x := y+z}, at given precision.
C++:
	x.Add(y,z, 300);
Yacas:
	MathAdd(x,y)
When subtracting almost equal numbers, a loss of precision will occur.
*	{BigNumber::Negate} -- Negate a number, {x := -y}.
C++:
	x.Negate(y);
Yacas:
	MathNegate(x)
*	{BigNumber::Multiply} -- Multiply two numbers, {x := y*z}, at given precision.
C++:
	x.Multiply(y,z, 300);
Yacas:
	MathMultiply(x,y)
*	{BigNumber::Divide} -- Divide two numbers, {x := y/z}, at given precision.
(Integers are divided exactly as integers and the "precision" argument is ignored.)
C++:
	x.Divide(y,z, 300);
Yacas:
	MathDivide(x,y)

4. Auxiliary operations (useful for optimization purposes but can be performed using the basic arithmetic).
All these operations are efficient to implement with a binary-based internal representation of big numbers.
*	{BigNumber::IsSmall} -- Check whether the number {x} fits into a platform type {long} or {double}. (Optimization of comparison.)
Sometimes this helps avoid unnecessary calculations with big numbers.
Note that the semantics of this operation is different for integers and for floats. An integer is "small" only when it fits into a platform {long} integer.
A float is "small" when it can be approximated by a platform {double} (that is, when its exponent is not too large).
C++:
	x.IsSmall()==true;
Yacas:
	MathIsSmall(x)
*	{BigNumber::MultiplyAdd} -- Multiply two numbers and add to the third, {x := x+y*z}, at given precision. (Optimization of a frequently used operation.)
C++:
	x.MultiplyAdd(y,z, 300);
Yacas:
	MathMultiplyAdd(x,y,z)
*	{BigNumber::Mod} -- Obtain the remainder modulo an integer, {x:=Mod(y,n)}.
C++:
	x.Mod(y,n);
Yacas:
	MathMod(x,n)
(Optimization of integer division, important for number theory applications.)
The integer modulus {n} is a big number.
The function is undefined for floating-point numbers.
*	{BigNumber::Sign} -- Obtain the sign of the number {x} (result is {-1}, {0} or {1}). (Optimization of comparison with 0.)
C++:
	int sign_of_x = x.Sign();
Yacas:
	MathSign(x)
*	{BigNumber::BitCount} -- Obtain
the integer part of the binary logarithm of the absolute value of {x}.
For integers, this function counts the significant bits, i.e. the number of bits needed to represent the integer.
This function is not to be confused with the number of bits that are set to 1, sometimes called the "population count" of an integer number.
The population count of 4 (binary "100") is 1, and the bit count of 4 is 3.

For floating-point numbers, {BitCount} should return the binary exponent of the number (with sign), like the integer output of the standard C function {frexp}.
Result is an integer number (a "big number").
More formally: if $n=BitCount(x)$, and $x!=0$, then $1/2 <= Abs(x)*2^(-n) < 1$.
The bit count of an integer or a floating $0$ is arbitrarily defined to be 1.
(Optimization of the binary logarithm.)
C++:
	x.BitCount(y);
	x.BitCount();
Yacas:
	MathBitCount(x)
*	{BigNumber::ShiftLeft}, {BigNumber::ShiftRight} -- Bit-shift the number (multiply or divide by the $n$-th power of $2$), {x := y >> n}, {x := y << n}.
For integers, this operation can be efficiently implemented because it has hardware support.
For floats, this operation is usually also much more efficient than multiplication or division by 2 (cf. the standard C function {ldexp}).
(Optimization of multiplication and division by a power of 2.)
Note that the shift amount is a big number.
C++:
	x.ShiftLeft(y, n); x.ShiftRight(y, n);
Yacas:
	ShiftLeft(x,n); ShiftRight(x,n);
(Versions of these functions with {n} a platform {long} integer are also provided for efficiency.)
*	{BigNumber::BitAnd}, {BigNumber::BitOr}, {BigNumber::BitXor}, {BigNumber::BitNot} -- Perform bitwise arithmetic, like in C: {x = y&z}, {x = y|z}, {x = y^z}, {x = ~y}.
This should be implemented only for integers.
Integer values are interpreted as bit sequences starting from the least significant bit.
(Optimization of operations on bit streams and some arithmetic involving powers of 2.)
C++:
	x.BitAnd(y,z); x.BitOr(y,z);
	x.BitXor(y,z); x.BitNot(y);
Yacas:
	BitAnd(x,y); BitOr(y,z);
	BitXor(y,z); BitNot(y);

The API includes only the most basic operations.
All other mathematical functions such as power, logarithm, cosine and so on, can be efficiently implemented using this basic interface.

Note that generally the arithmetic functions will set the type of the resulting object to the type of the result of the operation.
For example, operations that only apply to integers ({Mod}, {BitAnd} etc.) will set the type of the resulting object to integer if it is a float.
The results of these operations on non-integer arguments are undefined.

		Precision of arithmetic operations

All operations on integers are exact.
Integers must grow or shrink when necessary, limited only by system memory.
But with floating-point numbers, some management of precision is needed.
Here we consider the problems of handling the precision of floating-point numbers.

In some arithmetic operations (add, multiply, divide) the working precision is given explicitly.
For example,
	x.Add(y,z,100)
will add {y} to {z} and put the result into {x}, truncating it to at most 100 bits of mantissa, if necessary.
(The precision is usually given in bits, not in decimal digits, because when dealing with low-level operations it is much more natural to think in terms of bits.)
If the numbers {y}, {z} have fewer than 100 bits of mantissa each, then their sum will not be precise to all 100 digits.
That is fine;
but it is important that the sum should not contain <i>more</i> than 100 digits.
Floating-point values, unlike integers, only grow up to the given number of significant bits and then a round-off <i>must</i> occur.
Otherwise we will be wasting a lot of time on computations with many meaningless digits.

	    Automatic precision tracking

The precision of arithmetic operations on floating-point numbers can be maintained automatically, in a version of "poor man's interval arithmetic".

Suppose we have two floating-point numbers $x$ and $y$ and we know that they have certain numbers of correct mantissa bits, say $m$ and $n$.
In other words, $x$ is an approximation to an unknown real number $x'=x*(1+delta)$ and we know that $Abs(delta)<2^(-m)$; and similarly for $y$: $y'=y*(1+epsilon)$ with $Abs(epsilon)<2^(-n)$.
Here $delta$ and $epsilon$ are the relative errors for $x$ and $y$ and are typically much smaller than $1$.

Suppose that every floating-point number comes with its number of significant digits, i.e. we symbolically represent the numbers as pairs {{x,m}} or {{y,n}}.
When we perform an arithmetic operation on numbers, we need to update the precision component as well.
Now we shall consider the basic arithmetic operations to see how the precision is updated.

*HEAD Multiplication

If we need to multiply $x$ and $y$, the correct answer is $x'*y'$ but we only know an approximation to it, $x*y$.
We can estimate the precision by $x'*y' = x*y*(1+delta)*(1+epsilon)$ and it follows that the relative precision is at most $delta+epsilon$.
But we only represent the relative errors by the number of bits.
So we can either set the precision of $x*y$ to the smallest of the precisions of $x$ and $y$, or double it.

More formally, we have the estimates $Abs(delta)<2^(-m)$, $Abs(epsilon)<2^(-n)$ and we need a similar estimate $Abs(r)<2^(-p)$ for $r=delta + epsilon$.

If the two numbers $x$ and $y$ have the same number of correct bits, we should double the error (i.e. decrease the number of significant bits by 1).
But if they don't have the same number of bits, we cannot really estimate the error very well.
To be on the safe side, we might double the error if the numbers $x$ and $y$ have almost the same number of significant bits, and leave the error constant if the numbers of significant bits of $x$ and $y$ are very different.

The answer expressed as a formula is $p=Min(m,n)$ if $Abs(m-n)>2$ and $p=Min(m,n)-1$ otherwise.

If one of the operands is a floating zero $x$={{0.,m}} (see below) and $x$={{x,n}}, then $p=m-BitCount(x)+1$.
This is formally the same as if the bit count of {{0.,m}} were equal to $1-m$.

*HEAD Division

Division is multiplication by the inverse number.
When we take the inverse of $x*(1+delta)$, we obtain approximately $1/x*(1-delta)$.
The relative precision does not change when we take the inverse.
So the handling of precision is exactly the same as for the multiplication.

*HEAD Addition

Addition is more complicated because the absolute rather than the relative precision plays the main role,
and because there may be roundoff errors associated with subtracting almost equal numbers.

Formally, we have the relative precision $r$ of $x+y$ as
$$ r = (delta*x+epsilon*y)/(x+y) $$.
We have the bounds on $delta$ and $epsilon$:
$$ [Abs(delta)<2^(-m); Abs(epsilon)<2^(-n); ] $$,
and we need to find a bit bound on $r$, i.e. an integer $p$ such that $Abs(r)<2^(-p)$.
But we cannot estimate $p$ without first computing $x+y$ and analyzing the relative magnitude of $x$ and $y$.
To perform this estimate, we need to use the bit counts of $x$ and $y$ and on $x+y$.
Let these bit counts be $a$, $b$ and $c$, so that $Abs(x)<2^a$, $Abs(y)<2^b$, and $2^(c-1)<=Abs(x+y)<2^c$.
(At first we assume that $x!=0$, $y!=0$, and $x+y!=0$.)
Now we can estimate $r$ as
$$ r <= Abs((x*2^(-m))/(x+y)) + Abs((y*2^(-n))/(x+y)) <= 2^(a+1-m-c)+2^(b+1-n-c)$$.
This is formally similar to multiplying two numbers with $a+1-m-c$ and $b+1-m-c$ correct bits.
As in the case of multiplication, we may take the minimum of the two numbers, or double one of them if they are almost equal.

If one of the operands is a floating zero represented by $x$={{0.,m}} (see below), then the calculation of the error is formally the same as if $x$={{1.,m}}.
This is as if the bit count of {{0.,m}} were equal to $1$ (unlike the case of multiplication).

Finally, if the sum $x+y$ is a floating zero but $x!=0$ and $y!=0$,
then it must be that $a=b$.
In that case we represent $x+y$ as {{0.,p}}, where $p=Min(m,n)-a$.

*HEAD Computations with a given target precision

Using these rules, we can maintain a bound on the numerical errors of all calculations.
But sometimes we know in advance that we shall not be needing any more than a certain number of digits of the answer,
and we would like to avoid an unnecessarily high precision and reduce the computation time.
How can we combine an explicitly specified precision, for example, in the function
	x.Add(y,z,100)
with the automatic precision tracking?

We should truncate one or both of the arguments to a smaller precision before starting the operation.
For the multiplication as well as for the addition, the precision tracking involves a comparison of two binary exponents $2^(-g)$ and $2^(-h)$ to obtain an estimate on $2^(-g)+2^(-h)$.
Here $g$ and $h$ are some integers that are easy to obtain during the computation.
For instance, the multiplication involves $g=m$ and $h=n$.
This comparison will immediately show which of the arguments dominates the error.

The ideal situation would be when one of these exponentials is much smaller than the other, but not very much smaller (that would be a waste of precision).
In other words, we should aim for $Abs(g-h)<8$ or so, where $8$ is the number of guard bits we would like to maintain.
(Generally it is a good idea to have at least 8 guard bits;
somewhat more guard bits do not slow down the calculation very much, but 200 guard bits would be surely an overkill.)
Then the number that is much more precise than necessary can be truncated.

For example, if we find that $g=250$ and $h=150$, then we can safely truncate $x$ to $160$ bits or so;
if, in addition, we need only $130$ bits of final precision,
then we could truncate both $x$ and $y$ to about $140$ bits.

Note that when we need to subtract two almost equal numbers, there will be a necessary loss of precision,
and it may be impossible to decide on the target precision before performing the subtraction.
Therefore the subtraction will have to be performed using all available digits.

*HEAD The floating zero

When we obtain a zero, it is always a result of subtraction.
An integer zero is exact, so {0*1.1} is exactly zero, also an integer.
However, {x:=1.1-1.1} is a floating-point zero (a "floating zero" for short) of which we can only be sure about the first digit, {x=0.0}.
The number {x} might represent {0.01} or {-0.02} for all we know.

It is impossible to track the <i>relative</i> precision of a floating zero, but it is possible to track the <i>absolute</i> precision.
Suppose we store the bit count of the absolute precision, just as we store the bit count of the relative precision with nonzero floats.
Thus we represent a floating zero as a pair {{0.,n}} where $n$ is an integer, and the meaning of this is a number between $-2^(-n)$ and $2^(-n)$.

We can now perform some arithmetic operations on the floating zero.
Addition and multiplication are handled similarly to the non-zero case, except that we interpret {n} as the absolute error rather than the relative error.
This does not present any problems.
For example, the error estimates for addition is the same as if we had a number $1$ with relative error $2^(-n)$ instead of {{0.,n}}.
With multiplication of {{x,m}} by {{0.,n}}, the result is again a floating zero {{0.,p}}, and the new estimate of <i>absolute</i> precision is $p=n-BitCount(x)+1$.

The division by the floating zero, negative powers, and the logarithm of the floating zero are not representable in our arithmetic because, interpreted as intervals, they would correspond to infinite ranges.
The bit count of the floating zero is therefore undefined.
However, we can define a positive power of the floating zero (the result is again a floating zero).

The sign of the floating zero is defined as (integer) 0.
(Then we can quickly check whether a given number is a zero.)

	    Comparison of floats

Suppose we need to compare floating-point numbers {x} and {y}.
In the strict mathematical sense this is an unsolvable problem
because we may need in principle arbitrarily many digits of {x} and {y}
before we can say that they are equal. In other words, "zero-testing is
uncomputable". So we need to relax the mathematical rigor somewhat.

Suppose that {x=12.0} and {y=12.00}. Then in fact {x} might represent a number
such as {12.01}, while {y} might represent {11.999}.
There may be two approaches: first, "12.0" is not equal to "12.00"
because {x} and {y} <i>might</i> represent different numbers.  Second, "12.0"
is equal to "12.00" because {x} and {y} <i>might</i> also represent equal
numbers. A logical continuation of the
first approach is that "12.0" is not even equal to another copy
of "12.0"  because they <i>might</i> represent different numbers, e.g. if we
compute {x=6.0+6.0} and {y=24.0/2.0}, the roundoff errors <i>might</i> be
different.

Here is an illustration in support for the idea that the comparison {12.0=12} should
return {True}. Suppose we are writing an algorithm for computing the
power, {x^y}. This is much faster if {y} is an integer because we can use
the binary squaring algorithm. So we need to detect whether {y} is an
integer. Now suppose we are given {x=13.3} and {y=12.0}. Clearly we should
use the integer powering algorithm, even though technically {y} is a
float.
(To be sure, we should check that the integer powering algorithm generates enough significant digits.)

However, the opposite approach is also completely possible: no two floating-point numbers should be considered equal, except perhaps when one is a bit-for-bit exact copy of the other and when we haven't yet performed any arithmetic on them.
(The GMP library uses essentially this definition.)
It seems that no algorithm really needs a test for equality of floats.
The two useful comparisons on floats $x$, $y$ seem to be the following:
*	1. whether $Abs(x-y)<epsilon$ where $epsilon$ is a given floating-point number representing the precision,
*	2. whether $x$ is positive, negative, or zero.

Given these predicates, it seems that any floating-point algorithm can be implemented
just as efficiently as with any "reasonable" definition of the floating-point equality.

	    How to increase of the working precision

Suppose we declare {Precision(5)}, write {x:=0.1}, 
and then increase 
precision to 10 digits. What is {x} now? There are several approaches:

1) The number {x} stays the same but further calculations are done with 10
digits. In terms of the internal binary representation, the number is
padded with binary zeros. This means that now e.g. {1+x} will not be equal
to 1.1 but to something like 1.100000381 (to 10 digits). And actually x
itself should evaluate to 0.1000003815 now. This was 0.1 to 5 digits but
it is a little different if we print it to 10 digits.

This problem may look horrible at first sight -- "how come I can't write
0.1 any more??" -- but this seems so because we are used to
calculations in decimals with a fixed precision, and the operation such
as "increase precision by 10 digits" is largely unfamiliar to us except
in decimals. This seems to be mostly a cosmetic problem. In a real
calculation, we shouldn't be writing "0.1" when we need an exact number
{1/10}.
When we increase precision in the middle of the calculation, this mistake surfaces and gives unexpected results.

2) When precision is increased, the number {x} takes its decimal
representation, pads it with zeros, and converts back to the internal
representation, just so that the appearance of "1.100000381" does not
jar our eyes. (Note that the number {x} does not become "more precise"  
if we pad it with decimal zeros instead of binary zeros, unless we made
a mistake and wrote "0.1" instead an exact fraction 1/10.) 

With this approach, each number {x} that doesn't currently have enough
digits must change in a complicated way. This will mean a performance
hit in all calculations that require dynamically changing precision
(Newton's method and some other fast algorithms require this). In these
calculations, the roundoff error introduced by "1.100000381" is
automatically compensated and the algorithm will work equally well no
matter how we extend {x} to more digits; but it's a lot slower to go 
through the decimal representation every time.

	    The meaning of the {Precision()} call

We could use different interpretations:
The first interpretation is that {Precision(10)} means "I want all answers 
to contain 10 correct digits".
The second interpretation is "do all calculations with at least 10 
digits when floating-point is needed".

Suppose we have floating-point numbers {x} and {y}, known to 2 and 3 significant
digits respectively. For example, {x=1.6} and {y=2.00}. These {x} and {y} are
results of previous calculations and we do not have any more digits than this.  If we now say
	Precision(10);
	x*y;
then clearly the system cannot satisfy the first interpretation because there
aren't enough digits of $x$ and $y$ to know the 10 digits of $x*y$. But we
can satisfy the second interpretation, even if we print "3.2028214767" or 
something like that. The garbage after the third digit is unavoidable 
and harmless unless our calculation really depends on having 10 correct 
digits of $x*y$. But if our calculation depends on the way we choose the extra digits, then we are using a bad algorithm.

The first interpretation of {Precision()} is only possible to satisfy if
we are given a self-contained calculation starting with rational
numbers. For example,
	N(Sin(Sqrt(3)-10^(50)), 50)
This can be computed to 50 digits with some effort. (But only if
we are smart enough to use 100 digits in the calculation of the argument
of {Sin()}.)
The result of this calculation will have 50 digits and 
not a digit more; we cannot put the result inside another expression 
and expect full precision in all cases.
This seems to be a separate task, "compute something with {n} digits 
no matter what", and not a general routine to be followed at all times.

So it seems that the second interpretation of {Precision()}, namely:
"please use that many digits in all calculations now", is a little more
sensible as a general-purpose prescription.

But let's look at a particular case (for simplicify I am talking about
decimal digits but in the implementation they will be binary digits).
Suppose we have {x} precise to 10 digits and {y} precise to 20 digits, and
the user says {Precision(50)} and {z:=x*y+1.4}. What happens now in this
calculation? (Assume that {x} and {y} are small numbers of order 1; the
other cases are similar.)

First, the number "1.4" is now interpreted as being precise to 50 
digits, i.e. "1.4000000...0" but not more than 50 digits.

Then we compute {x*y} using their internal representations. The result is 
good only to 10 digits, and it knows this. We do not compute 50 digits 
of the product {x*y}, it would be pointless and a waste of time.

Then we add {x*y} to 1.4000...0. The sum, however, will be precise only to
10 digits. We can do one of the two things now: (a) we could pad {x*y}
with 40 more zero digits and obtain a 50-digit result. However, this
result will only be correct to 10 digits. (b) we could truncate 1.4 to
10 digits (1.400000000) and obtain the sum to 10 digits.
In both cases the result will "know" that it only has 10 correct digits.

It seems that the option (b) is better because we don't waste time with
extra digits

The result is a number that is precise to 10 digits. However, the user
wants to see this result with 50 digits. Even if we chose the option
(a), we would have had some bogus digits, in effect, 40 digits of
somewhat random round-off error. Should we print 10 correct digits and
40 bogus digits? It seems better to print only 10 correct
digits in this case.
The GMP library already has this functionality in its string printing functions: it does not print more digits than the number actually knows to be correct.

If we choose this route, then the only effect of {Precision(50)} was to 
interpret a literal constant 1.4 as a 50-digit number. All other numbers already know their 
real precision and will not invent any bogus digits.

In some calculations, however, we do want to explicitly extend the precision of a
number to some more digits. For example, in Newton's method we are given
a first approximation $x[0]$ to a root of $f(x)=0$ and we want to have more
digits of that root. Then we need to pad $x[0]$ with some more digits and
re-evaluate $f(x[0])$ to more digits, to get a better
approximation to the correct root. This padding operation seems rather
special, and directed at a particular number, not at all numbers at
once. For example, if $f(x)$ itself contains some floating-point numbers,
then we should be unable to evaluate it with higher precision than
possible. So it seems that we need access to low-level operations:  the
padding and the query of current precision.
The proposed interface is {GetExactBits(x)}
and {SetExactBits(x,n)}.
These operations are directed at particular number objects.

	    Summary of arbitrary-precision semantics

*	1. All integers are always exact; all floats carry an error estimate, which is stored as the number of correct bits of mantissa they have.
Symbolically, each float is a pair {{x,n}} where {x} is a floating-point value and {n} is a (platform) integer value.
If $x!=0$, then the relative error of $x$ is not larger than $2^(-n)$.
This integer {n} is returned by {GetExactBits(x)}
and can be modified by {SetExactBits(x,n)} (see below).
Error estimates are not guaranteed to be correct in all cases, but they should give sensible upper bounds on the error.
A number {{x,n}} stands for an interval between $x*(1-2^(-n))$ and $x*(1+2^(-n))$.
*	1. The number 0 is either an integer {0} or a floating-point {0.}
(a "floating zero" for short).
For a floating zero, the "number of exact bits" means an absolute error, not a relative error.
It means that the symbolic pair {{0.,n}} represents all number $x$ in the interval $-2^(-n)<=x<=2^(-n)$.
*	1. An integer and a float are equal only if the float contains this
integer value within its precision interval.
Two floats are equal only if their values differ by less than the largest of their error estimates (i.e. if their precision intervals intersect).
In particular, it means that an integer zero is always equal to any floating zero, and any two floating zeros are equal.
It follows that if {x=y}, then for any floating zeros {x+0.=y+0.} and {x-y=0.} as well.
(So this arithmetic is not obviously inconsistent.)
*	1. {IsInteger(x)} returns {True} if {x} has integer <i>type</i>;
{IsIntValue(x)} returns {True} if {x} has either integer type or floating type but an integer value within its precision.
For example,
	IsInteger(0)  =True
	IsIntValue(1.)=True
	IsInteger(1.) =False
*	1. {Precision(n)} sets a global parameter that controls the precision of
<i>newly created floats</i>.
It does not modify previously created floating-point numbers, and it has no effect on integer calculations.
New number objects can be created in three ways: from literal strings, from integers, and from calculations with other floats.
For example,
	x:=1.33;
	y:=x/3;
Here {x} is created from a literal string {"1.33"},
a temporary float is created from an integer {3},
and {y} is created as a result of division of two floats.
Converting an integer to a float is similar to converting from a literal string representing the integer.
A new number object created from a literal string must have at least as many bits of mantissa as is required to represent the value given by the string.
The string might be very long but we want to retain all information from a string, so we may have to make the number much more precise than the currently declared {Precision}.
*FOOT Note that the argument {n} of {Precision(n)} means <i>decimal</i> digits, not bits.
But if the necessary number of digits to represent the string is less than {n}, then the new number object will have the number of bits that corresponds to {n} decimal digits.
Thus, in creating objects from strings or from integers, {Precision} sets the <i>minimum</i> precision of the resulting floating-point number.
On the other hand, a new number object created from a calculation will already have an error estimate and will "know" its real precision.
But a directive {Precision(n)} indicates that we are only interested in $n$ digits of a result.
Therefore, a calculation should not generate <i>more</i> digits than
{n}, even if its operands have more digits.
Thus, in creating objects from operations, {Precision} sets the <i>maximum</i> precision of the resulting floating-point number.
*	1. {SetExactBits(x,n)} will make the number {x} think that it has {n} exact
bits. If {x} had more exact bits before, then it may be rounded. If {x}
had fewer exact bits before, then it may be padded. (The way the padding is done
is up to the internal representation, but the padding operation must be 
efficient and should not change the value of the number beyond its original
precision.)
*	1. All arithmetic operations and all kernel-supported numerical function
calls are performed with precision estimates, so that all results know
how precise they really are. Then in most cases it
will be unnecessary to call {SetExactBits} or {GetExactBits} explicitly.
This will be needed only in certain numerical applications that need to control the working precision for efficiency.

	    Formal definitions for precision of arithmetic operations

Here we shall consider arithmetic operations on floats $x$ and $y$, represented as pairs {{x,m}} and {{y,n}}.
The result of the operation is $z$, represented as a pair {{z,p}}.

We give formulae for $p$ in terms of $x$, $y$, $m$, and $n$.
Sometimes the bit count of a number $x$ is needed; it is denoted $B(x)$ for brevity.

*HEAD Formal definitions

A pair {{x,m}} where $x$ is a floating-point value and $m$ is an integer value (the "number of correct bits") denotes a real number between $x*(1-2^(-m))$ and $x*(1+2^(-m))$ when $x!=0$,
and a real number between $-2^(-m)$ and $2^(-m)$ when $x=0$ (a "floating zero").

The bit count $B(x)$ is an integer function of $x$ defined for real $x!=0$ by
$$ B(x) := 1+Floor(Ln(Abs(x))/Ln(2)) $$.
This function also satisfies
$$ 2^(B(x)-1) <= Abs(x) < 2^B(x) $$.
For example, $B(1/4)= -1$, $B(1)=B(3/2)=1$, $B(4)=3$.
The bit count of zero is arbitrarily set to 1.
For integer $x$, the value $B(x)$ is the number of bits needed to write the binary representation of $x$.

The bit count function can be usually computed in <i>constant</i> time because the usual representation of long numbers is by arrays of platform integers and a binary exponent.
The length of the array of digits is usually available at no computational cost.

The <i>absolute</i> error $Delta[x]$ of {{x,n}} is of order $Abs(x)*2^(-n)$.
Given the bit count of $x$, this can be estimated from as 
$$2^(B(x)-n-1)<=Delta[x]<2^(B(x)-n)$$.
So the bit count of $Delta$ is $B(x)-n$.

*HEAD {Floor()}

The function {Floor({x,m})} gives an integer result if there are enough digits to determine it exactly, and otherwise returns the unchanged floating-point number.
The condition for {Floor({x,m})} to give an exact result is
$$ m>=B(x) $$.

*HEAD {BecomeFloat()}

The function {BecomeFloat(n)} will convert an integer to a float with at least $n$ digits of precision.
If {x} is the original integer value, then the result is {{x,p}} where $p=Max(n,B(x))$.


*HEAD Underflow check

It is possible to have a number {{x,n}} with $x!=0$ such that {{0.,m}={x,n}} for some $m$.
This would mean that the floating zero {{0.,m}} is not precise enough to be distinguished from {{x,n}}, i.e.
$$ Abs(x) < 2^(-m) $$.
This situation is normal.
But it would be meaningless to have a number {{x,n}} with $x!=0$ and a precision interval that contains $0$.
Such {{x,n}} will in effect be equal to <i>any</i> zero {{0.,m}}, because we do not know enough digits of {x} to distinguish {{x,n}} from zero.

From the definition of {{x,n}} with $x!=0$ it follows that 0 can be within the precision interval only if $n<= -1$.
Therefore, we should transform any number {{x,n}} such that $x!=0$ and $n<= -1$
into a floating zero {{0.,p}} where
$$p=n-B(x)$$.
(Now it is not necessarily true that $p>=0$.)
This check should be performed at any point where a new precision estimate {n} is obtained for a number {x} and where a cancellation may occur (e.g. after a subtraction).
Then we may assume that any given float is already reduced to zero if possible.

*HEAD {Equals()}

We need to compare {{x,m}} and {{y,n}}.

First, we can quickly check that the values $x$ and $y$ have the same nonzero signs and the same bit counts, $B(x)=B(y)$.
If $x>0$ and $y<0$ or vice versa, or if $B(x)=B(y)$, then the two numbers are definitely unequal.
We can also check whether both $x=y=0$; if this is the case, then we know that {{x,m}={y,n}} because any two zeros are equal.

However, a floating zero can be sometimes equal to a nonzero number.
So we should now exclude this possibility:
{{0.,m}={y,n}} if and only if $Abs(y)<2^(-m)$.
This condition is equivalent to $$ B(y) < -m $$.

If these checks do not provide the answer, the only possibility left is when
$x!=0$ and $y!=0$ and $B(x)=B(y)$.

Now we can consider two cases: (1) both $x$ and $y$ are floats, (2) one is a float and the other is an integer.

In the first case, {{x,m}={y,n}} if and only if the following condition holds:
$$ Abs(x-y)<Max(2^(-m)*Abs(x), 2^(-n)*Abs(y)) $$.
This is a somewhat complicated condition but its evaluation does not require any long multiplications, only long additions, bit shifts and comparisons.

It is always necessary to compute $x-y$ (one long addition);
this computation needs to be done with $Min(m,n)$ bits of precision.

After computing $x-y$, we can avoid the full evaluation of the complicated condition by first checking some easier conditions with the bit count of $x-y$.
A fast sufficient (but not a necessary) condition is:
if $B(x-y)<=B(x)-Min(m,n)-1$ then {{x,m}={y,n}}.
A fast necessary (but not a sufficient) condition is:
if $B(x-y)>B(x)-Min(m,n)+1$ then {{x,m}!={y,n}}.
If neither of these conditions can give us the answer,
we have to evaluate the full condition by computing $Abs(x)*2^(-m)$ and $Abs(x)*2^(-m)$ and comparing with $Abs(x-y)$.

In the second case, one of the numbers is an integer {x} and the other is a float {{y,n}}.
Then {x={y,n}} if and only if $$ Abs(x-y)<2^(-n)*Abs(y) $$.
For the computation of $x-y$, we need to convert {x} into a float with precision of $n$ digits, i.e. replace the integer {x} by a float {{x,n}}.
Then we may use the procedure for the first case (two floats) instead of implementing a separate comparison procedure for integers.


*HEAD {LessThan()}

If {{x,m}}={{y,n}} according to the comparison function {Equals()}, then the predicate {LessThan} is false.
Otherwise it is true if and only if $x<y$ as floats.

*HEAD {IsIntValue()}

To check whether {{x,n}} has an integer value within its precision, we first need to check that {{x,n}} has enough digits to compute $Floor(x)$={Floor(x)} accurately.
If not (if $n<B(x)$), then we conclude that $x$ has an integer value.
Otherwise we compute $y:=x-Floor(x)$ as a float value (without precision control) to {n} bits.
If $y$ is exactly zero as a float value, then $x$ has an integer value.
Otherwise {{x,n}} has an integer value if and only if $B(y)< -n$.

This procedure is basically the same as comparing {{x,n}} with {Floor(x)}.

*HEAD {Sign()}

The sign of {{x,n}} is defined as the sign of the float value $x$.
(The number {{x,n}} should have been reduced to a floating zero if necessary.)

*HEAD Addition and subtraction ({Add}, {Negate})

We need to add {{x,m}} and {{y,n}} to get the result {{z,p}}.
Subtraction is the same as addition, except we negate the second number.
When we negate a number, its precision never changes.

First consider the case when $x+y!=0$.

If $x$ is zero, i.e. {{0.,m}} (but $x+y!=0$), then the situation with precision is the same as if $x$ were {{1.,m}}, because then the relative precision is equal to the absolute precision.
In that case we take the bit count of $x$ as $B(0)=1$ and proceed by the same route.

First, we should decide whether it is necessary to add the given numbers.
It may be unnecessary if e.g. $x+y<=>x$ within precision of $x$
(we may say that a "total underflow" occurred during addition).
To check for this, we need to estimate the absolute errors of $x$ and $y$:
$$ 2^(B(x)-m-1) <= Delta[x] < 2^(B(x)-m) $$,
$$ 2^(B(y)-n-1) <= Delta[y] < 2^(B(y)-n) $$.
Addition is not necessary if $Abs(x)<=Delta[y]$ or if $Abs(y)<=Delta[x]$.
Since we should rather perform an addition than wrongly dismiss it as unnecessary, we should use a sufficient condition here: if
$$ B(x)<=B(y)-n-1 $$
then we can neglect $x$ and set $z=y$, $p=n-Dist(B(x),B(y)-n-1)$.
(We subtract one bit from the precision of $y$ in case $x$ is close to the absolute error.)
Also, if
$$ B(y)<=B(x)-m-1 $$
then we can neglect $y$ and set $z=x$, $p=m-Dist(B(y),B(x)-m-1)$.

Suppose none of these checks were successful.
Now, the float value $z=x+y$ needs to be calculated.
To find it, we need the target precision of only
$$ 1+Max(B(x),B(y))-Max(B(x)-m,B(y)-n) $$
bits.
(An easy upper bound on this is $1+Max(m,n)$ but this is wasteful when $x$ and $y$ have very different precisions.)

Then we compute $B(z)$ and determine the precision $p$ as
$$ p = Min(m-B(x),n-B(y))+B(z)$$
$$-1-Dist(m-B(x),n-B(y)) $$,
where the auxiliary function $Dist(a,b)$ is defined as $0$ when $Abs(a-b)>2$ and $1$ otherwise.
*FOOT The definition of $Dist(a,b)$ is necessarily approximate; if we replace $2$ by a large number, we shall be overestimating the error in more cases.
The result is {{z,p}}.

Note that the obtained value of $p$ may be negative (total underflow) even though we have first checked for underflow.
In that case, we need to transform {{z,p}} into a floating zero, as usual.

Now consider the case when $z:=x+y=0$.

This is only possible when $B(x)=B(y)$.
Then the result is {{0.,p}} where $p$ is found as
$$ p = 1+Min(m,n)-B(x)-Dist(m,n) $$.
Note that this is the same formula as in the general case, if we define $B(z)=B(0):=1$.
Therefore with this definition of the bit count one can use one formula for the precision of addition in all cases.

If the addition needs to be performed with a given maximum precision $P$, and it turns out that $p>P$, then we may truncate the final result to $P$ digits and set its precision to $P$ instead.
(It is advisable to leave a few bits untruncated as guard bits.)
However, the first operation {z:=x+y} must be performed with the precision specified above, or else we run the danger of losing significant digits of $z$.

*HEAD Adding integers to floats

If an integer {x} needs to be added to a float {{y,n}}, then we should formally use the same procedure as if {x} had infinitely many precise bits.
In practice we can take some shortcuts.
It is enough to convert the integer to a float {{x,m}} with a certain finite precision $m$ and then follow the general procedure.
The precision $m$ must be large enough so that the absolute error of {{x,m}} is smaller than the absolute error of {{y,n}}: $B(x)-m<=B(y)-n-1$, hence
$$ m>=1+n+B(x)-B(y) $$.
In practice we may allow for a few guard bits over the minimum $m$.


*HEAD Multiplication

We need to multiply {{x,m}} and {{y,n}} to get the result {{z,p}}.

First consider the case when $x!=0$ and $y!=0$.
The resulting value is $z=x*y$ and the precision is
$$ p = Min(m,n)-Dist(m,n) $$.

If one of the numbers is an integer {x}, and the other is a float {{y,n}}, it is enough to convert {x} to a float with somewhat more than $n$ bits, e.g. {{x,n+3}}, so that the $Dist$ function does not decrement the precision of the result.

Now consider the case when {{x,m}}={{0,m}} but $y!=0$.
The result $z=0$ and the resulting precision is
$$ p = m-B(y)+1 $$.

Finally, consider the case when {{x,m}}={{0,m}} and {{y,n}}={{0,n}}.
The result $z=0$ and the resulting precision is
$$ p = m+n $$.

The last two formulae are the same if we defined the bit count of {{0.,m}} as $1-m$.
This differs from the "standard" definition of $B(0)=1$.
(The "standard" definition is convenient for the handling of addition.)
With this non-standard definition, we may use the unified formula
$$ p=2-B(x)-B(y) $$
for the case when one of $x$, $y$ is a floating zero.

If the multiplication needs to be performed to a given target precision $P$ which is larger than the estimate $p$, then we can save time by truncating both operands to $P$ digits before performing the multiplication.
(It is advisable to leave a few bits untruncated as guard bits.)

*HEAD Division

Division is handled essentially in the same way as multiplication.
The relative precision of {x/y} is the same as the relative precision of {x*y} as long as both $x!=0$ and $y!=0$.

When $x=0$ and $y!=0$, the result of division {{0.,m}/{y,n}} is a floating zero {{0.,p}} where $ p= m+B(y)-1$.
When $x$ is an integer zero, the result is also an integer zero.

Division by an integer zero or by a floating zero is not permitted.

*HEAD {ShiftLeft()}, {ShiftRight()}

These operations efficiently multiply a number by a positive or negative power of $2$.
Since $2$ is an exact integer, the precision handling is similar to that of multiplication of floats by integers.

If the number {{x,n}} is nonzero, then only $x$ changes by shifting but $n$ does not change;
if {{x,n}} is a floating zero, then $x$ does not change and $n$ is decremented ({ShiftLeft}) or incremented ({ShiftRight}) by the shift amount:
	{x, n} << s = {x<<s, n};
	{0.,n} << s = {0., n-s};
	{x, n} >> s = {x>>s, n};
	{0.,n} >> s = {0., n+s};


		Implementation notes

	    Large exponents

One proposed feature of the {BigNumber} API is the support for large exponents for floating-point numbers.
The idea is that a floating-point number $x$ is equivalent to two integers $M$, $N$ such that $x=M*2^N$. Here $M$ is the (denormalized) mantissa and $N$ is the (binary) exponent.
The integer $M$ must be a "big integer" that may represent thousands of significant bits.
Then it seems natural to make the exponent $N$ also a big integer and not impose some platform-dependent limitations on its size.
Implementing this idea will help avoid some cases of overflow and underflow, although one would not expect that most real-world calculations will be significantly affected.

The only concern with this scheme is efficiency of operations.
Arithmetic with floating-point numbers requires only very simple operations on their exponents (basically, addition and comparisons).
The {BigNumber} API can be implemented efficiently so that there is not much loss of time when the numbers are actually small.
This will reduce the overhead required for handling exponents.

To realize this idea, the API specifies that big numbers are used in situations when normally one would expect a platform number.
The relevant functions are {BitCount}, {ShiftLeft}, {ShiftRight}.
At first sight, it seems unlikely that we shall need numbers with more than $2^32$ bits (although computer hardware may develop very quickly to cover that range).
However, the real catch is the floating-point overflow and underflow.
The bit count is defined as the integer part of the binary logarithm of the absolute value of the number.
Defined in this way, the "bit count" of a floating-point number can exceed a 32-bit {long} value; consider for example $x=Exp(Exp(1000))$.
Similarly, we may need to multiply a floating-point number by a very large power of $2$ using the very efficient {ShiftLeft} function.

On the other hand, it is impractical to print several billion digits to the screen.
So the precision argument in string printing functions should be not a big integer but a platform integer.
Also, alternative versions of the API functions {BitCount}, {ShiftLeft}, {ShiftRight} may be provided with platform-typed arguments.


In the future this limitation might be avoided if we use a 64-bit platform.
(Clearly, a 64-bit platform is a better choice for heavy-duty multiple-precision computations than a 32-bit platform.)


	    Library versions of mathematical functions

It is usually the case that a multiple-precision library implements some basic mathematical functions such as the square root.
A library implementation may be already available and more efficient than an implementation using the API of the wrapper class {BigNumber}.
In this case it is desirable to wrap the library implementation of the mathematical function, rather than use a suboptimal implementation.
This could be done in two ways.

First, we recognize that we shall only have one particular numerical library linked with Yacas, and we do not have to compile our implementation of the square root if this library already contains a good implementation.
We can use conditional compilation directives ({#ifdef}) to exclude our square root code and to insert a library wrapper instead.
This scheme could be automated, so that appropriate {#define}s are automatically created for all functions that are already available in the given multiple-precision library, and the corresponding Yacas kernel code that uses the {BigNumber} API is automatically replaced by library wrappers.

Second, we might compile the library wrapper as a plugin, replacing the script-level square root function with a plugin-supplied function.
This solution is easier in some ways because it doesn't require any changes to the Yacas core, only to the script library.
However, the library wrapper will only be available to the Yacas scripts and not to the Yacas core functions.
The basic assumption of the plugin architecture is that plugins can provide new external objects and functions to the scripts, but plugins cannot modify anything in the kernel.
So plugins can replace a function defined in the scripts, but cannot replace a kernel function.
Suppose that some other function, such as a computation of the elliptic integral which heavily uses the square root, were implemented in the core using the {BigNumber} API.
Then it will not be able to use the square root function supplied by the plugin because it has been already compiled into the Yacas kernel.

Third, we might put all functions that use the basic API ({MathSqrt}, {MathSin} etc.) into the script library and not into the Yacas kernel.
When Yacas is compiled with a particular numerical library, the functions available from the library will also be compiled as the kernel versions of {MathSqrt}, {MathPower} and so on
(using conditional compilation or configured at build time).
Since Yacas tries to call the kernel functions before the script library functions, the available kernel versions of {MathSqrt} etc. will supersede the script versions, but other functions such as {BesselJ} will be used from the script library.
The only drawback of this scheme is that a plugin will not be able to use the faster versions of the functions, unless the plugin was compiled specifically with the requirement of the particular numerical library.

So it appears that either the first or the third solution is viable.





	    The internal storage of BigNumber objects

An object of type {BigNumber} represents a number (and contains all
information relevant to the number), and offers an interface to
operations on it, dispatching the operations to an underlying
arbitrary precision arithmetic library.

Higher up, Yacas only knows about objects derived from {LispObject}.
Specifically, there are objects of class {LispAtom} which represent
an atom. They are uniquely represented by the result returned by
the {String()} method. 

For numbers, there is a separate class, {LispNumber}. Objects
of class {LispNumber} also have a {String()} method in case
a string representation of a number is needed, but the main 
uniquely identifying piece of information is the object of
class {BigNumber} which is returned by the {Number(precision)}
method.

The life cycle of a {LispNumber} is as follows:

*	1. A {LispNumber} can be born when the parser reads in a numeric
atom. In such a case an object of type {LispNumber} is created in stead
of the {LispAtom}. The {LispNumber} constructor proceeds to create
an object of type {BigNumber} in response.
*	1. For a calculation, say addition, two arguments are passed in,
and their internal object should be of class {LispNumber}, so that the
function doing the multiplication can get at the {BigNumber} objects
by calling the {Number()} methods. The function doing the multiplying
then creates a new {BigNumber}, stores the result of the multiplication
in it, and again creates a {LispNumber} by constructing it with the
resulting {BigNumber}. Note no conversion to string representation is needed,
and thus not made. The result is a {LispNumber} with just a {BigNumber}
inside it. Other operations can proceed to use this {BigNumber}
stored inside the {LispNumber}. This is in effect the second way a
{LispNumber} can be born.
*	1. Right at the end, when a result needs to be printed to screen,
the printer will call the {String()} method of the {LispNumber} object,
to get a string representation to print. The string representation is also
stored in the {LispNumber} This is not expensive, as it is just a pointer
to a string in the string container (hash table).

In order to fully support the {LispNumber} object, the function in the
kernel that determines if two objects are the same needs to know about
{LispNumber}. This is required to get valid behaviour. Pattern matching
for instance uses comparisons of this type, so comparisons are performed
often and need to be efficient.

The other functions working on numbers can, in principle, call the
{String()} method, but that induces conversions from {BigNumber}
to string, which are relatively expensive operations. For efficiency
reasons, the functions dealing with numeric input should call the
{Number()} method, operate on the {BigNumber} returned, and
return a {LispNumber} constructed with a {BigNumber}. A function
can call {String()} and return a {LispNumber} constructed with 
a string representation, but it will be less efficient.


*HEAD Precision tracking inside LispNumber

There are various subtle details when dealing with precision.
A number gets constructed with a certain precision, but a
higher precision might be needed later on. That is the reason there
is a {aPrecision} argument to the {Number()} method. 

A {BigNumber} gets constructed with a minimum lower bound on the 
precision, but the actual internal representation the underlying
numeric library uses might actually store the number with even
higher precision. This is needed because at a certain stage 
the actual digits it was constructed with need to be reproduced
to higher precision than when the object was created. The string
representation has to match the one the {BigNumber} was created with.

There are thus actually two precisions in the {BigNumber}. One is
the precision it was constructed with, the value passed in by the system.
This is the lower bound, the minimum precision the user requires.
Above that, the representation inside {BigNumber} has the actual
precision, the precision it needs to perform to specifications.
It has to reproduce the string representation it was constructed
with, so it might decide to use a higher precision than the system passed
to it.









