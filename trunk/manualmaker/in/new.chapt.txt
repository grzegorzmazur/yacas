		Designing modules in the Yacas scripting language

	    Introduction

For any software project where the source code grows to
a substantial amount of different modules, there needs to be
a way to define interfaces between the modules, and a way
to make sure the modules don't interact with the environment
in an unintended way. 

One hallmark of a mature programming language is that it 
supports modules, and a way to define its interface while
hiding the internals of the module. This section describes
the mechanisms for doing so in the Yacas scripting language.

	    Demonstration of the problem
 
Unintentional interactions between two modules typically happen 
when the two modules accidentally share a common "global"
resource, and there should be a mechanism to guarantee that this
will not happen.

The following piece of code is a little example that demonstrates
the problem:

	SetExpand(fn_IsString) <-- [expand:=fn;];
	ram(x_IsList)_(expand != "") <-- ramlocal(x);
	expand:="";
	ramlocal(x) := Map(expand,{x});

This little bit of code defines a function {ram} that calls the
function {Map}, passing the argument passed if it is a string, and
if the function to be mapped was set with the {SetExpand} function.
It contains the following flaws:

*	0. {expand} is a global variable with a rather generic name, one
that another module might decide to use.
*	0. {ramlocal} was intended to be used from within this module only, and
doesn't check for correctness of arguments (a small speed up optimization
that can be used for routines that get called often). As it is, it can be
called from other parts, or even the command line.
*	0. the function {ramlocal} has one parameter, named {x}, which is also
generic (and might be used in the expression passed in to the function),
and {ramlocal} calls {Map}, which calls {Eval} on the arguments. 

The above code can be entered into a file and loaded from the command
line at leisure. Now, consider the following command line interaction
after loading the file with the above code in it:

	In> ramlocal(a)         
	In function "Length" : 
	bad argument number 1 (counting from 1)
	Argument matrix[1] evaluated to a
	In function call  Length(a)
	CommandLine(1) : Argument is not a list

We called {ramlocal} here, which should not have been allowed.

	In> ram(a)
	Out> ram(a);

The function {ram} checks that the correct arguments are passed in
and that {SetExpand} was called, so it will not evaluate if these
requirements are not met. 

Here are some lines showing the functionality of this code as
it was intended to be used:

	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};

The following piece of code forces the functionality to break
by passing in an expression containing the variable {x}, which
is also used as a parameter name to {ramlocal}.

	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {{Sin(x),Sin(y),Sin(z)},Sin(y),Sin(z)};

This result is obviously wrong, comparing it to the call above.
The following shows that the global variable {expand} is exposed
to its environment:

	In> expand
	Out> "Sin";


	    Declaring resources to be local to the module

The solution to the problem is {LocalSymbols}, which changes every
symbol with a specified name to a unique name that could never
be entered by the user on the command line and guarantees that it
can never interact with the rest of the system. The following code
snippet is the same as the above, with the correct use of {LocalSymbols}:


	LocalSymbols(x,expand,ramlocal) [
	  SetExpand(fn_IsString) <-- [expand:=fn;];
	  ram(x_IsList)_(expand != "") <-- ramlocal(x);
	  expand:="";
	  ramlocal(x) := Map(expand,{x});
	];


This version of the same code declares the symbols {x}, {expand}
and {ramlocal} to be local to this module.

With this the interaction becomes a little bit more predictable:

	In> ramlocal(a)
	Out> ramlocal(a);
	In> ram(a)
	Out> ram(a);
	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};
	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {Sin(x),Sin(y),Sin(z)};
	In> expand
	Out> expand;


	    When to use and when not to use {LocalSymbols}

The {LocalSymbols} should ideally be used for every global variable,
for functions that can only be useful within the module and thus
should not be used by other parts of the system, 
and for local variables that run the risk of being passed into 
functions like {Eval}, {Apply}, {Map}, etcetera (functions that
re-evaluate expressions).

A rigorous solution to this is to make all parameters to functions
and global variables local symbols by default, but this might cause
problems when this is not required, or even wanted, behaviour.

The system will never be able to second-guess which function
calls can be exposed to the outside world, and which ones should
stay local to the system. It also goes against a design rule of Yacas:
everything is possible, but not obligatory. This is important 
at moments when functionality is not wanted, as it can be hard 
to disable functionality when the system does it automatically.

There are more caveats: if a local variable is made unique with 
{LocalSymbols}, other routines can not reach it by using the 
{UnFence} construct. This means that {LocalSymbols} is not always 
wanted. 

Also, the entire expression on which the {LocalSymbols} command works
is copied and modified before being evaluated, making loading
time a little slower. This is not a big problem, because the 
speed hit is usually during calculations, not during loading, but
it is best to keep this in mind and keep the code passed to 
{LocalSymbols} concise.
















			Yacas: a computer algebra system

		Abstract

We describe the computer algebra system Yacas and its underlying
design.

@@@todo

		Introduction

Yacas is a small CAS which has been in development since beginning 1999.
The aim was to make a small system suitable for easily doing research
in the field of symbolic mathematics. Yacas offers a scripting language
that allows for concise description of mathematical algorithms.

As a secondary goal, the system will evolve into a full-blown
general purpose computer algebra system in the future.

		Design

Yacas consists of an interpreter for a scripting language. The scripting
language has been written in c++.

The aims for Yacas were:

	    Portability

Yacas should be as platform-independent as possible. Yacas is written
in a subset of c++ which is supported by almost all, if not all, c++
compilers. The platform-specific parts have been clearly separated
to facilitate easy porting to other systems. Even the standard c++
library is considered to be platform-specific, as there exist 
platforms without support even for the standard c++ libraries.

To date Yacas can be run on Linux and various other Unix variants,
Windows, Psion organizers, Ipaq palmtops, BeOS, and Apple iMacs. Creating an 
executable for other platforms should not be a problem.

	    Ease of use

The system should support a scripting language that allows
the user to express mathematical algorithms in a convenient way. A few
lines of code should go a long way.

Although Yacas works internally as a small Lisp-style interpreter,
interaction is through an infix grammar language, so the user doesn't 
see any Lisp style syntax.


@@@examples

	    Coding elegance over speed

Speed is obviously an important
factor. One big reason to use computers for doing mathematical 
calculations is that computers can do enormous amounts of tedious operations
in very little time. For Yacas, where a choice had to be made between
speed and elegance of code, elegance was chosen. This enhances maintainability
for the future.

This means that special-purpose systems designed for specific types
of calculations will outperform Yacas. Yacas offers a plugin 
system with which other libraries with such features can be linked
in to the system.

	    Policy-free engine

The Yacas system is built around two components: the kernel which
is written in c++, and the mathematical logic, which is written 
in the scripting language.

The core kernel is written in c++ and it offers basic functionality, 
and tries to be as policy-free as possible. 
The fact that the plus operator is an infix operator,
for instance, is defined in the scripts that come with Yacas.
It would be theoretically possible to write an entirely different
CAS based on the c++ kernel, with different syntax and different naming 
conventions, by replacing the standard scripts.

The policy-free scheme means that Yacas is highly configurable through
its scripting language.

The policy-free concept extends to typing: strong typing is
not required by the kernel, but can be enforced by the 
scripts (which also handle the declaration of transformation
rules and functions). The language offers features, but does not
enforce the use of them. Strong typing is a policy which
can be enforced in the scripts, if necessary.

	    Stand-alone package

Yacas should work as a stand alone package, requiring minimum
support from other operating system components. The system could
be compiled to use other arbitrary precision arithmetic libraries,
but the software comes with its own arbitrary precision arithmetic
module also. This is a corollary of the program being easy to port.
A dependency on libraries that might not be available on other
platforms would reduce ease of portability.

		The core kernel

The decision to write a custom language as opposed to taking an
already existing one was to have full control over the system.
While most of the features are syntactic sugar on top of a Lisp 
interpreter, some features not commonly found in Lisp systems were 
added, such as the system of transformation rules.

The core kernel is an interpreter from the Lisp family, with
an infix grammar interface. In addition the core kernel supports
declaring transformation rules, and has its own arbitrary precision
arithmetic module.

Extra functionality can be added through a plugin structure, where
dynamic link libraries can be loaded to add extra functionality
not found in the system. This can be used to add functionality
offered by system libraries, or other special-purpose libraries
for doing mathematical calculations.

		The Yacas scripting language

@@@large section to be written with lots of examples

		Documentation

The documentation is extensive, and growing every day. Yacas comes
with its own document formatting language for easily writing
documentation in text form. This text form can then easily be
converted to html, postscript or pdf format.

		Future plans

The aim for Yacas is to become an industrial-strength CAS, and to
remain a research tool for easily trying out various methods of
calculation.

The plugin structure will be fortified in the future, and a rich
set of extra additional libraries, system-specific as well as
mathematics-oriented, should be loadable from the Yacas system.

The issue of speed is also continuously being addressed. 

		References









