		Designing modules in the Yacas scripting language

	    Introduction

For any software project where the source code grows to
a substantial amount of different modules, there needs to be
a way to define interfaces between the modules, and a way
to make sure the modules don't interact with the environment
in an unintended way. 

One hallmark of a mature programming language is that it 
supports modules, and a way to define its interface while
hiding the internals of the module. This section describes
the mechanisms for doing so in the Yacas scripting language.

	    Demonstration of the problem
 
Unintentional interactions between two modules typically happen 
when the two modules accidentally share a common "global"
resource, and there should be a mechanism to guarantee that this
will not happen.

The following piece of code is a little example that demonstrates
the problem:

	SetExpand(fn_IsString) <-- [expand:=fn;];
	ram(x_IsList)_(expand != "") <-- ramlocal(x);
	expand:="";
	ramlocal(x) := Map(expand,{x});

This little bit of code defines a function {ram} that calls the
function {Map}, passing the argument passed if it is a string, and
if the function to be mapped was set with the {SetExpand} function.
It contains the following flaws:

*	0. {expand} is a global variable with a rather generic name, one
that another module might decide to use.
*	0. {ramlocal} was intended to be used from within this module only, and
doesn't check for correctness of arguments (a small speed up optimization
that can be used for routines that get called often). As it is, it can be
called from other parts, or even the command line.
*	0. the function {ramlocal} has one parameter, named {x}, which is also
generic (and might be used in the expression passed in to the function),
and {ramlocal} calls {Map}, which calls {Eval} on the arguments. 

The above code can be entered into a file and loaded from the command
line at leisure. Now, consider the following command line interaction
after loading the file with the above code in it:

	In> ramlocal(a)         
	In function "Length" : 
	bad argument number 1 (counting from 1)
	Argument matrix[1] evaluated to a
	In function call  Length(a)
	CommandLine(1) : Argument is not a list

We called {ramlocal} here, which should not have been allowed.

	In> ram(a)
	Out> ram(a);

The function {ram} checks that the correct arguments are passed in
and that {SetExpand} was called, so it will not evaluate if these
requirements are not met. 

Here are some lines showing the functionality of this code as
it was intended to be used:

	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};

The following piece of code forces the functionality to break
by passing in an expression containing the variable {x}, which
is also used as a parameter name to {ramlocal}.

	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {{Sin(x),Sin(y),Sin(z)},Sin(y),Sin(z)};

This result is obviously wrong, comparing it to the call above.
The following shows that the global variable {expand} is exposed
to its environment:

	In> expand
	Out> "Sin";


	    Declaring resources to be local to the module

The solution to the problem is {LocalSymbols}, which changes every
symbol with a specified name to a unique name that could never
be entered by the user on the command line and guarantees that it
can never interact with the rest of the system. The following code
snippet is the same as the above, with the correct use of {LocalSymbols}:


	LocalSymbols(x,expand,ramlocal) [
	  SetExpand(fn_IsString) <-- [expand:=fn;];
	  ram(x_IsList)_(expand != "") <-- ramlocal(x);
	  expand:="";
	  ramlocal(x) := Map(expand,{x});
	];


This version of the same code declares the symbols {x}, {expand}
and {ramlocal} to be local to this module.

With this the interaction becomes a little bit more predictable:

	In> ramlocal(a)
	Out> ramlocal(a);
	In> ram(a)
	Out> ram(a);
	In> SetExpand("Sin")
	Out> "Sin";
	In> ram({1,2,3})
	Out> {Sin(1),Sin(2),Sin(3)};
	In> ram({a,b,c})
	Out> {Sin(a),Sin(b),Sin(c)};
	In> ram({x,y,z})
	Out> {Sin(x),Sin(y),Sin(z)};
	In> expand
	Out> expand;


	    When to use and when not to use {LocalSymbols}

The {LocalSymbols} should ideally be used for every global variable,
for functions that can only be useful within the module and thus
should not be used by other parts of the system, 
and for local variables that run the risk of being passed into 
functions like {Eval}, {Apply}, {Map}, etcetera (functions that
re-evaluate expressions).

A rigorous solution to this is to make all parameters to functions
and global variables local symbols by default, but this might cause
problems when this is not required, or even wanted, behaviour.

The system will never be able to second-guess which function
calls can be exposed to the outside world, and which ones should
stay local to the system. It also goes against a design rule of Yacas:
everything is possible, but not obligatory. This is important 
at moments when functionality is not wanted, as it can be hard 
to disable functionality when the system does it automatically.

There are more caveats: if a local variable is made unique with 
{LocalSymbols}, other routines can not reach it by using the 
{UnFence} construct. This means that {LocalSymbols} is not always 
wanted. 

Also, the entire expression on which the {LocalSymbols} command works
is copied and modified before being evaluated, making loading
time a little slower. This is not a big problem, because the 
speed hit is usually during calculations, not during loading, but
it is best to keep this in mind and keep the code passed to 
{LocalSymbols} concise.
















			YACAS: yet another computer algebra system

*HEAD Ayal Pinkus and Serge Winitzki

	    Abstract

We describe the design and implementation of Yacas, a free (GPL) computer
algebra system currently under development.  The system consists of a small
core interpreter and a library of scripts that implement computer algebra
functionality.  The interpreter provides a high-level weakly typed functional
language ("Yacas script" language) which is designed to allow users to quickly
prototype computer algebra algorithms but is applicable more widely to all
kinds of symbolic manipulation.  The language supports recursive evaluation,
conditional term rewriting of symbolic expression trees, closures (pure
functions) and delayed evaluation, dynamic creation of rewriting rules,
arbitrary-precision numerical calculations, and flexible user-defined syntax
using infix notation.  The library of scripts is in development and currently
provides basic computer algebra functionality: real and complex polynomials and
elementary functions, symbolic limits, derivatives and (limited) integration,
symbolic solution of (simple) equations, and some special mathematical
functions. The main advantages of Yacas are: free (GPL) software;
cross-platform portability and small resource requirements; a flexible and
easy-to-use programming language with a comfortable and adjustable syntax; and extensibility.

		Introduction

Yacas is a small CAS which has been in development since the beginning of 1999.
The goal was to make a small system that allows to easily prototype and
research symbolic mathematics algorithms. Yacas offers a flexible scripting
language that allows a concise description of symbolic manipulation algorithms.

A secondary future goal is to evolve Yacas into a full-blown
general purpose computer algebra system.

		Design

Yacas consists of a "core", an interpreter for the Yacas scripting language,
and a library of script code. The Yacas interpreter has been implemented in
standard C++.

The design goals for Yacas are: portability, self-containment, ease of use,
code transparency, and flexibility of the core engine (lack of predefined "policies"). The system falls into the "prototype/hacker" rather than into the "axiom-algebraic" category, according to the classification of Fateman [Fateman].

	    Portability

Yacas is designed to be as platform-independent as possible. Yacas is written
in a subset of C++ which is supported by almost all, if not all, C++ compilers.
The platform-specific parts have been clearly separated to facilitate porting.
Even the standard C++ library is considered to be platform-specific, as there
exist  platforms without support for the standard C++ library (e.g. the
EPOC32).

The primary development platform is GNU/Linux. Currently Yacas runs under
various Unix variants, Windows environments, Psion organizers (EPOC32), Ipaq
palmtops, BeOS, and Apple iMacs. Creating an executable for another platform
should not be difficult for a developer. Since it is also possible to compile
all script library code into the Yacas executable, porting to embedded
platforms is possible.

	    A self-contained system

Yacas should work as a standalone package, requiring minimum support from other
operating system components. Yacas takes input and output in plain ASCII,
either interactively or in batch mode. The system comes with its own
(unoptimized) arbitrary precision arithmetic module but could be compiled to
use another arbitrary precision arithmetic library (currently linking to {gmp}
is experimentally supported). There is also an optional plugin mechanism
whereby external libraries can be linked into the system to provide extra
functionality.

Self-containment is a requirement if the program is to be easy to port. A
dependency on libraries that might not be available on other platforms would
reduce portability. On the other hand, Yacas can be compiled with a complement
of external libraries on "production" platforms.

	    Ease of use

Yacas is used mainly by executing programs written in the Yacas script
language. A design goal is to create a high-level language that allows the user
to conveniently express symbolic algorithms. A few lines of code should go a
long way.

Although Yacas works internally as a LISP-style interpreter, all user
interaction is through the Yacas script language which has a flexible infix
grammar. This means that the user does not have to see any LISP style syntax
and can define such syntactic conventions as are best suitable for a given
problem. An algebraic expression is easy to enter in the familiar infix form
such as
	(x+1)^2 - (y-2)/(y+3) + Sin(x*Pi/2)

Users can define new prefix, infix or postfix operators with short names such
as "{^^}" or "{@+}" and specify simplification rules for expressions involving
these operators. For example, it takes about 20 lines of Yacas script code to
define an infix operation {**} to express non-commutative multiplication with a
commutation relation appropriate for creation and annihilation operators of
quantum field theory, and to automatically "normal-order" all expressions
involving these symbols and other (commutative) factors. The rules that express
distributivity of the operation {**} with respect to addition may look like
this:

	15 # (_x + _y) ** _z <-- x ** z + y ** z;
	15 # _z ** (_x + _y) <-- z ** x + z ** y;
Here, {15 #} is a specification of rule precedence, {_x} denotes a
pattern-matching variable {x} and the expression to the right of {<--} is to be
substituted instead of a matched expression on the left hand side. Since all
rewriting rules are applied recursively, these two lines of code are enough for
the Yacas engine to expand all brackets in any expression containing the infix
operators {**} and {+}.

Rule-based programming is not the only syntax that can be used in Yacas
scripts. There are alternatives that may be more useful in some situations. For
example, the standard {if} / {else}, {While}, {For} loops of C are supported,
as well as the familiar procedural programming patterns such as defining
functions that return values with code blocks and temporary local variables. Users may freely combine rules with procedures and write code such as
	_x ** y_IsList <--
	[
	  Local(i, A, B);
	  For(i:=1, i<=Length(y), i++)
	  [
	  	... // some code
	  ];
	  A; // return resulting value
	];

@@@more examples?

	    Code clarity vs. speed

Speed is obviously an important factor. One reason to use computers for
mathematical  calculations is that computers can do enormous amounts of tedious
operations in very little time. For Yacas, where a choice had to be made
between speed and clarity of code, clarity was chosen. Yacas is mainly a
prototyping system and its future maintaintability is very important.

This means that special-purpose systems designed for specific types of
calculations, as well as heavily optimized industrial-strength computer algebra
systems, will outperform Yacas. Yacas supports a plugin mechanism to link specialized libraries into the system.

	    Flexible, "policy-free" engine

The Yacas system has two main components: the kernel (core interpreter) which
is written in C++, and the script library written  in the Yacas script
language.

The kernel is written in C++, and it offers sufficiently rich but basic
functionality through a limited number of core functions. This functionality
includes recursive substitutions and rewriting of symbolic expression trees,
syntax parser, and arbitrary-precision numerical computations. The core does
not include definitions of any symbolic mathematical operations and tries to be
as general and free of predefined notions or policies as possible.

The reason to implement yet another LISP-like custom language interpreter as
opposed to taking an already existing one was to have full control over the
system. While most of the features are syntactic sugar on top of a LISP 
interpreter, some features not commonly found in LISP systems were  added, such
as the system of transformation rules.

The script library contains declarations of rewriting rules and function
syntax. The intention is that all symbolic manipulation algorithms, definitions
of mathematical functions and so on should be held in the script library. The
only exception so far is for a very small number of mathematical or utility
functions that are frequently used; they are compiled into the core for speed.

For example, the mathematical operator {+} is an infix operator defined in the
library scripts. To the kernel, this operator is on the same footing as any
other function defined by the user and can be redefined. The Yacas kernel
itself does not store any properties for this operator. Instead it relies
entirely on the script library to provide rewriting rules for manipulating
expressions involving the {+} operator. In this way, the kernel does not need
to anticipate all possible meanings of the operator {+} that users might need
in their calculations.

This policy-free scheme means that Yacas is highly configurable through its
scripting language. It is possible to create an entirely different symbolic
manipulation engine based on the same C++ kernel, with different syntax and
different naming  conventions, by simply using another script library instead
of the current library scripts. As an example of the flexibility of the Yacas
syntax, a sample script {wordproblems.ys} comes with the system that makes
Yacas recognize simple English sentences such as "Tom has 3 apples" or "Jane
gave an apple to Tom" as valid Yacas expressions and evaluates them to {True} or
{False}.

The "policy-free" concept extends to typing: strong typing is not required by
the kernel, but can be easily enforced by the  scripts if necessary for a
particular problem. The language offers features, but does not enforce their
use.

	    The Yacas kernel

Yacas script is a functional language based on various ideas that seemed
useful  of list-based data structures, object properties, and recursive
functional programming a la LISP; term rewriting [TermRewriting] with pattern
matching somewhat along the lines of Mathematica; user-defined infix operators
a la PROLOG; and delayed evaluation of expressions.  Garbage collection and
memory management are automatic.

The kernel provides three basic data types: arbitrary-precision numbers, strings, and atoms, and two container types: list and static array (for speed). Atoms are implemented as strings that can be assigned values and evaluated. Association (hash) tables, stacks, and closures (pure functions) are implemented using nested lists. In addition, more data types might be provided by plugins.

The interpreter engine recursively evaluates expression trees according to
user-defined rewriting rules from the script library. This is the only
evaluation scheme but it is flexible enough because rewriting rules have
predicates that control whether a rule should be applied to an expression, and
precedence that controls the order of rules to be attempted. This flexibility
is taken further: predicates can be any Yacas expressions that evaluate to the
atoms {True} or {False}, and new rules can be defined dynamically, that is, it
is possible to define a "rule closure" that defines rules depending on its
arguments, or to erase rules. Thus, the script library does not necessarily
represent a fixed set of rewriting rules; an certain implementation of machine
learning is possible in Yacas.

Certain functions are defined to allow a more straightforward procedural
programming a la C and a more convenient syntax to define new rewriting rules.
Users can freely write code using {While} or {For} loops together with
recursive rewriting rule definitions or list processing primitives such as
{Head}, {Tail}. The interpreter is sufficiently flexible so that the functions
{While}, {For}, {ForEach}, {if}, {else} etc. can be defined in the script
library itself rather than in the kernel.

		The Yacas scripting language

@@@large section to be written with lots of examples

		Documentation

The documentation for the Yacas is extensive and growing every day.
Documentation is in the form of two tutorial guides (user's introduction and
programmer's introduction), a collection of essays that describe some more
advanced features in detail, and a full reference manual.

Yacas currently comes with its own document formatting conventions for writing
documentation in plain text format with a minimal markup. This text format is
automatically converted to HTML, PostScript and PDF formats. The HTML
documentation is hyperlinked and can be used as online help from the Yacas
prompt.

		Future plans

The long-term goal for Yacas is to become an industrial-strength CAS and to
remain a flexible research tool for easy prototyping of various methods of
various kinds of symbolic calculations. Yacas is meant to be a repository and a
testbed for such algorithm prototypes.

The plugin structure will be fortified in the future, and a rich set of extra
additional libraries, system-specific as well as mathematics-oriented, should
be loadable from the Yacas system. The issue of speed is also continuously
being addressed. 


		References

[Fateman] R. Fateman,
<i>On the design and construction of algebraic manipulation systems</i>,
also published as: ACM Proceedings of the ISSAC-90, Tokyo, Japan.

[TermRewriting] F. Baader and T. Nipkow, <i>Term rewriting and all that</i>,
Cambridge University Press, 1998.








