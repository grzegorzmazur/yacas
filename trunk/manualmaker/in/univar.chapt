
Chapter()"Polynomials";

ChapterIntro("This chapter contains commands to manipulate
polynomials. This includes function for constructing and evaluating
orthogonal polynomials.");



CmdDescription("Expand", "Put polynomial in expanded form");
StandardLib();

Topical()"Calling Sequence";
Text()
"Expand(expr) <br>
Expand(expr, var) <br>
Expand(expr, varlist)
";

Topical()"Parameters";
Text()
"expr - a polynomial expression <br>
var - a variable <br>
varlist - a list of variables
";

Topical()"Description";
Text() "
This command brings a polynomial in expanded form, in which
polynomials are represented in the form c0 + c1*x + c2*x^2 + ... +
cn*x^n. In this form, it is easier to test whether a polynomial is
zero, namely by testing whether all coefficients are zero.
<p> </p>
If the polynomial \"expr\" contains only one variable, the first
calling sequence can be used. Otherwise, the second form should be
used which explicitly mentions that \"expr\" should be considered as a
polynomial in the variable \"var\". The third calling form can be used
for multivariate polynomials. Firstly, the polynomial \"expr\" is
expanded with respect to the first variable in \"varlist\". Then the
coefficients are all expanded with respect to the second variable, and
so on.";

Topical() "Examples";
Text() HtmlCommand("
In> PrettyPrinter(\"PrettyForm\");

True

Out> 
In> Expand((1+x)^5);

 5        4         3         2            
x  + 5 * x  + 10 * x  + 10 * x  + 5 * x + 1

Out> 
In> Expand((1+x-y)^2, x);

 2                                2
x  + 2 * ( 1 - y ) * x + ( 1 - y ) 

Out> 
In> Expand((1+x-y)^2, {x,y});

 2                         2            
x  + ( -2 * y + 2 ) * x + y  - 2 * y + 1

Out> ");

Topical()"See Also"; 
SeeAlso({"ExpandBrackets"});



CmdDescription("Degree", "Degree of a polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "
Degree(expr) <br>
Degree(expr, var)";

Topical() "Parameters";
Text() "
expr - a polynomial <br>
var - a variable occurring in \"expr\"";

Topical() "Description";
Text() "
This command returns the degree of the polynomial \"expr\" with
respect to the variable \"var\". The degree is the highest power of
\"var\" occurring in the polynomial. If only one variable occurs in
\"expr\", the first calling sequence can be used. Otherwise the user
should use the second form in which the variable is explicitly
mentioned.";

Topical() "Examples";
Text() HtmlCommand("
In> Degree(x^5+x-1);
Out> 5;
In> Degree(a+b*x^3, a);
Out> 1;
In> Degree(a+b*x^3, x);
Out> 3;");

Topical() "See Also";
SeeAlso({"Expand", "Coef"});



CmdDescription("Coef", "Coefficient of a polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "Coef(expr, var, order)";

Topical() "Parameters";
Text() "
expr - a polynomial <br>
var - a variable occurring in \"expr\" <br>
order - integer or list of integers";

Topical() "Description";
Text() "
This command returns the coefficient of \"var\" to the power \"order\"
in the polynomial \"expr\". The parameter \"order\" can also be a list
of integers, in which case this function returns a list of
coefficients.";

Topical()"Examples";
Text() HtmlCommand("
In> e := Expand((a+x)^4,x)
Out> x^4+4*a*x^3+(a^2+(2*a)^2+a^2)*x^2+(a^2*2*a+2*a^3)*x+a^4;
In> Coef(e,a,2)
Out> 6*x^2;
In> Coef(e,a,0 .. 4)
Out> {x^4,4*x^3,6*x^2,4*x,1};");

Topical()"See Also"; 
SeeAlso({"Expand", "Degree", "LeadingCoef"});



CmdDescription("Content", "Content of a univariate polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "Content(expr)";

Topical() "Parameters";
Text() "expr - univariate polynomial";

Topical() "Description";
Text() "
This command determines the content of a univariate polynomial. The
content is the greatest common divisor of all the terms in the
polynomial. Every polynomial can be written as the product of the
content with the primitive part.";  

Topical() "Examples";
Text() HtmlCommand("
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> c := Content(poly);
Out> 2*x;
In> pp := PrimitivePart(poly);
Out> x+2;
In> Expand(pp*c);
Out> 2*x^2+4*x;");

Topical() "See Also";
SeeAlso({"PrimitivePart", "Gcd"});



CmdDescription("PrimitivePart", "Primitive part of a univariate polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "PrimitivePart(expr)";

Topical() "Parameters";
Text() "expr - univariate polynomial";

Topical() "Description";
Text() "
This command determines the primitive part of a univariate
polynomial. The primitive part is what remains after the content (the
greatest common divisor of all the terms) is divided out. So the
product of the content and the primitive part equals the original
polynomial."; 

Topical() "Examples";
Text() HtmlCommand("
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> c := Content(poly);
Out> 2*x;
In> pp := PrimitivePart(poly);
Out> x+2;
In> Expand(pp*c);
Out> 2*x^2+4*x;");

Topical() "See Also";
SeeAlso({"Content"});



CmdDescription("LeadingCoef", "Leading coefficient of a polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "
LeadingCoef(poly) <br>
LeadingCoef(poly, var)";

Topical() "Parameters";
Text() "
poly - a polynomial <br>
var - a variable";

Topical() "Description";
Text() "
This function returns the leading coefficient of \"poly\", regarded as
a polynomial in the variable \"var\". The leading coefficient is the
coefficient of the term of highest degree. If only one variable
appears in the expression \"poly\", it is obvious that it should be
regarded as a polynomial in this variable and the first calling
sequence may be used.";

Topical() "Examples";
Text() HtmlCommand("
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> lc := LeadingCoef(poly);
Out> 2;
In> m := Monic(poly);
Out> x^2+2*x;
In> Expand(lc*m);
Out> 2*x^2+4*x;

In> LeadingCoef(2*a^2 + 3*a*b^2 + 5, a);
Out> 2;
In> LeadingCoef(2*a^2 + 3*a*b^2 + 5, b);
Out> 3*a;");

Topical() "See Also";
SeeAlso({"Coef", "Monic"});



CmdDescription("Monic", "Monic part of a polynomial");
StandardLib();

Topical() "Calling Sequence";
Text() "
Monic(poly) <br>
Monic(poly, var)";

Topical() "Parameters";
Text() "
poly - a polynomial <br>
var - a variable";

Topical() "Description";
Text() "
This function returns the monic part of \"poly\", regarded as a
polynomial in the variable \"var\". The monic part of a polynomial is
the quotient of this polynomial by its leading coefficient. So the
leading coefficient of the monic part is always one. If only one
variable appears in the expression \"poly\", it is obvious that it
should be regarded as a polynomial in this variable and the first
calling sequence may be used.";

Topical() "Examples";
Text() HtmlCommand("
In> poly := 2*x^2 + 4*x;
Out> 2*x^2+4*x;
In> lc := LeadingCoef(poly);
Out> 2;
In> m := Monic(poly);
Out> x^2+2*x;
In> Expand(lc*m);
Out> 2*x^2+4*x;

In> Monic(2*a^2 + 3*a*b^2 + 5, a);
Out> a^2+(a*3*b^2)/2+5/2;
In> Monic(2*a^2 + 3*a*b^2 + 5, b);
Out> b^2+(2*a^2+5)/(3*a);");

Topical() "See Also";
SeeAlso({"LeadingCoef"});



CmdDescription("RandomPoly", "Construct a random polynomial");
StandardLib();
Topical()"Calling Sequence";
Text()"RandomPoly(var,deg,coefmin,coefmax)";

Topical()"Parameters";
Text()
"var - free variable for resulting univariate polynomial <br>
deg - degree of resulting univariate polynomial <br>
coefmin - minimum value for coefficients <br>
coefmax - maximum value for coefficients
";

Topical()"Description";
Text()
"RandomPoly generates a random polynomial in variable \"var\", of
degree \"deg\", with integer coefficients ranging from \"coefmin\" to
\"coefmax\" (inclusive). The coefficients are uniformly distributed in
this interval, and are independent of each other.";

Topical()"Examples";
Text()
HtmlCommand(
"In> RandomPoly(x,3,-10,10)
Out> 3*x^3+10*x^2-4*x-6;
In> RandomPoly(x,3,-10,10)
Out> -2*x^3-8*x^2+8;
");
Topical()"See Also"; 
SeeAlso({"Random","RandomIntegerVector"});


SubSection()"Div and Mod for polynomials";
StandardLib();
Text()"";

Text()
"
Div and Mod are also defined for polynomials.
";

Topical()"See Also"; 
SeeAlso({"Div","Mod"});


CmdDescription("Horner", "Convert polynomial in Horner form");
StandardLib();
Topical()"Calling Sequence";
Text() "Horner(expr, var)";

Topical()"Parameters";
Text()"expr - a polynomial in \"var\" <br>
var - a variable
";

Topical()"Description";
Text()"
This command turns the polynomial \"expr\", considered as a univariate
polynomial in \"var\", into Horner form. A polynomial in normal form
is an expression like" :
HtmlCommand("
                                  n-1           n
c(0) + c(1) * x + ... + c(n-1) * x    + c(n) * x  ") : "
If one converts this polynomial in Horner form, one gets the
equivalent expression" :
HtmlCommand("
(...( c(n) * x + c(n-1) ) * x + ...  + c(1) ) * x + c(0)") : "
Both expression are equal, but the latter form gives a more
efficient way to evaluate the polynomial as  the powers have
disappeared.";

Topical()"Examples";
Text()
HtmlCommand("
In&gt expr1:=Expand((1+x)^4) 
Out&gt x^4+4*x^3+6*x^2+4*x+1 
In&gt  Horner(expr1,x) 
Out&gt (((x+4)*x+6)*x+4)*x+1 
");

Topical()"See Also"; 
SeeAlso({"Expand", "ExpandBrackets"});



CmdDescription("ExpandBrackets", "Expand all terms");
StandardLib();
Topical()"Calling Sequence";
Text()"ExpandBrackets(expr)";

Topical()"Parameters";
Text()"expr - an expression";

Topical()"Description";
Text() "
This command tries to expand all the brackets by repeatedly using the
distributive laws \"a * (b+c) = a*b + a*c\" and \"(a+b) * c = a*c +
b*c\". It goes further than " : HtmlTerm("Expand") : ", in that it
expands all terms.";

Topical()"Examples";
Text()
HtmlCommand(
"In> Expand((a-x)*(b-x),x)
Out> x^2-(b+a)*x+a*b;
In> Expand((a-x)*(b-x),{x,a,b})
Out> x^2-(b+a)*x+b*a;
In> ExpandBrackets((a-x)*(b-x))
Out> a*b-x*b+x^2-a*x;
");

Topical()"See Also"; 
SeeAlso({"Expand"});



CmdDescription("OrthoP", "Legendre and Jacobi orthogonal polynomials");
StandardLib();

Topical() "Calling Sequence";
Text() "
OrthoP(n, x); <br>
OrthoP(n, a, b, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
x - point to evaluate polynomial at <br>
a, b - parameters for Jacobi polynomial";

Topical() "Description";
Text() "
The first calling sequence evaluates the Legendre polynomial of degree
\"n\" at the point \"x\". The second form does the same for the Jacobi
polynomial with parameters \"a\" and \"b\", which should be greater
than -1. 
<p> </p>
The Jacobi polynomials are orthogonal with respect to the weight
function (1-x)^a (1+x)^b on the interval [-1,1]. They satisfy the
recurrence relations: " :
HtmlCommand("
P(0,a,b,x) = 1

             a - b     /     a + b \\
P(1,a,b,x) = ----- + x | 1 + ----- |
               2       \\       2   /

                                 2   2
                                a - b + x (2n+a+b-2) (n+a+b)
P(n,a,b,x) = (2n + a + b - 1) * ---------------------------- P(n-1,a,b,x)
                                   2n (2n+a+b-2) (n+a+b)


                (n+a-1) (n+b-1) (2n+a+b)
             -  ------------------------ P(n-2,a,b,x),         for n > 1.
                  n (n+a+b) (2n+a+b-2)
") : "
<p> </p>
Legendre polynomials are a special case of Jacobi polynomials with the
specific parameter values a = b = 0. So they form an orthogonal system
with respect to the weight function identically equal to one on the
interval [-1,1], and they satisfy the recurrence relations: " :
HtmlCommand("
P(0,x) = 1

P(1,x) = x
        
         (2n - 1) x            n - 1
P(n,x) = ---------- P(n-1,x) - ----- P(n-2,x),     for n > 1.
             2n                  n
") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> PrettyPrinter(\"PrettyForm\");

True

Out> 
In> OrthoP(3, x);

    /      2     \\
    | 5 * x    3 |
x * | ------ - - |
    \\   2      2 /

Out> 
In> OrthoP(3, 1, 2, x);

1       /     / 21 * x   7 \\   7 \\
- + x * | x * | ------ - - | - - |
2       \\     \\   2      2 /   2 /

Out> 
In> Expand(%)

      3        2            
21 * x  - 7 * x  - 7 * x + 1
----------------------------
             2              

Out> 
In> OrthoP(3, 1, 2, 0.5);

-0.8124999999

Out> ");

Topical() "See Also";
SeeAlso({"OrthoG", "OrthoPoly"});



CmdDescription("OrthoH", "Hermite orthogonal polynomials");
StandardLib();

Topical() "Calling Sequence";
Text() "OrthoH(n, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
x - point to evaluate polynomial at";

Topical() "Description";
Text() "
This function evaluates the Hermite polynomial of degree \"n\" at the
point \"x\".
<p> </p>
The Hermite polynomials are orthogonal with respect to the weight
function e^(-x^2/2) on the entire real axis. They satisfy the
recurrence relations: " :
HtmlCommand("
H(0,x) = 1

H(1,x) = 2x

H(n,x) = 2x H(n-1,x) - 2(n-1) H(n-2,x),     for n > 1.") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> OrthoH(3, x);
Out> x*(8*x^2-12);
In> OrthoH(6, 0.5);
Out> 31;");

Topical() "See Also";
SeeAlso({"OrthoPoly"});



CmdDescription("OrthoG", "Gegenbauer orthogonal polynomials");
StandardLib();

Topical() "Calling Sequence";
Text() "OrthoG(n, a, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
a - parameter <br>
x - point to evaluate polynomial at";

Topical() "Description";
Text() "
This function evaluates the Gegenbauer (or ultraspherical) polynomial
with parameter \"a\" and degree \"n\" at the point \"x\". The
parameter \"a\" should be greater than -1/2.
<p> </p>
The Gegenbauer polynomials are orthogonal with respect to the weight
function (1-x^2)^(a-1/2) on the interval [-1,1]. Hence they are
connected to the Jacobi polynomials via G(n, a, x) =
P(n, a-1/2, a-1/2, x). They satisfy the recurrence relations: " :
HtmlCommand("
G(0,a,x) = 1

G(1,a,x) = 2x

             /     a - 1 \\                /     2 (a-2) \\
G(n,a,x) = 2 | 1 + ----- | x G(n-1,a,x) - | 1 + ------- | G(n-2,a,x), for n>1.
             \\       n   /                \\        n    /
") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
IIn> OrthoG(5, 1, x);
Out> x*((32*x^2-32)*x^2+6);
In> OrthoG(5, 2, -0.5);
Out> 2;");

Topical() "See Also";
SeeAlso({"OrthoP", "OrthoT", "OrthoU", "OrthoPoly"});



CmdDescription("OrthoL", "Laguerre orthogonal polynomials");
StandardLib();

Topical() "Calling Sequence";
Text() "OrthoL(n, a, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
a - parameter <br>
x - point to evaluate polynomial at";

Topical() "Description";
Text() "
This function evaluates the Laguerre polynomial with parameter \"a\"
and degree \"n\" at the point \"x\". The parameter \"a\" should be
greater than -1.
<p> </p>
The Laguerre polynomials are orthogonal with respect to the weight
function x^a * e^(-x) on the positive real axis. They satisfy the
recurrence relations: " :  
HtmlCommand("
L(0,a,x) = 1

L(1,a,x) = a + 1 - x

           /     a - 1 - x \\              /     a - 1 \\
L(n,a,x) = | 2 + --------- | L(n-1,a,x) - | 1 + ----- | L(n-2,a,x), for n>1.
           \\         n     /              \\       n   /
") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> OrthoL(3, 1, x);
Out> x*(x*(2-x/6)-6)+4;
In> OrthoL(3, 1/2, 0.25);
Out> 1.2005208334;");

Topical() "See Also";
SeeAlso({"OrthoPoly"});



CmdDescription("OrthoT", "Tshebyscheff polynomials of the first kind");
StandardLib();

Topical() "Calling Sequence";
Text() "OrthoT(n, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
x - point to evaluate polynomial at";

Topical() "Description";
Text() "
This function evaluates the Tschebyscheff polynomial of the first kind
of degree \"n\" at the point \"x\". The name is also spelled Chebyshev.
<p> </p>
The Tschebyscheff polynomials of the first kind are orthogonal with
respect to the weight function (1-x^2)^(-1/2). Hence they are a
special case of the Gegenbauer polynomials, with a=0. They satisfy the
recurrence relations: " :
HtmlCommand("
T(0,x) = 1

T(1,x) = x

T(n,x) = 2x T(n-1,x) - T(n-2,x),     for n > 1.") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
IIn> OrthoT(3, x);
Out> x*(4*x^2-3);
In> OrthoT(10, 0.9);
Out> -0.2007474688;");

Topical() "See Also";
SeeAlso({"OrthoG", "OrthoU", "OrthoPoly"});



CmdDescription("OrthoU", "Tshebyscheff polynomials of the second kind");
StandardLib();

Topical() "Calling Sequence";
Text() "OrthoU(n, x);";

Topical() "Parameters";
Text() "
n - degree of polynomial <br>
x - point to evaluate polynomial at";

Topical() "Description";
Text() "
This function evaluates the Tschebyscheff polynomial of the second kind
of degree \"n\" at the point \"x\". The name is also spelled Chebyshev.
<p> </p>
The Tschebyscheff polynomials of the second kind are orthogonal with
respect to the weight function (1-x^2)^(1/2). Hence they are a
special case of the Gegenbauer polynomials, with a=1. They satisfy the
recurrence relations: " :
HtmlCommand("
U(0,x) = 1

U(1,x) = 2x

U(n,x) = 2x U(n-1,x) - u(n-2,x),     for n > 1.") : "
<p> </p>
Most of the work is performed by the internal function " :
HtmlTerm("OrthoPoly") : ".";

Topical() "Examples";
Text() HtmlCommand("
In> OrthoU(3, x);
Out> x*(8*x^2-4);
In> OrthoU(10, 0.9);
Out> -2.2234571776;");

Topical() "See Also";
SeeAlso({"OrthoG", "OrthoT", "OrthoPoly"});



CmdDescription("OrthoPoly", 
               "Internal function for constructing orthogonal polynomials");
StandardLib();

Topical() "Calling sequence";
Text() "OrthoPoly(name, n, par, x)";

Topical() "Parameters";
Text() "
name - string containing name of orthogonal family <br>
n - degree of the polynomial <br>
par - list of values for the parameters <br>
x - point to evaluate at";

Topical() "Description";
Text() "
This function is used internally to construct orthogonal
polynomials. It returns the \"n\"-th polynomial from the family
\"name\" with parameters \"par\" at the point \"x\".
<p> </p>
All known families are stored in the association list " :
HtmlTerm("KnownOrthoPoly") : ". The name serves as key. At the moment
the following names are known to Yacas: " : HtmlTerm("\"Jacobi\"") :
", " : HtmlTerm("\"Gegenbauer\"") : ", " : HtmlTerm("\"Laguerre\"") :
", " : HtmlTerm("\"Hermite\"") : ", " : HtmlTerm("\"Tscheb1\"") : ",
and " : HtmlTerm("\"Tscheb2\"") : ". The value associated to the key
is a pure function that takes two arguments: the order \"n\" and the
extra parameters \"p\", and returns a list of two lists: the first list
contains the coefficients {A,B} of the n=1 polynomial, i.e. \"A+B*x\";
the second list contains the coefficients {A,B,C} in the recurrence
relation, i.e. \"P_n = (A+B*x)*P_{n-1}+C*P_{n-2}\". (So far there are
only 3 coefficients in the second list, i.e. no \"C+D*x\", but we don't
want to be limited.)
<p> </p>
If the argument \"x\" is numeric, the function " :
HtmlTerm("OrthoPolyNumeric") : " is called. Otherwise, the function "
: HtmlTerm("OrthoPolyCoeffs") : " computes a list of coefficients, and
" : HtmlTerm("EvaluateHornerScheme") : " converts this lists into a
polynomial.";

Topical() "See Also";
SeeAlso({"OrthoP", "OrthoG", "OrthoH", "OrthoL", "OrthoT", "OrthoU"});

