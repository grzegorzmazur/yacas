
			Functional operators

*INTRO
These operators can help the user to program in the style of
functional programming languages like Miranda and Haskell.

*CMD : --- Prepend item to list, or concatenate strings
*STD
*CALL
	item : list (prec. 7)
	string1 : string2 (prec. 7)

*PARMS
{item} -- an item to be prepended to a list

{list} -- a list

{string1} -- a string

{string2} -- a string

*DESC

The first form prepends "item" as the first entry to the list
"list". The second form concatenates the strings "string1" and
"string2".

*E.G.

	In> a:b:c:{}
	Out> {a,b,c};
	In> "This":"Is":"A":"String"
	Out> "ThisIsAString";

*SEE Concat, ConcatStrings

*CMD @ --- Apply a function
*STD
*CALL
	fn @ arglist (prec. 60)

*PARMS

{fn} -- function to apply

{arglist} -- single argument, or a list of arguments

*DESC

This function is a shorthand for {Apply}. It applies the
function "fn" to the argument(s) in "arglist" and returns the
result. The first parameter "fn" can either be a string containing
the name of a function or a pure function.

*E.G.

	In> "Sin" @ a
	Out> Sin(a);
	In> {{a},Sin(a)} @ a
	Out> Sin(a);
	In> "f" @ {a,b}
	Out> f(a,b);

*SEE Apply

*CMD /@ --- Apply a function to all entries in a list
*STD
*CALL

fn /@ list (prec. 60)

*PARMS

{fn} -- function to apply

{list} -- list of arguments

*DESC
This function is a shorthand for {MapSingle}. It
successively applies the function "fn" to all the entries in
"list" and returns a list contains the results. The parameter "fn"
can either be a string containing the name of a function or a pure
function.

*E.G.

	In> "Sin" /@ {a,b}
	Out> {Sin(a),Sin(b)};
	In> {{a},Sin(a)*a} /@ {a,b}
	Out> {Sin(a)*a,Sin(b)*b};

*SEE MapSingle, Map, MapArgs

*CMD .. --- Construct a list of consecutive integers

*STD

*CALL

	n .. m (prec. 60)

*PARMS

{n} -- integer. the first entry in the list

{m} -- integer, the last entry in the list

*DESC

This command returns the list {{n, n+1, n+2, ..., m}}. If {m} is
smaller than {n}, the empty list is returned. Note that the
{..} operator should be surrounded by spaces to keep the
parser happy, if "n" is a number. So one should write "{1 .. 4}" instead of "{1..4}".

*EG

	In> 1 .. 4
	Out> {1,2,3,4};

*SEE Table

*CMD NFunction --- make wrapper for numeric functions
*STD
*CALL
	NFunction("newname","funcname", {arglist})

*PARMS
"newname" -- name of new function

{"funcname"} -- name of an existing function

{arglist} -- symbolic list of arguments

*DESC
This function will define a function named "newname"
with the same arguments as an existing function named "funcname". The new function will evaluate and return the expression "funcname(arglist)" only when
all items in the argument list {arglist} are numbers, and return unevaluated otherwise.

This can be useful when plotting functions defined through other Yacas routines that cannot return unevaluated.

*EG

Suppose we need to define a complicated function {t(x)} which cannot be evaluated unless {x} is a number:

	In> t(x) := If(x<=0.5, 2*x, 2*(1-x));
	Out> True;
	In> t(0.2);
	Out> 0.4;
	In> t(x);
	In function "If" :
	bad argument number 1 (counting from 1)
	CommandLine(1) : Invalid argument
Then, we can use {NFunction()} to define a wrapper {t1(x)} around {t(x)} which will not try to evaluate {t(x)} unless {x} is a number.

	In> NFunction("t1", "t", {x})
	Out> True;
	In> t1(x);
	Out> t1(x);
	In> t1(0.2);
	Out> 0.4;
Now we can plot the function.

	In> GnuPlot(-0.1, 1.1, 30, t1(x))
	Out> True;

*SEE MacroRule
