
			Functional operators

*INTRO
These operators can help the user to program in the style of
functional programming languages like Miranda and Haskell.

*CMD : --- Prepend item to list, or concatenate strings

*STD

*CALL

item : list (prec. 7)

string1 : string2 (prec. 7)

*PARMS

item - an item to be prepended to a list

list - a list

string1 - a string

string2 - a string

*DESC

The first form prepends "item" as the first entry to the list
"list". The second form concatenates the strings "string1" and
"string2".

*E.G.

	In> a:b:c:{}
	Out> {a,b,c};
	In> "This":"Is":"A":"String"
	Out> "ThisIsAString";

*SEE Concat, ConcatStrings

*CMD @ --- Apply a function

*STD

*CALL

fn @ arglist (prec. 60)

*PARMS

fn - function to apply

arglist - single argument, or a list of arguments

*DESC

This function is a shorthand for {Apply}. It applies the
function "fn" to the argument(s) in "arglist" and returns the
result. The first parameter "fn" can either be a string containing
the name of a function or a pure function.

*E.G.

	In> "Sin" @ a
	Out> Sin(a);
	In> {{a},Sin(a)} @ a
	Out> Sin(a);
	In> "f" @ {a,b}
	Out> f(a,b);

*SEE Apply

*CMD /@ --- Apply a function to all entries in a list

*STD

*CALL

fn /@ list (prec. 60)

*PARMS

fn - function to apply

list - list of arguments

*DESC

This function is a shorthand for {MapSingle}. It
successively applies the function "fn" to all the entries in
"list" and returns a list contains the results. The parameter "fn"
can either be a string containing the name of a function or a pure
function.

*E.G.

	In> "Sin" /@ {a,b}
	Out> {Sin(a),Sin(b)};
	In> {{a},Sin(a)*a} /@ {a,b}
	Out> {Sin(a)*a,Sin(b)*b};

*SEE MapSingle, Map, MapArgs

*CMD .. --- Construct a list of consecutive integers

*STD

*CALL

n .. m (prec. 60)

*PARMS

n - integer. the first entry in the list

m - integer, the last entry in the list

*DESC

This command returns the list "{n, n+1, n+2, ..., m}". If "m" is
smaller than "n", the empty list is returned. Note that the
{..} operator should be surrounded by spaces to keep the
parser happy, if "n" is a number. So one should write {1 .. 4} instead of {1..4}.

*E.G.

	In> 1 .. 4
	Out> {1,2,3,4};

*SEE Table

