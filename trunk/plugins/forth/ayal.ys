
/*
TODO:
x Yank in the other routines I defined so far.
x support for passing arguments
- dynamically extending the list of functions you can call.
- C++ version of the VM
*/

Macro()Test(expression);
PExprEcho(_e) <-- Echo(" ",e);

PExpr := PExprEcho;
//5 # Test(_rest) <-- Echo("PExpr is ",@PExpr);
10 # Test(_x + _y) <-- [Test(@x);Test(@y);@PExpr("AddFloats");];
10 # Test(_x - _y) <-- [Test(@x);Test(@y);@PExpr("NegFloat");@PExpr("AddFloats");];
10 # Test(   - _y) <-- [         Test(@y);@PExpr("NegFloat");];
10 # Test(_x * _y) <-- [Test(@x);Test(@y);@PExpr("MulFloats");];
10 # Test(_x / _y) <-- [Test(@x);Test(@y);@PExpr("DivFloats");];
10 # Test(_x ^ _y) <-- [Test(@x);Test(@y);@PExpr("PowFloats");];

10 # Test(Sin(_x)) <-- [Test(@x);@PExpr("SinFloat");];
10 # Test(Cos(_x)) <-- [Test(@x);@PExpr("CosFloat");];
10 # Test(Tan(_x)) <-- [Test(@x);@PExpr("TanFloat");];

10 # Test(ArcSin(_x)) <-- [Test(@x);@PExpr("AsinFloat");];
10 # Test(ArcCos(_x)) <-- [Test(@x);@PExpr("AcosFloat");];
10 # Test(ArcTan(_x)) <-- [Test(@x);@PExpr("AtanFloat");];

10 # Test(Exp(_x))    <-- [Test(@x);@PExpr("ExpFloat");];
10 # Test(Ln(_x))     <-- [Test(@x);@PExpr("LnFloat");];

20 # Test(x_IsNumber) <-- [@PExpr("PushFloat");@PExpr(@x);];
30 # Test(x_IsAtom)_Contains(args,x) <-- 
[
  @PExpr("GetArg");
  Local(id);
  Set(id,Find(@args,@x));
  Apply(PExpr,{id});
];

100 # Test(_rest) <-- Check(False,ToString()Echo("Can not compile expression ",rest));

UnFence("Test",1);

Macro("Compile",{ar,expr})
[
  Local(PExpr);
  Local(code,args);
  args:= @ar;
  code:={};
  PExpr := Hold({{n},DestructiveAppend(code,n)});
  Test(@expr);
  Apply(PExpr,{"Return"});
  code;
];

VMStack'New() <-- {};
VMStack'Push(_stack,_object) <-- Push(stack,object);
VMStack'Pop(_stack) <-- PopFront(stack);

VMStack'PushArguments(_stack,args_IsList) <--
[
  VMStack'Push(stack,Length(stack));
  Local(i);
  For(i:=1,i<=Length(args),i++) VMStack'Push(stack,args[i]);
  stack;  
];

RunFunction(_code,_stack,_pc,_st) <--
[
  Local(op);
  While (st>0)
  [
    Set(op,OpCode());
    `ExecOp(@op);
  ];
  VMStack'Pop(stack);
];
Macro(OpCode,{})
[
  Local(result);
  result:=code[pc];
  pc++;
  result;
];

Macro()ExecOp(op);
ExecOp("PushFloat") <-- VMStack'Push(stack,OpCode());
ExecOp("NegFloat") <-- VMStack'Push(stack,-(VMStack'Pop(stack)));

ExecOp("SinFloat") <-- VMStack'Push(stack,MathSin(VMStack'Pop(stack)));
ExecOp("CosFloat") <-- VMStack'Push(stack,MathCos(VMStack'Pop(stack)));
ExecOp("TanFloat") <-- VMStack'Push(stack,MathTan(VMStack'Pop(stack)));
ExecOp("ExpFloat") <-- VMStack'Push(stack,MathExp(VMStack'Pop(stack)));

ExecOp("AsinFloat") <-- VMStack'Push(stack,MathArcSin(VMStack'Pop(stack)));
ExecOp("AcosFloat") <-- VMStack'Push(stack,MathArcCos(VMStack'Pop(stack)));
ExecOp("AtanFloat") <-- VMStack'Push(stack,MathArcTan(VMStack'Pop(stack)));
ExecOp("LnFloat") <-- VMStack'Push(stack,MathLn(VMStack'Pop(stack)));

ExecOp("AddFloats") <-- VMStack'Push(stack,MathAdd(VMStack'Pop(stack),VMStack'Pop(stack)));
ExecOp("MulFloats") <-- VMStack'Push(stack,MathMultiply(VMStack'Pop(stack),VMStack'Pop(stack)));
ExecOp("DivFloats") <-- 
[
  Local(x,y);
  Set(y,VMStack'Pop(stack));
  Set(x,VMStack'Pop(stack));
  VMStack'Push(stack,MathDivide(x,y));
];

ExecOp("PowFloats") <-- 
[
  Local(x,y);
  Set(y,VMStack'Pop(stack));
  Set(x,VMStack'Pop(stack));
  VMStack'Push(stack,MathPower(x,y));
];

ExecOp("Return") <-- 
[
  Local(result,frame);
  Set(result,VMStack'Pop(stack));
  While(Length(stack) > st)
  [
    VMStack'Pop(stack);
  ];
  Set(st,VMStack'Pop(stack));
  VMStack'Push(stack,result);
];


ExecOp("GetArg") <-- 
[
  Local(index,value);
  Set(index,OpCode());
  Set(value,stack[Length(stack)+1-st-index]);
Echo("Getting arg nr ",index," value is ",value);
  VMStack'Push(stack,value);
];


/*
code := Compile({},Sin(2)+3^4)
RunFunction(code,VMStack'PushArguments(VMStack'New(),{}),1,1);
*/


CompileFn(fname,args,body) :=
[
  Local(code);
  code := `Compile(@args,@body);
//Echo("Code is ");
//Write(code);
  `(Function(@fname,@args)RunFunction(@code,VMStack'PushArguments(VMStack'New(),@args),1,1));

];


