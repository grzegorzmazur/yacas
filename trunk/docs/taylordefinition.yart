{{title:Fun with derivatives part 2: Taylor series expansions:title}}

The idea behind a Taylor series expansion is to derive a polynomial {{expr:p(x):expr}} that approximates a function {{expr:f(x):expr}} up to a specified degree {{expr:n:expr}}. It does so by selecting the coefficients for each term such that the mth derivative of the polynomial is the same as the m-th derivative of the function. Thus

{{math:
\frac{d^m}{dx^m} p(x) = \frac{d^m}{dx^m} f(x)
:math}}

If we write out the polynomial:

{{math:
p(x) = a_0 + a_1 x + a_2 x^2 + ... +a_n x^n
:math}}

Then we can derive a form for each of the coefficients based on the initial constraint on the derivatives. 

{{math:
\frac{d^m}{dx^m} p(x) = m ! a_m  + x \left[ ... \right]
:math}}

for {{expr:x = 0:expr}} we are left with 

{{math:
\frac{d^m}{dx^m} p(x) = m ! a_m 
:math}}

or

{{math:
a_m = \frac{1}{m!} \left[ \frac{d^m}{dx^m} p(x) \right]
   = \frac{1}{m!} \left[ \frac{d^m}{dx^m} f(x) \right]
:math}}

And so we arrive at 

{{math:
p(x) = { \sum_{m=0}^{n} } \frac{1}{m!} x^m \frac{d^m f(x)}{dx^m}
:math}}

Say we want to calculate a Taylor series expansion of {{expr:Sin(x):expr}} op to degree 8. I will
just give you the complete expression and then explain how it is constructed:

{{expr:(Add(MapSingle(Lambda({n},(x^n/(n!))*D(x0,n)Sin(x0)), 0 .. 8)) Where x0 == 0);:expr}}

The inner part is a MapSingle, which performs an operation on each element of a list, in this case
the list of integers from 0 through 8 (due to the {{expr:0 .. 8:expr}}). The operation applied on each
is to generate a term in the Taylor series expansion: {{expr:(x^n/(n!))*D(x0,n)Sin(x0):expr}}, where 
the Lambda expression makes sure that {{expr:n:expr}} is matched to the integer from the list that
{{expr:MapSingle:expr}} is operating on. 

The {{expr:MapSingle:expr}} command returns a list with an element for each of the elements from the original
lists. It thus has a list of the terms of the Taylor expansion. Those need to be added together, and
that is done with the {{expr:Add:expr}} function fall. After that we tell <i>Yacas</i> to reduce 
{{expr:x0:expr}} to zero. The result should be the Taylor series expansion of {{expr:Sin(x):expr}} 
around {{expr:x=0:expr}} up to order 8.

<i>Yacas</i> has a standard built-in function that returns a Taylor series expansion, but what would
be the fun of that? The above way of doing it is much more rewarding because you build up a calculation
from smaller building blocks that you can also use for other calculations. Meanwhile all it took was
one line of code. Actually calling the built-in function is not going to save many key presses (although
the built-in version might be optimized some more).

The equivalent for the calculation above would be to call {{expr:Taylor(x,0,8)Sin(x):expr}}. You can try both examples
out by going to the calculation center. There you can verify that the two methods return the same result.
If you click on the "Run" button at the top of this page you can click on the "Example" button,
which will call the two different ways of calculating a Taylor series expansion. You are free
to modify these lines a bit. Enjoy!

{{example:(Add(MapSingle(Lambda({n},(x^n/(n!))*D(x0,n)Sin(x0)), 0 .. 8)) Where x0 == 0);:example}}
{{example:Taylor(x,0,8)Sin(x);:example}}

{{test:
  Verify(
   IsZero(Simplify(
    (Add(MapSingle(Lambda({n},(x^n/(n!))*D(x0,n)Sin(x0)), 0 .. 8)) Where x0 == 0) -
    (Taylor(x,0,8)Sin(x))
   )),
   True);
:test}}





