
{{title:Code accompanying the demonstration of fast convergence of Newton iteration:title}}
Here is the math behind Newton iteration; we start with a function <tt>f(x)</tt>, and start at some value <tt>x0</tt>, and take a first-order Taylor series expansion as an approximation of the function:

{{math:
f \left( x \right) = f \left( x_0 \right) + \left( x - x_0 \right) \frac{d f(x)}{dx}
:math}}

We thus effectively approximate the function with a straight line. The shorter the distance (the nearer x is to x0), the more correct that approximation will be. This method thus only works well when the initial guess x0 is close to the real answer.

We want the function f(x1) to be zero, so setting it to zero yields:

{{math:
f \left( x_0 \right) + \left( x_1 - x_0 \right) \frac{d f(x)}{dx} = 0
:math}}

Or:

{{math,heightPixels.160:
x_1 = x_0 - \frac{f \left( x_0 \right) }{ \left[ \frac{d f \left( x_0 \right) }{dx} \right] }
:math}}

Repeating this for x1 to x2 and so on should yield more and more accurate answers. 

We will now try this out on a simple example. We will try to get the zero 
<tt>Sin(x)=0</tt> for x at pi (thus effectively approximating the value of pi). The derivative of <tt>Sin(x)</tt> with respect to x is <tt>Cos(x)</tt>, so the above expression becomes:

{{math,heightPixels.160:
x_1 = x_0 - \frac{sin \left( x_0 \right) }{cos \left( x_0 \right) }
:math}}

Or

{{math:
x_1 = x_0 - tan \left( x_0 \right)
:math}}

The demonstration at the top of this article shows the result of applying Newton iteration to a few examples. For each iteration it shows the current result, where the digits in red are the digits that are already correct, the black ones are not correct yet. This demonstration is really using Yacas, so you can insert real examples to try out yourself.

The following block of code implements the Newton iteration used in the accompanying article. 

{{code:
setup(expression):=
[
  newtonIteration(x):=Eval(`(Simplify(x-(@expression)/(D(x)(@expression)))));
];
newtonInitValue:=3;
newtonPrecision := 50;
start():= [ x:=newtonInitValue; x; ];
iterate() := 
[ 
  x := RoundTo(N(newtonIteration(x),2*newtonPrecision),newtonPrecision); 
  Check(Abs(newtonInitValue-x)/(1+Abs(newtonInitValue)) < 10000,"Iteration might be diverging");
  Atom(String(x));
];
:code}}

<a href="newtonconvergence.html">Back</a> to the article.


