
<html>
<HEAD>
<title>Yacas future plans</title>
<h1>Yacas todo list</h1>
</head>
<body BGCOLOR=WHITE>

<FONT face="Helvetica" size="3">

Current work Ayal:<br>
I am currently working on cleaning up the system, making it
more consistent. 
<ul>
  <li> fix reference counting problems: right now, where reference
       counting is optional, this is causing problems. Eg: strings
       not being freed after an error occurred, the user functions
       table corrupted after a reload.
  <li> Clean up integration code, and document algorithm used.
  <li> document threaded use of integration
  <li> sparserep from multi, use for uni too
  <li> n .. m more elegant
  <li> lists/arrays interchangable
  <li> global var access, test code using a function to return
       a list of global variables.
  <li> Clean up Solve code, and document algorithm used.
  <li> Put new complex numbers system in place.
  <li> Document some long-standing undocumented functions.
  <li> extend plugin facilities a bit: the plugins directory
       could (should?) contain some plugins for specific
       platforms and libraries, to extend Yacas capabilities,
       and possible plugins that implement capabilities more
       efficiently than the current code.
    <ol>
      <li> make changes to the core so functions defined in
           plugins can replace functions defined in scripts.
           This is already done, partially, because the system
           searches c++ defined functions before searching for
           a scripted function. But more needs to be replacable.
           It would be nice, for instance, to be able to mount
           a different file system, one that loads files from
           over the net, or reads scripts from a zip file.
      <li> Change Yacas code to put most functions supported
           in plugins. This will allow us to more easily
           replace functions in the core kernel itself.
      <li> extensions so c++ objects can be addressed too.
      <li> code to process standard c/c++ header files, to automatically
           create a plugin for it.
    </ol>
  <li> Finalize error reporting (in yacasdebug).
    <ol>
      <li> STILL not all errors dump a stack.
      <li> when stack overflow occurs, it still doesn't show all arguments
           evaluated.
    </ol>
  <li> Solve broken, and not as powerful as if can be.
  <li> Test code, documentation for multivariate polys.
</ul>

<p>
This is a list of some expressions that currently go wrong:

<pre>
<ul>
  <li> parsing errors:  FromBase(16,7d)
  <li> exponential algorithm for Limit:
       Taylor(x,0,5)Sin(x)/x; 
       seems to keep on going for ever, actually due to Limits:
       Limit(x,0)D(x,2)Sin(x)/x; // never terminates, causing the taylor to never terminate
  <li> infinite recursion in Integrate:
       Integrate(x)x*Ln(x); // goes into an infinite loop, exhausting the stack
       due to integration by parts entering a recursion. integrating Ln(x) returns
       x*Ln(x), which then causes reintegrating Ln(x), etcetera.
  <li> infinite recursion in Integrate:
       Integrate(x)Sin(Exp(x)); // exhausted stack
       this one is due to the incorrect assumption that TrigSimpCombine will always
       bring expressions with trigonometric functions in them into a form that is integrable.
  <li> In> Factor(17041024)
       Out> 19*13*11*2^7*7^2;
       In> Factor(170410240)
       never stops: problem in PollardRhoFactorize()? why doesn't it detect
       just one extra factor of 10?
  <li> In> Limit(n, Infinity) n^5/2^n
       Out> Infinity/(Infinity*Ln(2));
       wrong answer -- L'Hospital's theorem is not always the correct thing to
       do... but it's not easy to decide the growth of exp-log and powers.
       There is a paper by Richardson, Salvy et al "Asymptotic expansions of
       exp-log functions" that may be helpful.
  <li> In> Limit(n, Infinity) (n+1)/(2*n+3)*I
       Out> 0;
       apparently, it doesn't work with complex numbers although it works with
       reals. Probably a trivial bug.
  <li> In> Simplify(2*x/4.5)
       never stops
  <li> In> Simplify( a*(Sqrt(Pi))^2/2)
       never stops, even though the following examples work:
  <li> In> Simplify( 3*(Sqrt(Pi))^2/2)
       Out> (3*Pi)/2;  // ok
  <li> In> Simplify( a*(Sqrt(b))^2/2)
       Out> (a*b)/2;   // ok
  <li> In> Integrate(x) x^(-1)
       Out> Undefined+C20;
  <li> In> Integrate(x) x^(1/x)
       Out> x^(1/x+1)/(1/x+1)+C29;
  <li> In> Integrate(x) x^(Sin(x))
       Out> x^(Sin(x)+1)/(Sin(x)+1)+C30;
  <li> In> Integrate(x) Ln(0)
       Out> C35-Infinity*x;
  <li> In> Integrate(x) Exp(x^2)
       Out> Undefined*Exp(x^2)+C41;
  <li> In> Integrate(x) Sin(x^2)
       Out> C44-Undefined*Cos(x^2);
</ul>
</pre>



<H1>Future plans</h1>

This is a todo list of things I want to get out of the way before version
2.0.

<h1>emergencies</h1>
<ul>
  <li> Support for scientific notation in anumber.
  <li> Multi-line epoc version.
  <li> revisit MathPower: MathPower(0,0.5) locks up.
  <li> revisit all analytic functions implemented in anumber, including
       log, sin, arctan, etc.
  <li> remove the final references to stdlib in the code.
  <li> integrating x ln x goes into infinite recursion.
  <li> Improved complex numbers. Ln(x) for x &lt 0 not working yet.
  <li> put Nl() in a common place.
  <li> test Apart for polys. This might have to be adjusted by adding
       using the same mechanism used for the integer version.
  <li> loading dll only once (defload mechanism), DllUse iso DllLoad
  <li> the refcount 0xffff problem? Problem is actually the intermediate
       expression swell.
  <li> improved TraceExp
  <li> multivariate polynomials, groebner bases.
  <li> Ascii graph plotter.
  <li> Ascii help when no browser is around
  <li> Taylor on functions containing Abs/Sign can not be trusted.
</ul>


<ul>
  <li> better error reporting.
    <ul>
      <li> show function the error occurred in
      <li> if the error was based on an argument type, show the argument
      <li> If the error was on the number of arguments, specify number
           expected and number received.
      <li> To detect recursion problems, show the stack (ar the last few
           items in the stack). Show it in a form
           Function(internal)
           Function(rule number)
           Function
           And show only the last few.
    </ul>
  <li> Need to improve debugging facilities and tracing facilities. Would be
       good to see how yacas is stepping through rule applications.
  <li> Allow TSimplify() on TSum()..-TSum()..
  <li> Sin(Pi/5) = Sqrt(5-Sqrt(5))/Sqrt(8)
  <li> Fix the Debian package to not require the new gmp.
<li>


<H2>Bugs to be fixed</H2>
<UL>
  <li> factorization of poly's can not do all polys yet. As a consequence:
	  <UL> 
	       	 <li> integrals over rational polys don't always work correctly. 
         <li> partial fraction expansion does not always return correct result (esp. the example in MCA).
		 <li> roots of a polynomial doesn't work yet.
		 <li> eigenvalues of a matrix doesn't work fully yet
      </UL>
  <li> BUG: InverseTaylor not working correctly for Sin and Tan???
  <li> BUG: complex^float.

   <li> Mod(a,b) generates some "UniVariate()" calls if a and b
	are undefined (I expected it to return unevaluated). If one of them
	is defined, and the other undefined, Mod() returns some numbers.
	Mod(x,-3) returns unevaluated. I'm not sure what
	the "correct" meaning of Mod is for negative moduli bases, but the
	answer should in any case be non-negative. Mod(a,b) is defined as the
	smallest non-negative number c such that a-c is divisible by b.


</UL>


<H2>Engine functionality</H2>
These are the items specifying functionality that can not be implemented
from within Yacas, so have a rather high priority if the functionality
is needed.

<UL>
  <li> Define the Local,.. functions based on their Macro counterparts,
       in the scripts.
  <li> Remove the {} [] [[]] brackets support from the engine to the scripts.
  <li> Faster numerical calculation, by caching the internal format,
       and only converting back to ascii when needed.
  <LI> Add Karatsuba multiplication.
  <LI> also define a Head and Tail for arrays, and append/concat/
       insert/delete/copy. This will ease swapping between lists
       and arrays.
  <LI> Allow for type convertors in pattern matchers. For instance: IsUniVar, 
       should be combined with CanBeUni and NormalForm to get the correct
	   one back.
  <li> A RuleBaseDefined-like function that returns a list of defined
       arities.
  <li> HoldEvaluation(function-list)body that holds evaluation of
       these functions.
</UL>

<H2>Math high priority</H2>
This is the real meat, the functionality that should be in Yacas 2.0.

<ul>
	<li> render matrices and square roots nicely too, in PrettyForm.
	<li> FindZeroes (polynoms and other functions)
	<li> redivide some code ('newly')
	<li> make suchthat more powerful, so it simplifies sin(x)=cos(x) to tan(x)=1 to x/Pi/4
	<li> groebner bases
	<li> see if using arrays for matrices speeds up things.
	<li> Fix CanBeUni so that it deals correctly with 1/c
	<li> Test script has been disregarded recently. Make a tests subdir,
		 install it also, with a lot of small files that can be loaded,
		 each implementing some tests.
	<li> EquateCoefs equate coefficients in two polys, and return as list.
	<li> /. as with mathematica, treat args as locals.
	<li> allow solve to return a list usable in /.
	<li> matrix^negative is inverse^positive
	<li> BesselJ
	<li> Get started on differential equations: first order
	<li> try support for sparse objects (matrices, vectors, polynomials).
	<li> try support for iterators.
        <li> support for Atom("a"):=2;
</ul>



<H2>Documentation</H2>

The documentation can be improved. 

<UL>
<li> Add more of a general overview:
  <ul>
  
    <li> what is Yacas? How did it come into existence? Why did I write it? Who is it for?
		 Why no user interface? Why no plotting?
</ul>
<li> document the algorithms used, and expand on all of the functions
     currently implemented.
<li> separate manual chapter on tensors. (Serge? Is it going to change?). TSimplify and TExplicitSum, TD, X
<li> document the source code.
<li> mention  the use of lists for passing multiple arguments.
<li> document HoldArg in combination with <--
<li> ~/.yacas_history and ~/.yacasrc

<li> document the following commands:
  <UL>
  <li> II, ReII, ImII, IsComplexII
  <li> ExpressionDepth, PAdicExpandInternal, GetPrimeFactors, 
          Rem, Roots, Apart, Together
  <li> UnHoldable, GcdReduce, ApplyPure
	DestructiveAppendList, PatternMatches, PatternCreate, RuleBaseDefined,
	TemplateFunction, Lambda (in combination with Apply), 
	Primes, MapArgs, Substitute, 
  <li> %, |, &, ^, if, else (else binds to the last if)
  <li> DivPoly, RootsWithMultiples,
  <li> OdeSolve
  <li> Deriv, Berlekamp, ExtendedEuclidean, ExtendedEuclideanMonic
  <li> IsVariable
  <li> the fact that VarList can also be called with a second argument, a
       filter predicate.
  <li> Extended predicates in the pattern matcher (needs to be explained).
  <li> CTokenizer(), DefaultTokenizer()

  <li> XmlTokenizer, XmlExplodeTag
  <li> BSearch, FindIsq Search for a zero in a monotonously
       growing function. BSearch returns -1 if not found,
       FindIsq returns the insertion point.
  <li>   MultiDivide, MultiGcd, Groebner
  <li> restart, quit, 

  </UL>
  <li> Add a 'History of Yacas' to the introduction.
  <li> Explain what is destructive about the Destructive... routines,
    why they are there, and when to use them.
  <li> Do slightly more on pure functions, to show why they are useful. Show for example Select.
  <li> Explain what Simplify currently does (internal algorithm).


  <li> Html... commands.
  <li> FakeDb... functions.
  <li> some blurb on the pattern matching/multivirtual functionality.
</UL>

<H2>Engine internal improvements</H2>

These are nice to haves in the engine.

<UL>
  <li> An environment object. Within(environment)body should then
     evaluate something within the environment. Together with
     Apply this would allow for packages.
  <li> engine-side apply "op" for speed.
<li> faster Pi() calculation --? seems okay for now
<li>  LispCleanupStack: implement LocalLispString and LocalLispPtr.
<li>  Clean up c++ code a little: Remove ALL TODO's and write javadoc-able-comments in the
      source code.
<li> allow access to the rules database from within yacas, for showing
  the rules to the user.
<li> optimize string concatenation.
<li> Try to find all the places that can use the CArrayGrower with the
  iArrayOwnedExternally set.
<li> it seems I can still optimize InternalEval
</UL>


<H2>Math nice to have</H2>
<ul>

<li> Clean up TrigSimpCombine and Simplify in such a way as to make the
      code reusable for other simplifications.
<li> QSort (? have HeapSort now)
<li> BinarySearch (array!)
<li> FourierTransform?
<li> LaplaceTransform?
<li> Singular Value Decomposition.

<li> FortranForm
<li> Resultants
<li> some DE algos.
<li> implement Diff(f(x),x)
<li> Try all the 131 Wester tests.

</ul>

<h2> Serge's grand roadmap</h2>

These plans are possibly further away but (in my opinion) important enough to keep in mind.

<ol>
<li> Engine/language improvements

 <ol>
 <li> Multiple-precision (MP) math should be redesigned with the following goals:

  <ol>
  <li> Internal "big number" format must be better than char*. There must be two basic classes: "big int" (always signed and dynamically allocated) and "big float". "Big float" may consist simply of two big integers (mantissa and exponent, both signed). I'd rather have the exponent a big integer than a 32-bit -- many MP libraries suffer from this problem.
  <li> MP wrapper class holds big numbers in the internal format and passes them to either "ANumber" or "GMPNumber" backends with hopefully minimal conversion on input and output. MP algorithms such as ArcSin() should not have to be written separately for each MP backend; they are written using the MP wrapper class. Plugins can also use the MP wrapper class only.
  <li> Almost all MP numerical algorithms should be coded in the script library rather than compiled. (except for critical ones). Experiments with MathPi() show that it does not really slow things down when the bulk of the calculation is in the numerics.
  </ol>

This should mostly take care of the MP calculations - no need to reimplement Karatsuba multiplication etc., it's all already done in GMP and platforms without GMP are probably not suitable for serious numerics.

 <li> Random number generation should be fixed to give a uniform distribution. Also, arbitrary-precision random numbers should be generated if requested. Need a better interface to make random arrays?

 </ol>

<li> Library improvements
 <ol>
 <li> Library could be redesigned to streamline all calculations:
  <ol>
  <li> remove default ad hoc simplifications such as a^2*b^2 <-- (a*b)^2, 4*b/c <-- (4*b)/c etc. -- instead provide functions for collecting powers, exponentials, coefficients for a variable, etc., so that the user can do this when needed
  <li> use property tags to make simplification algorithms more understandable
  <li> remove unconventional notation such as a+-b or a^-c
  <li> modify precedences of infix operations: 10, 20, 30 instead of 0,1,2 to allow more fine-grained control
  </ol>
  <li> Implement classical algorithms as well as newest algorithms -- the more different algorithms, the better. There is frequently no "best" algorithm.
 </ol>


<li> Other items
 <ol>
 <li> Improve GUI so that it is more usable than the xterm text mode
 <li> Allow inline graphics in documentation (EPS / PNG / JPG ?)
 <li> All symbolic and numerical algorithms should be documented as soon as they are implemented -- make Yacas a repository of algorithm codes and documentation.
 </ol>
</ol>


</FONT>
</BODY>
</HTML>





 6657552 n.
