

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Number theory algorithms &mdash; Yacas</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Yacas" href="../../index.html"/>
        <link rel="up" title="The Yacas Book of Algorithms" href="index.html"/>
        <link rel="next" title="YAGY" href="../yagy/index.html"/>
        <link rel="prev" title="Finding real roots of polynomials" href="sturm-sequences.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../index.html" class="icon icon-home"> Yacas
        

        
          
          <img src="../../_static/yacaslogo.png" class="logo" />
        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/index.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/index.html#installation-from-sources">Installation from sources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#yacas-syntax">Yacas syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#using-yacas-from-the-calculation-center">Using Yacas from the calculation center</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#yacas-as-a-symbolic-calculator">Yacas as a symbolic calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#arbitrary-precision-numbers">Arbitrary precision numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#analytic-functions">Analytic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#boolean-expressions-and-predicates">Boolean expressions and predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#strings-and-lists">Strings and lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#writing-simplification-rules">Writing simplification rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#local-simplification-rules">Local simplification rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#programming-essentials">Programming essentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#the-practice-of-programming-in-yacas">The practice of programming in Yacas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#defining-your-own-operators">Defining your own operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#some-assorted-programming-topics">Some assorted programming topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/index.html#linear-algebra">Linear Algebra</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference_manual/index.html">Reference Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/arithmetic.html">Arithmetic and other operations on numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/calc.html">Calculus and elementary functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/simplify.html">Simplification of expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/solvers.html">Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/ode.html">Differential Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/logic.html">Propositional logic theorem prover</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/linear-algebra.html">Linear Algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/univariate-polynomials.html">Operations on polynomials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/lists.html">List operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/functional.html">Functional operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/controlflow.html">Control flow functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/predicates.html">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/consts.html">Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/vars.html">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/io.html">Input/output and plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/strings.html">String manipulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/probability-and-statistics.html">Probability and Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/number-theory.html">Number theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference_manual/programming.html">Functions related to programming in Yacas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../programming_in_yacas/index.html">Programming in Yacas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#the-yacas-architecture">The Yacas architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#yacas-evaluation-scheme">Yacas evaluation scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#rules">Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#structured-programming-and-control-flow">Structured programming and control flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#additional-syntactic-sugar">Additional syntactic sugar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#using-macro-rules-e-g-nfunction">Using &#8220;Macro rules&#8221; (e.g. {NFunction})</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#macro-expansion">Macro expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#scope-of-variable-bindings">Scope of variable bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#evaluation-of-expressions">Evaluation of expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#the-lisp-heritage">The LISP heritage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#evaluation">Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#yacas-specific-extensions-for-cas-implementations">{Yacas}-specific extensions for CAS implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#the-evaluation-is-simplification-hack">The &#8220;Evaluation is Simplification&#8221; hack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#destructive-operations">Destructive operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#coding-style">Coding style</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#writing-new-library-functions">Writing new library functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#advanced-example-1-parsing-expressions-cform">Advanced example 1: parsing expressions ({CForm})</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#yacas-programming-pitfalls">Yacas programming pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#debugging-in-yacas">Debugging in Yacas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../programming_in_yacas/index.html#advanced-example-2-implementing-a-non-commutative-algebra">Advanced example 2: implementing a non-commutative algebra</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Yacas Book of Algorithms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="multivar.html">Sparse representations</a></li>
<li class="toctree-l2"><a class="reference internal" href="integration.html">Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="transforms.html">Transforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="sturm-sequences.html">Finding real roots of polynomials</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Number theory algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../yagy/index.html">YAGY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Yacas</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Yacas Book of Algorithms</a> &raquo;</li>
      
    <li>Number theory algorithms</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/doc/book_of_algorithms/numtheory.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="number-theory-algorithms">
<h1>Number theory algorithms<a class="headerlink" href="#number-theory-algorithms" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the algorithms used for computing various
number-theoretic functions.  We call &#8220;number-theoretic&#8221; any function
that takes integer arguments, produces integer values, and is of
interest to number theory.</p>
<div class="section" id="euclidean-gcd-algorithms">
<h2>Euclidean GCD algorithms<a class="headerlink" href="#euclidean-gcd-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The main algorithm for the calculation of the GCD of two integers is
the binary Euclidean algorithm.  It is based on the following
identities: $ Gcd(a,b) = Gcd(b,a) $, $ Gcd(a,b) = Gcd(a-b,b)$, and for
odd $b$, $Gcd(2*a,b) = Gcd(a,b)$.  Thus we can produce a sequence of
pairs with the same GCD as the original two numbers, and each pair
will be at most half the size of the previous pair.  The number of
steps is logarithmic in the number of digits in $a$, $b$.  The only
operations needed for this algorithm are binary shifts and
subtractions (no modular division is necessary).  The low-level
function for this is {MathGcd}.</p>
<p>To speed up the calculation when one of the numbers is much larger
than another, one could use the property $Gcd(a,b)=Gcd(a,Mod(a,b))$.
This will introduce an additional modular division into the algorithm;
this is a slow operation when the numbers are large.</p>
</div>
<div class="section" id="prime-numbers-the-miller-rabin-test-and-its-improvements">
<h2>Prime numbers: the Miller-Rabin test and its improvements<a class="headerlink" href="#prime-numbers-the-miller-rabin-test-and-its-improvements" title="Permalink to this headline">¶</a></h2>
<p>Small prime numbers</p>
<ul class="simple">
<li>EVAL &#8220;$p&lt;=&#8221; : (ToString()Write(FastIsPrime(0))) : &#8220;$&#8221;</li>
</ul>
<p>are simply stored in a precomputed table as an array of bits; the bits
corresponding to prime numbers are set to 1.  This makes primality
testing on small numbers very quick.  This is implemented by the
function {FastIsPrime}.</p>
<p>Primality of larger numbers is tested by the function {IsPrime} that
uses the Miller-Rabin algorithm.  (FOOT Initial implementation and
documentation was supplied by Christian Obrecht.)  This algorithm is
deterministic (guaranteed correct within a certain running time) for
&#8220;small&#8221; numbers $n&lt;3.4*10^13$ and probabilistic (correct with high
probability but not guaranteed) for larger numbers.  In other words,
the Miller-Rabin test could sometimes flag a large number $n$ as prime
when in fact $n$ is composite; but the probability for this to happen
can be made extremely small. The basic reference is [Rabin 1980].  We
also implemented some of the improvements suggested in [Davenport
1992].</p>
<p>The idea of the Miller-Rabin algorithm is to improve the Fermat
primality test. If $n$ is prime, then for any $x$ we have
$Gcd(n,x)=1$. Then by Fermat&#8217;s &#8220;little theorem&#8221;,
$x^(n-1):=Mod(1,n)$. (This is really a simple statement; if $n$ is
prime, then $n-1$ nonzero remainders modulo $n$: 1, 2, ..., $n-1$ form
a cyclic multiplicative group.) Therefore we pick some &#8220;base&#8221; integer
$x$ and compute $Mod(x^(n-1), n)$; this is a quick computation even if
$n$ is large. If this value is not equal to $1$ for some base $x$,
then $n$ is definitely not prime.  However, we cannot test
&lt;i&gt;every&lt;/i&gt; base $x&lt;n$; instead we test only some $x$, so it may
happen that we miss the right values of $x$ that would expose the
non-primality of $n$.  So Fermat&#8217;s test sometimes fails, i.e. says
that $n$ is a prime when $n$ is in fact not a prime.  Also there are
infinitely many integers called &#8220;Carmichael numbers&#8221; which are not
prime but pass the Fermat test for every base.</p>
<p>The Miller-Rabin algorithm improves on this by using the property that
for prime $n$ there are no nontrivial square roots of unity in the
ring of integers modulo $n$ (this is Lagrange&#8217;s theorem). In other
words, if $x^2:=Mod(1,n)$ for some $x$, then $x$ must be equal to $1$
or $-1$ modulo $n$. (Since $n-1$ is equal to $-1$ modulo $n$, we have
$n-1$ as a trivial square root of unity modulo $n$.  Note that even if
$n$ is prime there may be nontrivial divisors of $1$, for example,
$2*49:=Mod(1,97)$.)</p>
<p>We can check that $n$ is odd before applying any primality test. (A
test $n^2:=Mod(1,24)$ guarantees that $n$ is not divisible by $2$ or
$3$.  For large $n$ it is faster to first compute $Mod(n,24)$ rather
than $n^2$, or test $n$ directly.)  Then we note that in Fermat&#8217;s test
the number $n-1$ is certainly a composite number because $n-1$ is
even. So if we first find the largest power of $2$ in $n-1$ and
decompose $n-1=2^r*q$ with $q$ odd, then $x^(n-1):=Mod(a^(2^r),n)$
where $a:=Mod(x^q,n)$. (Here $r&gt;=1$ since $n$ is odd.) In other words,
the number $Mod(x^(n-1),n)$ is obtained by repeated squaring of the
number $a$.  We get a sequence of $r$ repeated squares: $a$, $a^2$,
<tt class="docutils literal"><span class="pre">...</span></tt>, $a^(2^r)$.  The last element of this sequence must be $1$ if
$n$ passes the Fermat test.  (If it does not pass, $n$ is definitely a
composite number.)  If $n$ passes the Fermat test, the last-but-one
element $a^(2^(r-1))$ of the sequence of squares is a square root of
unity modulo $n$.  We can check whether this square root is
non-trivial (i.e. not equal to $1$ or $-1$ modulo $n$). If it is
non-trivial, then $n$ definitely cannot be a prime. If it is trivial
and equal to $1$, we can check the preceding element, and so on. If an
element is equal to $-1$, we cannot say anything, i.e. the test passes
($n$ is &#8220;probably a prime&#8221;).</p>
<p>This procedure can be summarized like this:</p>
<ul class="simple">
<li>1. Find the largest power of $2$ in $n-1$ and an odd number $q$ such
that $n-1=2^r*q$.</li>
<li>2. Select the &#8220;base number&#8221; $x&lt;n$. Compute the sequence
$a:=Mod(x^q,n)$, $a^2$, $a^4$, ..., $a^(2^r)$ by repeated squaring
modulo $n$. This sequence contains at least two elements since
$r&gt;=1$.</li>
<li>3. If $a=1$ or $a=n-1$, the test passes on the base number
$x$. Otherwise, the test passes if at least one of the elements of
the sequence is equal to $n-1$ and fails if none of them are equal
to $n-1$.  This simplified procedure works because the first element
that is equal to $1$ &lt;i&gt;must&lt;/i&gt; be preceded by a $-1$, or else we
would find a nontrivial root of unity.</li>
</ul>
<p>Here is a more formal definition.  An odd integer $n$ is called
&lt;i&gt;strongly-probably-prime&lt;/i&gt; for base $b$ if $b^q:=Mod(1,n)$ or
$b^(q*2^i):=Mod(n-1,n)$ for some $i$ such that $0 &lt;= i &lt; r$, where $q$
and $r$ are such that $q$ is odd and $n-1 = q*2^r$.</p>
<p>A practical application of this procedure needs to select particular
base numbers.  It is advantageous (according to [Pomerance &lt;i&gt;et
al.&lt;/i&gt; 1980]) to choose &lt;i&gt;prime&lt;/i&gt; numbers $b$ as bases, because
for a composite base $b=p*q$, if $n$ is a strong pseudoprime for both
$p$ and $q$, then it is very probable that $n$ is a strong pseudoprime
also for $b$, so composite bases rarely give new information.</p>
<p>An additional check suggested by [Davenport 1992] is activated if
$r&gt;2$ (i.e. if $n:=Mod(1,8)$ which is true for only 1/4 of all odd
numbers).  If $i&gt;=1$ is found such that $b^(q*2^i):=Mod(n-1,n)$, then
$b^(q*2^(i-1))$ is a square root of $-1$ modulo $n$.  If $n$ is prime,
there may be only two different square roots of $-1$.  Therefore we
should store the set of found values of roots of $-1$; if there are
more than two such roots, then we woill find some roots $s1$, $s2$ of
$-1$ such that $s1+s2!=Mod(0,n)$.  But $s1^2-s2^2:=Mod(0,n)$.
Therefore $n$ is definitely composite, e.g. $Gcd(s1+s2,n)&gt;1$. This
check costs very little computational effort but guards against some
strong pseudoprimes.</p>
<p>Yet another small improvement comes from [Damgard &lt;i&gt;et al.&lt;/i&gt; 1993].
They found that the strong primality test sometimes (rarely) passes on
composite numbers $n$ for more than $1/8$ of all bases $x&lt;n$ if $n$ is
such that either $3*n+1$ or $8*n+1$ is a perfect square, or if $n$ is
a Carmichael number. Checking Carmichael numbers is slow, but it is
easy to show that if $n$ is a large enough prime number, then neither
$3*n+1$, nor $8*n+1$, nor any $s*n+1$ with small integer $s$ can be a
perfect square.  [If $s*n+1=r^2$, then $s*n=(r-1)*(r+1)$.]  Testing
for a perfect square is quick and does not slow down the algorithm.
This is however not implemented in Yacas because it seems that perfect
squares are too rare for this improvement to be significant.</p>
<p>If an integer is not &#8220;strongly-probably-prime&#8221; for a given base $b$,
then it is a composite number.  However, the converse statement is
false, i.e. &#8220;strongly-probably-prime&#8221; numbers can actually be
composite.  Composite strongly-probably-prime numbers for base $b$ are
called &lt;i&gt;strong pseudoprimes&lt;/i&gt; for base $b$. There is a theorem
that if $n$ is composite, then among all numbers $b$ such that $1 &lt; b
&lt; n$, at most one fourth are such that $n$ is a strong pseudoprime for
base $b$.  Therefore if $n$ is strongly-probably-prime for many bases,
then the probability for $n$ to be composite is very small.</p>
<p>For numbers less than $B=34155071728321$, exhaustive (FOOT And surely
exhausting.)  computations have shown that there are no strong
pseudoprimes simultaneously for bases 2, 3, 5, 7, 11, 13 and 17. This
gives a simple and reliable primality test for integers below $B$.  If
$n &gt;= B$, the Rabin-Miller method consists in checking if $n$ is
strongly-probably-prime for $k$ base numbers $b$.  The base numbers
are chosen to be consecutive &#8220;weak pseudoprimes&#8221; that are easy to
generate (see below the function {NextPseudoPrime}).</p>
<p>In the implemented routine {RabinMiller}, the number of bases $k$ is
chosen to make the probability of erroneously passing the test $p &lt;
10^(-25)$. (Note that this is &lt;i&gt;not&lt;/i&gt; the same as the probability
to give an incorrect answer, because all numbers that do not pass the
test are definitely composite.) The probability for the test to pass
mistakenly on a given number is found as follows.  Suppose the number
of bases $k$ is fixed. Then the probability for a given composite
number to pass the test is less than $p[f]=4^(-k)$. The probability
for a given number $n$ to be prime is roughly $p[p]=1/Ln(n)$ and to be
composite $p[c]=1-1/Ln(n)$. Prime numbers never fail the test.
Therefore, the probability for the test to pass is $p[f]*p[c]+p[p]$
and the probability to pass erroneously is $$ p =
(p[f]*p[c])/(p[f]*p[c]+p[p]) &lt; Ln(n)*4^(-k) $$.  To make $p&lt;epsilon$,
it is enough to select $k=1/Ln(4)*(Ln(n)-Ln(epsilon))$.</p>
<p>Before calling {MillerRabin}, the function {IsPrime} performs two
quick checks: first, for $n&gt;=4$ it checks that $n$ is not divisible by
2 or 3 (all primes larger than 4 must satisfy this); second, for
$n&gt;257$, it checks that $n$ does not contain small prime factors
$p&lt;=257$.  This is checked by evaluating the GCD of $n$ with the
precomputed product of all primes up to 257.  The computation of the
GCD is quick and saves time in case a small prime factor is present.</p>
<p>There is also a function {NextPrime(n)} that returns the smallest
prime number larger than {n}.  This function uses a sequence
5,7,11,13,... generated by the function {NextPseudoPrime}.  This
sequence contains numbers not divisible by 2 or 3 (but perhaps
divisible by 5,7,...).  The function {NextPseudoPrime} is very fast
because it does not perform a full primality test.</p>
<p>The function {NextPrime} however does check each of these pseudoprimes
using {IsPrime} and finds the first prime number.</p>
</div>
<div class="section" id="factorization-of-integers">
<h2>Factorization of integers<a class="headerlink" href="#factorization-of-integers" title="Permalink to this headline">¶</a></h2>
<p>When we find from the primality test that an integer $n$ is composite,
we usually do not obtain any factors of $n$.  Factorization is
implemented by functions {Factor} and {Factors}.  Both functions use
the same algorithms to find all prime factors of a given integer $n$.
(Before doing this, the primality checking algorithm is used to detect
whether $n$ is a prime number.)  Factorization consists of repeatedly
finding a factor, i.e. an integer $f$ such that $Mod(n, f)=0$, and
dividing $n$ by $f$.  (Of course, each fastor $f$ needs to be
factorized too.)</p>
<div class="section" id="small-prime-factors">
<h3>small prime factors<a class="headerlink" href="#small-prime-factors" title="Permalink to this headline">¶</a></h3>
<p>First we determine whether the number $n$ contains &#8220;small&#8221; prime
factors $p&lt;=257$. A quick test is to find the GCD of $n$ and the
product of all primes up to $257$: if the GCD is greater than 1, then
$n$ has at least one small prime factor. (The product of primes is
precomputed.) If this is the case, the trial division algorithm is
used: $n$ is divided by all prime numbers $p&lt;=257$ until a factor is
found. {NextPseudoPrime} is used to generate the sequence of candidate
divisors $p$.</p>
</div>
<div class="section" id="checking-for-prime-powers">
<h3>checking for prime powers<a class="headerlink" href="#checking-for-prime-powers" title="Permalink to this headline">¶</a></h3>
<p>After separating small prime factors, we test whether the number $n$
is an integer power of a prime number, i.e. whether $n=p^s$ for some
prime number $p$ and an integer $s&gt;=1$. This is tested by the
following algorithm. We already know that $n$ is not prime and that
$n$ does not contain any small prime factors up to 257. Therefore if
$n=p^s$, then $p&gt;257$ and $2&lt;=s&lt;s[0]=Ln(n)/Ln(257)$. In other words,
we only need to look for powers not greater than $s[0]$. This number
can be approximated by the &#8220;integer logarithm&#8221; of $n$ in base 257
(routine {IntLog(n, 257)}).</p>
<p>Now we need to check whether $n$ is of the form $p^s$ for $s=2$, 3,
<tt class="docutils literal"><span class="pre">...</span></tt>, $s[0]$. Note that if for example $n=p^24$ for some $p$, then
the square root of $n$ will already be an integer,
$n^(1/2)=p^12$. Therefore it is enough to test whether $n^(1/s)$ is an
integer for all &lt;i&gt;prime&lt;/i&gt; values of $s$ up to $s[0]$, and then we
will definitely discover whether $n$ is a power of some other integer.
The testing is performed using the integer $n$-th root function
{IntNthRoot} which quickly computes the integer part of $n$-th root of
an integer number. If we discover that $n$ has an integer root $p$ of
order $s$, we have to check that $p$ itself is a prime power (we use
the same algorithm recursively). The number $n$ is a prime power if
and only if $p$ is itself a prime power. If we find no integer roots
of orders $s&lt;=s[0]$, then $n$ is not a prime power.</p>
</div>
<div class="section" id="pollard-s-rho-algorithm">
<h3>Pollard&#8217;s &#8220;rho&#8221; algorithm<a class="headerlink" href="#pollard-s-rho-algorithm" title="Permalink to this headline">¶</a></h3>
<p>If the number $n$ is not a prime power, the Pollard &#8220;rho&#8221; algorithm is
applied [Pollard 1978]. The Pollard &#8220;rho&#8221; algorithm takes an
irreducible polynomial, e.g. $p(x)=x^2+1$ and builds a sequence of
integers $x[k+1]:=Mod(p(x[k]),n)$, starting from $x[0]=2$. For each
$k$, the value $x[2*k]-x[k]$ is attempted as possibly containing a
common factor with $n$. The GCD of $x[2*k]-x[k]$ with $n$ is computed,
and if $Gcd(x[2*k]-x[k],n)&gt;1$, then that GCD value divides $n$.</p>
<p>The idea behind the &#8220;rho&#8221; algorithm is to generate an effectively
random sequence of trial numbers $t[k]$ that may have a common factor
with $n$. The efficiency of this algorithm is determined by the size
of the smallest factor $p$ of $n$. Suppose $p$ is the smallest prime
factor of $n$ and suppose we generate a random sequence of integers
$t[k]$ such that $1&lt;=t[k]&lt;n$. It is clear that, on the average, a
fraction $1/p$ of these integers will be divisible by $p$. Therefore
(if $t[k]$ are truly random) we should need on the average $p$ tries
until we find $t[k]$ which is accidentally divisible by $p$. In
practice, of course, we do not use a truly random sequence and the
number of tries before we find a factor $p$ may be significantly
different from $p$. The quadratic polynomial seems to help reduce the
number of tries in most cases.</p>
<p>But the Pollard &#8220;rho&#8221; algorithm may actually enter an infinite loop
when the sequence $x[k]$ repeats itself without giving any factors of
$n$. For example, the unmodified &#8220;rho&#8221; algorithm starting from
$x[0]=2$ loops on the number $703$. The loop is detected by comparing
$x[2*k]$ and $x[k]$. When these two quantities become equal to each
other for the first time, the loop may not yet have occurred so the
value of GCD is set to 1 and the sequence is continued. But when the
equality of $x[2*k]$ and $x[k]$ occurs many times, it indicates that
the algorithm has entered a loop. A solution is to randomly choose a
different starting number $x[0]$ when a loop occurs and try factoring
again, and keep trying new random starting numbers between 1 and $n$
until a non-looping sequence is found. The current implementation
stops after 100 restart attempts and prints an error message, &#8220;failed
to factorize number&#8221;.</p>
<p>A better (and faster) integer factoring algorithm needs to be
implemented in Yacas.</p>
</div>
<div class="section" id="overview-of-algorithms">
<h3>overview of algorithms<a class="headerlink" href="#overview-of-algorithms" title="Permalink to this headline">¶</a></h3>
<p>Modern factoring algorithms are all probabilistic (i.e. they do not
guarantee a particular finishing time) and fall into three categories:</p>
<ul class="simple">
<li>1. Methods that work well (i.e. quickly) if there is a relatively
small factor $p$ of $n$ (even if $n$ itself is large).  Pollard&#8217;s
&#8220;rho&#8221; algorithm belongs to this category. The fastest in this
category is Lenstra&#8217;s elliptic curves method (ECM).</li>
<li>2. Methods that work equally quickly regardless of the size of
factors (but slower with larger $n$). These are the continued
fractions method and the various &#8220;sieve&#8221; methods. The current best
is the &#8220;General Number Field Sieve&#8221; (GNFS) but it is quite a
complicated algorithm requiring operations with high-order algebraic
numbers. The next best one is the &#8220;Multiple Polynomial Quadratic
Sieve&#8221; (MPQS).</li>
<li>3. Methods that are suitable only for numbers of special
&#8220;interesting&#8221; form, e.g. Fermat numbers $2^(2^k)-1$ or generally
numbers of the form $r^s+a$ where $s$ is large but $r$ and $a$ are
very small integers. The best method seems to be the &#8220;Special Number
Field Sieve&#8221; which is a faster variant of the GNFS adapted to the
problem.</li>
</ul>
<p>There is ample literature describing these algorithms.</p>
</div>
</div>
<div class="section" id="the-jacobi-symbol">
<h2>The Jacobi symbol<a class="headerlink" href="#the-jacobi-symbol" title="Permalink to this headline">¶</a></h2>
<p>A number $m$ is a &#8220;quadratic residue modulo $n$&#8221; if there exists a
number $k$ such that $k^2:=Mod(m,n)$.</p>
<p>The Legendre symbol ($m$/$n$) is defined as $+1$ if $m$ is a quadratic
residue modulo $n$ and $-1$ if it is a non-residue.  The Legendre
symbol is equal to $0$ if $m/n$ is an integer.</p>
<p>The Jacobi symbol $[m/n;]$ is defined as the product of the Legendre
symbols of the prime factors $f[i]$ of $n=f[1]^p[1]*...*f[s]^p[s]$, $$
[m/n;] := [m/f[1];]^p[1]*...*[m/f[s];]^p[s] $$.  (Here we used the
same notation $[a/b;]$ for the Legendre and the Jacobi symbols; this
is confusing but seems to be the current practice.)  The Jacobi symbol
is equal to $0$ if $m$, $n$ are not mutually prime (have a common
factor).  The Jacobi symbol and the Legendre symbol have values $+1$,
$-1$ or $0$.</p>
<p>The Jacobi symbol can be efficiently computed without knowing the full
factorization of the number $n$.  The currently used method is based
on the following four identities for the Jacobi symbol:
* 1. $[a/1;] = 1$.
* 2. $[2/b;] = (-1)^((b^2-1)/8)$.
* 3. $[(a*b)/c;] = [a/c;]*[b/c;]$.
* 4. If $a:=Mod(b,c)$, then $[a/c;]=[b/c;]$.
* 5. If $a$, $b$ are both odd, then $[a/b;]=[b/a;] * (-1)^((a-1)*(b-1)/4)$.</p>
<p>Using these identities, we can recursively reduce the computation of
the Jacobi symbol $[a/b;]$ to the computation of the Jacobi symbol for
numbers that are on the average half as large.  This is similar to the
fast &#8220;binary&#8221; Euclidean algorithm for the computation of the GCD.  The
number of levels of recursion is logarithmic in the arguments $a$,
$b$.</p>
<p>More formally, Jacobi symbol $[a/b;]$ is computed by the following
algorithm.  (The number $b$ must be an odd positive integer, otherwise
the result is undefined.)</p>
<ul class="simple">
<li>1. If $b=1$, return $1$ and stop. If $a=0$, return $0$ and
stop. Otherwise, replace $[a/b;]$ by $[Mod(a,b)/b;]$ (identity 4).</li>
<li>2. Find the largest power of $2$ that divides $a$. Say, $a=2^s*c$
where $c$ is odd.  Replace $[a/b;]$ by $[c/b;]*(-1)^(s*(b^2-1)/8)$
(identities 2 and 3).</li>
<li>3. Now that $c&lt;b$, replace $[c/b;]$ by $[b/c;]*(-1)^((b-1)*(c-1)/4)$
(identity 5).</li>
<li><ol class="first arabic" start="4">
<li>Continue to step 1.</li>
</ol>
</li>
</ul>
<p>Note that the arguments $a$, $b$ may be very large integers and we
should avoid performing multiplications of these numbers.  We can
compute $(-1)^((b-1)*(c-1)/4)$ without multiplications. This
expression is equal to $1$ if either $b$ or $c$ is equal to 1 mod 4;
it is equal to $-1$ only if both $b$ and $c$ are equal to 3 mod 4.
Also, $(-1)^((b^2-1)/8)$ is equal to $1$ if either $b:=1$ or $b:=7$
mod 8, and it is equal to $-1$ if $b:=3$ or $b:=5$ mod 8.  Of course,
if $s$ is even, none of this needs to be computed.</p>
</div>
<div class="section" id="integer-partitions">
<h2>Integer partitions<a class="headerlink" href="#integer-partitions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="partitions-of-an-integer">
<h3>partitions of an integer<a class="headerlink" href="#partitions-of-an-integer" title="Permalink to this headline">¶</a></h3>
<p>A partition of an integer $n$ is a way of writing $n$ as the sum of
positive integers, where the order of these integers is unimportant.
For example, there are 3 ways to write the number 3 in this way:
$3=1+1+1$, $3=1+2$, $3=3$.  The function {PartitionsP} counts the
number of such partitions.</p>
</div>
<div class="section" id="partitions-of-an-integer-by-rademacher-hardy-ramanujan-series">
<h3>partitions of an integer!by Rademacher-Hardy-Ramanujan series<a class="headerlink" href="#partitions-of-an-integer-by-rademacher-hardy-ramanujan-series" title="Permalink to this headline">¶</a></h3>
<p>Large $n$</p>
<p>The first algorithm used to compute this function uses the
Rademacher-Hardy-Ramanujan (RHR) theorem and is efficient for large
$n$.  (See for example [Ahlgren &lt;i&gt;et al.&lt;/i&gt; 2001].)  The number of
partitions $P(n)$ is equal to an infinite sum:</p>
<p>$$ P(n) = 1/(Pi*Sqrt(2))*Sum(k,1,Infinity, Sqrt(k)*A(k,n)*S(k,n)) $$,
where the functions $A$ and $S$ are defined as follows:</p>
<p>$$S(k,n) := Deriv(n) Sinh(Pi/k*Sqrt(2/3*(n-1/24)))/Sqrt(n-1/24)$$</p>
<p>$$ A(k,n) := Sum(l,1,k,
delta(Gcd(l,k),1)*Exp(-2*Pi*I*(l*n)/k+Pi*I*B(k,l))) $$, where
$delta(x,y)$ is the Kronecker delta function (so that the summation
goes only over integers $l$ which are mutually prime with $k$) and $B$
is defined by $$ B(k,l) := Sum(j,1,k-1, j/k*(l*j/k-Floor(l*j/k)-1/2))
$$.</p>
<p>The first term of the series gives, at large $n$, the Hardy-Ramanujan
asymptotic estimate, $$ P(n) &lt;&gt; P_0(n) :=
1/(4*n*Sqrt(3))*Exp(Pi*Sqrt((2*n)/3))$$.  The absolute value of each
term decays quickly, so after $O(Sqrt(n))$ terms the series gives an
answer that is very close to the integer result.</p>
<p>There exist estimates of the error of this series, but they are
complicated.  The series is sufficiently well-behaved and it is easier
to determine the truncation point heuristically.  Each term of the
series is either 0 (when all terms in $A(k,n)$ happen to cancel) or
has a magnitude which is not very much larger than the magnitude of
the previous nonzero term.  (But the series is not actually
monotonic.)  In the current implementation, the series is truncated
when $Abs(A(k,n)*S(n)*Sqrt(k))$ becomes smaller than $0.1$ for the
first time; in any case, the maximum number of calculated terms is
$5+Sqrt(n)/2$.  One can show that asymptotically for large $n$, the
required number of terms is less than $mu/Ln(mu)$, where
$mu:=Pi*Sqrt((2*n)/3)$.</p>
<p>[Ahlgren &lt;i&gt;et al.&lt;/i&gt; 2001] mention that there exist explicit
constants $B[1]$ and $B[2]$ such that $$
Abs(P(n)-Sum(k,1,B[1]*Sqrt(n),A(k,n))) &lt; B[2]*n^(-1/4)$$.</p>
<p>The floating-point precision necessary to obtain the integer result
must be at least the number of digits in the first term $P_0(n)$, i.e.
$$ Prec &gt; (Pi*Sqrt(2/3*n)-Ln(4*n*Sqrt(3)))/Ln(10) $$.  However, Yacas
currently uses the fixed-point precision model.  Therefore, the
current implementation divides the series by $P_0(n)$ and computes all
terms to $Prec$ digits.</p>
<p>The RHR algorithm requires $O((n/Ln(n))^(3/2))$ operations, of which
$O(n/Ln(n))$ are long multiplications at precision $Prec&lt;&gt;O(Sqrt(n))$
digits.  The computational cost is therefore $O(n/Ln(n)*M(Sqrt(n)))$.</p>
</div>
<div class="section" id="partitions-of-an-integer-by-recurrence-relation">
<h3>partitions of an integer!by recurrence relation<a class="headerlink" href="#partitions-of-an-integer-by-recurrence-relation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Small $n$</div></blockquote>
<p>The second, simpler algorithm involves a recurrence relation $$ P[n] =
Sum(k,1,n, (-1)^(k+1)*( P[n-k*(3*k-1)/2]+P[n-k*(3*k+1)/2] ) ) $$.  The
sum can be written out as $$ P(n-1)+P(n-2)-P(n-5)-P(n-7)+... $$, where
1, 2, 5, 7, ... is the &#8220;generalized pentagonal sequence&#8221; generated by
the pairs $k*(3*k-1)/2$, $k*(3*k+1)/2$ for $k=1$, 2, ...  The
recurrence starts from $P(0)=1$, $P(1)=1$.  (This is implemented as
{PartitionsP&#8217;recur}.)</p>
<p>The sum is actually not over all $k$ up to $n$ but is truncated when
the pentagonal sequence grows above $n$.  Therefore, it contains only
$O(Sqrt(n))$ terms.  However, computing $P(n)$ using the recurrence
relation requires computing and storing $P(k)$ for all $1&lt;=k&lt;=n$.  No
long multiplications are necessary, but the number of long additions
of numbers with $Prec&lt;&gt;O(Sqrt(n))$ digits is $O(n^(3/2))$.  Therefore
the computational cost is $O(n^2)$.  This is asymptotically slower
than the RHR algorithm even if a slow $O(n^2)$ multiplication is used.
With internal Yacas math, the recurrence relation is faster for
$n&lt;300$ or so, and for larger $n$ the RHR algorithm is faster.</p>
<blockquote>
<div><blockquote>
<div>Miscellaneous functions</div></blockquote>
<p>divisors</p>
</div></blockquote>
<p>The function {Divisors} currently returns the number of divisors of
integer, while {DivisorsSum} returns the sum of these divisors.  (The
current algorithms need to factor the number.) The following theorem
is used:</p>
<p>Let <span class="math">\(p[1]^k[1]* ... *p[r]^k[r]\)</span> be the prime factorization of $n$,
where $r$ is the number of prime factors and $k[r]$ is the
multiplicity of the $r$-th factor. Then</p>
<p>..math:: Divisors(n) =(k[1]+1)*...*(k[r]+1)</p>
<p>..math:: DivisorsSum(n) = ( ((p[1]^(k[1]+1) -1)/(p[1]-1)))*...*(p[r]^(k[r]+1)-1)/(p[r]-1) $$.</p>
<p>divisors!proper</p>
<p>The functions {ProperDivisors} and {ProperDivisorsSum} are functions
that do the same as the above functions, except they do not consider
the number $n$ as a divisor for itself.  These functions are defined
by:</p>
<p>$ ProperDivisors(n) = Divisors(n) - 1 $,</p>
<p>$ ProperDivisorsSum(n) = DivisorsSum(n) - n $.</p>
<p>Another number-theoretic function is {Moebius}, defined as follows:
$Moebius(n)=(-1)^r$ if no factors of $n$ are repeated, $Moebius(n)=0$
if some factors are repeated, and $Moebius(n)=1$ if $n = 1$.  This
again requires to factor the number $n$ completely and investigate the
properties of its prime factors. From the definition, it can be seen
that if $n$ is prime, then $Moebius(n) = -1 $. The predicate
{IsSquareFree(n)} then reduces to $Moebius(n)!=0$, which means that no
factors of $n$ are repeated.</p>
</div>
</div>
<div class="section" id="gaussian-integers">
<h2>Gaussian integers<a class="headerlink" href="#gaussian-integers" title="Permalink to this headline">¶</a></h2>
<p>A &#8220;Gaussian integer&#8221; is a complex number of the form <span class="math">\(z =
a+b*\imath\)</span>, where $a$ and $b$ are ordinary (rational) integers.
(FOOT To distinguish ordinary integers from Gaussian integers, the
ordinary integers (with no imaginary part) are called &#8220;rational
integers&#8221;.)  The ring of Gaussian integers is usually denoted by
$Z$[$I$] in the mathematical literature. It is an example of a ring of
algebraic integers.</p>
<p>The function {GaussianNorm} computes the norm $N(z)=a^2+b^2$ of $z$.
The norm plays a fundamental role in the arithmetic of Gaussian
integers, since it has the multiplicative property: $$ N(z.w) =
N(z).N(w) $$.</p>
<p>A unit of a ring is an element that divides any other element of the
ring.  There are four units in the Gaussian integers: $1$, $-1$, $I$,
$-I$. They are exactly the Gaussian integers whose norm is $1$. The
predicate {IsGaussianUnit} tests for a Gaussian unit.</p>
<p>Two Gaussian integers $z$ and $w$ are &#8220;associated&#8221; is $z/w$ is a unit.
For example, $2+I$ and $-1+2*I$ are associated.</p>
<p>A Gaussian integer is called prime if it is only divisible by the
units and by its associates. It can be shown that the primes in the
ring of Gaussian integers are:</p>
<ul class="simple">
<li><ol class="first arabic">
<li>$1+i$ and its associates.</li>
</ol>
</li>
<li><ol class="first arabic" start="2">
<li>The rational (ordinary) primes of the form $4*n+3$.</li>
</ol>
</li>
<li>3. The factors $a+b*I$ of rational primes $p$ of the form $p=4*n+1$,
whose norm is $p=a^2+b^2$.</li>
</ul>
<p>For example, $7$ is prime as a Gaussian integer, while $5$ is not,
since $ 5 = (2+I)*(2-I) $.  Here $2+I$ is a Gaussian prime.</p>
<div class="section" id="factors">
<h3>Factors<a class="headerlink" href="#factors" title="Permalink to this headline">¶</a></h3>
<p>The ring of Gaussian integers is an example of an Euclidean ring,
i.e. a ring where there is a division algorithm.  This makes it
possible to compute the greatest common divisor using Euclid&#8217;s
algorithm. This is what the function {GaussianGcd} computes.</p>
<p>As a consequence, one can prove a version of the fundamental theorem
of arithmetic for this ring: The expression of a Gaussian integer as a
product of primes is unique, apart from the order of primes, the
presence of units, and the ambiguities between associated primes.</p>
<p>The function {GaussianFactors} finds this expression of a Gaussian
integer $z$ as the product of Gaussian primes, and returns the result
as a list of pairs {{p,e}}, where $p$ is a Gaussian prime and $e$ is
the corresponding exponent.  To do that, an auxiliary function called
{GaussianFactorPrime} is used. This function finds a factor of a
rational prime of the form $4*n+1$. We compute $a := (2*n)!$ (mod
p). By Wilson&#8217;s theorem $a^2$ is congruent to $-1$ (mod $p$), and it
follows that $p$ divides $(a+I)*(a-I)=a^2+1$ in the Gaussian
integers. The desired factor is then the {GaussianGcd} of $a+I$ and
$p$. If the result is $a+b*I$, then $p=a^2+b^2$.</p>
<p>If $z$ is a rational (i.e. real) integer, we factor $z$ in the
Gaussian integers by first factoring it in the rational integers, and
after that by factoring each of the integer prime factors in the
Gaussian integers.</p>
<p>If $z$ is not a rational integer, we find its possible Gaussian prime
factors by first factoring its norm $N(z)$ and then computing the
exponent of each of the factors of $N(z)$ in the decomposition of $z$.</p>
</div>
<div class="section" id="references-for-gaussian-integers">
<h3>References for Gaussian integers<a class="headerlink" href="#references-for-gaussian-integers" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>1. G. H. Hardy and E. M. Wright, &lt;i&gt;An Introduction to the Theory of
Numbers&lt;/i&gt;. Oxford University Press (1945).</li>
<li>2. H. Pollard, &lt;i&gt;The theory of Algebraic Numbers&lt;/i&gt;. Wiley, New
York (1965).</li>
</ul>
</div>
</div>
<div class="section" id="a-simple-factorization-algorithm-for-univariate-polynomials">
<h2>A simple factorization algorithm for univariate polynomials<a class="headerlink" href="#a-simple-factorization-algorithm-for-univariate-polynomials" title="Permalink to this headline">¶</a></h2>
<p>This section discusses factoring polynomials using arithmetic modulo
prime numbers. Information was used from D. Knuth, &lt;I&gt;The Art of
Computer Programming, Volume 2, Seminumerical Algorithms &lt;/I&gt; and
J.H. Davenport et. al., &lt;I&gt;Computer Algebra, SYSTEMS AND ALGORITHMS
FOR ALGEBRAIC COMPUTATION&lt;/I&gt;.</p>
<p>A simple factorization algorithm is developed for univariate
polynomials. This algorithm is implemented as the function
{BinaryFactors}. The algorithm was named the binary factoring
algorithm since it determines factors to a polynomial modulo $2^n$ for
successive values of $n$, effectively adding one binary digit to the
solution in each iteration. No reference to this algorithm has been
found so far in literature.</p>
<p>Berlekamp showed that polynomials can be efficiently factored when
arithmetic is done modulo a prime. The Berlekamp algorithm is only
efficient for small primes, but after that Hensel lifting can be used
to determine the factors modulo larger numbers.</p>
<p>The algorithm presented here is similar in approach to applying the
Berlekamp algorithm to factor modulo a small prime, and then factoring
modulo powers of this prime (using the solutions found modulo the
small prime by the Berlekamp algorithm) by applying Hensel lifting.
However it is simpler in set up. It factors modulo 2, by trying all
possible factors modulo 2 (two possibilities, if the polynomial is
monic). This performs the same action usually left to the Berlekamp
step. After that, given a solution modulo $2^n$, it will test for a
solution $f_i$ modulo $2^n$ if $f_i$ or $f_i + 2^n$ are a solution
modulo $2^(n+1)$.</p>
<p>This scheme raises the precision of the solution with one digit in
binary representation. This is similar to the linear Hensel lifting
algorithm, which factors modulo $p^n$ for some prime $p$, where $n$
increases by one after each iteration. There is also a quadratic
version of Hensel lifting which factors modulo $p^2^n$, in effect
doubling the number of digits (in p-adic expansion) of the solution
after each iteration. However, according to &#8220;Davenport&#8221;, the quadratic
algorithm is not necessarily faster.</p>
<p>The algorithm here thus should be equivalent in complexity to Hensel
lifting linear version. This has not been verified yet.</p>
</div>
<div class="section" id="modular-arithmetic">
<h2>Modular arithmetic<a class="headerlink" href="#modular-arithmetic" title="Permalink to this headline">¶</a></h2>
<p>This section copies some definitions and rules from &lt;I&gt;The Art of
Computer Programming, Volume 1, Fundamental Algorithms &lt;/I&gt; regarding
arithmetic modulo an integer.</p>
<p>Arithmetic modulo an integer $p$ requires performing the arithmetic
operation and afterwards determining that integer modulo $p$. A number
$x$ can be written as $$x=q*p+r$$ where $q$ is called the quotient,
and $r$ remainder.  There is some liberty in the range one chooses $r$
to be in. If $r$ is an integer in the range ${0,1, ... ,(p-1)}$ then
it is the &lt;i&gt;modulo&lt;/i&gt;, $r = Mod(x,p)$.</p>
<p>When $Mod(x,p) = Mod(y,p)$, the notation $Mod(x=y,p)$ is used. All
arithmetic calculations are done modulo an integer $p$ in that case.</p>
<p>For calculations modulo some $p$ the following rules hold:</p>
<ul class="simple">
<li>If $Mod(a=b,p)$ and $Mod(x=y,p)$, then $Mod(a*x=b*y,p)$,
$Mod(a+x=b+y,p)$, and $Mod(a-x=b-y,p)$.  This means that for
instance also $Mod(x^n,p) = Mod(Mod(x,p)^n,p)$</li>
<li>Two numbers $x$ and $y$ are &lt;i&gt;relatively prime&lt;/i&gt; if they don&#8217;t
share a common factor, that is, if their greatest common denominator
is one, $Gcd(x,y)=1$.</li>
<li>If $Mod(a*x=b*y,p)$ and if $Mod(a=b,p)$, and if $a$ and $p$ are
relatively prime, then $Mod(x=y,p)$.  This is useful for dividing
out common factors.</li>
<li>$Mod(a=b,p)$ if and only if $Mod(a*n=b*n,n*p)$ when $n != 0$.  Also,
if $r$ and $s$ are relatively prime, then $Mod(a=b,r*s)$ only if
$Mod(a=b,r)$ and $Mod(a=b,s)$.  These rules are useful when the
modulus is changed.</li>
</ul>
<p>For polynomials $v_1(x)$ and $v_2(x)$ it further holds that $$
Mod((v_1(x)+v_2(x))^p = v_1(x)^p + v_2(x)^p,p) $$ This follows by
writing out the expression, noting that the binomial coefficients that
result are multiples of $p$, and thus their value modulo $p$ is zero
($p$ divides these coefficients), so only the two terms on the right
hand side remain.</p>
<div class="section" id="some-corollaries">
<h3>Some corollaries<a class="headerlink" href="#some-corollaries" title="Permalink to this headline">¶</a></h3>
<p>One corollary of the rules for calculations modulo an integer is
&lt;i&gt;Fermat&#8217;s theorem, 1640&lt;/i&gt; : if $p$ is a prime number then
$$Mod(a^p=a,p)$$ for all integers $a$ (for a proof, see Knuth).</p>
<p>An interesting corollary to this is that, for some prime integer $p$:
$$ Mod(v(x)^p = v(x^p),p) $$.  This follows from writing it out and
using Fermat&#8217;s theorem to replace $a^p$ with $a$ where appropriate
(the coefficients to the polynomial when written out, on the left hand
side).</p>
</div>
<div class="section" id="factoring-using-modular-arithmetic">
<h3>Factoring using modular arithmetic<a class="headerlink" href="#factoring-using-modular-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>The task is to factor a polynomial</p>
<p>$$ p(x) = a_n*x^n + ... + a_0 $$</p>
<p>into a form</p>
<p>$$ p(x) = C*g(x)*f_1(x)^p_1*f_2(x)^p_2 * ... * f_m(x)^p_m $$</p>
<p>Where $f_i(x)$ are irreducible polynomials of the form:</p>
<p>$$ f_i(x) = x+c_i $$</p>
<p>The part that could not be factorized is returned as $g(x)$,
with a possible constant factor $C$.</p>
<p>The factors $f_i(x)$ and $g(x)$ are determined uniquely by requiring
them to be monic. The constant $C$ accounts for a common factor.</p>
<p>The $c_i$ constants in the resulting solutions $f_i(x)$ can be
rational numbers (or even complex numbers, if Gaussian integers
are used).</p>
</div>
<div class="section" id="preparing-the-polynomial-for-factorization">
<h3>Preparing the polynomial for factorization<a class="headerlink" href="#preparing-the-polynomial-for-factorization" title="Permalink to this headline">¶</a></h3>
<p>The final factoring algorithm needs the input polynomial to be monic
with integer coefficients (a polynomial is monic if its leading
coefficient is one). Given a non-monic polynomial with rational
coefficients, the following steps are performed:</p>
<p>Convert polynomial with rational coefficients to polynomial with integer coefficients</p>
<p>First the least common multiple $lcm$ of the denominators of the
coefficients $p(x)$ has to be found, and the polynomial is multiplied
by this number.  Afterwards, the $C$ constant in the result should
have a factor $1/lcm$.</p>
<p>The polynomial now only has integer coefficients.</p>
</div>
<div class="section" id="convert-polynomial-to-a-monic-polynomial">
<h3>Convert polynomial to a monic polynomial<a class="headerlink" href="#convert-polynomial-to-a-monic-polynomial" title="Permalink to this headline">¶</a></h3>
<p>The next step is to convert the polynomial to one where the leading
coefficient is one. In order to do so, following &#8220;Davenport&#8221;, the
following steps have to be taken:</p>
<ul class="simple">
<li><ol class="first arabic">
<li>Multiply the polynomial by $a_n^(n-1)$</li>
</ol>
</li>
<li><ol class="first arabic" start="2">
<li>Perform the substitution $x=(y/a_n)$</li>
</ol>
</li>
</ul>
<p>The polynomial is now a monic polynomial in $y$.</p>
<p>After factoring, the irreducible factors of $p(x)$ can be obtained by
multiplying $C$ with $1/(a_n^(n-1))$, and replacing $y$ with
$a_n*x$. The irreducible solutions $a_n*x+c_i$ can be replaced by
$x+c_i/a_i$ after multiplying $C$ by $a_n$, converting the factors to
monic factors.</p>
<p>After the steps described here the polynomial is now monic with
integer coefficients, and the factorization of this polynomial can be
used to determine the factors of the original polynomial $p(x)$.</p>
</div>
<div class="section" id="definition-of-division-of-polynomials">
<h3>Definition of division of polynomials<a class="headerlink" href="#definition-of-division-of-polynomials" title="Permalink to this headline">¶</a></h3>
<p>To factor a polynomial a division operation for polynomials modulo
some integer is needed. This algorithm needs to return a quotient
$q(x)$ and remainder $r(x)$ such that:</p>
<p>$$ Mod(p(x) = q(r)*d(x) + r(x),p) $$</p>
<p>for some polymomial $d(x)$ to be divided by, modulo some
integer p. $d(x)$ is said to divide $p(x)$ (modulo $p$) if $r(x)$ is
zero.  It is then a factor modulo $p$.</p>
<p>For binary factoring algorithm it is important that if some monic
$d(x)$ divides $p(x)$, then it also divides $p(x)$ modulo some integer
$p$.</p>
<p>Define $deg(f(x))$ to be the degree of $f(x)$ and $lc(f(x))$ to be the
leading coefficient of $f(x)$. Then, if $deg(p(x)) &gt;= deg(d(x))$, one
can compute an integer $s$ such that</p>
<p>$$ Mod(lc(d(x))*s = lc(p(x)),p) $$</p>
<p>If $p$ is prime, then</p>
<p>$$s = Mod(lc(p(x))*lc(d(x))^(p-2),p) $$</p>
<p>Because $Mod(a^(p-1) = 1,p)$ for any $a$. If $p$ is not prime but
$d(x)$ is monic (and thus $lc(d(x)) = 1$),</p>
<p>$$s = lc(p(x)) $$</p>
<p>This identity can also be used when dividing in general (not modulo
some integer), since the divisor is monic.</p>
<p>The quotient can then be updated by adding a term:</p>
<p>$term = s*x^(deg(p(x))-deg(d(x)))$</p>
<p>and updating the polynomial to be divided, $p(x)$, by subtracting
$d(x)*term$. The resulting polynomial to be divided now has a degree
one smaller than the previous.</p>
<p>When the degree of $p(x)$ is less than the degree of $d(x)$ it is
returned as the remainder.</p>
<p>A full division algorithm for arbitrary integer $p&gt;1$ with $lc(d(x)) =
1$ would thus look like:</p>
<div class="highlight-python"><div class="highlight"><pre>divide(p(x),d(x),p)
   q(x) = 0
   r(x) = p(x)
   while (deg(r(x)) &gt;= deg(d(x)))
      s = lc(r(x))
      term = s*x^(deg(r(x))-deg(d(x)))
      q(x) = q(x) + term
      r(x) = r(x) - term*d(x) mod p
   return {q(x),r(x)}
</pre></div>
</div>
<p>The reason we can get away with factoring modulo $2^n$ as opposed to
factoring modulo some prime $p$ in later sections is that the divisor
$d(x)$ is monic. Its leading coefficient is one and thus $q(x)$ and
$r(x)$ can be uniquely determined. If $p$ is not prime and $lc(d(x))$
is not equal to one, there might be multiple combinations for which
$p(x) = q(x)*d(x)+r(x)$, and we are interested in the combinations
where $r(x)$ is zero. This can be costly to determine unless
{q(x),r(x)} is unique.  This is the case here because we are factoring
a monic polynomial, and are thus only interested in cases where
$lc(d(x)) = 1$.</p>
</div>
<div class="section" id="determining-possible-factors-modulo-2">
<h3>Determining possible factors modulo 2<a class="headerlink" href="#determining-possible-factors-modulo-2" title="Permalink to this headline">¶</a></h3>
<p>We start with a polynomial $p(x)$ which is monic and has integer
coefficients.</p>
<p>It will be factored into a form:</p>
<p>$$ p(x) = g(x)*f_1(x)^p_1*f_2(x)^p_2 * ... * f_m(x)^p_m $$</p>
<p>where all factors $f_i(x)$ are monic also.</p>
<p>The algorithm starts by setting up a test polynomial, $p_test(x)$
which divides $p(x)$, but has the property that</p>
<p>$$ p_test(x) = g(x)*f_1(x)*f_2(x) * ... * f_m(x) $$</p>
<p>Such a polynomial is said to be &lt;i&gt;square-free&lt;/i&gt;.  It has the same
factors as the original polynomial, but the original might have
multiple of each factor, where $p_test(x)$ does not.</p>
<p>The square-free part of a polynomial can be obtained as follows:</p>
<p>$$ p_test(x) = p(x)/Gcd(p(x),D(x)p(x)) $$</p>
<p>It can be seen by simply writing this out that $p(x)$ and $D(x)p(x)$
will have factors $f_i(x)^(p_i-1)$ in common. these can thus be
divided out.</p>
<p>It is not a requirement of the algorithm that the algorithm being
worked with is square-free, but it speeds up computations to work with
the square-free part of the polynomial if the only thing sought after
is the set of factors. The multiplicity of the factors can be
determined using the original $p(x)$.</p>
<p>Binary factoring then proceeds by trying to find potential solutions
modulo $p=2$ first. There can only be two such solutions: $x+0$ and
$x+1$.</p>
<p>A list of possible solutions $L$ is set up with potential solutions.</p>
</div>
<div class="section" id="determining-factors-modulo-2-n-given-a-factorization-modulo-2">
<h3>Determining factors modulo $2^n$ given a factorization modulo 2<a class="headerlink" href="#determining-factors-modulo-2-n-given-a-factorization-modulo-2" title="Permalink to this headline">¶</a></h3>
<p>At this point there is a list $L$ with solutions modulo $2^n$ for some
$n$. The solutions will be of the form: $x+a$. The first step is to
determine if any of the elements in $L$ divides $p(x)$ (not modulo any
integer).  Since $x+a$ divides $p_test(x)$ modulo $2^n$, both $x+a$
and $x+a-2^n$ have to be checked.</p>
<p>If an element in $L$ divides $p_test(x)$, $p_test(x)$ is divided by
it, and a loop is entered to test how often it divides $p(x)$ to
determine the multiplicity $p_i$ of the factor. The found factor
$f_i(x) = x+c_i$ is added as a combination ($x+c_i$, $p_i$). $p(x)$ is
divided by $f_i(x)^p_i$.</p>
<p>At this point there is a list $L$ of factors that divide $p_test(x)$
modulo $2^n$. This implies that for each of the elements $u$ in $L$,
either $u$ or $u+2^n$ should divide $p_test(x)$ modulo $2^(n+1)$.  The
following step is thus to set up a new list with new elements that
divide $p_test(x)$ modulo $2^(n+1)$.</p>
<p>The loop is re-entered, this time doing the calculation modulo
$2^(n+1)$ instead of modulo $2^n$.</p>
<p>The loop is terminated if the number of factors found equals
$deg(p_test(x))$, or if $2^n$ is larger than the smallest non-zero
coefficient of $p_test(x)$ as this smallest non-zero coefficient is
the product of all the smallest non-zero coefficients of the factors,
or if the list of potential factors is zero.</p>
<p>The polynomial $p(x)$ can not be factored any further, and is added as
a factor ($p(x)$, $1$).</p>
<p>The function {BinaryFactors}, when implemented, yields the following
interaction in Yacas:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">In</span><span class="o">&gt;</span> <span class="n">BinaryFactors</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Out</span><span class="o">&gt;</span> <span class="p">{{</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">},{</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">}}</span>
<span class="n">In</span><span class="o">&gt;</span> <span class="n">BinaryFactors</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
<span class="n">Out</span><span class="o">&gt;</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">}}</span>
<span class="n">In</span><span class="o">&gt;</span> <span class="n">BinaryFactors</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1123125</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">123233</span><span class="p">))</span>
<span class="n">Out</span><span class="o">&gt;</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="n">x</span><span class="o">-</span><span class="mi">1123125</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="n">x</span><span class="o">+</span><span class="mi">123233</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">}}</span>
</pre></div>
</div>
<p>The binary factoring algorithm starts with a factorization modulo 2,
and then each time tries to guess the next bit of the solution,
maintaining a list of potential solutions.  This list can grow
exponentially in certain instances.  For instance, factoring
$(x-a)*(x-2*a)*(x-3*a)* ... $ implies a that the roots have common
factors. There are inputs where the number of potential solutions
(almost) doubles with each iteration.  For these inputs the algorithm
becomes exponential. The worst-case performance is therefore
exponential. The list of potential solutions while iterating will
contain a lot of false roots in that case.</p>
</div>
<div class="section" id="efficiently-deciding-if-a-polynomial-divides-another">
<h3>Efficiently deciding if a polynomial divides another<a class="headerlink" href="#efficiently-deciding-if-a-polynomial-divides-another" title="Permalink to this headline">¶</a></h3>
<p>Given the polynomial $p(x)$, and a potential divisor $$ f_i(x) = x-p
$$ modulo some $q=2^n$ an expression for the remainder after division
is</p>
<p>$$ rem(p)=Sum(i,0,n,a_i*p^i) $$</p>
<p>For the initial solutions modulo 2, where the possible solutions are
$x$ and $x-1$. For $p=0$, $rem(0) = a_0$.  For $p=1$, $rem(1) =
Sum(i,0,n,a_i)$ .</p>
<p>Given a solution $x-p$ modulo $q=2^n$, we consider the possible
solutions $Mod(x-p,2^(n+1))$ and $Mod(x-(p+2^n),2^n+1)$.</p>
<p>$x-p$ is a possible solution if $Mod(rem(p),2^(n+1)) = 0$.</p>
<p>$x-(p+q)$ is a possible solution if $Mod(rem(p+q),2^(n+1)) = 0$.
Expanding $Mod(rem(p+q),2*q)$ yields:</p>
<p>$$ Mod(rem(p+q),2*q) = Mod(rem(p) + extra(p,q),2*q) $$</p>
<p>When expanding this expression, some terms grouped under $extra(p,q)$
have factors like $2*q$ or $q^2$. Since $q=2^n$, these terms vanish if
the calculation is done modulo $2^(n+1)$.</p>
<p>The expression for $extra(p,q)$ then becomes $$ extra(p,q) =
q*Sum(i,1,n/2, (2*i-1)*a(2*i)*p^(2*i-2)) $$</p>
<p>An efficient approach to determining if $x-p$ or $x-(p+q)$ divides
$p(x)$ modulo $2^(n+1)$ is then to first calculate
$Mod(rem(p),2*q)$. If this is zero, $x-p$ divides $p(x)$.  In
addition, if $Mod(rem(p)+extra(p,q),2*q)$ is zero, $x-(p+q)$ is a
potential candidate.</p>
<p>Other efficiencies are derived from the fact that the operations are
done in binary. Eg. if $q=2^n$, then $q_next=2^(n+1) = 2*q = q&lt;&lt;1 $ is
used in the next iteration. Also, calculations modulo $2^n$ are
equivalent to performing a bitwise and with $2^n-1$. These operations
can in general be performed efficiently on todays hardware which is
based on binary representations.</p>
</div>
<div class="section" id="extending-the-algorithm">
<h3>Extending the algorithm<a class="headerlink" href="#extending-the-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Only univariate polynomials with rational coefficients have been
considered so far. This could be extended to allow for roots that are
complex numbers $a+I*b$ where both $a$ and $b$ are rational numbers.</p>
<p>For this to work the division algorithm would have to be extended to
handle complex numbers with integer $a$ and $b$ modulo some integer,
and the initial setup of the potential solutions would have to be
extended to try $x+1+I$ and $x+I$ also. The step where new potential
solutions modulo $2^(n+1)$ are determined should then also test for
$x+I*2^n$ and $x+2^n+I*2^n$.</p>
<p>The same extension could be made for multivariate polynomials,
although setting up the initial irreducible polynomials that divide
$p_test(x)$ modulo 2 might become expensive if done on a polynomial
with many variables ($2^(2^m-1)$ trials for $m$ variables).</p>
<p>Lastly, polynomials with real-valued coefficients &lt;i&gt;could&lt;/i&gt; be
factored, if the coefficients were first converted to rational
numbers. However, for real-valued coefficients there exist other
methods (Sturm sequences).</p>
</div>
<div class="section" id="newton-iteration">
<h3>Newton iteration<a class="headerlink" href="#newton-iteration" title="Permalink to this headline">¶</a></h3>
<p>What the {BinaryFactor} algorithm effectively does is finding a set of
potential solutions modulo $2^(n+1)$ when given a set of potential
solutions modulo $2^n$.  There is a better algorithm that does
something similar: Hensel lifting. Hensel lifting is a generalized
form of Newton iteration, where given a factorization modulo $p$, each
iteration returns a factorization modulo $p^2$.</p>
<p>Newton iteration is based on the following idea: when one takes a
Taylor series expansion of a function:</p>
<p>$$f(x[0]+dx) := f(x[0]) + (D(x)f(x[0]))*dx + ... $$</p>
<p>Newton iteration then proceeds by taking only the first two terms in
this series, the constant plus the constant times $dx$. Given some
good initial value $x_0$, the function will is assumed to be close to
a root, and the function is assumed to be almost linear, hence this
approximation.  Under these assumptions, if we want $f(x_0+dx)$ to be
zero,</p>
<p>$$f(x[0]+dx) = f(x[0]) + (D(x)f(x[0]))*dx = 0 $$</p>
<p>This yields:</p>
<p>$$ dx := -f(x[0])/(D(x)f(x[0])) = 0 $$</p>
<p>And thus a next, better, approximation for the root is
$x[1]:=x_0-f(x[0])/(D(x)f(x[0]))$, or more general:</p>
<p>$$ x[n+1] =x[n]-f(x[n])/(D(x)f(x[n]))$$</p>
<p>If the root has multiplicity one, a Newton iteration can converge
&lt;i&gt;quadratically&lt;/i&gt;, meaning the number of decimals precision for
each iteration doubles.</p>
<p>As an example, we can try to find a root of $Sin(x)$ near
$3$, which should converge to $Pi$.</p>
<p>Setting precision to 30 digits,:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; Builtin&#39;Precision&#39;Set(30)
Out&gt; True;
</pre></div>
</div>
<p>We first set up a function $dx(x)$:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; dx(x):=Eval(-Sin(x)/(D(x)Sin(x)))
Out&gt; True;
</pre></div>
</div>
<p>And we start with a good initial approximation to $Pi$, namely
$3$. Note we should set {x} &lt;i&gt;after&lt;/i&gt; we set dx(x), as the right
hand side of the function definition is evaluated. We could also have
used a different parameter name for the definition of the function
$dx(x)$.:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; x:=3
Out&gt; 3;
</pre></div>
</div>
<p>We can now start the iteration:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; x:=N(x+dx(x))
Out&gt; 3.142546543074277805295635410534;
In&gt; x:=N(x+dx(x))
Out&gt; 3.14159265330047681544988577172;
In&gt; x:=N(x+dx(x))
Out&gt; 3.141592653589793238462643383287;
In&gt; x:=N(x+dx(x))
Out&gt; 3.14159265358979323846264338328;
In&gt; x:=N(x+dx(x))
Out&gt; 3.14159265358979323846264338328;
</pre></div>
</div>
<p>As shown, in this example the iteration converges quite quickly.</p>
</div>
<div class="section" id="finding-roots-of-multiple-equations-in-multiple-variables-using-newton-iteration">
<h3>Finding roots of multiple equations in multiple variables using Newton iteration<a class="headerlink" href="#finding-roots-of-multiple-equations-in-multiple-variables-using-newton-iteration" title="Permalink to this headline">¶</a></h3>
<p>One generalization, mentioned in W.H. Press et al., &lt;i&gt;NUMERICAL
RECIPES in C, The Art of Scientific computing&lt;/i&gt; is finding roots for
multiple functions in multiple variables.</p>
<p>Given $N$ functions in $N$ variables, we want to solve</p>
<p>$$ f_i(x[1],...,x[N]) = 0 $$</p>
<p>for $i = 1 .. N $. If de denote by $X$ the vector
$$ X := {x[1],x[2],...,x[N]} $$</p>
<p>and by $dX$ the delta vector, then one can write</p>
<p>$$ f_i(X+dX) := f_i(X)+Sum(j,1,N,(D(x_j)f_i(X)))*dx[j] $$</p>
<p>Setting $f_i(X+dX)$ to zero, one obtains</p>
<p>$$ Sum(j,1,N,a[i][j]*dx_j)=b[i]$$</p>
<p>where</p>
<p>$$a[i][j] := D(x_j)f_i(X)$$</p>
<p>and</p>
<p>$$b_i := -f_i(X)$$</p>
<p>So the generalization is to first initialize $X$ to a good initial
value, calculate the matrix elements $a[i][j]$ and the vector $b[i]$,
and then to proceed to calculate $dX$ by solving the matrix equation,
and calculating</p>
<p>$$X[i+1] := X[i] + dX[i]$$</p>
<p>In the case of one function with one variable, the summation reduces
to one term, so this linear set of equations was a lot simpler in that
case. In this case we will have to solve this set of linear equations
in each iteration.</p>
<p>As an example, suppose we want to find the zeroes for the following
two functions:</p>
<p>$$f_1(a,x) := Sin(a*x)$$</p>
<p>and</p>
<p>$$f_2(a,x) := a-2$$</p>
<p>It is clear that the solution to this is $a=2$ and $x:=N*Pi/2$
for any integer value $N$.</p>
<p>We will do calculations with precision 30:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; Builtin&#39;Precision&#39;Set(30)
Out&gt; True;
</pre></div>
</div>
<p>And set up a vector of functions ${f_1(X),f_2(X)}$
where $X:={a,x}$:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; f(a,x):={Sin(a*x),a-2}
Out&gt; True;
</pre></div>
</div>
<p>Now we set up a function {matrix(a,x)} which returns the
matrix $a[i][j]$:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; matrix(a,x):=Eval({D(a)f(a,x),D(x)f(a,x)})
Out&gt; True;
</pre></div>
</div>
<p>We now set up some initial values:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; {a,x}:={1.5,1.5}
Out&gt; {1.5,1.5};
</pre></div>
</div>
<p>The iteration converges a lot slower for this example, so we
will loop 100 times:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; For(ii:=1,ii&lt;100,ii++)[{a,x}:={a,x}+\
      N(SolveMatrix(matrix(a,x),-f(a,x)));]
Out&gt; True;
In&gt; {a,x}
Out&gt; {2.,0.059667311457823162437151576236};
</pre></div>
</div>
<p>The value for $a$ has already been found. Iterating a
few more times:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; For(ii:=1,ii&lt;100,ii++)[{a,x}:={a,x}+\
      N(SolveMatrix(matrix(a,x),-f(a,x)));]
Out&gt; True;
In&gt; {a,x}
Out&gt; {2.,-0.042792753588155918852832259721};
In&gt; For(ii:=1,ii&lt;100,ii++)[{a,x}:={a,x}+\
         N(SolveMatrix(matrix(a,x),-f(a,x)));]
Out&gt; True;
In&gt; {a,x}
Out&gt; {2.,0.035119151349413516969586788023};
</pre></div>
</div>
<p>the value for $x$ converges a lot slower this time, and to the
uninteresting value of zero (a rather trivial zero of this set of
functions).  In fact for all integer values $N$ the value $N*Pi/2$ is
a solution.  Trying various initial values will find them.</p>
</div>
<div class="section" id="newton-iteration-on-polynomials">
<h3>Newton iteration on polynomials<a class="headerlink" href="#newton-iteration-on-polynomials" title="Permalink to this headline">¶</a></h3>
<p>von zur Gathen et al., &lt;i&gt;Modern Computer algebra&lt;/i&gt; discusses taking
the inverse of a polynomial using Newton iteration.  The task is,
given a polynomial $f(x)$, to find a polynomial $g(x)$ such that $f(x)
= 1/g(x)$, modulo some power in x.  This implies that we want to find
a polynom $g$ for which:</p>
<p>$$h(g) = 1/g-f = 0$$</p>
<p>Applying a Newton iteration step $g[i+1] = g[i] -
h(g[i])/(D(g)h(g[i]))$ to this expression yields:</p>
<p>$$g[i+1] = 2*g[i] - f*(g[i])^2$$</p>
<p>von zur Gathen then proves by induction that for $f(x)$ monic, and
thus $f(0)=1$, given initial value $g_0(x) = 1$, that</p>
<p>$$Mod(f*g_i=1,x^(2^i))$$</p>
<p>Example:</p>
<p>suppose we want to find the polynomial $g(x)$ up to the 7th degree
for which $Mod(f(x)*g(x) = 1,x^8)$, for the function</p>
<p>$$ f(x):=1+x+x^2/2+x^3/6+x^4/24 $$</p>
<p>First we define the function f:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; f:=1+x+x^2/2+x^3/6+x^4/24
Out&gt; x+x^2/2+x^3/6+x^4/24+1;
</pre></div>
</div>
<p>And initialize $g$ and $i$.:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; g:=1
Out&gt; 1;
In&gt; i:=0
Out&gt; 0;
</pre></div>
</div>
<p>Now we iterate, increasing $i$, and replacing $g$ with the
new value for $g$:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; [i++;g:=BigOh(2*g-f*g^2,x,2^i);]
Out&gt; 1-x;
In&gt; [i++;g:=BigOh(2*g-f*g^2,x,2^i);]
Out&gt; x^2/2-x^3/6-x+1;
In&gt; [i++;g:=BigOh(2*g-f*g^2,x,2^i);]
Out&gt; x^7/72-x^6/72+x^4/24-x^3/6+x^2/2-x+1;
</pre></div>
</div>
<p>The resulting expression must thus be:</p>
<p>$$g(x):=x^7/72-x^6/72+x^4/24-x^3/6+x^2/2-x+1$$</p>
<p>We can easily verify this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">In</span><span class="o">&gt;</span> <span class="n">Expand</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="n">Out</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">^</span><span class="mi">11</span><span class="o">/</span><span class="mi">1728</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">10</span><span class="o">/</span><span class="mi">576</span><span class="o">+</span><span class="n">x</span><span class="o">^</span><span class="mi">9</span><span class="o">/</span><span class="mi">216</span><span class="o">+</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">576</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>This expression is 1 modulo $x^8$, as can easily be shown:</p>
<div class="highlight-python"><div class="highlight"><pre>In&gt; BigOh(%,x,8)
Out&gt; 1;
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../yagy/index.html" class="btn btn-neutral float-right" title="YAGY">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sturm-sequences.html" class="btn btn-neutral" title="Finding real roots of polynomials"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Ayal Pinkus, Serge Winnitzky, Grzegorz Mazur.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.3.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>