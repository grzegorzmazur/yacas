
/* 
 * VerifySolve(e1, e2) tests whether 'e1' evaluates to something
 * "equal" to 'e2', and complains if it doesn't. 
 *
 * Here, "equal" means:
 *  o  for lists: having the same entries, possibly in a different
 *     order;
 *  o  for equations: having the same right-hand sides, possibly after
 *     'Simplify';
 *  o  in all other cases: literal equality, as tested by 'Equals'.
 * Hence, { a == 1, a == x+1 } is "equal" to { a == 1+x, a == 1 }.
 */

VerifySolve(_e1, _e2) <--
If (VerifySolve'Equal(Eval(e1), Eval(e2)), 
    True,
    [ 
      WriteString("******************");    NewLine();
      ShowLine();                           NewLine();
      Write(e1);                            NewLine();
      WriteString(" evaluates to ");        NewLine();
      Write(Eval(e1));                      NewLine();
      WriteString(" which differs from ");  NewLine();
      Write(e2);                            NewLine();
      WriteString("******************");    NewLine();
      False; 
    ]); 
HoldArgNr("VerifySolve", 2, 1);

10 # VerifySolve'Equal({}, {}) <-- True;

20 # VerifySolve'Equal({}, e2_IsList) <-- False;

30 # VerifySolve'Equal(e1_IsList, e2_IsList) <--
[
  Local(i, found);
  found := False;
  i := 0;
  While(i < Length(e2) And Not found) [
    i++;
    found := VerifySolve'Equal(Head(e1), e2[i]);
  ];
  If (found, VerifySolve'Equal(Tail(e1), Delete(e2, i)), False);
];

40 # VerifySolve'Equal(_l1 == _r1, _l2 == _r2) 
<-- Equals(l1,l2) And Simplify(r1-r2)=0;

50 # VerifySolve'Equal(_e1, _e2) <-- Equals(e1,e2);

/**********************************************************************/

Testing("Solve");

Verify(Solve(a+x*y==z,x),(z-a)/y);
Verify(Solve({a+x*y==z},{x}),{{(z-a)/y}});


VerifySolve(JNSolve(a+x*y == z, x), { x == (z-a)/y });

VerifySolve(JNSolve(x^2-3*x+2, x), { x == 1, x == 2 });

VerifySolve(JNSolve(2^n == 32, n), { n == Ln(32)/Ln(2) });  
            /* Of course, Ln(32)/Ln(2) = 5 */

VerifySolve(JNSolve(ArcTan(x^4) == Pi/4, x), 
            { x == 1, x == -1, x == I, x == -I });

VerifySolve(JNSolve(Exp(x)/(1-Exp(x)) == a, x), {x == Ln(a/(a+1))});
VerifySolve(JNSolve(Exp(x)/(1-Exp(x)) == a, a), {a == Exp(x)/(1-Exp(x))});

VerifySolve(JNSolve(x^5 == 1, x), 
            { x == 1, x == Exp(2/5*I*Pi), x == Exp(4/5*I*Pi), 
              x == Exp(-2/5*I*Pi), x == Exp(-4/5*I*Pi)});

VerifySolve(JNSolve(Sqrt(x) == 1, x),  { x == 1 });
VerifySolve(JNSolve(Sqrt(x) == -1, x), { });
VerifySolve(JNSolve(Sqrt(x) == I, x),  { x == -1 });
VerifySolve(JNSolve(Sqrt(x) == -I, x), { });
VerifySolve(JNSolve(Sqrt(x) == 0, x),  { x == 0 });


/* The following equations have in fact infinitely many solutions */

VerifySolve(JNSolve(Sin(x), x), { x == 0, x == Pi });

VerifySolve(JNSolve(x*Exp(x), x), { x == 0 });

VerifySolve(JNSolve(Cos(a)^2 == 1/2, a), 
            { a == Pi/4, a == 3/4*Pi, a == -3/4*Pi, a == -Pi/4 });

/* This goes into an infinite recursion:
 * VerifySolve(JNSolve(Sin(a*Pi)^2-Sin(a*Pi)/2 == 1/2, a), 
 *             { a == 1/2, a == 7/6 });
 */

Verify(IsError(), False);

/* This equation can be solved (the solution is x>0), but the current
 * code does not do this. The least we can expect is that no spurious
 * solutions are returned. */
VerifySolve(JNSolve(0^x == 0, x), {});
Verify(ClearError("JNSolve'Fails"), True);
Verify(IsError(), False);

/* This equation could be solved using the Lambert W function */
VerifySolve(JNSolve(x^x == 1, x), {});
Verify(ClearError("JNSolve'Fails"), True);
Verify(IsError(), False);

/* Another equation which cannot be solved at the moment */
VerifySolve(JNSolve(BesselJ(1,x), x), {});
Verify(ClearError("JNSolve'Fails"), True);
Verify(IsError(), False);

/* And another one */
VerifySolve(JNSolve(Exp(x)+Cos(x) == 3, x), {});
Verify(ClearError("JNSolve'Fails"), True);
Verify(IsError(), False);

/* This equation could be solved if we knew that x >= 0 */
VerifySolve(JNSolve(Sqrt(x) == a, x),  { });
Verify(ClearError("JNSolve'Fails"), True);
Verify(IsError(), False);

/* Test the type-checking mechanism */
VerifySolve(JNSolve(2*x == 1, 1), {});
Verify(ClearError("JNSolve'TypeError"), True);
Verify(IsError(), False);

/*TODO PSolve, MatrixSolve*/
