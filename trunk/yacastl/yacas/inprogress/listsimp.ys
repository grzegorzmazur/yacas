
/*
Example usage:

// Convert to internal format (a list)
	In> Flat(2*x^2*y*a*x^3*y^10*3)
	Out> {2,3,a,x^2,x^3,y^10,y};

// Simplify, using the Pat(x,y) set of transformation rules defined in
this file
	In> TrySimp(%,"Patt")
	Out> {y^11,x^5,a,6};

// Convert back to normal form
	In> UnFlat(%)
	Out> y^11*x^5*6*a;

*/

// simple comparison function, numbers, variables and variables raised to
a power.
10 # QCompare(x_IsAtom,y_IsAtom) <-- LessThan(x,y);
20 # QCompare(x_IsAtom,_y^_n) <-- LessThan(x,y);
20 # QCompare(_x^_n,y_IsAtom) <-- LessThan(x,y);
30 # QCompare(_x^_n,_y^_m) <-- LessThan(x,y);
40 # QCompare(_x,_y) <-- Check(False,"not supported");

// convert to internal representation, list in this case
Flat(expr) := BubbleSort(Flatten(expr,"*"),"QCompare");

// Bring back from internal representation to normal form
UnFlat(list) := UnFlatten(list,"*",1);

//Example simplification rules
10 # Patt(x_IsNumber,y_IsNumber) <-- x*y;
20 # Patt(_x,_x) <-- x^2;
30 # Patt(_x,_x^_n) <-- x^(n+1);
30 # Patt(_x^_n,_x) <-- x^(n+1);
40 # Patt(_x^_n,_x^_m) <-- x^(n+m);
50 # Patt(_x,_y) <-- x;

// TrySimp applies some set of transformation rules for adjacent
// terms on a list, returns the simplified list.
// This is the bit of code that is hopefully the same for all
// simplifications (eg. rewriting all simplifications to this scheme).
LocalSymbols(First,Second)
[
	First(list) := Head(list);
	Second(list) := Head(Tail(list));

	TrySimp(list,rules):=
	[
	  Local(result,new);
	  result := {};
	  While (Length(list)>1)
	  [
		new:=Apply(rules,{First(list),Second(list)});
		result:=(new:result);
		If (new!=First(list),list:=Tail(list));
		list:=Tail(list);
	  ];
          If(Length(list)=1,result:=Head(list):result);
	  result;
	];
];




/*
Next experiment: making an internal representation suited for polynomials:
  N1/D1 + N2/D2 + ... + Nn/Dn
  { { N1,D1 }, { N2,D2 } }
*/


/*
  Creating an internal representation
*/
PlAdd(_x,_y) <-- Concat(x,y);
PlMul(_x,_y) <--
[
  Local(result);
  result:={};
  ForEach(xitem,x)
  ForEach(yitem,y)
  [
    result :=
{Concat(xitem[1],yitem[1]),Concat(xitem[2],yitem[2])}:result;
  ];
  result;
];

10 # PlInput(_x+_y) <-- PlAdd(PlInput(x),PlInput(y));
10 # PlInput(_x-_y) <-- PlAdd(PlInput(x),-PlInput(y));
10 # PlInput(  -_y) <--                  -PlInput(y);
10 # PlInput(_x*_y) <-- PlMul(PlInput(x),PlInput(y));
20 # PlInput(_x) <--                  { { {x},{} } };

/* Converting from internal representation to normal form */
10 # PlOutput({}) <-- 0;
20 # PlOutput(s_IsList) <-- Factorize(Head(s)[1])/Factorize(Head(s)[2]) +
PlOutput(Tail(s));


/* simple simplifier */
SimpleSimp(expr):=
[
  Local(outres,numer,denom);
  expr:=PlInput(expr);
  outres:={};
  ForEach(item,expr)
  [
    numer:=TrySimp(BubbleSort(item[1],"QCompare"),"Patt");
    denom:=TrySimp(BubbleSort(item[2],"QCompare"),"Patt");
    outres:={numer,denom}:outres;
  ];
  PlOutput(outres);
];







