

GetTokenPosition() := tokenIndex;
SetTokenPosition(aPosition) := [ tokenIndex := aPosition;];

10 # GetCurrentToken()_(tokenIndex > Length(CodeTrans'input)) <-- EndOfFile;
20 # GetCurrentToken() <-- (CodeTrans'input[tokenIndex][1]);


10 # NextToken()_(tokenIndex > Length(CodeTrans'input)) <-- True;

20 # NextToken() <--
[
  tokenIndex++;
  While (tokenIndex <= Length(CodeTrans'input) And 
          (CodeTrans'input[tokenIndex][2] = Comments Or 
           CodeTrans'input[tokenIndex][2] = Spaces   Or
           CodeTrans'input[tokenIndex][2] = PreProcessorDirective
          )
        )
  [
    tokenIndex++;
  ];

//VerboseParse
//If(tokenIndex <= Length(CodeTrans'input),Echo(CodeTrans'input[tokenIndex][4]," : ",CodeTrans'input[tokenIndex][1]));

  True;
];


/** Matching a grammar, which is either:
 *  AcceptAtom : accepting any token
 *  "token"    : accept specific token
 *  list       : this is a list of potential matches to be matched with MatchStatement
 *  The result is either an integer (for atomic input), or a list with the matched
 *  expression.
 */



// Accept a specific token, written out as a string
10 # MatchGrammar(grammar_IsString)_(GetCurrentToken() = grammar) 
   <--
[
  Local(result);
  Set(result, GetTokenPosition());
  NextToken();
  result;
];

// Otherwise, don't accept the string
15 # MatchGrammar(grammar_IsString) <-- {};

// Accept a token of a specified type here.
10 # MatchGrammar(AcceptToken(_type))_(CodeTrans'input[tokenIndex][2] = type)
   <--
[
  Local(result);
  Set(result, GetTokenPosition());
  NextToken();
  result;
];
11 # MatchGrammar(AcceptToken(_type)) <-- {};


10 # MatchGrammar(AnyOf(list_IsList))_(Contains(list,CodeTrans'input[tokenIndex][1]))
   <--
[
  Local(result);
  Set(result, GetTokenPosition());
  NextToken();
  result;
];
11 # MatchGrammar(AnyOf(list_IsList)) <-- {};


20 # MatchGrammar(grammar_IsList)
   <-- 
[
  Local(lockposition,result);
  Set(result,{});
  Set(lockposition, GetTokenPosition());
  While (grammar != {})
  [
    Set(result, MatchStatement(Head(grammar)));
    If(result != {},
    [
      Set(grammar, {});
    ]
    ,
    [
      SetTokenPosition(lockposition);
      Set(grammar, Tail(grammar));
    ]);
  ];
  result;
];


Macro(DefineGrammar,{name,grammar})
[
  0 # MatchGrammar(@name) <-- MatchGrammar(@grammar);
];

30 # MatchGrammar(_grammar) 
   <-- 
      Check(False,ReportParseError(ToString()Echo("Undefined grammar ",grammar),tokenIndex));

10 # MatchStatement(stmt_IsList) 
   <--
[
  Local(applyOperation,current,result);
  Set(applyOperation, Head(stmt));
  Set(stmt, Tail(stmt));
  Set(result, {});
  While (current != {} And stmt != {})
  [
//Echo("Trying to match ",Head(stmt));
//Echo("First token to match to: ",GetInputTokens(tokenIndex));

//VerboseParse
//If(IsAtom(Head(stmt)),Echo("SUB ",Head(stmt)));

    Set(current, MatchGrammar(Head(stmt)));
//if (current = {})
//  Echo("FAILED to match ",Head(stmt))
//else
//  Echo("Accepted ",GetInputTokens(current));
    Set(stmt, Tail(stmt));
    DestructiveAppend(result,current);
  ];
  If(current = {},
  [
    Set(result, {});
  ],
  [
    DestructiveInsert(result,1,applyOperation);
//    Set(result, applyOperation:result);
  ]);
  result;
];

GenericParserNextExpression( grammar ):=
[
  Local(result);
  result := MatchGrammar(grammar);
  Check(result != {},
    [
        Local(token,rest);
        token := CodeTrans'input[tokenIndex];
        Set(rest,token[1]);
        if (Length(rest)>50)
        [
          rest:=StringMid(1,50,rest):"...";
        ];
        ToString()[Echo("UnRecognized CPP'expression in file ",TokenFile(tokenIndex)," at line ",TokenLine(tokenIndex),
        ":
",rest);];
    ]);

//Echo("Read ",GetInputTokens(result));
  result;
];


