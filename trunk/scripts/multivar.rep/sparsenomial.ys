
/* Implementation of MultiNomials based on sparse representation
   in the sparsetree.ys code. This is the real driver, using 
   the sparse trees just for representation.
API:
- CreateMonomial(vars,{coefs,fact}) 
  create a Multivariate polynomial with one monomial, in the
  variables defined in 'var', with the (key,value) pair
  (coefs,fact)

- MultiNomialAdd(multi1, multi2) 
  add two multivars, and destructively modify multi1 to contain
  the result: [multi1:=multi1+multi2;multi1;];
- MultiNomialMultiplyAdd(multi1, multi2,coefs,fact) 
  add two multivars, and destructively modify multi1 to contain
  the result. multi2 is considered multiplied by a monomial
  represented by the (key,value) pair (coefs,fact).
  [multi1:=multi1+term*multi2;multi1;];
- MultiNomialNegate(multi) 
  negate a multivar, returning -multi, and destructively changing
  the original.
  [multi:= -multi;multi1;];
- MultiNomialMultiply(multi1,multi2) 
  Multiply two multivars, and destructively modify multi1 to contain
  the result, returning the result: [multi1:=multi1*multi2;multi1;];
- NormalForm(multi)
  convert MultiNomial to normal form (as would be typed in be the user).
- MultiLeadingMonomial(multi) 
  return the (key,value) pair (coefs,fact) representing the leading
  monomial
- MultiDropLeadingZeroes(multi) 
  remove leading terms with zero factors.
- MultiTermLess(x,y)
  for two (key,value) pairs, return true if x<y, for the '<' used for
  the representation, and False otherwise.
- ScanMultiNomial(op,multi)
  traverse all the monomials of the multivariate, applying the
  function 'op' to each (key,value) pair (coefs,fact)
 */
Use("multivar.rep/sparsetree.ys");

LocalSymbols(NormalMultiNomial) [

CreateMonomial(_vars,{_coefs,_fact}) 
  <-- MultiNomial(vars,CreateSparseTree(coefs,fact));

/************************************************************

Adding and multiplying multivariate polynomials

************************************************************/
MultiNomialAdd(MultiNomial(_vars,_x), MultiNomial(_vars,_y)) 
    <-- MultiNomial(vars,AddSparseTrees(Length(vars),x,y));
MultiNomialMultiplyAdd(MultiNomial(_vars,_x), MultiNomial(_vars,_y),_coefs,_fact) 
    <-- MultiNomial(vars,MultiplyAddSparseTrees(Length(vars),x,y,coefs,fact));
MultiNomialNegate(MultiNomial(_vars,_terms)) 
    <-- 
    [
      SparseTreeMap(Hold({{coefs,list},-list}),Length(vars),terms);
      MultiNomial(vars,terms);   
    ];
MultiNomialMultiply(MultiNomial(_vars,_x),_multi2) 
    <--
    [
      Local(result);
      Set(result,MakeMultiNomial(0,vars));
      SparseTreeScan("muadm",Length(vars),x);
      result;
    ];
muadm(_coefs,_fact) <--
[
  Set(result,MultiNomialMultiplyAdd(result, multi2,coefs,fact));
];
UnFence("muadm",2);


/* NormalForm: done as an explicit loop in stead of using SparseTreeScan
   for speed. This routine is a lot faster!
 */
10 # NormalForm(x_IsMulti/y_IsMulti) <-- NormalForm(x)/NormalForm(y);
20 # NormalForm(MultiNomial(_vars,_list) ) 
    <-- NormalMultiNomial(vars,list,1);
10 # NormalMultiNomial({},_term,_prefact) <-- prefact*term;
20 # NormalMultiNomial(_vars,_list,_prefact) 
    <--
    [
      Local(first,rest,result);
      Set(first,Head(vars));
      Set(rest,Tail(vars));
      Set(result,0);
      ForEach(item,list)
      [
        Set(result,result+NormalMultiNomial(rest,item[2],prefact*first^(item[1])));
      ];
      result;
    ];

]; // LocalSymbols

MultiLeadingMonomial(MultiNomial(_vars,_terms)) 
    <--
    [
      Local(coefs,fact);
      Set(coefs,MultiDegreeScanHead(terms,Length(vars)));
      {coefs,fact};
    ];
10 # MultiDegreeScanHead(_tree,0)
   <--
   [
     Set(fact,tree);
     {};
   ];
10 # MultiDegreeScanHead(_tree,1)
   <--
   [
     Set(fact,tree[1][2]);
     {tree[1][1]};
   ];
20 # MultiDegreeScanHead(_tree,_depth)
   <--
   [ 
     (tree[1][1]):MultiDegreeScanHead(tree[1][2],depth-1);
   ];
UnFence("MultiDegreeScanHead",2);

ScanMultiNomial(_op,MultiNomial(vars_IsList,_terms))
    <-- SparseTreeScan(op,Length(vars),terms);
UnFence("ScanMultiNomial",2);


MultiDropLeadingZeroes(MultiNomial(_vars,_terms)) 
    <--
    [
      MultiDropScan(terms,Length(vars));
      MultiNomial(vars,terms);
    ];
10 # MultiDropScan(0,0) <-- True;
10 # MultiDropScan({_n,0},0) <-- True;
20 # MultiDropScan(_n,0)
   <--
   [
     False;
   ];
30 # MultiDropScan(_tree,_depth)
   <--
   [ 
     Local(i);
     For(i:=1,i<=Length(tree),i++)
     [
       if (MultiDropScan(tree[i][2],depth-1))
       [
         DestructiveDelete(tree,i);
         i--;
       ]
       else
       [
         i:=Length(tree);
       ];
     ];
     (tree = {});
   ];
UnFence("MultiDropScan",2);


MultiTermLess({_deg1,_fact1},{_deg2,_fact2}) <--
  [
    Local(deg);
    Set(deg, deg1-deg2);
    While(deg != {} And Head(deg) = 0) [ Set(deg, Tail(deg));];

    ((deg = {}) And (fact1-fact2 < 0)) Or
    ((deg != {}) And (deg[1] < 0));
  ];
