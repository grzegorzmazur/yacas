

Use("codecheck.rep/codetransform.ys");
Use("codecheck.rep/genericparser.ys");

/*
 * Parser part for reading Common Lisp CPP'expressions
 */

/*
 * Tokens the LISP tokenizer needs to understand.
 */
CPP'Tokens :=
{
  {"^[\\s]+",Spaces},
  {"^//.*?\\n",Comments},
  {"^#.*?(?!\\\\).\\n",PreProcessorDirective},
  {"^#(.*?\\\\\\n)*.*?(?!\\\\).\\n",PreProcessorDirective},
  {"^/\\*.*?\\*/",Comments},
  {"^[\\(\\)\\{\\}\\[\\]]",Brackets},
  {"^\\\".*?(?!\\\\).\\\"",Atoms}, // String, allowing for escapes
  {"^\\\"\\\"",Atoms}, // empty string
//  {"^\\\".*?\\\"",Atoms},
  {"^\\\'.*?\\\'",Atoms},
  {"^[0-9]*\\.[0-9]+",Atoms},
  {"^[0-9]+\\.",Atoms},
  {"^[0-9]+",Atoms},
  {"^\\<\\<\\=",Operators},
  {"^\\>\\>\\=",Operators},
  {"^\\+\\+",Operators},
  {"^\\-\\-",Operators},
  {"^\\-\\>",Operators},
  {"^\\<\\=",Operators},
  {"^\\|\\|",Operators},
  {"^\\|\\=",Operators},
  {"^\\^\\=",Operators},
  {"^\\>\\>",Operators},
  {"^\\>\\=",Operators},
  {"^\\=\\=",Operators},
  {"^\\<\\<",Operators},
  {"^\\/\\=",Operators},
  {"^\\-\\=",Operators},
  {"^\\+\\=",Operators},
  {"^\\*\\=",Operators},
  {"^\\&\\=",Operators},
  {"^\\&\\&",Operators},
  {"^\\%\\=",Operators},
  {"^\\!\\=",Operators},
  {"^[\\<\\=\\>\\^\\|\\*\\+\\-\\/\\&\\%\\~\\!]",Operators},
  {"^\\$.*?\\$",Patterns}, // $ is reserved for pattern definitions
  {"^[\\;\\:\\,\\.]",Delimiters},
  {"^[a-zA-Z_][a-zA-Z0-9_]*",Atoms},
  {"^.+",UnParsed}
};


CPP'grammar:=
  {
   {StrctType1,CPP'objDef,";"}
  ,{TypeDecl1,"typedef",CPP'typeDecl,CPP'annotatedVar,";"}
    ,{GlobalDefinedVariable,CPP'varDecl,";"}
  ,{GlobalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,CPP'statement}
   ,{GlobalDefinedFunction, CPP'annotatedVar,CPP'argList,CPP'statement}
//   ,{StrctType1,"union",CPP'symbolName,CPP'block,";"}
  };


CPP'varDecl:=
  {
    {Pattern1,"vardecl",AcceptToken(Patterns)}
   ,{VarDefInit, CPP'typeDecl,CPP'annotatedVar,"=",CPP'expression}
   ,{VarDefNonInit, CPP'typeDecl,CPP'annotatedVar}
  };

CPP'annotatedVar :=
  {
    {Pattern1,"varname",AcceptToken(Patterns)},
    {Pointer1,"*",CPP'annotatedVar}
   ,{Destructor1,"~",CPP'annotatedVar}
   ,{VarName, CPP'symbolName,CPP'arrayAugment}
   ,{SimpleAtom,CPP'tokenName}
  };

CPP'arrayAugment :=
  {
    {EmptyArray1,"[","]",CPP'arrayAugment}
   ,{Array1,"[",CPP'expression,"]",CPP'arrayAugment}
   ,{EmptyArray1}
  };

CPP'typeDecl:=
  {
    {Pattern1,"typenamed",AcceptToken(Patterns)}
    ,{Type1,CPP'plainType}
    ,{StrctType1,"struct",CPP'block}
    ,{StrctType1,"class",CPP'block}
//    ,{StrctType1,"union",CPP'block}
  };


CPP'plainType :=
  {
    {PlainType1,CPP'plainType2,CPP'plainType}
   ,{PlainType1,CPP'plainType2}
  };

CPP'plainType2 :=
  {
    {PlainType1,AnyOf(CPP'typeList)}
  };
CPP'typeList :=
  {"static","const","unsigned","char","short","int","long","float","void"};


CPP'symbolName := 
  { 
    {SymbolnamePointer,"*",CPP'symbolName},
    {SymbolnameNameSpaced,CPP'tokenName,"::",CPP'tokenName},
    {SimpleAtom,CPP'tokenName}
  };

// CPP'tokenName can be either a name of some symbol that will end up in the symbol
// table, or an expression with the $ sign that gets translated into a pattern to be recognized.
CPP'tokenName :=
  {
     {Pattern1,"tokenname",AcceptToken(Patterns)}
    ,{Token1,AcceptToken(Atoms)}
  };


CPP'argList := 
{
  {Pattern1,"arglist",AcceptToken(Patterns)}
  ,{NormalArgList1,"(",")"}
  ,{NormalArgList1,"(",CPP'restargs,")"}
  ,{SimpleAtom,CPP'tokenName}
};
//hier
CPP'restargs := 
{
   {Pattern1,"restargs",AcceptToken(Patterns)}
  ,{RestArgList1,CPP'varDecl,",",CPP'restargs}
  ,{RestArgList1,CPP'varDecl}
};

/*
Operators:
,	|= ^= &= >>= <<= -= += %= /= *= = ?: || && | ^ & != == >= > <= < >> << - + % / * (cast)x ! ~ - + * & --x ++x sizeof -> 
*/

CPP'expression := 
  {
     {Pattern1,"expression",AcceptToken(Patterns)}
     ,{Expression,CPP'expr0}
  };

CPP'expr0 := {{Expr1,CPP'expr1,CPP'exprRest0}}; 

CPP'exprRest0 := 
  {
    {Expr1,","  ,CPP'expr0},
    {Expr1}
  };
CPP'expr1 := {{Expr1,CPP'expr2,CPP'exprRest1}}; 
CPP'exprRest1 := 
  {
    {Expr1,AnyOf({"|=" ,"^=" ,"&=" ,">>=","<<=","-=" ,"+=" ,"%=" ,"/=" ,"*=" ,"="})   ,CPP'expr1},
    {Expr1}
  };

CPP'expr2:= {{Expr1,CPP'expr3,CPP'exprRest2}};
CPP'exprRest2:= 
  {
    {Expr1,"?",CPP'expression,":",CPP'expr2},
    {Expr1}
  };


CPP'expr3:= {{Expr1,CPP'expr4,CPP'exprRest3}};
CPP'exprRest3:= {{Expr1,"||",CPP'expr3},{Expr1}};

CPP'expr4:= {{Expr1,CPP'expr5,CPP'exprRest4}};
CPP'exprRest4:= {{Expr1,"&&",CPP'expr4},{Expr1}};

CPP'expr5:= {{Expr1,CPP'expr6,CPP'exprRest5}};
CPP'exprRest5:= {{Expr1,"|",CPP'expr5},{Expr1}};

CPP'expr6:= {{Expr1,CPP'expr7,CPP'exprRest6}};
CPP'exprRest6:= {{Expr1,"^",CPP'expr6},{Expr1}};

CPP'expr7:= {{Expr1,CPP'expr8,CPP'exprRest7}};
CPP'exprRest7:= {{Expr1,"&",CPP'expr7},{Expr1}};

CPP'expr8:= {{Expr1,CPP'expr9,CPP'exprRest8}};
CPP'exprRest8:= 
  {
    {Expr1,AnyOf({"!=","=="}),CPP'expr8},
    {Expr1}
  };

CPP'expr9:= {{Expr1,CPP'expr10,CPP'exprRest9}};
CPP'exprRest9:= 
  {
    {Expr1,AnyOf({">=",">","<=","<"}),CPP'expr9},
    {Expr1}
  };

CPP'expr10:= {{Expr1,CPP'expr11,CPP'exprRest10}};
CPP'exprRest10:= 
  {
    {Expr1,AnyOf({">>","<<"}),CPP'expr10},
    {Expr1}
  };

CPP'expr11:= {{Expr1,CPP'expr12,CPP'exprRest11}};
CPP'exprRest11:= 
  {
    {Expr1,AnyOf({"+","-"}),CPP'expr11},
    {Expr1}
  };



CPP'expr12:= {{Expr1,CPP'expr13,CPP'exprRest12}};
CPP'exprRest12:=
  {
    {Expr1,AnyOf({"*","/","%"}),CPP'expr12},
    {Expr1}
  };

CPP'expr13:= 
  {
    {Expr1,AnyOf({"sizeof","++","--","&","*","+","-","~","!"}),CPP'expr13},
    {Expr1,"(",CPP'typeDecl,")",CPP'expr14},
    {Expr1,CPP'expr14}
  };


CPP'expr14:= { {Expr1,CPP'expr15,CPP'exprRest14} };
CPP'exprRest14:= 
  {
    {Expr1,AnyOf({"++","--"})},
    {Expr1,"[","]",CPP'exprRest14},
    {Expr1,"[",CPP'expression,"]",CPP'exprRest14},
    {Expr1,"(",")",CPP'exprRest14},
    {Expr1,"(",CPP'expression,")",CPP'exprRest14},
    {Expr1,AnyOf({".","->"}),CPP'expression,CPP'exprRest14},
    {Expr1}
  };
CPP'expr15 := 
  { 
    {SubExpression,"(",CPP'expression,")"}
    ,{SimpleAtom,CPP'tokenName}
  };


CPP'block := 
  {
    {Pattern1,"block",AcceptToken(Patterns)}
    ,{BlockStatement,"{",CPP'restStmt}
    ,{EmptyStmt,";"}
  };

CPP'restStmt := 
  {
    {StmtClose,"}"},
    {Stmt,CPP'statement,CPP'restStmt}
  };
CPP'statement:=
  {
    {EmptyStmt,";"},
    {ReturnStmt,"return",optExpr},
    {BreakStmt,"break",";"},
    {ContinueStmt,"continue",";"},
    {DoWhile,"do",CPP'statement,"while","(",CPP'expression,")",";"},
    {IfElse,"if","(",CPP'expression,")",CPP'statement,"else",CPP'statement},
    {IfIf,"if","(",CPP'expression,")",CPP'statement},
    {SwitchStmt,"switch","(",CPP'expression,")",CPP'statement},
    {WhileStmt,"while","(",CPP'expression,")",CPP'statement},
    {ForStmt,"for","(",optExpr,optExpr,CPP'optClose,CPP'statement},
    {BreakStmt,"goto",CPP'tokenName,";"},
    {LabelStmt,CPP'tokenName,":"},
    {CaseStmt,"case",CPP'tokenName,":"},
    {DefaultStmt,"default",":"}
   ,{Expression,CPP'expr0,";"}
   ,{LocalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,CPP'statement}
   ,{LocalDefinedVariable,CPP'varDecl,";"}
   ,{LocalDefinedFunction, CPP'annotatedVar,CPP'argList,CPP'statement}
   ,{StrctType1,CPP'objDef,";"}
//   ,{StrctType1,"union",CPP'tokenName,CPP'block,";"}
   ,{BlockStmt,CPP'block}
  };

CPP'objDef :=
  {
    {StrctType1,"struct",CPP'tokenName,CPP'block}
   ,{StrctType1,"class",CPP'tokenName,CPP'block}
  };


optExpr := 
  {
    {EmptyOpt,";"},
    {ExprOpt,CPP'expression,";"}
  };

CPP'optClose :=
  {
    {EmptyOpt,")"},
    {ExprOpt,CPP'expression,")"}
  };

CPP'GetExpression() := CPP'GetExpression(CPP'grammar);

CPP'GetExpression(grammar) := 
[
  CPP'CleanParseTree(GenericParserNextExpression(grammar));
];



10  # CPP'CleanParseTreeOp({Expr1,_a,{Expr1}}) <-- a;
10  # CPP'CleanParseTreeOp({Expr1,_a}) <-- a;
10  # CPP'CleanParseTreeOp({PlainType1,_a}) <-- a;
10  # CPP'CleanParseTreeOp({VarName,_a,{EmptyArray1}}) <-- a;
IsType(op_IsString,_expression) <-- (Type(expression) = op);
10  # CPP'CleanParseTreeOp({Pattern1,_patternId}) <-- ReplacePatternMatcher(patternId);
10  # CPP'CleanParseTreeOp({Pattern1,_typeId,_patternId}) <-- ReplacePatternMatcher(patternId);
ReplacePatternMatcher(patternId):=
[
  Local(string);
  string:=GetInputTokens(patternId);
  string:=StringMid(2,Length(string)-2,string);
  string:=string:";";
  FromString(string)Read();
];
100 # CPP'CleanParseTreeOp(_rest) <-- rest;

LocalSymbols(xtree)
[
  CPP'CleanParseTree(xtree) := `WithApply("CPP'CleanParseTreeOp",@xtree);
];



