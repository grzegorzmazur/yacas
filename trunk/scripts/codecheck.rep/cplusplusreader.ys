
/* C++ grammar definition */

Use("codecheck.rep/codetransform.ys");
Use("codecheck.rep/genericparser.ys");

/*
* Parser part for reading Common Lisp CPP'expressions
*/

/*
* Tokens the LISP tokenizer needs to understand.
*/
CPP'Tokens :=
{
  {"^[\\s]+",Spaces},
  {"^//.*?\\n",Comments},
  {"^#.*?(?!\\\\).\\n",PreProcessorDirective},
  {"^#(.*?\\\\\\n)*.*?(?!\\\\).\\n",PreProcessorDirective},
  {"^/\\*.*?\\*/",Comments},
  {"^[\\(\\)\\{\\}\\[\\]]",Brackets},
  {"^\\\".*?(?!\\\\).\\\"",Atoms}, // String, allowing for escapes
  {"^\\\"\\\"",Atoms}, // empty string
//  {"^\\\".*?\\\"",Atoms},
  {"^\\\'.*?\\\'",Atoms},
  {"^[0-9]*\\.[0-9]+",Atoms},
  {"^[0-9]+\\.",Atoms},
  {"^[0-9]+",Atoms},
  {"^\\<\\<\\=",Operators},
  {"^\\>\\>\\=",Operators},
  {"^\\+\\+",Operators},
  {"^\\-\\-",Operators},
  {"^\\-\\>",Operators},
  {"^\\<\\=",Operators},
  {"^\\|\\|",Operators},
  {"^\\|\\=",Operators},
  {"^\\^\\=",Operators},
  {"^\\>\\>",Operators},
  {"^\\>\\=",Operators},
  {"^\\=\\=",Operators},
  {"^\\<\\<",Operators},
  {"^\\/\\=",Operators},
  {"^\\-\\=",Operators},
  {"^\\+\\=",Operators},
  {"^\\*\\=",Operators},
  {"^\\&\\=",Operators},
  {"^\\&\\&",Operators},
  {"^\\%\\=",Operators},
  {"^\\!\\=",Operators},
  {"^[\\<\\=\\>\\^\\|\\*\\+\\-\\/\\&\\%\\~\\!]",Operators},
  {"^\\$.*?\\$",Patterns}, // $ is reserved for pattern definitions
  {"^\\.\\.\\.",Operators},
  {"^\\:\\:",Operators},
  {"^[\\;\\:\\,\\.]",Delimiters},
  {"^[a-zA-Z_][a-zA-Z0-9_]*",Atoms},
  {"^.+",UnParsed}
};


DefineGrammar(CPP'grammar,
  {
    {Template1,"template","<",CPP'templateDeclList,">",CPP'grammar}
  ,{StrctType1,CPP'objDef,";"}
  ,{TypeDecl1,"typedef",CPP'typeDecl,CPP'annotatedVar,";"}
  ,{GlobalDefinedVariable,CPP'varDecl,";"}
  ,{GlobalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,CPP'statement}
  ,{GlobalDefinedFunction, CPP'storageClass,CPP'annotatedVar,CPP'argList,":",CPP'initList,CPP'statement}
  ,{GlobalDefinedFunction, CPP'storageClass,CPP'annotatedVar,CPP'argList,CPP'statement}
  });


DefineGrammar(CPP'templateDeclList,
  {
    {TempType1,CPP'templateTypeDecl,",",CPP'templateDeclList}
  ,{TempType1,CPP'templateTypeDecl}
  });
DefineGrammar(CPP'templateTypeDecl,
  {
    {Temp1,"class",CPP'tokenName}
  });


DefineGrammar(CPP'varDecl,
  {
    {Pattern1,"vardecl",AcceptToken(Patterns)}
  ,{VarDefInit, CPP'typeDecl,CPP'annotatedVar,"=",CPP'expression}
  ,{VarDefNonInit, CPP'typeDecl,CPP'annotatedVar}
  });


DefineGrammar(CPP'annotatedVar,
  {
    {Pattern1,"varname",AcceptToken(Patterns)},
    {Pointer1,"*",CPP'annotatedVar}
  ,{Reference1,"&",CPP'annotatedVar}
  ,{Destructor1,"~",CPP'annotatedVar}
  ,{Operator1,"operator","(",")"}
  ,{Operator1,"operator",CPP'annotatedVar}
  ,{Operator1,"operator",AcceptToken(Operators)}
  ,{VarName, CPP'symbolName,CPP'arrayAugment}
  ,{SimpleAtom,CPP'tokenName}
  });

DefineGrammar(CPP'arrayAugment,
  {
    {Pattern1,"array",AcceptToken(Patterns)},
    {EmptyArray1,"[","]",CPP'arrayAugment}
  ,{Array1,"[",CPP'expression,"]",CPP'arrayAugment}
  ,{EmptyArray1}
  });

DefineGrammar(CPP'typeDecl,
  {
    {Pattern1,"typenamed",AcceptToken(Patterns)}
    ,{Type1,CPP'storageClass,CPP'plainType,CPP'templateParams}
    ,{StrctType1,CPP'storageClass,"struct",CPP'block}
    ,{StrctType1,CPP'storageClass,"class",CPP'block}
    ,{EnumType1,CPP'storageClass,"enum",CPP'enumBlock}
//    ,{StrctType1,"union",CPP'block}
  });

DefineGrammar(CPP'enumBlock,
  {
    {Enum1,CPP'expression},
    {Enum1,CPP'enumElement,",",CPP'enumBlock},
    {Enum1,CPP'enumElement},
    {Enum1}
  });
DefineGrammar(CPP'enumElement,
  {
    {EnumConst1,CPP'tokenName,"=",CPP'expression},
    {EnumConst1,CPP'tokenName}
  });

DefineGrammar(CPP'templateParams,
  {
    {TemplateParams1,"<",CPP'templateTypeList,">"}
  ,{TemplateParams1}
  });

DefineGrammar(CPP'templateTypeList,
  {
    {TempType1,CPP'typeDecl,CPP'typePost,",",CPP'templateTypeList}
  ,{TempType1,CPP'typeDecl,CPP'typePost}
  });

DefineGrammar(CPP'typePost,
  {
    {TypeInst1,"*"}
  ,{TypeInst1}
  });

DefineGrammar(CPP'plainType,
  {
    {PlainType1,CPP'typeList,CPP'plainType2}
  ,{PlainType1,CPP'plainType3}
  });

DefineGrammar(CPP'plainType2,
  {
    {PlainType2,CPP'typeList,CPP'plainType2}
  ,{PlainType2}
  });
DefineGrammar(CPP'plainType3,
  {
    {PlainType3,CPP'tokenName}
  });

DefineGrammar(CPP'storageClass,
  {
    {StorageClass1,CPP'storageClassToken,CPP'storageClass}
  ,{StorageClass1}
  });

DefineGrammar(CPP'storageClassToken,
  {
    {StorageClassToken1,AnyOf({"extern","inline","virtual","static","register","auto","volatile","const"})}
  });
  

DefineGrammar(CPP'typeList,
  {
    {NativeType1,AnyOf({"signed","unsigned","char","short","int","long","float","double","void"})}
  });

DefineGrammar(CPP'symbolName,
  { 
    {Pattern1,"symbol",AcceptToken(Patterns)},
    {SymbolnamePointer,"*",CPP'symbolName},
    {SymbolnameNameSpaced,CPP'tokenName,"::","~",CPP'tokenName},
    {SymbolnameNameSpaced,CPP'tokenName,"::",CPP'tokenName},
    {SimpleAtom,CPP'tokenName}
  });



// CPP'tokenName can be either a name of some symbol that will end up in the symbol
// table, or an expression with the $ sign that gets translated into a pattern to be recognized.
DefineGrammar(CPP'tokenName,
  {
    {Pattern1,"tokenname",AcceptToken(Patterns)}
    ,{Token1,AcceptToken(Atoms)}
  });


DefineGrammar(CPP'argList,
{
  {Pattern1,"arglist",AcceptToken(Patterns)}
  ,{NormalArgList1,"(",")",CPP'accessModifier}
  ,{NormalArgList1,"(",CPP'restargs,")",CPP'accessModifier}
  ,{SimpleAtom,CPP'tokenName}
});

DefineGrammar(CPP'restargs,
{
  {Pattern1,"restargs",AcceptToken(Patterns)}
  ,{RestArgList1,"..."}
  ,{RestArgList1,CPP'varDecl,",",CPP'restargs}
  ,{RestArgList1,CPP'varDecl}
});

DefineGrammar(CPP'accessModifier,
  {
    {Access1,"const"}
  ,{Access1}
  });

/*
Operators:
,	|= ^= &= >>= <<= -= += %= /= *= = ?: || && | ^ & != == >= > <= < >> << - + % / * (cast)x ! ~ - + * & --x ++x sizeof -> 
*/

DefineGrammar(CPP'expression,
  {
    {Pattern1,"expression",AcceptToken(Patterns)}
    ,{Expression,CPP'expr0}
  });

DefineGrammar(CPP'expr0,{{Expr1,CPP'expr1,CPP'exprRest0}});

DefineGrammar(CPP'exprRest0,
  {
    {Expr1,","  ,CPP'expr0},
    {Expr1}
  });
DefineGrammar(CPP'expr1, {{Expr1,CPP'expr2,CPP'exprRest1}}); 
DefineGrammar(CPP'exprRest1,
  {
    {Expr1,AnyOf({"|=" ,"^=" ,"&=" ,">>=","<<=","-=" ,"+=" ,"%=" ,"/=" ,"*=" ,"="})   ,CPP'expr1},
    {Expr1}
  });

DefineGrammar(CPP'expr2, {{Expr1,CPP'expr3,CPP'exprRest2}});
DefineGrammar(CPP'exprRest2,
  {
    {Expr1,"?",CPP'expression,":",CPP'expr2},
    {Expr1}
  });


DefineGrammar(CPP'expr3, {{Expr1,CPP'expr4,CPP'exprRest3}});
DefineGrammar(CPP'exprRest3, {{Expr1,"||",CPP'expr3},{Expr1}});

DefineGrammar(CPP'expr4, {{Expr1,CPP'expr5,CPP'exprRest4}});
DefineGrammar(CPP'exprRest4, {{Expr1,"&&",CPP'expr4},{Expr1}});

DefineGrammar(CPP'expr5, {{Expr1,CPP'expr6,CPP'exprRest5}});
DefineGrammar(CPP'exprRest5, {{Expr1,"|",CPP'expr5},{Expr1}});

DefineGrammar(CPP'expr6, {{Expr1,CPP'expr7,CPP'exprRest6}});
DefineGrammar(CPP'exprRest6, {{Expr1,"^",CPP'expr6},{Expr1}});

DefineGrammar(CPP'expr7, {{Expr1,CPP'expr8,CPP'exprRest7}});
DefineGrammar(CPP'exprRest7, {{Expr1,"&",CPP'expr7},{Expr1}});

DefineGrammar(CPP'expr8, {{Expr1,CPP'expr9,CPP'exprRest8}});
DefineGrammar(CPP'exprRest8, 
  {
    {Expr1,AnyOf({"!=","=="}),CPP'expr8},
    {Expr1}
  });

DefineGrammar(CPP'expr9, {{Expr1,CPP'expr10,CPP'exprRest9}});
DefineGrammar(CPP'exprRest9, 
  {
    {Expr1,AnyOf({">=",">","<=","<"}),CPP'expr9},
    {Expr1}
  });

DefineGrammar(CPP'expr10, {{Expr1,CPP'expr11,CPP'exprRest10}});
DefineGrammar(CPP'exprRest10,
  {
    {Expr1,AnyOf({">>","<<"}),CPP'expr10},
    {Expr1}
  });

DefineGrammar(CPP'expr11, {{Expr1,CPP'expr12,CPP'exprRest11}});
DefineGrammar(CPP'exprRest11,
  {
    {Expr1,AnyOf({"+","-"}),CPP'expr11},
    {Expr1}
  });



DefineGrammar(CPP'expr12, {{Expr1,CPP'expr13,CPP'exprRest12}});
DefineGrammar(CPP'exprRest12,
  {
    {Expr1,AnyOf({"*","/","%"}),CPP'expr12},
    {Expr1}
  });

DefineGrammar(CPP'expr13,
  {
    {Expr1,AnyOf({"sizeof","++","--","&","*","+","-","~","!"}),CPP'expr13},
    {Expr1,"(",CPP'typeDecl,")",CPP'expr14},
    {Expr1,CPP'expr14}
  });


DefineGrammar(CPP'expr14, { {Expr1,CPP'expr15,CPP'exprRest14} });
DefineGrammar(CPP'exprRest14,
  {
    {Expr1,AnyOf({"++","--"})},
    {Expr1,"[","]",CPP'exprRest14},
    {Expr1,"[",CPP'expression,"]",CPP'exprRest14},
    {Expr1,"(",")",CPP'exprRest14},
    {Expr1,"(",CPP'expression,")",CPP'exprRest14},
    {Expr1,AnyOf({".","->"}),CPP'expression,CPP'exprRest14},
    {Expr1}
  });
DefineGrammar(CPP'expr15,
  { 
    {SubExpression,"(",CPP'expression,")"}
    ,{NameSpaced1,CPP'tokenName,"::",CPP'tokenName}
    ,{SimpleAtom,CPP'tokenName}
  });


DefineGrammar(CPP'block,
  {
    {Pattern1,"block",AcceptToken(Patterns)}
    ,{BlockStatement,"{",CPP'restStmt}
    ,{EmptyStmt,";"}
  });

DefineGrammar(CPP'restStmt,
  {
    {StmtClose,"}"},
    {Stmt,CPP'statement,CPP'restStmt}
  });
DefineGrammar(CPP'statement,
  {
    {EmptyStmt,";"},
    {ReturnStmt,"return",CPP'optExpr},
    {BreakStmt,"break",";"},
    {ContinueStmt,"continue",";"},
    {DoWhile,"do",CPP'statement,"while","(",CPP'expression,")",";"},
    {IfElse,"if","(",CPP'expression,")",CPP'statement,"else",CPP'statement},
    {IfIf,"if","(",CPP'expression,")",CPP'statement},
    {SwitchStmt,"switch","(",CPP'expression,")",CPP'statement},
    {WhileStmt,"while","(",CPP'expression,")",CPP'statement},
    {ForStmt,"for","(",CPP'optExpr,CPP'optExpr,CPP'optClose,CPP'statement},
    {BreakStmt,"goto",CPP'tokenName,";"},
    {LabelStmt,CPP'tokenName,":"},
    {CaseStmt,"case",CPP'tokenName,":"},
    {DefaultStmt,"default",":"}
  ,{LocalDefinedVariable,CPP'varDecl,";"}
  ,{LocalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,"=","0",";"}
  ,{LocalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,":",CPP'initList,CPP'statement}
  ,{LocalDefinedFunction, CPP'typeDecl,CPP'annotatedVar,CPP'argList,CPP'statement}
  ,{LocalDefinedFunction, CPP'storageClass,CPP'annotatedVar,CPP'argList,":",CPP'initList,CPP'statement}
  ,{LocalDefinedFunction, CPP'storageClass,CPP'annotatedVar,CPP'argList,CPP'statement}
  ,{StrctType1,CPP'objDef,";"}
  ,{Expression,CPP'expr0,";"}
//   ,{StrctType1,"union",CPP'tokenName,CPP'block,";"}
  ,{BlockStmt,CPP'block}
  });

DefineGrammar(CPP'initList,
  {
    {InitList1,CPP'init,",",CPP'initList}
  ,{InitList1,CPP'init}
  });

DefineGrammar(CPP'init,
  {
    {Init1,CPP'tokenName,"(",CPP'expression,")"} 
  });

DefineGrammar(CPP'objDef,
  {
    {StrctType1,"struct",CPP'tokenName,":",CPP'superList,CPP'block}
  ,{StrctType1,"struct",CPP'tokenName,CPP'block}
  ,{StrctType1,"class" ,CPP'tokenName,":",CPP'superList,CPP'block}
  ,{StrctType1,"class" ,CPP'tokenName,CPP'block}
  ,{EnumType1,"enum",CPP'tokenName,CPP'enumBlock}

  });

DefineGrammar(CPP'superList,
  {
    {Pattern1,"super",AcceptToken(Patterns)}
  ,{SuperList1,CPP'super,",",CPP'superList}
  ,{SuperList1,CPP'super}
  });

DefineGrammar(CPP'super,
  {
    {Super1,"public",CPP'tokenName,CPP'templateParams}
  ,{Super1,"protected",CPP'tokenName,CPP'templateParams}
  ,{Super1,"private",CPP'tokenName,CPP'templateParams}
  });

DefineGrammar(CPP'optExpr, 
  {
    {EmptyOpt,";"},
    {ExprOpt,CPP'expression,";"}
  });

DefineGrammar(CPP'optClose,
  {
    {EmptyOpt,")"},
    {ExprOpt,CPP'expression,")"}
  });

CPP'GetExpression() := CPP'GetExpression(CPP'grammar);

CPP'GetExpression(grammar) := 
[
  CPP'CleanParseTree(GenericParserNextExpression(grammar));
];



10  # CPP'CleanParseTreeOp({Expr1,_a,{Expr1}}) <-- a;
10  # CPP'CleanParseTreeOp({Expr1,_a}) <-- a;
10  # CPP'CleanParseTreeOp({PlainType1,_a}) <-- a;
10  # CPP'CleanParseTreeOp({VarName,_a,{EmptyArray1}}) <-- a;
IsType(op_IsString,_expression) <-- (Type(expression) = op);
10  # CPP'CleanParseTreeOp({Pattern1,_patternId}) <-- ReplacePatternMatcher(patternId);
10  # CPP'CleanParseTreeOp({Pattern1,_typeId,_patternId}) <-- ReplacePatternMatcher(patternId);
ReplacePatternMatcher(patternId):=
[
  Local(string);
  string:=GetInputTokens(patternId);
  string:=StringMid(2,Length(string)-2,string);
  string:=string:";";
  FromString(string)Read();
];
100 # CPP'CleanParseTreeOp(_rest) <-- rest;

LocalSymbols(xtree)
[
  CPP'CleanParseTree(xtree) := `WithApply("CPP'CleanParseTreeOp",@xtree);
];



