/* Tests on logic */

/* Small theorem prover for propositional logic, based on the
 * resolution principle.
 * Written by Ayal Pinkus
 * Version 0.1 initial implementation.
 *
 *
 * Examples:
CanProve(( (a=>b) And (b=>c)=>(a=>c) ))  <-- True
CanProve(a  Or   Not a)                  <-- True
CanProve(True  Or  a)                    <-- True
CanProve(False  Or  a)                   <-- a
CanProve(a  And   Not a)                 <-- False
CanProve(a  Or b Or (a And b))           <-- a Or b
 */

RuleBase("=>",{a,b});


/*
   Simplify a boolean expression. CNF is responsible
   for converting an expression to the following form:
        (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
   That is, a conjunction of disjunctions.
*/

// Trivial simplifications
10  # CNF( Not  True)                  <-- False;
11  # CNF( Not  False)                 <-- True;
12  # CNF(True   And  (_x))            <-- CNF(x);
13  # CNF(False  And  (_x))            <-- False;
14  # CNF(_x   And  True)              <-- CNF(x);
15  # CNF(_x  And  False)              <-- False;
16  # CNF(True   Or  (_x))             <-- True;
17  # CNF(False  Or  (_x))             <-- CNF(x);
18  # CNF((_x)  Or  True )             <-- True;
19  # CNF((_x)  Or  False)             <-- CNF(x);

// A bit more complext
21  # CNF(_x  Or  _x)                  <-- CNF(x);
22  # CNF(_x  And  _x)                 <-- CNF(x);
23  # CNF(_x  Or Not (_x))             <-- True;
14  # CNF(Not (_x)  Or _x)             <-- True;
25  # CNF(_x  And Not (_x))            <-- False;
26  # CNF(Not (_x)  And _x)            <-- False;

// Simplifications that deal with (in)equalities
25  # CNF(((_x) == (_y))   Or  ((_x) !== (_y)))   <-- True;
25  # CNF(((_x) !== (_y))  Or  ((_x) == (_y)))    <-- True;
26  # CNF(((_x) == (_y))   And ((_x) !== (_y)))   <-- False;
26  # CNF(((_x) !== (_y))  And ((_x) == (_y)))    <-- False;

27  # CNF(((_x) >= (_y))   And ((_x) < (_y)))     <-- False;
27  # CNF(((_x) < (_y))    And ((_x) >= (_y)))    <-- False;
28  # CNF(((_x) >= (_y))   Or  ((_x) < (_y)))     <-- True;
28  # CNF(((_x) < (_y))    Or  ((_x) >= (_y)))    <-- True;

// some things that are more complex
120  # CNF((_x)  Or  (_y))            <-- LogOr(x, y, CNF(x), CNF(y));
10 # LogOr(_x,_y,_x,_y)               <-- x Or y;
20 # LogOr(_x,_y,_u,_v)               <-- CNF(u Or v);

130  # CNF( Not  (_x))                <-- LogNot(x, CNF(x));
10 # LogNot(_x, _x)                   <-- Not (x);
20 # LogNot(_x, _y)                   <-- CNF(Not (y));

40 # CNF( Not ( Not  (_x)))           <-- CNF(x);                           // eliminate double negation
45 # CNF((_x)=>(_y))                  <-- CNF((Not x)  Or  y);              // eliminate implication

50 # CNF( Not ((_x)  And  (_y)))      <-- CNF((Not x) Or (Not y));          // De Morgan's law
60 # CNF( Not ((_x)  Or  (_y)))       <-- CNF(Not x) And CNF(Not y);        // De Morgan's law

/*
70 # CNF((_x) And ((_y)  Or  (_z)))   <-- CNF(x And y) Or CNF(x And z);
70 # CNF(((_x) Or (_y)) And (_z))     <-- CNF(x And z) Or CNF(y And z);

80 # CNF((_x)  Or  ((_y)  And  (_z))) <-- CNF(x Or y) And CNF(x Or z);
80 # CNF(((_x)  And  (_y)) Or (_z))   <-- CNF(x Or z) And CNF(y Or z);
*/

70 # CNF(((_x)  And  (_y))  Or  (_z)) <-- CNF(x Or z) And CNF(y Or z);      // Distributing Or over And
80 # CNF((_x)  Or  ((_y)  And  (_z))) <-- CNF(x Or y) And CNF(x Or z);

90 # CNF((_x)  And  (_y))             <-- CNF(x) And CNF(y);                // Transform subexpression

101 # CNF( (_x) < (_y) )              <-- Not Simplify(x >=  y);
102 # CNF( (_x) > (_y) )              <-- Simplify(x >   y);
103 # CNF( (_x) >= (_y) )             <-- Simplify(x >=  y);
104 # CNF( (_x) <= (_y) )             <-- Not Simplify(x >  y);
105 # CNF( (_x) == (_y) )             <-- Simplify(x ==  y);
106 # CNF( (_x) !== (_y) )            <-- Not Simplify(x == y);

111 # CNF( Not((_x) <  (_y)) )        <-- Simplify( x >= y );
113 # CNF( Not((_x) <= (_y)) )        <-- Simplify( x > y );
116 # CNF( Not((_x) !== (_y)) )       <-- Simplify( x == y );

/* Accept as fully simplified, fallthrough case */
200 # CNF(_x)                         <-- x;


// Some shortcuts to match prev interface
CanProveAux(_proposition)                           <-- LogicSimplify(proposition, 3);
10 # LogicSimplify(_proposition, _level)_(level<2)  <-- CNF(proposition);

20 # LogicSimplify(_proposition, _level) <--
[
  Local(cnf, list, clauses);
  Check(level > 1, "Wrong level");
  // First get the CNF version of the proposition
  cnf := CNF(proposition);

  If(level <= 1, cnf, [
    list    := Flatten(cnf, "And");
    clauses := {};
    ForEach(clause, list)
    [
      Local(newclause);
      /*newclause := BubbleSort(LogicRemoveTautologies(Flatten(clause,"Or")), LexLessThan);*/
      newclause := LogicRemoveTautologies(Flatten(clause, "Or"));
      If(newclause != {True}, DestructiveAppend(clauses, newclause));
    ];

    /*
        Note that we sort each of the clauses so that they look the same,
        i.e. if we have (A And B) And ( B And A), only the first one will
        persist.
    */
    clauses := RemoveDuplicates(clauses);
    If((level = 3) And (Length(clauses) != 0), [
        clauses := LogicCombine(clauses);
    ]);

    If(Length(clauses) = 0, True, [
        /* assemble the result back into a boolean expression */
        Local(result);
        result := True;
        ForEach(item,clauses)
        [
            result:= result And UnFlatten(item, "Or", False);
        ];

        result;
    ]);
  ]);
];

/* CanProve tries to prove that the negation of the negation of
   the proposition is true. Negating twice is just a trick to
   allow all the simplification rules a la De Morgan to operate
 */
/*CanProve(_proposition) <-- CanProveAux( Not CanProveAux( Not proposition));*/

CanProve(_proposition) <-- CanProveAux( proposition );

1 # SimpleNegate(Not (_x)) <-- x;
2 # SimpleNegate(_x)       <-- Not(x);

/* LogicRemoveTautologies scans a list representing e1 Or e2 Or ... to find
   if there are elements p and  Not p in the list. This signifies p Or Not p,
   which is always True. These pairs are removed. Another function that is used
   is RemoveDuplicates, which converts p Or p into p.
 */

/* this can be optimized to walk through the lists a bit more efficiently and also take
care of duplicates in one pass */
LogicRemoveTautologies(_e) <--
[
  Local(i, len, negationfound); len := Length(e);
  negationfound := False;

  For(i := 1, (i <= len) And (Not negationfound), i++)
  [
    Local(x, n, j);
    x := e[i];
    n := SimpleNegate(e[i]);      /* this is all we have to do because of
                                     the kind of expressions we can have coming in */

    For(j := i+1, (j <= len) And (Not negationfound), j++)
    [
        Local(y); y := e[j];

        If(Equals(y, n),
            [
/*                Echo({"Deleting from ", e, " i=", i, ", j=", j, Nl()}); */

                negationfound := True;
                Echo({"Removing clause ", i, Nl()});
            ],
        If(Equals(y, x),
            [
/*                Echo({"Deleting from ", e, " j=", j, Nl()});    */
                DestructiveDelete(e, j);
                len--;
            ])
        );
    ];
    Check(len = Length(e), "The length computation is incorrect");
  ];

  If(negationfound, {True}, e);            /* note that a list is returned */
];

/* find the number of the list that contains n in it, a pointer to a list of lists in passed */
LogicFindWith(_list,_n)<--
[
  Local(i);
  Local(result);
  result:= -1;
  For(i:=1,(result<0) And (i<=Length(list)),i++)
  [
    If( /*Length(list[i])>1 And */ Contains(list[i],n),result:=i);
  ];
  result;
];

/* LogicCombine is responsible for scanning a list of lists, which represent
   a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ... by scanning the lists
   for combinations x Or Y  And   Not x Or Z <-- Y Or Z . If Y Or Z is empty then this clause
   is false, and thus the entire proposition is false.
*/
LogicCombine(_list) <--
[
  Local(i, j);
  For(i:=1, i<=Length(list), i++)
  [
    Echo({"list[", i, "/", Length(list), "]: ", list[i], Nl()});
    Local(redo);
    redo := False;

    For(j:=1, Not(redo) And (j<=Length(list[i])),j++)
    [
    Local(tocombine, n);
    n := SimpleNegate(Not (list[i][j]));

    tocombine := LogicFindWith(list, n);  // this is the list we will combine the current one with
    If(tocombine > 0 And i<tocombine,
        [
        If(i>=tocombine,Echo({"WRONG!!!"}));

        DestructiveDelete(list[i],j);
        DestructiveDelete(list[tocombine],Find(list[tocombine],n));
        list[i]:= LogicRemoveTautologies(Concat(list[i],list[tocombine]));
        DestructiveDelete(list,tocombine);
        If(list[i] = {False}, list[i]:={});
        If(list[i] = {},
            [
            list:={{}};
            i:=Length(list)+1;
            ],
            i:=0);
        redo := True;
        ]
        );
    ];
  ];
  list;
];