/* Tests on logic */

/* Small theorem prover for propositional logic, based on the
 * resolution principle.
 * Written by Ayal Pinkus
 * Version 0.1 initial implementation.
 *
 *
 * Examples:
CanProve(( (a=>b) And (b=>c)=>(a=>c) ))  <-- True
CanProve(a  Or   Not a)                  <-- True
CanProve(True  Or  a)                    <-- True
CanProve(False  Or  a)                   <-- a
CanProve(a  And   Not a)                 <-- False
CanProve(a  Or b Or (a And b))           <-- a Or b
 */

RuleBase("=>",{a,b});


/*
   Simplify a boolean expression. LogicSimplify is responsible
   for converting an expression to the following form:
        (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
   That is, a conjunction of disjunctions.
*/

10  # LogicSimplify( Not  True)                  <-- False;
11  # LogicSimplify( Not  False)                 <-- True;
12  # LogicSimplify(True   And  (_x))            <-- LogicSimplify(x);
13  # LogicSimplify(False  And  (_x))            <-- False;
14  # LogicSimplify(_x   And  True)              <-- LogicSimplify(x);
15  # LogicSimplify(_x  And  False)              <-- False;
16  # LogicSimplify(True   Or  (_x))             <-- True;
17  # LogicSimplify(False  Or  (_x))             <-- LogicSimplify(x);
18  # LogicSimplify((_x)  Or  True )             <-- True;
19  # LogicSimplify((_x)  Or  False)             <-- LogicSimplify(x);

/*Still not fully sure about these, but...  */
21  # LogicSimplify(_x  Or  _x)                  <-- LogicSimplify(x);
22  # LogicSimplify(_x  And  _x)                 <-- LogicSimplify(x);
23  # LogicSimplify(_x  Or Not (_x))             <-- True;
14  # LogicSimplify(Not (_x)  Or _x)             <-- True;
25  # LogicSimplify(_x  And Not (_x))            <-- False;
26  # LogicSimplify(Not (_x)  And _x)            <-- False;


25  # LogicSimplify(((_x) == (_y))   Or  ((_x) !== (_y)))   <-- True;
25  # LogicSimplify(((_x) !== (_y))  Or  ((_x) == (_y)))    <-- True;
26  # LogicSimplify(((_x) == (_y))   And ((_x) !== (_y)))   <-- False;
26  # LogicSimplify(((_x) !== (_y))  And ((_x) == (_y)))    <-- False;

27  # LogicSimplify(((_x) >= (_y))   And ((_x) < (_y)))     <-- False;
27  # LogicSimplify(((_x) < (_y))    And ((_x) >= (_y)))    <-- False;
28  # LogicSimplify(((_x) >= (_y))   Or  ((_x) < (_y)))     <-- True;
28  # LogicSimplify(((_x) < (_y))    Or  ((_x) >= (_y)))    <-- True;


/*
31  # LogicSimplify((_x)  Or  (_y))_(x!= LogicSimplify(x) Or y!=LogicSimplify(y))               
                                              <--
  LogicSimplify(LogicSimplify(x) Or LogicSimplify(y));
*/

120  # LogicSimplify((_x)  Or  (_y)) <-- LogOr(x,y,LogicSimplify(x),LogicSimplify(y));
10 # LogOr(_x,_y,_x,_y) <-- x Or y;
20 # LogOr(_x,_y,_u,_v) <-- LogicSimplify(u Or v);



/*
35  # LogicSimplify( Not  (_x))_(x != LogicSimplify(x))
                                                <-- LogicSimplify(Not LogicSimplify(x));        
*/                                                

130  # LogicSimplify( Not  (_x))                <-- LogNot(x, LogicSimplify(x));
10 # LogNot(_x,_x) <-- Not (x);
20 # LogNot(_x,_y) <-- LogicSimplify(Not (y));


40 # LogicSimplify( Not ( Not  (_x)))           <-- LogicSimplify(x);                           /* eliminate double negation */
45 # LogicSimplify((_x)=>(_y))                  <-- LogicSimplify((Not x)  Or  y);              /* eliminate implication */

50 # LogicSimplify( Not ((_x)  And  (_y)))      <-- LogicSimplify((Not x) Or (Not y));                     /* De Morgan's law */
60 # LogicSimplify( Not ((_x)  Or  (_y)))       <-- LogicSimplify(Not x) And LogicSimplify(Not y);         /* De Morgan's law */

70 # LogicSimplify(((_x)  And  (_y))  Or  (_z)) <-- LogicSimplify(x Or z) And LogicSimplify(y Or z);       /* Distribution */
80 # LogicSimplify((_x)  Or  ((_y)  And  (_z))) <-- LogicSimplify(x Or y) And LogicSimplify(x Or z);       /* Distribution */

90 # LogicSimplify((_x)  And  (_y))             <-- LogicSimplify(x) And LogicSimplify(y);      /* Transform subexpression */

101 # LogicSimplify( (_x) < (_y) )              <-- Not Simplify(x >=  y);
102 # LogicSimplify( (_x) > (_y) )              <-- Simplify(x >   y);
103 # LogicSimplify( (_x) >= (_y) )             <-- Simplify(x >=  y);
104 # LogicSimplify( (_x) <= (_y) )             <-- Not Simplify(x >  y);
105 # LogicSimplify( (_x) == (_y) )             <-- Simplify(x ==  y);
106 # LogicSimplify( (_x) !== (_y) )            <-- Not Simplify(x == y);

111 # LogicSimplify( Not((_x) <  (_y)) )        <-- Simplify( x >= y );
/*112 # LogicSimplify( Not((_x) >  (_y)) )        <-- Simplify( x <= y );*/
113 # LogicSimplify( Not((_x) <= (_y)) )        <-- Simplify( x > y );
/*114 # LogicSimplify( Not((_x) >= (_y)) )        <-- Simplify( x < y );*/
/*115 # LogicSimplify( Not((_x) == (_y)) )        <-- Simplify( x !== y );*/
116 # LogicSimplify( Not((_x) !== (_y)) )       <-- Simplify( x == y );

/* Accept as fully simplified, fallthrough case */
200 # LogicSimplify(_x)                         <-- x;


/* Simplify the logic expression to see if it is true. */
CanProveAux(_proposition) <--
[
  Local(negated,list,clauses);
  /* First get the LogicSimplify version of the negation of the proposition */
  negated:=LogicSimplify(proposition);
  list:=Flatten(negated,"And");
  clauses:={};
  ForEach(clause,list)
  [
    Local(newclause);
    newclause:=LogicRemoveTautologies(RemoveDuplicates(Flatten(clause,"Or")));
    If(newclause != {}, DestructiveAppend(clauses,newclause));
  ];

  clauses:=RemoveDuplicates(clauses);
  clauses:=LogicCombine(clauses);

  Local(result);
  result:=True;
  ForEach(item,clauses)
  [
    result:= result And UnFlatten(item,"Or",False);
  ];

  result;
];

/* CanProve tries to prove that the negation of the negation of
   the proposition is true. Negating twice is just a trick to
   allow all the simplification rules a la De Morgan to operate
 */
CanProve(_proposition) <-- CanProveAux( Not CanProveAux( Not proposition));

1 # SimpleNegate(Not (_x)) <-- x;
2 # SimpleNegate(_x)       <-- Not(x);

/* LogicRemoveTautologies scans a list representing e1 Or e2 Or ... to find
   if there are elements p and  Not p in the list. This signifies p Or   Not
p,
   which is always True. These pairs are removed. Another function that is
used
   is RemoveDuplicates, which converts p Or p into p.
 */
LogicRemoveTautologies(_e) <--
[
  Local(i, len); len := Length(e);

  For(i := 1, i <= len, i++)
  [
    Local(x, n, j, negationfound);
    x := e[i];
    n := SimpleNegate(e[i]);      /* this is all we have to do because of
                                     the kind of expressions we can have coming in */
    negationfound := False;

    For(j := i+1, j <= len, j++)
    [
        Local(y); y := e[j];

        If(Equals(y, n),
            [
/*                Echo({"Deleting from ", e, " i=", i, ", j=", j, Nl()}); */

                DestructiveDelete(e, j);
                len--;

                negationfound := True;
            ],
        If(Equals(y, x),
            [
/*                Echo({"Deleting from ", e, " i=", Nl()}); */

                DestructiveDelete(e, j);
                len--;
            ])
        );
    ];

    If(negationfound,
    [
        DestructiveDelete(e, i);
        len--;
        i--;
    ]);
  ];

  Check(len = Length(e), "The length computation is incorrect");

  e;
];


LogicFindWith(_list,_n)<--
[
  Local(i);
  Local(result);
  result:= -1;
  For(i:=1,(result<0) And (i<=Length(list)),i++)
  [
    If( /*Length(list[i])>1 And */ Contains(list[i],n),result:=i);
  ];
  result;
];

/* LogicCombine is responsible for scanning a list of lists, which represent
   a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ... by scanning the lists
   for combinations x Or Y  And   Not x Or Z => Y Or Z . If Y Or Z is empty then this clause
   is false, and thus the entire proposition is false.
 */
LogicCombine(_list) <--
[
  Local(i,j);
  For(i:=1,i<=Length(list),i++)
  [
    Local(redo);
    redo:=False;
/*    if (Length(list[i]) > 1) */
    For(j:=1,Not(redo) And (j<=Length(list[i])),j++)
    [
      Local(tocombine,n);
      n:=LogicSimplify( Not (list[i][j]));

      tocombine:=LogicFindWith(list,n);
      If(tocombine > 0 And i<tocombine,
         [
           If(i>=tocombine,Echo({"WRONG!!!"}));

           DestructiveDelete(list[i],j);
           DestructiveDelete(list[tocombine],Find(list[tocombine],n));
           list[i]:=
             LogicRemoveTautologies(RemoveDuplicates(Concat(list[i],list[tocombine])));
           DestructiveDelete(list,tocombine);
           If(list[i] = {False},list[i]:={});
           If(list[i] = {},
              [
               list:={{}};
               i:=Length(list)+1;
              ],
              i:=0);
           redo:=True;
         ]
        );
    ];
  ];
  list;
];
