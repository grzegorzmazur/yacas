/*******************/
/* Complex numbers */
/*******************/

/* Edited by Norbert Nemec, Mar 22, 2003
   based on former works found in the yacas library */

/*
    The arithmetics follows the same rules as described in stdarith.ys
    with Complex numbers considered numeric values.

    A number of rules could be simplified if complex number were just merged
    in with standard arithmetics. Alternatively, one could use extensible
    predicates in stdarith that are then simply extended by complex numbers
    in this file.
*/


/*
This implementation of complex numbers is incompatible with the current official
Complex(r,i) form. One day, the representation of complex numbers may be
switched to this format. Until then I'll leave it commented out.
//
// II is the imaginary number Sqrt(-1), and remains that way.
// The difference is it isn't converted to the form Complex(x,y).
//

10 # II^n_IsNegativeInteger <-- (-II)^(-n);
20 # (II^_n)_(IsEven(n) = True) <-- (-1)^(n>>1);
20 # (II^_n)_(IsOdd(n)  = True) <--  II*(-1)^(n>>1);

Set(complexReduce,
Hold(
{
  Exp(x_IsComplexII) <- Exp(ReII(x))*(Cos(ImII(x))+II*Sin(ImII(x)))
}));


NN(_c) <--
[
  Local(result);
  c := (c /:: complexReduce);
  result := Coef(Expand(c,II),II,{0,1});
  result;
];
ReII(_c) <-- NN(c)[1];
ImII(_c) <-- NN(c)[2];
IsComplexII(_c) <-- (ImII(c) != 0);
*/

/* IsComplex for all constant complex values */
1 # IsComplex(x_IsRationalOrNumber) <-- True;
2 # IsComplex(Complex(_r,_i))       <-- True;
3 # IsComplex(_x)                   <-- False;

IsNotComplex(x) := Not(IsComplex(x));

/* to correct unnecessary and incorrect Complex values */
0 # Complex(_r,i_IsZero) <-- r;
10 # Complex(_r,_i)
    _(Not (IsRationalOrNumber(r) And IsRationalOrNumber(i)))
//    _(Not Check(IsRationalOrNumber(r) And IsRationalOrNumber(i),"Complex used on non-numeric arguments"))
    <-- r + I * i;


 50 # Complex(_r1,_i1) + Complex(_r2,_i2) <-- Complex(r1+r2,i1+i2);
 50 # Complex(_r,_i) + x_IsRationalOrNumber <-- Complex(r+x,i);
 50 # x_IsRationalOrNumber + Complex(_r,_i) <-- Complex(x+r,i);

 50 # - Complex(_r,_i) <-- Complex(-r,-i);

 50 # Complex(_r1,_i1) - Complex(_r2,_i2) <-- Complex(r1-r2,i1-i2);
 50 # Complex(_r,_i) - x_IsRationalOrNumber <-- Complex(r-x,i);
 50 # x_IsRationalOrNumber - Complex(_r,_i) <-- Complex(x-r,-i);


/* Multiplication */
 50 # Complex(_r1,_i1) * Complex(_r2,_i2) <-- Complex(r1*r2-i1*i2,r1*i2+r2*i1);
 50 # Complex(_r,_i) * y_IsRationalOrNumber <-- Complex(r*y,i*y);
 50 # y_IsRationalOrNumber * Complex(_r,_i) <-- Complex(y*r,y*i);
/* right now this is slower than above
110 # Complex(_r1,_i1) * Complex(_r2,_i2) <--
[	// the Karatsuba trick
	Local(A,B);
	A:=r1*r2;
	B:=i1*i2;
	Complex(A-B,(r1+i1)*(r2+i2)-A-B);
];
*/

 50 # Complex(_r1,_i1) / Complex(_r2,_i2) <-- Complex(r1*r2+i1*i2,r2*i1-r1*i2)/(r2^2+i2^2);
 50 # x_IsRationalOrNumber / Complex(_r,_i) <-- Complex(x*r,-x*i)/(r^2+i^2);
 50 # Complex(_r,_i) / y_IsRationalOrNumber <-- Complex(r/y,i/y);

// These could probably be combined with those in stdarith with proper predicates
100 # (_x + y_IsComplex) + z_IsComplex <-- x+(y+z);
100 # (_x - y_IsComplex) + z_IsComplex <-- x-(y-z);
100 # (_x + y_IsComplex) - z_IsComplex <-- x+(y-z);
100 # (_x - y_IsComplex) - z_IsComplex <-- x-(y+z);

100 # x_IsComplex * (y_IsComplex * _z) <-- (x * y) * z;

100 # (Complex(_r,_i) * _z) / (x_IsComplex * _y) <-- ((Complex(r,i)/x)*z)/y;
100 # (x_IsComplex * _z) / (Complex(_r,_i) * _y) <-- ((x/Complex(r,i))*z)/y;
100 # (Complex(_r,_i) * _z) / x_IsComplex <-- (Complex(r,i)/x)*y;
100 # (x_IsComplex * _z) / Complex(_r,_i) <-- (x/Complex(r,i))*y;
100 # Complex(_r,_i) / (x_IsComplex * _y) <-- (Complex(r,i)/x)/y;
100 # x_IsComplex / (Complex(_r,_i) * _y) <-- (x/Complex(r,i))/y;

100 # Complex(_r,_i) + x <-- x + Complex(r,i);
100 # Complex(_r,_i) - x <-- (-x) + Complex(r,i);
100 # (_x + Complex(_r,_i)) + _y <-- (x + y) + Complex(r,i);
100 # (_x - Complex(_r,_i)) + _y <-- (x + y) - Complex(r,i);
100 # (_x + Complex(_r,_i)) - _y <-- (x - y) + Complex(r,i);
100 # (_x - Complex(_r,_i)) - _y <-- (x - y) - Complex(r,i);
100 # _x * Complex(_r,_i) <-- Complex(r,i) * x;
100 # _x * (Complex(_r,_i) * _y) <-- Complex(r,i) * (x * y);



// Just some unsystematic stuff:
110 # (_x ^ Complex(_r,_i)) <-- Exp(Complex(r,i)*Ln(x));

110 # Sqrt(Complex(_r,_i)) <-- Exp(Ln(Complex(r,i))/2);
110 # (Complex(_r,_i) ^ x_IsRationalOrNumber)_(Not(IsInteger(x))) <-- Exp(x*Ln(Complex(r,i)));

// This is commented out because it used MathPower so (2*I)^(-10) became a floating-point number. Now everything is handled by binary algorithm below
//120 # Complex(0,_i) ^ n_IsInteger <-- {1,I,-1,-I}[1+Mod(n,4)] * i^n;

123 # Complex(_r, _i) ^ n_IsNegativeInteger <-- 1/Complex(r, i)^(-n);

124 # Complex(_r, _i) ^ 0 <-- 1;	// cannot have Complex(0,0) here

125 # Complex(_r, _i) ^ n_IsPositiveInteger <--
[
	// use binary method
	Local(result, x);
	x:=Complex(r,i);
	result:=1;
	While(n > 0)
	[
		if ((n&1) = 1)
		[
		  result := result*x;
		];
		x := x*x;
		n := n>>1;
	];
	result;
];


/*[	// this method is disabled b/c it suffers from severe roundoff errors
  Local(rr,ii,count,sign);
  rr:=r^n;
  ii:=0;
  For(count:=1,count<=n,count:=count+2) [
    sign:=If(IsZero(Mod(count-1,4)),1,-1);
    ii:=ii+sign*Bin(n,count)*i^count*r^(n-count);
    If(count<n,
      rr:=rr-sign*Bin(n,count+1)*i^(count+1)*r^(n-count-1));
  ];
  Complex(rr,ii);
];
*/

/*Real parts */
100 # Re(x_IsRationalOrNumber) <-- x;
100 # Re(Complex(_r,_i)) <-- r;
100 # Re(_x + _y) <-- Re(x) + Re(y);
100 # Re(_x - _y) <-- Re(x) - Re(y);
100 # Re( -x) <-- - Re(x);
100 # Re(_x * _y) <-- Re(x) * Re(y) - Im(x) * Im(y);
100 # Re(_x / _y) <-- (Re(x)+Re(y))/(Re(x)^2 + Im(y)^2);

/* Imaginary parts */
100 # Im(Complex(_r,_i)) <-- i;
100 # Im(x_IsRationalOrNumber) <-- 0;
100 # Im(_x + _y) <-- Im(x) + Im(y);
100 # Im(_x - _y) <-- Im(x) - Im(y);
100 # Im( -x) <-- - Im(x);
100 # Im(_x * _y) <-- Re(x) * Im(y) + Im(x) * Re(y);
100 # Im(_x / _y) <-- (Im(x)-Im(y))/(Re(x)^2 + Im(y)^2);

100 # Conjugate(Complex(_r,_i)) <-- Complex(r,-i);
100 # Conjugate(x_IsRationalOrNumber) <-- x;
100 # Conjugate(_x + _y) <-- Conjugate(x) + Conjugate(y);
100 # Conjugate(_x - _y) <-- Conjugate(x) - Conjugate(y);
100 # Conjugate(-x) <-- - Conjugate(x);
100 # Conjugate(_x * _y) <-- Conjugate(x)*Conjugate(y);
100 # Conjugate(_x / _y) <-- Conjugate(x)/Conjugate(y);

100 # Conjugate(Re(_x)) <-- Re(x);
100 # Conjugate(Im(_x)) <-- Im(x);
100 # Re(Conjugate(_x)) <-- Re(x);
100 # Im(Conjugate(_x)) <-- -Re(x);

100 # Re(Re(_x)) <-- Re(x);
100 # Re(Im(_x)) <-- Im(x);
100 # Im(Re(_x)) <-- 0;
100 # Im(Im(_x)) <-- 0;


Function("Magnitude",{x}) [
    Sqrt(Re(x)^2 + Im(x)^2);
];

10 # Arg(Complex(Cos(_x),Sin(_x))) <-- x;
10 # Arg(x_IsZero) <-- Undefined;
15 # Arg(x_IsPositiveReal) <-- 0;
15 # Arg(x_IsNegativeReal) <-- Pi;
20 # Arg(Complex(r_IsZero,i_IsConstant)) <-- Sign(i)*Pi/2;
30 # Arg(Complex(r_IsPositiveReal,i_IsConstant)) <-- ArcTan(i/r);
40 # Arg(Complex(r_IsNegativeReal,i_IsPositiveReal)) <-- Pi+ArcTan(i/r);
50 # Arg(Complex(r_IsNegativeReal,i_IsNegativeReal)) <-- ArcTan(i/r)-Pi;

// returns the n roots of unity
Function("RootsOfUnity",{n})[
    Check(IsPositiveInteger(n),"RootsOfUnity: argument must be a positive integer");
    MapSingle({{k},Exp(2*Pi*I*k/n)}, 1 .. n );
];



/* See the comment in stdarith.ys about arithmetics on Infinity */
/*
30  # Complex(_r,_i) / y_IsZero <-- Sign(r)*Infinity;

50  # Infinity + Complex(_r,_i) <-- Infinity;
50  # Infinity - Complex(_r,_i) <-- Infinity;
50  # (-Infinity) + Complex(_r,_i) <-- -Infinity;
50  # (-Infinity) - Complex(_r,_i) <-- -Infinity;
50  # (_a + Infinity) + Complex(_r,_i) <-- a+Infinity;
50  # (_a + Infinity) - Complex(_r,_i) <-- a+Infinity;
50  # (_a - Infinity) + Complex(_r,_i) <-- a-Infinity;
50  # (_a - Infinity) - Complex(_r,_i) <-- a-Infinity;
50  # Complex(_r,_i) * Infinity <-- Sign(r)*Infinity;
50  # Infinity / Complex(_r,_i) <-- Sign(r)*Infinity;
50  # Complex(_r,_i) / Infinity <-- 0;

50 # Infinity ^ (x_IsComplex) <-- Infinity;
50 # (x_IsComplex ^ Infinity)_(Magnitude(x) > 1) <-- Infinity;
50 # (x_IsComplex ^ Infinity)_(Magnitude(x) < -1) <-- -Infinity;
50 # (x_IsComplex ^ Infinity)_(Magnitude(x) > -1 And Magnitude(x) < 1) <-- 0;
55 # (x_IsComplex ^ Infinity)_(Abs(x) = 1) <-- Undefined;
55 # (x_IsComplex ^ -Infinity)_(Abs(x) = 1) <-- Undefined;
*/