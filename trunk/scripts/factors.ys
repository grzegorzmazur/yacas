
/* This module implements factorizing integers and polynomials */


/* This is Pollard's Rho method of factorizing, as described in
 * "Modern Computer Algebra". It is a rather fast algorithm for
 * factoring, but doesn't scale to polynomials regrettably.
 *
 * It acts 'by chance'. This is the Floyd cycle detection trick, where
 * you move x(i+1) = f(x(i)) and y(i+1) = f(f(y(i))), so the y goes twice
 * as fast as x, and for a certain i x(i) will be equal to y(i).
 *
 * "Modern Computer Algebra" reasons that if f(x) = (x^2+1) mod n for
 * the value n to be factored, then chances are good that gcd(x-y,n)
 * is a factor of n. The function x^2+1 is arbitrary, a higher order
 * polynomial could have been chosen also.
 *
 */

PollardRhoRandom(n_IsInteger) <-- MathFloor(Random()*n);

10 # PollardRhoFactorize(n_IsPrimePower) <-- {GetPrimeFactors(n)};
15 # PollardRhoFactorize(0) <-- {};
20 # PollardRhoFactorize(_n) <--
[
  Local(x,y,i,gcd);

  gcd:=n;
  While(gcd = n)
  [
    /* Pick a random value between 0 and n-1 */
    x:=PollardRhoRandom(n);

    /* Initialize loop */
    gcd:=1; y:=x; i:=0;

    /* loop until failure or success found */
    While(gcd = 1)
    [
      x:= Mod( ((x^2)+1), n);
      y:= Mod( ((y^2)+1)^2+1, n);
      i++;
      If(x-y = 0,
         gcd := 1,
         gcd:=Gcd(x-y,n)
         );
    ];
  ];
  /* Return result found */
  PollardCombineLists(PollardRhoFactorize(gcd),PollardRhoFactorize(Div(n,gcd)));
];

/* PollardCombineLists combines two assoc lists used for factoring.
   the first element in each item list is the factor, and the second
   the exponent. Thus, an assoc list of {{2,3},{3,5}} means 2^3*3^5.
*/

5 # PollardMerge(_list,{1,_n}) <-- True;
10 # PollardMerge(_list,_item)_(Assoc(item[1],list) = Empty) <--
  DestructiveInsert(list,1,item);

20 # PollardMerge(_list,_item) <--
[
  Local(assoc);
  assoc := Assoc(item[1],list);
  assoc[2]:=assoc[2]+item[2];
];

PollardCombineLists(_left,_right) <--
[
  ForEach(item,right)
  [
    PollardMerge(left,item);
  ];
  left;
];


/* TODO for Bk:
   - Handling special case (x-a)^n more efficiently
   - (x+2)^5*(x-1) goes wrong: last factorization is missed!
     results in (x+2)^4*(x^2+x-2)
   - calculations don't terminate if pp(poly) is not monic.
     we need the Knuth thing for handling non-monic polys,
     as low as possible (below the handling of rational coeffs).
   - (x+1)*(x-10) goes wrong (too low prime selected?) It returns
     x^2+2*x+1
   - (x+1/2)^3*(x-2)
   - possibility: factoring over several small primes. See which one
     is the biggest.
*/


10 # FindMod(_poly,_item,_p,_n)_(Degree(Gcd(poly,item)) > 0) <-- Expand(item);
11 # FindMod(_poly,_item,_p,_n) <-- FindModAux(poly,item,p,n);

11 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,item+n*p) = 0) <-- Expand(item+n*p);
12 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,item-n*p) = 0) <-- Expand(item-n*p);
20 # FindModAux(_poly,_item,_p,_n) <--
[
/* Echo({item,p,"n = ",n}); */
  FindModAux(poly,item,p,n+1);
];

MergeTerm(_f,_i) <-- MergeTerm(f,i,Assoc(i[1],f));
10 # MergeTerm(_f,_i,Empty) <-- DestructiveAppend(f,i);
20 # MergeTerm(_f,_i,list_IsList) <--
[
  list[2] := list[2] + i[2];
];

10 # MergeFactors(_f,_s) <--
[
  ForEach(i,s)
    MergeTerm(f,{Monic(i[1]),i[2]});
  f;
];

FactorUniVarSec(_poly) <--
[
  Local(checked);
  checked := Bk(poly);
  Local(pre);
/*
Echo(poly);
Echo(checked);
*/
  pre:=Div(poly,FW(checked));
  if (pre != 1)
  [
    checked := {pre,1}:checked;
  ];
  checked;
];


Bk(_poly) <--
[
  Local(p,checked,factored,result);

  // result will contain the final result returned to the user. 
  checked := {};
  result:= {};
  // Create a internal representation, to speed up processing
  poly := MakeUni(poly,VarList(poly));

  // Convert from polynomial containing rational coefficients
  // to one containing integer coefficients
  [
    Local(cf,t1,t2);
    cf := MapSingle("Denom",Abs(Coef(poly,(0 .. Degree(poly)))));
    cf := Select({{n},Not IsZero(n)},cf);

    While (Length(cf) > 1)
    [
      t1:=Head(cf);
      cf:=Tail(cf);
      t2:=Head(cf);
      cf:=Tail(cf);
      cf := Lcm(t1,t2):cf;
    ];
    poly := poly*(cf[1]);
  ];

  // Trivial factors
  if (poly[2] > 0)
  [
    poly := UniVariate(poly[1],0,poly[3]);
  ];

  // square-free factorization
  [
    Local(dv,dd);
    dd := Apply("D",{x,poly});
    dv:=Gcd(poly,dd);
    if (Degree(dv)>0)
    [
      dv := Monic(dv);
      poly := Monic(Div(poly,dv));
      MergeFactors(checked, Bk(dv));
    ];
  ];

  p:=Max(1+Abs(Coef(poly,(0 .. Degree(poly)))));
  if (p<5) [p := 5;];
  if (p > 100) [ p := 100; ];
  While (Not IsPrime(p)) p++;

/*
  [
    Local(pp,lc);
    pp := 1;
    lc := LeadingCoef(poly);
    
    While(Mod(lc*pp,p) != 1)
    [
//      Echo({pp});
      pp++;
    ];
    poly := poly*pp;
  ];
*/


  factored := Bk(poly,p);
  ForEach(item,factored)
  [
    MergeFactors(result,{{FindMod(poly,item[1],p,0),item[2]}});
  ];
  MergeFactors(checked,result);
  checked;
];
Bk(_poly,_prime) <--
[
  Local(coefs,result);
  if (Degree(poly)<2)
  [
    result := {{poly,1}};
  ]
  else
  [
    coefs := MakeUni(poly)[3];
    result := Berlekamp(coefs,prime);
    Local(i);
    For(i:=1,i<=Length(result),i++)
    [
      result[i] := {NormalForm(UniVariate(x,0,result[i])),1};
    ];
  ];
  result;
];



/* New factorization : split between integers and polynomials. */
10 # Factors(p_IsInteger) <-- PollardRhoFactorize(p);
20 # Factors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  FactorUniVarSec(p);


/*
20 # Factors(p_CanBeUni)_(Length(VarList(p)) > 1) <-- FactorFactors(p);

TryMod(_f,_g,_v) <--
[
  Local(result,item);
  result:=0;
  ForEach(item,v)
  [
    if (NormalForm(Mod(MakeUni(f,item),MakeUni(g,item))) = 0)
    [
      ForEach(i2,v)
      [
        Local(new);
        new :=NormalForm(Div(MakeUni(f,i2),MakeUni(g,i2)));
        if (CanBeUni(new)) (result:=new);
      ];
    ];
  ];
  result;
];

FactorFactors(_p) <--
[
  Local(vars,nr,result);
  vars := VarList(p);
  nr:=Length(vars);
  result:={};
  While(Not IsConstant(p))
  [
    Local(i,j,found);
    found:=False;
    For(i:=1,i<=nr,i++)
    [
      For(j:=i+1,j<=nr,j++)
      [
        Local(try,trymod);
        Local(count);
        try := vars[i]+vars[j];

        count:=0;
        trymod:=TryMod(p,try,vars);
        While (trymod != 0)
        [
Echo({p});
          found:=True;
          count++;
          p:=trymod;
          trymod:=TryMod(p,try,vars);
        ];
        if (count > 0) DestructiveAppend(result,{try,count});

        try := vars[i]-vars[j];
        count:=0;
        trymod:=TryMod(p,try,vars);
        While (trymod != 0)
        [
Echo({p});
          found:=True;
          count++;
          p:=trymod;
          trymod:=TryMod(p,try,vars);
        ];
        if (count > 0) DestructiveAppend(result,{try,count});
      ];
    ];
    if (found = False)
    [
      DestructiveAppend(result,{p,1});
      p := 1;
    ];
  ];
  if (p != 1) DestructiveAppend(result,{p,1});
  result;
];
*/

Factor(_p) <-- FW(Factors(p));

/* FW: pass FW the result of Factors, and it will show it in the
 * form of p0^n0*p1^n1*...
 */

10 # FWatom({_a,1}) <-- a;
20 # FWatom({_a,_n}) <-- UnList({Atom("^"),a, n});
5  # FW(_list)_(Length(list) = 0) <-- 1;
10 # FW(_list)_(Length(list) = 1) <-- FWatom(list[1]);
20 # FW(_list) <--
[
  Local(result);
  result:=FWatom(Head(list));
  ForEach(item,Tail(list))
  [
   result := UnList({ Atom("*"),result,FWatom(item)});
  ];
  result;
];

10 # Roots(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    If(Degree(uni) = 1,
      [
        root:= -Coef(uni,0)/Coef(uni,1);
        For(i:=0,i<item[2],i++)
          result:= root : result;
      ]
      );
  ];
  result;
];

10 # RootsWithMultiples(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    If(Degree(uni) = 1,
      [
        root:= -Coef(uni,0)/Coef(uni,1);
        For(i:=0,i<item[2],i++)
          result:= {root,item[2]} : result;
      ]
      );
  ];
  result;
];







