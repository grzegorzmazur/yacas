
/*
document:
- StubApiCStruct
- StubApiCShortIntegerConstant(_onearg)
*/

WriteYacasName(s) := 
[ WriteString("\""); 
  For(i:=1, i<=Length(s), i++) WriteString(If(s[i]="_","'",s[i]));
  WriteString("\"");
];
  
StubApiCStart(s_IsString) <--
[
  cconsts := "";
  cfuncs  := "";
  cadders := "";
  cremovers := "";
  cincludes:="";
  cremarks:="";
  prelog := "";
  postlog:="";
  pluginname := s:"Plugin";
  plugin'pretty'name := s;	// default name, may be overridden
  cstructs:={};
];

StubApiCPrelog(s_IsString) <-- [prelog := prelog:s;];
StubApiCPostlog(s_IsString) <-- [postlog := postlog:s;];

StubApiCStruct(name) := StubApiCStruct(name,"PlatFree");
StubApiCStruct(name,free):=
[
  cremarks:=cremarks:"
Declared struct {":name:"}
";
  cstructs[name]:=free;
];


StubApiCRemark(text):=
[
  cremarks:=cremarks:text:Nl();
];

StubApiCPrettyName(text) :=
[
	plugin'pretty'name := text;
];

// default purpose is empty, to allow plugins that don't have purpose
plugin'purpose := "";
StubApiCPluginPurpose(text) :=
[
	plugin'purpose := text;
];
// prepare a title for the documentation
StubMakeTitle() :=
[
"
		The ":plugin'pretty'name:" plugin

":plugin'purpose:"

";
];


StubApiCSetEnv(string):=
[
  cadders := cadders: "  ":string:"(aEnvironment);
  ";
];

StubApiCShortIntegerConstant(const,val) :=
[
  cremarks:=cremarks:"
Constant {":const:"} refers to the library name	{":val:"}
";
  cconsts:= cconsts:PatchString(
"  SetShortIntegerConstant(aEnvironment, <?WriteYacasName(const);?>, <?WriteString(val  );?>);
");
];

/* Use this one for defines */
StubApiCShortIntegerConstant(_onearg) <--
  StubApiCShortIntegerConstant(onearg,onearg);



StubApiCInclude(file):=
[
cincludes:=cincludes : "#include ":file:"
";
];

CArgsGet(args_IsList) <--
[
  Local(arg,i);
  i:=1;
  ForEach(arg,args)
  [
    CArgsGet(CArgType(arg),i,i);
    i++;
  ];
];

10 # CArgType(arg_IsList)<-- arg[1];
20 # CArgType(arg_IsString)<-- arg;

10 # CArgName(arg_IsList,_i)_(Length(arg)>1) <-- arg[2];
20 # CArgName(_arg,_i) <-- "arg":String(i);

20 # CArgsGet("int",_i,_argnr) <--
[
  WriteString(PatchString(
"  ShortIntegerArgument(<? WriteString(\"arg\":String(i)); ?>, <?Write(argnr);?> );
"));
];


20 # CArgsGet("double",_i,_argnr) <--
[
 WriteString(PatchString(
"  DoubleFloatArgument(<? WriteString(\"arg\":String(i)); ?>,<?Write(argnr);?>);
"));
];

20 # CArgsGet("input_string",_i,_argnr) <--
[
 WriteString(PatchString(
"  InpStringArgument(<? WriteString(\"arg\":String(i)); ?>,<?Write(argnr);?>);
"));
];

30 # CArgsGet(name_IsString,_i,_argnr)_(cstructs[name] != Empty) <--
[
 WriteString(PatchString(
"  VoidStructArgument(<?WriteString(name);?>,<? WriteString(\"arg\":String(i)); ?>,<?Write(argnr);?>,<?Write(name);?>);
"));
];




100 # CArgsGet(_a,_i,_argnr) <-- Check(False,"Argument type ":a:" not supported");

CCall(returntype,fname,args):=
[
 WriteString(fname);
 WriteString("(");
 Local(i);
 For (i:=1,i<=Length(args),i++)
     [
      If(i>1,WriteString(", "));
     WriteString("arg":String(i));
     ];
 WriteString(");");
];

10  # CReturnResult("void") <--
    WriteString("  InternalTrue(aEnvironment,aEnvironment.iStack.GetElement(aStackTop));");

10  # CReturnResult("int") <--
    WriteString("  ReturnShortInteger(aEnvironment,aEnvironment.iStack.GetElement(aStackTop),r);");
10  # CReturnResult("double") <--
    WriteString("  ReturnDoubleFloat(aEnvironment,aEnvironment.iStack.GetElement(aStackTop),r);");

20  # CReturnResult(name_IsString)_(cstructs[name] != Empty)<--

    WriteString("  ReturnVoidStruct(aEnvironment, aEnvironment.iStack.GetElement(aStackTop),":String(name):", r,":cstructs[name]:");");

100 # CReturnResult(_r) <-- Check(False,"Return type ":r:" not supported");


10  # CCallContain("void") <-- True;
10  # CCallContain("int") <-- WriteString("int r = ");
10  # CCallContain("double") <-- WriteString("double r = ");

20  # CCallContain(name_IsString)_(cstructs[name] != Empty)<--
      WriteString("void* r = ");
100 # CCallContain(_r) <-- Check(False,"Return type ":r:" not supported");



funcstring:=
"
static void base_<? WriteString(fname); ?>(LispEnvironment& aEnvironment, LispInt aStackTop)
{
  /* Obtain arguments passed in. */
<?
CArgsGet(args);
?>  

  /* Call the actual function. */
<?CCallContain(returntype);?> <?CCall(returntype,fname,args); ?>

/* Return result. */
<?
CReturnResult(returntype);
?>
}
";


cadderstring:=
"  aEnvironment.SetCommand(base_<? WriteString(fname); ?>, <? WriteYacasName(fname2); ?>,<?Write(Length(args));?>,YacasEvaluator::Function | YacasEvaluator::Fixed);
";

cremoverstring:=
"  aEnvironment.RemoveCoreCommand(<? WriteYacasName(fname2); ?>);
";


fileapi:=
"
/* This file was automatically generated with cstubgen.
*/
#include \"lisptype.h\"
#include \"lispenvironment.h\"
#include \"lispatom.h\"
#include \"standard.h\"
#include \"arggetter.h\"
#include \"lispplugin.h\"
#include \"platmath.h\"
#include \"stubs.h\"
#include \"genericstructs.h\"

<?
WriteString(prelog);
?>

<?
WriteString(cincludes);
?>
<?
WriteString(cfuncs);
?> 


class <? WriteString(pluginname); ?> : public LispPluginBase
{
public:
    virtual void Add(LispEnvironment& aEnvironment);
    virtual void Remove(LispEnvironment& aEnvironment);
};
void <? WriteString(pluginname); ?>::Add(LispEnvironment& aEnvironment)
{
<?
WriteString(cconsts);
?>
<?
WriteString(cadders);
?>}

void <? WriteString(pluginname); ?>::Remove(LispEnvironment& aEnvironment)
{
//printf(\"CLOSED DLL!!!\\n\");
<?
WriteString(cremovers);
?>}

extern \"C\" {
LispPluginBase* <?Echo(\"make_\":plfname);?>(void) 
{
    return NEW <? WriteString(pluginname); ?>;
}

}

<?
WriteString(postlog);
?>


";

StubApiCDocumentFunction(returntype,fname,fname2,args):=
[
  Local(arg, bare'args, dressed'args, i);
  /* create a documentation entry of the form

Function {func}({x,y}),
calls {double func(double x, double y)}

*/
  bare'args := "";
  dressed'args := "";
  i := 1;
  ForEach(arg, args)
  [
  	bare'args := bare'args : If(i=1, "", ",") : CArgName(arg, i);
	dressed'args := dressed'args : If(i=1, "", "}, {") : CArgType(arg) : "} {" : CArgName(arg, i);
	i++;
  ];
  dressed'args := "{" : dressed'args : "}";
  cremarks:=cremarks:
"
Function {" : fname2  : "}({" : bare'args : "}),
calls {" : CArgType(returntype) : " " : fname : "} (" : dressed'args : ")
";
];

StubApiCFunction(returntype,fname,args) :=
[
  Local(fname2);
  cfuncs:= cfuncs:PatchString(funcstring);
  fname2:=fname;
  cadders:=cadders:PatchString(cadderstring);
  cremovers:=cremovers:PatchString(cremoverstring);
  StubApiCDocumentFunction(returntype,fname,fname2,args);
];

StubApiCFunction(returntype,fname,fname2,args) :=
[
  cfuncs:= cfuncs:PatchString(funcstring);
  cadders:=cadders:PatchString(cadderstring);
  cremovers:=cremovers:PatchString(cremoverstring);
  StubApiCDocumentFunction(returntype,fname,fname2,args);
];


StubApiCFile(plfname,file):=
[
  ToFile(file:".cc")WriteString(PatchString(fileapi));
  ToFile(file:".man.txt")WriteString(ConcatStrings(StubMakeTitle(), cremarks));
];
