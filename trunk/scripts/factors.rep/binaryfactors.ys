
/* Implementation of binary factoring algorithm (see documentation).
   Ayal Pinkus
*/

LocalSymbols(Mkp,Mkpc,Mkn,Mkc,MkMod,Mkd,TryFact)[

// input roots, output poly
Mkp(roots):= Factorize(x-roots);

// Mkpc: input coefs, output poly
Mkpc(coefs,var):= NormalForm(UniVariate(var,0,coefs));

// Mkn: input roots, output roots modulo an integer
Mkn(list,n):= Mod(list,n);

// Mkc: returns list of coefficients of polynomial
// input poly, output coefficients
Mkc(poly,var):=
[
  Set(poly,MakeUni(poly,var));
  Concat(FillList(0,poly[2]),poly[3]);
];

10 # MkMod(_n,Infinity) <-- n;
20 # MkMod(_n,_m) <-- Mod(n,m);

// Division: input coefficients for polys, output coefs for quotient and remainder
Mkd(numer,denom,p):=
[
  Local(q,r,i,j,ln,ld,nq);

  Set(numer,MkMod(numer,p));
  Set(denom,MkMod(denom,p));

  DropEndZeroes(numer);
  DropEndZeroes(denom);

  Set(numer,Reverse(numer));
  Set(denom,Reverse(denom));
  Set(ln,Length(numer));
  Set(ld,Length(denom));
  Set(q,FillList(0,ln));
  Set(r,FillList(0,ln));

  Set(i,1);
  If(ld>0,
  [
    While(Length(numer)>=Length(denom))
    [
      Set(nq,numer[1]);
//      Set(nq,MkDiv(numer[1],denom[1],p));
      q[ln-(Length(numer)-ld)] := nq;
      For(j:=1,j<=Length(denom),j++)
      [
        numer[j] := MkMod(numer[j] - nq*denom[j],p);
      ];
      r[i] := MkMod(r[1] + numer[1],p);

      Set(numer, Tail(numer));
      i++;
    ];
  ]);
  For(j:=0,j<Length(numer),j++)
  [
    r[i+j] := MkMod(r[i+j] + numer[j+1],p);
  ];
  Set(q,Reverse(q));
  Set(r,Reverse(r));
  DropEndZeroes(q);
  DropEndZeroes(r);
  {q,r};
];

BinaryFactors(polynom):=
[
  Local(list,i,result,p,newlist,poly,nrroots,unrat,leadingcoef,lowestcoef,an,origdegree,anmul,andiv,var,gcd);
  Set(result,{});

  // Make list of coefficients
  Set(var,VarList(polynom));
  Check(Length(var)=1,"BinaryFactors: Only univariate polynomials supported");
  Set(var,var[1]);
  Set(poly,Mkc(polynom,var));

  [
    Set(gcd,Gcd(poly));
    If(poly[Length(poly)] < 0,Set(gcd, gcd * -1));
    Set(poly,poly/gcd);
  ];


  Set(unrat,Lcm(MapSingle("Denom",poly)));
  Set(poly,unrat*poly);

  Set(origdegree,Length(poly)-1);
  Set(an,poly[Length(poly)]);
  Set(poly,poly* (an^((origdegree-1) .. -1)));
  Set(polynom,Mkpc(poly,var));
  Set(andiv,an^(origdegree-1));
  Set(anmul,1);
  
  Set(leadingcoef,poly[Length(poly)]);
  [ 
    Local(i);
    Set(i,1);
    Set(lowestcoef,Abs(poly[i]));
    While (lowestcoef = 0 And i<=Length(poly))
    [
      Set(i,i+1);
      Set(lowestcoef,Abs(poly[i]));
    ];
  ];
  // testpoly is the square-free version of the polynomial, used for finding
  // the factors. the original polynomials is kept around to find the
  // multiplicity of the factor.
  Set(testpoly,Mkc(Div(polynom,Monic(Gcd(polynom,Deriv(var)polynom))),var));

  // resulting factors will be stored here
  Set(list,{});

  // Start off with the seeds for factoring
  If(IsZeroVector(Mkd(testpoly,{0,1},2)[2]),Set(list,{0,1}:list));
  If(IsZeroVector(Mkd(testpoly,{1,1},2)[2]),Set(list,{1,1}:list));
  If(IsZeroVector(Mkd(testpoly,{1,0},2)[2]),Set(list,{1,0}:list));
  If(IsZeroVector(Mkd(testpoly,{0,0},2)[2]),Set(list,{0,0}:list));

  Set(p,2);
  Set(nrroots,Length(poly)-1);

  While(nrroots>0 And Length(list)>0)
  [
    Local(pp);
    Set(pp,(2*p));

    // check if any of the factors already divides the original polynomial
    For(i:=1,i<=Length(list),i++)
    [
      Local(lst1);

      TryFact({-p+list[i][1],list[i][2]});
      TryFact({list[i][1],list[i][2]});
    ];

    // Given the partial solutions so far (potential roots modulo p), determine
    // new roots up to modulo 2*p. This step essentially adds one binary bit
    // to the potential solutions and checks if they are still a solution.
    Set(newlist,{});
    For(i:=1,i<=Length(list),i++)
    [
      If(Not(list[i] = {1,0} And p>leadingcoef),
      [
        If(p<=lowestcoef And IsZeroVector(Mkd(testpoly,{(list[i][1]+p),list[i][2]},pp)[2]),
	  		  Set(newlist,{(list[i][1]+p),list[i][2]}:newlist));
        If(IsZeroVector(Mkd(testpoly,{(list[i][1]),list[i][2]},pp)[2]),
			    Set(newlist,{(list[i][1]),list[i][2]}:newlist));
      ]);
    ];

    Set(newlist,RemoveDuplicates(newlist));

    // We now have a new set of potential roots, modulo 2*p
    Set(list,newlist);

    Set(p,2*p);

//Echo("Solutions modulo ",p," with ",Length(list),"potential solutions",list);
  ];

  // If the polynom is not one, it is a polynomial which is not reducible any further
  // with this algorithm, return as is.
  Set(poly,poly*an^(0 .. (Length(poly)-1)));
  Set(poly,gcd*anmul*poly/(unrat * andiv ));
  If(poly != {1},Set(result,{Mkpc(poly,var),1}:result));

  result;
];


/* TryFact is an utility macro used in SimpleFactors. For a polynomial
'poly'
   for which the square-free part is 'testpoly', it determines if the
'root'
   passed in is a root. If so, it is added to the list of results, and the
   macro determines the multiplicity based on 'poly'. The factor (x-root)
is
   then divided out of the polynomials.
 */
Macro(TryFact,{root})
[
  If((@root)[2] != 0,
  [
    Set(lst1,Mkd(testpoly,(@root),Infinity));
    If(IsZeroVector(lst1[2]),
      [
        Set(testpoly,lst1[1]);
        Set(lst1,Mkd(poly,(@root),Infinity));
        Local(count);
        Set(count,0);
        While(IsZeroVector(lst1[2]))
        [
          count++;
          Set(poly,lst1[1]);
          Set(lst1,Mkd(poly,(@root),Infinity));
          nrroots--;
        ];
        Local(lgcd,lc);
        Set(lgcd,Gcd({andiv,an*(@root)[2],(@root)[1]}));
        Set(lc,Div(an*(@root)[2],lgcd));
        Set(result,{var+Div((@root)[1],lgcd)/lc,count}:result);
        Set(andiv,Div(andiv,lgcd^count));
        Set(anmul,anmul*lc^count);
      ]
    );
  ]);
];

];

/*
// Addition: input coefficients for polys, output coefs 
Mkadd(x,y):=
[
  Local(result,i);
  Set(result,FillList(0,Max(Length(x),Length(y))));
  For(i:=1,i<=Length(x),i++) result[i]:=result[i]+x[i];  
  For(i:=1,i<=Length(y),i++) result[i]:=result[i]+y[i];  
  DropEndZeroes(result);
  result;
];

Mkmonic(poly):=
[
  Local(lc);
  lc:=poly[Length(poly)];
  poly*(lc^((Length(poly)-2) .. -1));
];

// Multiplication: input coefficients for polys, output coefs 
Mkmul(x,y):=
[
  Local(result,i,j);
  Set(result,FillList(0,Length(x)+Length(y)));
  For(i:=1,i<=Length(x),i++) 
  [
    For(j:=1,j<=Length(y),j++) 
      result[i+j-1]:=result[i+j-1]+x[i]*y[j];  
  ];
  DropEndZeroes(result);
  result;
];

10 # MkDiv(_n,_m,Infinity) <-- Div(n,m);
20 # MkDiv(_n,_m,_p) <-- MkMod(n*m^(p-2),p);

// Greatest common divisor modulo p
// input coefficients to polys n,m, and integer p
// output greatest common divisor
10 # MkGcd(_n,_m,_p)_(Length(n)<Length(m)) <-- MkGcd(m,n,p);
20 # MkGcd(_n,m_IsZeroVector,_p) <-- n;
30 # MkGcd(_n,_m,_p) <--
[
  Local(q,r);
  {q,r} := Mkd(n,m,p);

  [
    Local(u,i);
    Set(u,1);
    For(i:=1,i<p,i++)
      If(Mod(i*r[Length(r)],p) = 1,Set(u,i));
    Set(r,Mod(r*u,p));
  ];

//  Echo("(n,m) = ",n,m,"(q,r) = ",q,r);
  If(Length(r)>=Length(m),{1},MkGcd(m,r,p));
];


10 # MkExtEuclid(_n,_m,_p)_(Length(n) < Length(m))
   <--
   [
     Local(res);
     Set(res,MkExtEuclid(m,n,p));
     {res[2],res[1],res[3]};
   ];
20 # MkExtEuclid(_n,_m,_p)
   <-- MkExtEuclidAux(p,{{1},{},n},{{},{1},m},{0,0,0});
10 # MkExtEuclidAux(_p,_u,_v,_t)_IsZeroVector(v[3])
   <-- u;
20 # MkExtEuclidAux(_p,_u,_v,_t) <--
[
  Local(q,r);
  {q,r} := Mkd(u[3],v[3],p);

  [
    Local(uu,i);
    Set(uu,1);
    For(i:=1,i<p,i++)
      If(Mod(i*r[Length(r)],p) = 1,Set(uu,i));
    Set(r,Mod(r*uu,p));
  ];


  Set(t,{
       Mod(Mkc(Mkpc(u[1],x)-Mkpc(v[1],x)*Mkpc(q,x),x),p),
       Mod(Mkc(Mkpc(u[2],x)-Mkpc(v[2],x)*Mkpc(q,x),x),p),
       Mod(Mkc(Mkpc(u[3],x)-Mkpc(v[3],x)*Mkpc(q,x),x),p)
     });
   Set(u,v);
   Set(v,t);
//  Echo("(n,m) = ",n,m,"(q,r) = ",q,r);
  If(Length(v[3])>=Length(u[3]),u,MkExtEuclidAux(p,u,v,t));
];

*/

