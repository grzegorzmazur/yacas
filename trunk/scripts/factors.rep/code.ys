
/* This module implements factorizing integers and polynomials */

/// Middle level function: returns a list of prime factors and their powers.
/// E.g. FactorizeInt(50) returns {{2, 1}, {5, 2}}.
1# FactorizeInt(0) <-- {};
1# FactorizeInt(1) <-- {};

/// Call TrialFactorize() for small numbers and PollardRhoFactorize() for large numbers.
2# FactorizeInt(n_IsInteger)_(Abs(n)<100000) <-- TrialFactorize(Abs(n));
3# FactorizeInt(n_IsInteger) <--
[
  Local(small'powers);
  // first, find powers of 2, 3, ..., p with p=200 currently -- this speeds up PollardRho and sometimes avoids its worst-case performance
  small'powers := TrialFactorize(Abs(n), 200);	// value is {n1, {p1,q1}, {p2,q2}, ...} and n1=1 if completely factorized into these factors, and the remainder otherwise
  n := small'powers[1];	// remainder
  If(n=1, Tail(small'powers),
  // if n!=1, need to factorize the remainder; but first check that it is not a prime power
	If(IsPrimePower(n), PollardCombineLists(Tail(small'powers), {GetPrimeFactors(n)}),
  // otherwise proceed with Pollard Rho algorithm
	  PollardCombineLists(Tail(small'powers), PollardRhoFactorize(n))
	)
  );
];

/// Simple trial factorization: can be very slow for integers > 1,000,000.
// Try all prime factors up to Sqrt(n)
2# TrialFactorize(n_IsPrimePower) <-- {GetPrimeFactors(n)};
3# TrialFactorize(n_IsInteger) <--
[
	Local(factorization);
	factorization := TrialFactorize(n, n);	// TrialFactorize will limit to Sqrt(n) automatically
	If(
		Head(factorization) = 1,	// all factors were smaller than Sqrt(n)
		Tail(factorization),
		// the first element needs to be replaced
		Concat(Tail(factorization), {{Head(factorization),1}})
	);
];

/// Auxiliary function. Return the power of a given prime contained in a given integer and remaining integer.
/// E.g. FindPrimeFactor(42, 3) returns {14, 1} and FindPrimeFactor(42,17) returns {42, 0}
FindPrimeFactor(n, prime) :=
[
	Local(power);
	power := 0;
	While(Mod(n, prime)=0)
	[
		n := Div(n, prime);
		power++;
	];
	{n, power};
];

/// Auxiliary function. Factorizes by trials. Return prime factors up to given limit and the remaining number.
/// E.g. TrialFactorize(42, 2) returns {21, {{2, 1}}} and TrialFactorize(37, 4) returns {37}
TrialFactorize(n, limit) :=
[
	Local(power, prime, result);
	result := {n};	// first element of result will be replaced by the final value of n
	prime := 2;	// first prime
	While(prime <= limit And n>1 And prime*prime <= n)
	[	// find the max power of prime which divides n
		{n, power} := FindPrimeFactor(n, prime);
		If(
			power>0,
			DestructiveAppend(result, {prime,power})
		);
		prime := NextPrime(prime);
	];
	// replace the first element which was n by the new n
	DestructiveReplace(result, 1, n);
];

/* This is Pollard's Rho method of factorizing, as described in
 * "Modern Computer Algebra". It is a rather fast algorithm for
 * factoring, but doesn't scale to polynomials regrettably.
 *
 * It acts 'by chance'. This is the Floyd cycle detection trick, where
 * you move x(i+1) = f(x(i)) and y(i+1) = f(f(y(i))), so the y goes twice
 * as fast as x, and for a certain i x(i) will be equal to y(i).
 *
 * "Modern Computer Algebra" reasons that if f(x) = (x^2+1) mod n for
 * the value n to be factored, then chances are good that gcd(x-y,n)
 * is a factor of n. The function x^2+1 is arbitrary, a higher order
 * polynomial could have been chosen also.
 *
 */

/*
Warning: The Pollard Rho algorithm cannot factor some numbers, e.g. 703, and
can enter an infinite loop. This currently results in an error message: "failed to factorize".
Hopefully the TrialFactorize() step will avoid these situations by excluding
small prime factors.
This problem could also be circumvented by trying a different random initial value for x when a loop is encountered -- hopefully another initial value will not get into a loop. (currently this is not implemented)
*/

RandomInteger(n) := MathFloor(Random()*n);
/// Polynomial for the Pollard Rho iteration
PollardRhoPolynomial(_x) <-- x^2+1;

2# PollardRhoFactorize(n_IsPrimePower) <-- {GetPrimeFactors(n)};
3# PollardRhoFactorize(_n) <--
[
  Local(x,y,i,gcd,repeat);
  gcd:=n;
  While(gcd = n)
  [
    /* Pick a random value between 0 and n-1 */
    x:= 1;//RandomInteger(n);	// will start with 2 on first iteration

    /* Initialize loop */
    gcd:=1; y:=x;
	repeat := 2;	// allow at most this many repetitions
//		Echo({"entering gcd loop, n=", n});
 
    /* loop until failure or success found */
    While(gcd = 1 And repeat>=0)
    [
      x:= Mod( PollardRhoPolynomial(x), n);
   	  y:= Mod( PollardRhoPolynomial(PollardRhoPolynomial(y)), n);
   	  If(x-y = 0,
       	 [
		 	gcd := 1;
		 	repeat--;	// guard against infinite loop but allow a few repetitions
		 ],
       	 gcd:=Gcd(x-y,n)
       	 );
//		Echo({"gcd=",gcd," x=", x," y=", y});
   	];
	Check(repeat>=0, "PollardRhoFactorize: Warning: failed to factorize " : String(n));
  ];
  /* Return result found */
  PollardCombineLists(PollardRhoFactorize(gcd), PollardRhoFactorize(Div(n,gcd)));
];

/* PollardCombineLists combines two assoc lists used for factoring.
   the first element in each item list is the factor, and the second
   the exponent. Thus, an assoc list of {{2,3},{3,5}} means 2^3*3^5.
*/

5 # PollardMerge(_list,{1,_n}) <-- True;
10 # PollardMerge(_list,_item)_(Assoc(item[1],list) = Empty) <--
  DestructiveInsert(list,1,item);

20 # PollardMerge(_list,_item) <--
[
  Local(assoc);
  assoc := Assoc(item[1],list);
  assoc[2]:=assoc[2]+item[2];
];

PollardCombineLists(_left,_right) <--
[
  ForEach(item,right)
  [
    PollardMerge(left,item);
  ];
  left;
];


/* TODO for Bk:
   - ModDivide, ModGcd, make an interface for in the scripts.
   - The cases non-monic polynomials and polys with rational
     coefficients are not handled very well yet. These two
     are related: if the non-monic goes well then the
     rational coeffs goes well. Problem is that Knuth describes
     an order n! algorithm, for the n possible options!
     This cannot be right... When you have many factors
     this might go wrong. The algorithm will terminate (a
     great improvement over the previous) but might not
     fully factor the polynomial.
*/

10 # FindMod(_poly,_item,_p,_n)_(Degree(Gcd(poly,item)) > 0) <-- Expand(item);
11 # FindMod(_poly,_item,_p,_n) <-- FindModAux(poly,item,p,n);

11 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,item+n*p) = 0) <-- Expand(item+n*p);
12 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,item-n*p) = 0) <-- Expand(item-n*p);

13 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,(LeadingCoef(poly))*item+n*p) = 0) <-- Expand((LeadingCoef(poly))*item+n*p);
14 # FindModAux(_poly,_item,_p,_n)_(Mod(poly,(LeadingCoef(poly))*item-n*p) = 0) <-- Expand((LeadingCoef(poly))*item-n*p);

20 # FindModAux(_poly,_item,_p,_n)_(n<10) <--
[
/*
 Echo({item,p,"n = ",n});
 Echo({(Mod(LeadingCoef(poly),p))*item+n*p});
*/ 
  FindModAux(poly,item,p,n+1);
];
30 # FindModAux(_poly,_item,_p,_n) <-- 1;

5  # MergeTerm(_f,{1,_pow}) <-- True;
10 # MergeTerm(_f,_i) <-- MergeTerm(f,i,Assoc(i[1],f));
10 # MergeTerm(_f,_i,Empty) <-- DestructiveAppend(f,i);
20 # MergeTerm(_f,_i,list_IsList) <--
[
  list[2] := list[2] + i[2];
];

10 # MergeFactors(_f,_s) <--
[
  ForEach(i,s)
    MergeTerm(f,{Monic(i[1]),i[2]});
  f;
];

FactorUniVarSec(_poly) <--
[
  Local(checked,i);

  checked := Bk(poly);
  Local(pre);
  pre:=Div(poly,FW(checked));
  pre:=Eval(pre); //TODO very crude form of simplification?
  // Rescan the solutions, because there may be some that still
  // divide the remaining polynomial.
  For(i:=1,i<=Length(checked),i++)
  [
    if (Degree(checked[i][1]) > 0)
    While (Mod(pre,checked[i][1]) = 0)
    [
      checked[i][2] := checked[i][2] + 1;
      pre := Div(pre, checked[i][1]);
      pre:=Eval(pre); //TODO very crude form of simplification?
    ];
  ];

  if (pre != 1)
  [
    Local(lc,monic);
    lc := LeadingCoef(pre);
    monic := Monic(pre);
    if (monic != 1) [checked := {monic,1}:checked;];
    if (lc != 1) [checked := {lc,1}:checked;];
  ];
  checked;
];


MakeInteger(_poly) <--
[
  Local(cf,t1,t2);
  cf := MapSingle("Denom",Abs(Coef(poly,(0 .. Degree(poly)))));
  cf := Select({{n},Not IsZero(n)},cf);

  While (Length(cf) > 1)
  [
    t1:=Head(cf);
    cf:=Tail(cf);
    t2:=Head(cf);
    cf:=Tail(cf);
    cf := Lcm(t1,t2):cf;
  ];
  poly := poly*(cf[1]);
  poly;
];


Bk(_poly) <--
[
  Local(p,checked,factored,result,var);

  // result will contain the final result returned to the user. 
  checked := {};
  result:= {};
  // Create a internal representation, to speed up processing
  var:=(VarList(poly)[1]);
//  poly :=Apply("Subst",{var,Hold(x),poly};
  poly:=Subst(var,Hold(x))poly;
  poly := MakeUni(poly,VarList(poly));

  // Convert from polynomial containing rational coefficients
  // to one containing integer coefficients
  poly := MakeInteger(poly);

  // Trivial factors
  if (poly[2] > 0)
  [
    poly := UniVariate(poly[1],0,poly[3]);
  ];

//  poly := poly*LeadingCoef(poly);
/*Echo({poly," should have integer coefficients"});*/
  
  // square-free factorization
  [
    Local(dv,dd);
    dd := Apply("D",{x,poly});
    dv:=0;
    if (Degree(dd) > 0) [ dv:=Gcd(poly,dd); ];
    if (Degree(dv)>0)
    [
      Local(new);
      dv := Monic(dv);
      poly := Div(poly,dv);
      poly := MakeInteger(poly);
/*Echo({poly," should have integer coefficients"});*/
      new := Bk(dv);
      ForEach(item,new)
      [
        While(Mod(poly,item[1]) = 0)
        [
          item[2] := item[2] + 1;
          poly := Div(poly,item[1]);
        ];
      ];
      poly := MakeInteger(poly);

      MergeFactors(checked, new);
/*Echo({"squarefree: ",checked});      */
    ];
  ];


  p:=Max(1+2*Abs(Coef(poly,(0 .. Degree(poly)))));
  if (p<5) [p := 5;];
  if (p > 100) [ p := 100; ];
  While (Not IsPrime(p)) p++;

  factored := Bk(poly,p);
  if (Length(factored) < 2)
  [
    p++;
    While (Not IsPrime(p)) p++;

    factored := Bk(poly,p);
  ];
  
  ForEach(item,factored)
  [
    if (Degree(item[1]) = 1)
      MergeFactors(result,{{Monic(FindMod(poly,item[1],p,0)),item[2]}});

  ];
  MergeFactors(checked,result);
  Subst(Hold(x),var)checked;
];
Bk(_poly,_prime) <--
[
  Local(coefs,result);
  if (Degree(poly)<2)
  [
    result := {{poly,1}};
  ]
  else
  [
    coefs := MakeUni(poly)[3];
    result := Berlekamp(coefs,prime);
    Local(i);
    For(i:=1,i<=Length(result),i++)
    [
      result[i] := {Monic(NormalForm(UniVariate(x,0,result[i]))),1};
    ];
  ];
  result;
];



/* New factorization : split between integers and polynomials. */
10 # Factors(p_IsInteger) <-- FactorizeInt(p);
20 # Factors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  FactorUniVarSec(p);



Factor(_p) <-- FW(Factors(p));

/* FW: pass FW the result of Factors, and it will show it in the
 * form of p0^n0*p1^n1*...
 */

10 # FWatom({_a,1}) <-- a;
20 # FWatom({_a,_n}) <-- UnList({Atom("^"),a, n});
5  # FW(_list)_(Length(list) = 0) <-- 1;
10 # FW(_list)_(Length(list) = 1) <-- FWatom(list[1]);
20 # FW(_list) <--
[
  Local(result);
  result:=FWatom(Head(list));
  ForEach(item,Tail(list))
  [
   result := UnList({ Atom("*"),result,FWatom(item)});
  ];
  result;
];

10 # Roots(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    If(Degree(uni) = 1,
      [
        root:= -Coef(uni,0)/Coef(uni,1);
        For(i:=0,i<item[2],i++)
          result:= root : result;
      ]
      );
  ];
  result;
];

10 # RootsWithMultiples(poly_CanBeUni) <--
[
  Local(factors,result,uni,root,i);
  factors:=Factors(poly);
  result:={};
  ForEach(item,factors)
  [
    uni:=MakeUni(item[1]);
    If(Degree(uni) = 1,
      [
        root:= -Coef(uni,0)/Coef(uni,1);
        For(i:=0,i<item[2],i++)
          result:= {root,item[2]} : result;
      ]
      );
  ];
  result;
];







