/* CForm: convert Yacas objects to C/C++ code. */

/* version 0.1 */

/* Changelog
	0.1	CForm() derived from TeXForm() v0.4. Have basic functionality. Do not allow list manipulation, unevaluated derivatives, set operations, limits, integrals, Infinity, explicit matrices. Complex numbers and expressions are handled just like real ones. Indexed symbols are assumed to be arrays and handled literally. No declarations or prototypes are supplied. Function definitions are not handled. Sum() is left as is (can be defined as a C function).
*/

/* To do:
	0. Find and fix bugs.
	1. Chop strings that are longer than 80 chars
	2. Optimization of C code?
*/

RuleBase("CForm",{expression});
RuleBase("CForm",{expression, precedence});

Function ("CFormBracketIf", {predicate, string})
[
	Check(IsBoolean(predicate) And IsString(string), "CForm internal error: non-boolean and/or non-string argument of CFormBracketIf");
	If(predicate, ConcatStrings("( ", string, ") "), string);
];

/* Proceed just like CForm()
*/

TeXFormMaxPrec := 60000;	 /* This precedence will never be bracketed. It is equal to KMaxPrec */

100 # CForm(_x) <-- CForm(x, TeXFormMaxPrec);

/* Replace numbers and variables -- never bracketed except explicitly */
110 # CForm(x_IsNumber, _p) <-- String(x);
/* Variables are left as is */
200 # CForm(x_IsAtom, _p) <-- String(x);

/* Strings must be quoted but not bracketed */
100 # CForm(x_IsString, _p) <-- ConcatStrings("\"", x, "\"");

/* Replace operations */

/* arithmetic */

	/* addition, subtraction, multiplication, all comparison and logical operations are "regular" */

Bodied("if",0);
Infix("else",60000);
/* Bitwise operations we REALLY need. Perhaps we should define them
   also as Yacas operators?
 */
Infix("&",5);
Infix("|",5);
Infix("%",5);
Infix("^",5);


CFormRegularOps := { {"+"," + "}, {"-"," - "}, {"*"," * "},
                     {"/"," / "}, {":="," = "}, {"=="," == "},
                     {"="," == "}, {"!="," != "}, {"<="," <= "},
                     {">="," >= "}, {"<"," < "}, {">"," > "},
                     {"And"," && "}, {"Or"," || "}, {">>", " >> "},
                     { "<<", " << " }, { "&", " & " }, { "|", " | " },
                     { "%", " % " }, { "^", " ^ " },
                     };

	/* This is the template for "regular" binary infix operators:
100 # CForm(_x + _y, _p) <-- CFormBracketIf(p<OpPrecedence("+"), ConcatStrings(CForm(x, OpLeftPrecedence("+")), " + ", CForm(y, OpRightPrecedence("+")) ) );
	*/ 

	/* unary addition */
100 # CForm(+ _y, _p) <-- CFormBracketIf(p<OpPrecedence("+"), ConcatStrings(" + ", CForm(y, OpRightPrecedence("+")) ) );

	/* unary subtraction */
100 # CForm(- _y, _p) <-- CFormBracketIf(p<OpPrecedence("-"), ConcatStrings(" - ", CForm(y, OpRightPrecedence("-")) ) );

	/* power's argument is never bracketed but it must be put in braces. */
100 # CForm(_x ^ _y, _p) <-- CFormBracketIf(p<=OpPrecedence("^"), ConcatStrings("pow(", CForm(x, TeXFormMaxPrec), ", ", CForm(y, TeXFormMaxPrec), ")" ) );

100 # CForm(if(_pred)_body, _p) <-- "if (":CForm(pred,60000):") ":CForm(body);
100 # CForm(_left else _right, _p) <-- CForm(left):" else ":CForm(right);


CFormMathFunctions :=
  {
    {"Sqrt","sqrt"},
    {"Cos","cos"},
    {"Sin","sin"},
    {"Tan","tan"},
    {"Cosh","cosh"},
    {"Sinh","sinh"},
    {"Tanh","tanh"},
    {"Ln","log"},
    {"ArcCos","arccos"},
    {"ArcCos","arccos"},
    {"ArcSin","arcsin"},
    {"ArcTan","arctan"},
    {"ArcCosh","arccosh"},
    {"ArcSinh","arcinh"},
    {"ArcTanh","arctanh"},
    {"Max","max"},
    {"Min","min"},
    {"Abs","abs"}
  };

/* Precedence of 120 because we'd like to process some special functions like pow() first */


120 # CForm(expr_IsFunction, _p)_(NrArgs(expr)=2 And Contains(AssocIndices(CFormRegularOps), Type(expr)) ) <--
      CFormBracketIf(p<OpPrecedence(Type(expr)), ConcatStrings(CForm(Listify(expr)[2], OpLeftPrecedence(Type(expr))), CFormRegularOps[Type(expr)], CForm(Listify(expr)[3], OpRightPrecedence(Type(expr))) ) );

120 # CForm(expr_IsFunction, _p) _
      (NrArgs(expr)=1 And Contains(AssocIndices(CFormMathFunctions), Type(expr)) ) <--
      ConcatStrings(CFormMathFunctions[Type(expr)], "(", CForm( Listify(expr)[2], -TeXFormMaxPrec),")" );

/* functions */

/* Unknown function, precedence 200. Leave as is, never bracket the function itself and bracket the argument(s) automatically since it's a list. Other functions are precedence 100 */

CFormArgs(list_IsList) <--
[
  Local(i,nr,result);
  result:="";
  nr:=Length(list);
  For (i:=1,i<=nr,i++)
  [
    result:=result:CForm(list[i]);
    If (i<nr, result:=result:", ");
  ];
  result;
];


200 # CForm(_x, _p)_(IsFunction(x)) <--
[
  ConcatStrings(Type(x), "(", CFormArgs(Tail(Listify(x))),")" );
];

/* Sin, Cos, etc. and their argument is always bracketed */



/* Complex numbers */
100 # CForm(Complex(0, 1), _p) <-- "I";
100 # CForm(Complex(_x, 0), _p) <-- CForm(x, p);
110 # CForm(Complex(_x, 1), _p) <-- CForm(x+Hold(I), p);
110 # CForm(Complex(0, _y), _p) <-- CForm(Hold(I)*y, p);
120 # CForm(Complex(_x, _y), _p) <-- CForm(x+Hold(I)*y, p);

/* Some special functions: Mod */

100 # CForm(Mod(_x, _y), _p) <-- CFormBracketIf(p<OpPrecedence("/"), ConcatStrings(CForm(x, OpPrecedence("/")), " % ", CForm(y, OpPrecedence("/")) ) )
;

/* Indexed expressions */

100 # CForm(_x [ _i ], _p) <-- ConcatStrings(CForm(x, TeXFormMaxPrec), "[", CForm(i, TeXFormMaxPrec), "]");

cindent:=1;

Nl():=
[
  Local(result);
  result:=
"
";
  Local(i);
  For(i:=1,i<cindent,i++)
  [
    result:=result:"  ";
  ];
  result;
];
CIndent() :=
[
(cindent++);
"";
];
CUndent() :=
[
(cindent--);
"";
];


CFormStatement(_x) <-- CForm(x):";":Nl();

120 # CForm(_x,_p)_(Type(x) = "Prog") <--
[
  Local(result);
  result:=CIndent():"{":Nl();
  ForEach(item,Tail(Listify(x)))
  [
    result:=result:CFormStatement(item);
  ];
  result:=result:"}":CUndent():Nl();
  result;
];

120 # CForm(For(_from,_to,_step)_body,_p) <--
    "for(":CForm(from,TeXFormMaxPrec):";":CForm(to,TeXFormMaxPrec):";":CForm(step,TeXFormMaxPrec):")":CIndent():Nl():CFormStatement(body):CUndent();

/*TODO test
test:=Hold(

           For(i:=1,i<=10,i:=i+1)
             For(j:=i+1,j<=10,j:=j+1)
             [
               m[i][j]:=1/(1+i+j);
             ]
           );
    
*/


