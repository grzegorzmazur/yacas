/// This procedure computes the uniform approximation for the Gamma function
/// due to Lanczos and Spouge (the so-called "less precise coefficients")
/// evaluated at arbitrary precision by using a large number of terms
/// See J. L. Spouge, SIAM J. of Num. Anal. 31, 931 (1994)
/// See also Paul Godfrey 2001 (unpublished): http://winnie.fit.edu/~gabdo/gamma.txt for a discussion

/// Calculate the uniform approximation to the logarithm of the Gamma function
/// in the Re z > 0 half-plane; argument z may be symbolic or complex
/// but current value of precision is used
/// Note that we return LnGamma(z), not of z+1
/// This function should not be used by applications
10 # LnGammaNum(_z, _a)_(N(Re(z))<0) <-- N(Ln(Pi/Sin(Pi*z))-LnGammaNum(1-z));
20 # LnGammaNum(_z, _a) <-- [
	Local(e, k, tmpcoeff, coeff, result);
	a := Max(a, 4);	// guard against low values
	e := N(Exp(1));
	k:=Ceil(a);	// prepare k=N+1; the k=N term is probably never significant but we don't win much by excluding it
	result := 0;	// prepare for last term
	// use Horner scheme to prevent loss of precision
	While(k>1) [	// 'result' will accumulate just the sum for now
		k:=k-1;
		result := N( MathPower(a-k,k)/((z+k)*Sqrt(a-k))-result/(e*k) );
	];
	N(Ln(1+Exp(a-1)/Sqrt(2*Pi)*result) + Ln(2*Pi)/2 -a-z+(z+1/2)*Ln(z+a) - Ln(z));
];

/*
20 # LnGammaNum1(_z, _a) <-- [
	Local(e, k, tmpcoeff, coeff, result);
	a := Max(a, 4);	// guard against low values
	e := N(Exp(1));
	k:=Ceil(a)-1;	// prepare k=N b/c we can drop the last term, really
	result := 0;	// prepare last term
	// use Horner scheme to prevent loss of precision
	While(k>1) [	// 'result' will accumulate just the sum for now
		k--;
		result := N( Sqrt(a-k)/(z+k)
			-result*(a-k-1)/(e*k)*MathPower(N(1-1/(a-k)), k-1) );
	];
	N(Ln(1+Exp(a-1)/Sqrt(2*Pi)*result) + Ln(2*Pi)/2 -a-z+(z+1/2)*Ln(z+a) - Ln(z));
];
*/
/*
20 # LnGammaNum0(_z, _a) <-- [
	Local(e, k, tmpcoeff, coeff0, coeff, result);
	e := N(Exp(1));
	a := Max(a, 4);	// guard against low values
	coeff0 := 1;
	result := coeff0;
	tmpcoeff := N(Exp(a-1)/Sqrt(2*Pi));
	For(k:=1, k<=Ceil(a)-1, k++) [
		coeff := N(tmpcoeff*(a-k)^(k-1/2));
//		Echo({"coeff c[", k, "] =",  coeff});
		result := N(result + coeff/(z+k));
//		Echo({"sum at step ", k, " =",  result});
		tmpcoeff := N(-tmpcoeff/(k*e));
	];
//	Echo({k, " coefficients, last is", tmpcoeff});
	N(Ln(result) + Ln(2*Pi)/2 - a  - z +(z+1/2)*Ln(z+a) - Ln(z));
];
*/

LnGammaNum(z) := [
	Local(a, prec, result);
	prec := GetPrecision();
	Precision(10);	// save time here
	a:= Floor(N( 0.9*prec*Ln(10)/Ln(2*Pi) )) + 0.4;	// fudge factor 0.9 :)
	/// same as parameter "g" in Godfrey 2001.
	/// Chosen to satisfy Spouge's error bound:
	/// error < Sqrt(a)/Real(a+z)/(2*Pi)^(a+1/2)
//	Echo({"parameter a = ", a, " setting precision to ", Ceil(prec*1.4)});
	Precision(Ceil(prec*1.4));	// need more precision b/c of roundoff errors
	result := LnGammaNum(z,a);
	Precision(prec);
	result;
];

GammaNum(z) := N(Exp(LnGammaNum(z)));
GammaNum(z,a) := N(Exp(LnGammaNum(z,a)));	/// should not be used by applications

Retract("Gamma", 1);	// want to be able to Load() this many times
/// User visible functions: Gamma(x), LnGamma(x)
10 # Gamma(_n)_(IsInteger(n) And n<=0) <-- Infinity;
20 # Gamma(n_IsNumber)_(IsPositiveInteger(n) Or IsInteger(N(2*n))) <-- (n-1)!;
10 # LnGamma(_n)_(IsInteger(n) And n<=0) <-- Infinity;
20 # LnGamma(n_IsNumber)_(IsPositiveInteger(n) Or IsInteger(N(2*n))) <-- Ln((n-1)!);

