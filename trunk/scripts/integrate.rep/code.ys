
RuleBase("IntegrateMultiplicative",{var,from,a,b});
UnFence("IntegrateMultiplicative",4);

10# (Integrate(_var)(expr_IsList)) 
    <-- Map("Integrate",{FillList(var,Length(expr)),expr});
20 # (Integrate(_var)(_expr)) <-- IntSub(var,expr,AntiDeriv(var,IntClean(var,expr)));


10 # IntSub(_var,_expr,Integrate(_var)(_expr2)) <--
     `Hold(Integrate(@var)(@expr));
20 # IntSub(_var,_expr,_result) <-- result + UniqueConstant();

////////////////////////////////////////////////
//
// Integrate over a range
//
////////////////////////////////////////////////
10# (Integrate(_var,_from,_to)(expr_IsList)) 
    <-- Map("Integrate",{FillList(var,Length(expr)),
                         FillList(from,Length(expr)),
			 FillList(to,Length(expr)),
                         expr});
20 # (Integrate(_var,_from,_to)(_expr))
    <-- indefIntegrate(var,from,to,expr,a,b);

////////////////////////////////////////////////
//
// separate rules can be added here for specific integrals
// to indefIntegrate
//
////////////////////////////////////////////////
100 # indefIntegrate(_var,_from,_to,_expr,_a,_b) 
    <-- IntegrateRange(var,expr,from,to,AntiDeriv(var,expr));

////////////////////////////////////////////////
//
// No anti-derivative found, return unavaluated.
//
////////////////////////////////////////////////
10 # IntegrateRange(_var,_expr,_from,_to,Integrate(_var)_expr2)
    <-- `Hold(Integrate(@var,@from,@to)@expr);
    
////////////////////////////////////////////////
//
// Anti-derivative found, return result.
//
////////////////////////////////////////////////
20 # IntegrateRange(_var,_expr,_from,_to,_antideriv)
    <-- `(@antideriv Where @var == @to) - `(@antideriv Where @var == @from);

////////////////////////////////////////////////
//
// IntClean cleans up an expression before passing
// it on to integration. This function normalizes
// an expression in a way desirable for integration.
// TrigSimpCombine, for instance, expands expressions
// containing trigonometric functions so that they are
// additive as opposed to multiplicative.
//
////////////////////////////////////////////////
10 # IntClean(_var,_expr) <-- Simplify(TrigSimpCombine(expr));

////////////////////////////////////////////////
//
// Anti-derivative of a univariate polynomial
//
////////////////////////////////////////////////
5  # AntiDeriv(_var, poly_CanBeUni(var) )
     <-- NormalForm(AntiDeriv(var,`MakeUni(@poly,@var)));
5 # AntiDeriv(_var,UniVariate(_var,_first,_coefs)) <--
[
  Local(result,i);
  result:=FlatCopy(coefs);
  For(i:=1,i<=Length(result),i++)
  [
    result[i]:= result[i]/(first+i);
  ];
  UniVariate(var,first+1,result);
];



////////////////////////////////////////////////
//
// Standard additive properties of integration.
//
////////////////////////////////////////////////
10 # AntiDeriv(_var,_x + _y) <-- AntiDeriv(var,x) + AntiDeriv(var,y);
10 # AntiDeriv(_var,_x - _y) <-- AntiDeriv(var,x) - AntiDeriv(var,y);
10 # AntiDeriv(_var,   - _y) <--            - AntiDeriv(var,y);


////////////////////////////////////////////////
//
// Multiplying a polynomial with another (integrable)
// function, Integrate by parts.
//
////////////////////////////////////////////////
70 # IntegrateMultiplicative(_var,(exy_CanBeUni(var)) * _exx,_dummy1,_dummy2)
     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));
70 # IntegrateMultiplicative(_var,_exx * (exy_CanBeUni(var)),_dummy1,_dummy2)
     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));
10 # IntByParts(_var,_exy * _exx,Integrate(_var)(_something)) <--
     `Hold(AntiDeriv(@var,((@exy)*(@exx))));
20 # IntByParts(_var,_exy * _exx,_anti)_(Not IsFreeOf(anti,exx)) <--
     `Hold(AntiDeriv(@var,((@exy)*(@exx))));
30 # IntByParts(_var,_exy * _exx,_anti) <--
     [
       Local(cf);
       cf:=anti*Deriv(var)exy;
//  Echo({exy*anti,exy*exx,cf});
       exy*anti - `(AntiDeriv(@var,@cf));
     ];

////////////////////////////////////////////////
//
// Rational functions: f(x)/g(x) where f and g are
// polynomials.
//
////////////////////////////////////////////////
70 # IntegrateMultiplicative(_var,(exy_CanBeUni(var)) / (exx_CanBeUni(var)),_dummy1,_dummy2) <--
     IntRat(var,exy/exx,MakeUni(exy,var),MakeUni(exx,var));

10 # IntRat(_var,_exy / _exx,_exyu,_exxu)_
     (Degree(exyu) > Degree(exxu) Or Degree(Gcd(exyu,exxu)) > 0) <--
     [
     Local(gcd);
     gcd:=Gcd(exxu,exyu);
     exyu:=Div(exyu,gcd);
     exxu:=Div(exxu,gcd);
     AntiDeriv(var,NormalForm(Div(exyu,exxu))) +
       AntiDeriv(var,NormalForm(Mod(exyu,exxu))/NormalForm(exxu));
     ];

11 # IntRat(_var,_exy / _exx,_exyu,_exxu)_
        (Degree(exxu,var) > 1 And LeadingCoef(exxu)=1 And
	 IsNumericList(Coef(exxu,var,0 .. Degree(exxu)))) <--
[
  Local(ee);
  ee:=Apart(exy/exx,var);
  `AntiDeriv(@var,@ee);
];


20 # IntRat(_var,_exy / _exx,_exyu,_exxu) <--
     `Hold(AntiDeriv(@var,((@exy)/(@exx))));


////////////////////////////////////////////////
//
// No simple form, try something else
//
////////////////////////////////////////////////
100 # AntiDeriv(_var,_exp) <--
[
  IntegrateMultiplicative(var,exp,a,b);
];


////////////////////////////////////////////////
//
// Special anti-derivatives can be added here.
//
////////////////////////////////////////////////

// integrating expressions containing if:
10 # IntegrateMultiplicative(_var,if(_cond)(_body),_a,_b)
     <--
     [
       body := AntiDeriv(var,body);
       `Hold(if(@cond)(@body));
     ];
// integrating expressions containing else
10 # IntegrateMultiplicative(_var,(_left) else (_right),_a,_b)
     <--
     [
       left  := AntiDeriv(var,left);
       right := AntiDeriv(var,right);
       `Hold( (@left) else (@right) );
     ];


////////////////////////////////////////////////
//
// Could not find anti-derivative, return unsimplified
//
////////////////////////////////////////////////
100 # IntegrateMultiplicative(_var,_exp,_a,_b) <-- `Hold(Integrate(@var)(@exp));

////////////////////////////////////////////////
//
// IntFunc declares the anti-derivative of a function
// that has one argument.
// Calling sequence: IntFunc(variable,from,to);
// Example: IntFunc(x,Cos(_x),Sin(x));
//
////////////////////////////////////////////////
IntFunc(_vr,_from,_to) <--
[
  `(50 # IntegrateMultiplicative(_var,@from,_dummy1,_dummy2)_MatchLinear(var,@vr) <-- (@to)/a);
];


/** MatchPureSquared(variable,expression) - matches expressions
 *  of the form a*x^2+b.
 */
10 # MatchPureSquared(var_IsAtom,_sign2,_sign0,expr_CanBeUni(var)) <--
[
  Set(expr,MakeUni(expr,var));
  MatchPureSquared(expr,sign2,sign0);
];
20 # MatchPureSquared(_var,_sign2,_sign0,_expr) <-- False;

10 # MatchPureSquared(_expr,_sign2,_sign0)_(Degree(expr,var)=2 And 
                                    Coef(expr,1) = 0 And   
				    IsNumber(Coef(expr,0)) And
				    IsNumber(Coef(expr,2)) And
				    Coef(expr,0)*sign0 > 0 And
				    Coef(expr,2)*sign2 > 0
				    ) <--
[
  Check(IsUniVar(expr),ToString()Echo({"Incorrect argument ",expr," passed to MatchLinear"}));
  Check(Not IsBound(A), "Found bound variable which should have been unbound, in MatchLinear");
  Check(Not IsBound(B), "Found bound variable which should have been unbound, in MatchLinear");
  a := Coef(expr,2);
  b := Coef(expr,0);
  True;
];
20 # MatchPureSquared(_expr,_sign2,_sign0) <-- False;
UnFence("MatchPureSquared",3);
UnFence("MatchPureSquared",4);

IntPureSquare(_vr,_from,_sign2,_sign0,_to) <--
[
  `(50 # IntegrateMultiplicative(_var,@from,_dummy1,_dummy2)_MatchPureSquared(var,@sign2,@sign0,@vr) <-- (@to));
];




////////////////////////////////////////////////
//
// Declaration of the anti-derivatives of a few analytic functions
//
////////////////////////////////////////////////
IntFunc(x,Sin(_x),-Cos(x));
IntFunc(x,Csc(_x),-Ln(Csc(x)+Cot(x)));
IntFunc(x,Cos(_x),Sin(x));
IntFunc(x,Sec(_x),Ln(Sec(x)+Tan(x)));
IntFunc(x,Tan(_x),-Ln(Cos(x)));
IntFunc(x,Cot(_x),Ln(Sin(x)));
IntFunc(x,Exp(_x),Exp(x));
IntFunc(x,(C_IsFreeOf(var))^(_x),C^x/Ln(C));
IntFunc(x,num_IsFreeOf(var) / (_x),num*Ln(Abs(x)));
IntFunc(x,Ln(_x),x*Ln(x)-x);
IntFunc(x,(_x)*Ln(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );
IntFunc(x,Ln(_x)*(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );

IntFunc(x,Csc(_x)^2,-Cot(x));
IntFunc(x,Sec(_x)^2,Tan(x));
IntFunc(x,Csc(_x)*Cot(_x),-Csc(x));
IntFunc(x,Sec(_x)*Tan(_x),Sec(x));
IntFunc(x,CscH(_x)^2,-CotH(x));
IntFunc(x,SecH(_x)^2,TanH(x));
IntFunc(x,CscH(_x)*Cot(_x),-CscH(x));
IntFunc(x,SecH(_x)*TanH(_x),-SecH(x));


// n>0
IntFunc(x,Ln(_x)*(_x)^n_IsNumber,(1/(n+1))*x^(n+1)*Ln(x) - (1/(n+1)^2)*x^(n+1) );

// n>0
IntFunc(x,Ln(A_IsNumber*_x)*(_x)^n_IsNumber,(1/(n+1))*x^(n+1)*Ln(A*x) - (1/(n+1)^2)*x^(n+1) );

IntFunc(x,Sin(Ln(_x)),x*Sin(Ln(x))/2 - x*Cos(Ln(x))/2 );
IntFunc(x,Cos(Ln(_x)),x*Sin(Ln(x))/2 - x*Cos(Ln(x))/2 );

IntFunc(x,1/((_x)*Ln(_x)),Ln(Ln(x)));

IntFunc(x,SinH(_x),CosH(x));
IntFunc(x,SinH(_x)^2,SinH(2*x)/4 - x/2);

IntFunc(x,CscH(_x),Ln(TanH(x/2)));

IntFunc(x,CosH(_x),SinH(x));
IntFunc(x,CosH(_x)^2,SinH(2*x)/4 + x/2);

IntFunc(x,SecH(_x),ArcTan(SinH(x)));
IntFunc(x,TanH(_x),Ln(CosH(x)));

IntFunc(x,SecH(_x)*TanH(_x),-SecH(x));
IntFunc(x,SecH(_x)^2,TanH(x));
IntFunc(x,CscH(_x)*CotH(_x),-CscH(x));

IntFunc(x,CotH(_x),Ln(SinH(x)));
IntFunc(x,Abs(_x),Abs(x)*x/(2*a));
 
IntFunc(x,ArcTan(_x),x*ArcTan(x) - Ln(x^2 + 1)/2);
IntFunc(x,ArcCot(_x),(x*ArcCot(x)) + Ln(x^2 + 1)/2);
IntFunc(x,ArcSin(_x),(x*ArcSin(x)) + Sqrt(1-x^2) );
IntFunc(x,ArcCos(_x),x*ArcCos(x) - Sqrt(1-x^2) );
IntFunc(x,ArcSec(_x),x*ArcSec(x) - Ln(x + Sqrt(x^2 - 1)) );
IntFunc(x,ArcCsc(_x),x*ArcCsc(x) + Ln(x + Sqrt(x^2 - 1) ));

IntFunc(x,ArcTanH(_x),x*ArcTanH(x) + Ln(1-x^2)/2 );
IntFunc(x,ArcSinH(_x),x*ArcSinH(x) - Sqrt(x^2 + 1) );
IntFunc(x,ArcCosH(_x),x*ArcCosH(x) - Sqrt(x-1)*Sqrt(x+1) );
IntFunc(x,ArcSecH(_x),x*ArcSecH(x)-ArcTan(Sqrt(1/x-1)*Sqrt(1/x+1) ) );
IntFunc(x,ArcCscH(_x),x*ArcCscH(x)+Ln(x+x*Sqrt(1+1/x^2)) );
IntFunc(x,ArcCotH(_x),x*ArcCotH(x)+1/2*Ln(x^2-1) );


// n^2 > x^2 
IntFunc(x,num_IsFreeOf(var)/(-(_x)^2 + n_IsNumber),num*ArcTanH(x/Sqrt(n))/n);

// x^2 > n^2
IntFunc(x,num_IsFreeOf(var)/((_x)^2 - n_IsNumber),num * -ArcCotH(x/Sqrt(n))/Sqrt(n));

// n^2 > x^2
IntFunc(x,num_IsFreeOf(var)/Sqrt(n_IsNumber - (_x)^2),num*ArcSin(x/Sqrt(n)));

// previous code is killing this....
IntFunc(x,num_IsFreeOf(var)/(A_IsNumber + B_IsNumber*(_x))^2,-num/(A*b + B^2*x));

// Code works now?
IntFunc(x,num_IsFreeOf(var)/(n_IsNumber + m_IsNumber*Exp(p_IsNumber*(_x))),num*x/n - num*Ln(n + m*Exp(p*x))/(n*p));
IntFunc(x,num_IsFreeOf(var)/(m_IsNumber*Exp(p_IsNumber*(_x)) + n_IsNumber),num*x/n - num*Ln(n + m*Exp(p*x))/(n*p));

//TODO remove, replaced correctly? 
// IntFunc(x,num_IsFreeOf(var)/((_x)^2 + n_IsNumber ),num*ArcTan(x/Sqrt(n))/Sqrt(n));

IntPureSquare(x,num_IsFreeOf(var)/(_x),1,1,(num/(a*Sqrt(b/a)))*ArcTan(var/Sqrt(b/a)));

