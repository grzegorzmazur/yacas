
RuleBase("IntegrateMultiplicative",{var,from,a,b});
UnFence("IntegrateMultiplicative",4);

(Integrate(_var)(_expr)) <-- IntSub(var,expr,AntiDeriv(var,IntClean(var,expr)));
10 # IntSub(_var,_expr,Integrate(_var)(_expr2)) <--
     `Hold(Integrate(@var)(@expr));
20 # IntSub(_var,_expr,_result) <-- result + UniqueConstant();

////////////////////////////////////////////////
//
// Integrate over a range
//
////////////////////////////////////////////////
(Integrate(_var,_from,_to)(_expr))
    <-- indefIntegrate(var,from,to,expr,a,b);

////////////////////////////////////////////////
//
// separate rules can be added here for specific integrals
// to indefIntegrate
//
////////////////////////////////////////////////
100 # indefIntegrate(_var,_from,_to,_expr,_a,_b) 
    <-- IntegrateRange(var,expr,from,to,AntiDeriv(var,expr));

////////////////////////////////////////////////
//
// No anti-derivative found, return unavaluated.
//
////////////////////////////////////////////////
10 # IntegrateRange(_var,_expr,_from,_to,Integrate(_var)_expr2)
    <-- `Hold(Integrate(@var,@from,@to)@expr);
    
////////////////////////////////////////////////
//
// Anti-derivative found, return result.
//
////////////////////////////////////////////////
20 # IntegrateRange(_var,_expr,_from,_to,_antideriv)
    <-- `(@antideriv Where @var == @to) - `(@antideriv Where @var == @from);

////////////////////////////////////////////////
//
// IntClean cleans up an expression before passing
// it on to integration. This function normalizes
// an expression in a way desirable for integration.
// TrigSimpCombine, for instance, expands expressions
// containing trigonometric functions so that they are
// additive as opposed to multiplicative.
//
////////////////////////////////////////////////
10 # IntClean(_var,_expr) <-- Simplify(TrigSimpCombine(expr));

////////////////////////////////////////////////
//
// Anti-derivative of a univariate polynomial
//
////////////////////////////////////////////////
5  # AntiDeriv(_var, _poly )_CanBeUni(poly,var)
     <-- NormalForm(AntiDeriv(var,`MakeUni(@poly,@var)));
5 # AntiDeriv(_var,UniVariate(_var,_first,_coefs)) <--
[
  Local(result);
  result:=FlatCopy(coefs);
  For(i:=1,i<=Length(result),i++)
  [
    result[i]:= result[i]/(first+i);
  ];
  UniVariate(var,first+1,result);
];



////////////////////////////////////////////////
//
// Standard additive properties of integration.
//
////////////////////////////////////////////////
10 # AntiDeriv(_var,_x + _y) <-- AntiDeriv(var,x) + AntiDeriv(var,y);
10 # AntiDeriv(_var,_x - _y) <-- AntiDeriv(var,x) - AntiDeriv(var,y);
10 # AntiDeriv(_var,   - _y) <--            - AntiDeriv(var,y);


////////////////////////////////////////////////
//
// Multiplying a polynomial with another (integrable)
// function, Integrate by parts.
//
////////////////////////////////////////////////
70 # IntegrateMultiplicative(_var,_exy * _exx,_dummy1,_dummy2)_
     (CanBeUni(exy,var))
     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));
70 # IntegrateMultiplicative(_var,_exx * _exy,_dummy1,_dummy2)_
     (CanBeUni(exy,var))
     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));
10 # IntByParts(_var,_exy * _exx,Integrate(_var)(_something)) <--
     `Hold(AntiDeriv(@var,((@exy)*(@exx))));
20 # IntByParts(_var,_exy * _exx,_anti)_(Not IsFreeOf(anti,exx)) <--
     `Hold(AntiDeriv(@var,((@exy)*(@exx))));
30 # IntByParts(_var,_exy * _exx,_anti) <--
     [
       Local(cf);
       cf:=anti*Deriv(var)exy;
//  Echo({exy*anti,exy*exx,cf});
       exy*anti - `(AntiDeriv(@var,@cf));
     ];

////////////////////////////////////////////////
//
// Rational functions: f(x)/g(x) where f and g are
// polynomials.
//
////////////////////////////////////////////////
70 # IntegrateMultiplicative(_var,_exy / _exx,_dummy1,_dummy2)_
        (CanBeUni(exx,var) And CanBeUni(exy,var)) <--
     IntRat(var,exy/exx,MakeUni(exy,var),MakeUni(exx,var));

10 # IntRat(_var,_exy / _exx,_exyu,_exxu)_
     (Degree(exyu) > Degree(exxu) Or Degree(Gcd(exyu,exxu)) > 0) <--
     [
     Local(gcd);
     gcd:=Gcd(exxu,exyu);
// Echo({"gcd = ",NormalForm(gcd)});
     exyu:=Div(exyu,gcd);
     exxu:=Div(exxu,gcd);
// Echo({"numer = ",NormalForm(exyu)});
// Echo({"denom = ",NormalForm(exxu)});
     AntiDeriv(var,NormalForm(Div(exyu,exxu))) +
       AntiDeriv(var,NormalForm(Mod(exyu,exxu))/NormalForm(exxu));
     ];
20 # IntRat(_var,_exy / _exx,_exyu,_exxu) <--
     `Hold(AntiDeriv(@var,((@exy)/(@exx))));


////////////////////////////////////////////////
//
// No simple form, try something else
//
////////////////////////////////////////////////
100 # AntiDeriv(_var,_exp) <--
[
  IntegrateMultiplicative(var,exp,a,b);
];


////////////////////////////////////////////////
//
// Special anti-derivatives can be added here.
//
////////////////////////////////////////////////

// integrating expressions containing if:
10 # IntegrateMultiplicative(_var,if(_cond)(_body),_a,_b)
     <--
     [
       body := AntiDeriv(var,body);
       `Hold(if(@cond)(@body));
     ];
// integrating expressions containing else
10 # IntegrateMultiplicative(_var,(_left) else (_right),_a,_b)
     <--
     [
       left  := AntiDeriv(var,left);
       right := AntiDeriv(var,right);
       `Hold( (@left) else (@right) );
     ];


////////////////////////////////////////////////
//
// Could not find anti-derivative, return unsimplified
//
////////////////////////////////////////////////
100 # IntegrateMultiplicative(_var,_exp,_a,_b) <-- `Hold(Integrate(@var)(@exp));

////////////////////////////////////////////////
//
// IntFunc declares the anti-derivative of a function
// that has one argument.
// Calling sequence: IntFunc(variable,from,to);
// Example: IntFunc(x,Cos(_x),Sin(x));
//
////////////////////////////////////////////////
IntFunc(_vr,_from,_to) <--
[
  `(50 # IntegrateMultiplicative(_var,@from,_dummy1,_dummy2)_MatchLinear(var,@vr) <-- (@to)/a);
];

////////////////////////////////////////////////
//
// Declaration of the anti-derivatives of a few analytic functions
//
////////////////////////////////////////////////
IntFunc(x,Sin(_x),-Cos(x));
IntFunc(x,Cos(_x),Sin(x));
IntFunc(x,Tan(_x),-Ln(Cos(x)));
IntFunc(x,Exp(_x),Exp(x));
IntFunc(x,(A_IsFreeOf2(var))^(_x),A^x/Ln(A));
//TODO ugly hack, IsFreeOf2
IsFreeOf2(_var,_expr) <-- IsFreeOf(expr,var);
IntFunc(x,num_IsFreeOf2(var) / (_x),num*Ln(Abs(x)));
IntFunc(x,Ln(_x),x*Ln(x)-x);
IntFunc(x,(_x)*Ln(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );
IntFunc(x,Ln(_x)*(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );
IntFunc(x,Ln(_x)*(_x)^n_IsInteger,(1/(n+1))*x^(n+1)*Ln(x) - (1/(n+1)^2)*x^(n+1) );
IntFunc(x,SinH(_x),CosH(x));
IntFunc(x,CosH(_x),SinH(x));
IntFunc(x,TanH(_x),Ln(CosH(x)));
IntFunc(x,Abs(_x),Abs(x)*x/(2*a));

