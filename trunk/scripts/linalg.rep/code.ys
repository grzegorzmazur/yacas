
/* Levi-civita symbol */
Function("LeviCivita",{indices})
[
  Local(i,j,length,left,right,factor);
  length:=Length(indices);
  factor:=1;

  For (j:=length,j>1,j--)
  [
    For(i:=1,i<j,i++)
    [
      left:=indices[i];
      right:=indices[i+1];

      If (Equals(left,right),
      [ factor := 0 ; ],
      [
        If(Not(Apply("<",{left,right})),
        [
/*
          Swap(indices,i,i+1);
*/
          indices:=Insert(Delete(indices,i),i+1,left);
          factor:= -factor;
        ]);
      ]);
    ];
  ];
  factor;
];

Function("Permutations",{result,list})
[
  If (Length(list) = 0,
  [
    result;
  ],
  [
    Local(head);
    Local(newresult);
    Local(i);
    head:=list[1];
    newresult:={};
    ForEach(item,result)
    [
      For(i:=Length(item)+1,i>0,i--)
      [
        DestructiveInsert(newresult,1,Insert(item,i,head));
      ];
    ];
    newresult:=DestructiveReverse(newresult);
    Permutations(newresult,Tail(list));
  ]);
];


Function("Permutations",{list})
[
  Permutations({{}},list);
];

Function("InProduct",{aLeft,aRight})
[
  Local(length);
  length:=Length(aLeft);
  Check(length = Length(aRight),"InProduct: error, vectors not of the same dimension");

  Local(result);
  result:=0;
  Local(i);
  For(i:=1,i<=length,i++)
  [
    result := result + aLeft[i] * aRight[i];
  ];
  result;
];


Function("CrossProduct",{aLeft,aRight})
[
  Local(length);
  length:=Length(aLeft);
  Check(length = 3,"OutProduct: error, vectors not of dimension 3");
  Check(length = Length(aRight),"OutProduct: error, vectors not of the same dimension");

  Local(perms);
  perms := Permutations({1,2,3});

  Local(result);
  result:=ZeroVector(3);

  Local(term);
  ForEach(term,perms)
  [
    result[ term[1] ] := result[ term[1] ] +
      LeviCivita(term) * aLeft[ term[2] ] * aRight[ term[3] ] ;
  ];
  result;
];


_x o _y <-- Outer(x,y);

// outer product of vectors
Outer(t1_IsVector, t2_IsVector) <--
[
   Local(i,j,n,m,result);
   n:=Length(t1);
   m:=Length(t2);
   result:=ZeroMatrix(n,m);
   For(i:=1,i<=n,i++)
      For(j:=1,j<=m,j++)
	 result[i][j]:=t1[i]*t2[j];
   result;
];



Function("ZeroVector",{n})
[
    Local(i,result);
    result:={};
    For(i:=1,i<=n,i++)
    [
      DestructiveInsert(result,1,0);
    ];
    result;
];


Function("BaseVector",{row,n})
[
    Local(i,result);
    result:=ZeroVector(n);
    result[row] := 1;
    result;
];

RandomIntegerVector(_count,_coefmin,_coefmax) <--
  Table(MathFloor(coefmin+Random()*(coefmax+1-coefmin)),i,1,count,1);


Identity(n_IsNonNegativeInteger) <--
[
    Local(i,result);
    result:={};
    For(i:=1,i<=n,i++)
    [
      DestructiveAppend(result,BaseVector(i,n));
    ];
    result;
];


Function("Diagonal",{A})
[
	Local(result,i,n);
	n:=Length(A);
	result:=ZeroVector(n);
	For(i:=1,i<=n,i++)
	[
		result[i] := A[i][i];
	];      
	result;
];

Function("DiagonalMatrix",{list})
[
  Local(result,i,n);
  n:=Length(list);
  result:=Identity(n);
  For(i:=1,i<=n,i++)
  [
    result[i][i] := list[i];
  ];
  result;
];

Function("Normalize",{vector})
[
  Local(norm);
  norm:=0;
  ForEach(item,vector)
  [
    norm:=norm+item*item;
  ];
  (1/(norm^(1/2)))*vector;
];

ZeroMatrix(n_IsNonNegativeInteger,m_IsNonNegativeInteger) <--
[
  Local(i,result);
  result:={};
  For(i:=1,i<=n,i++)
    DestructiveInsert(result,i,ZeroVector(m));
  result;
];


Transpose(matrix_IsList)_(Length(Dimensions(matrix))>1) <--
[
  Local(i,j,result);
  result:=ZeroMatrix(Length(matrix[1]),Length(matrix));
  For(i:=1,i<=Length(matrix),i++)
    For(j:=1,j<=Length(matrix[1]),j++)
      result[j][i]:=matrix[i][j];
  result;
];

FrobeniusNorm(matrix_IsMatrix) <--
[
	Local(i,j,result);
	result:=0;
	For(i:=1,i<=Length(matrix),i++)
		For(j:=1,j<=Length(matrix[1]),j++)
			result:=result+Abs(matrix[i][j])^2;
	
	Sqrt(result);

];



/* Cramer-like matrix operations */
20 # Determinant(_matrix) <-- 
[
  Local(perms,indices,result);
  Check((IsMatrix(matrix)),"Determinant: Argument must be a matrix");
  indices:=Table(i,i,1,Length(matrix),1);
  perms:=Permutations(indices);
  result:=0;
  ForEach(item,perms)
     result:=result+Factorize(i,1,Length(matrix),matrix[i][item[i] ])*
                    LeviCivita(item);
  result;
];

10 # Determinant(_matrix)_(IsUpperTriangular(matrix) Or IsLowerTriangular(matrix)) <--
[ 
	Local(result);
	result:=1;
	ForEach(i, Diagonal(matrix) )
		result:=result*i;
	result;
];
Function("CoFactor",{matrix,ii,jj})
[
  Local(perms,indices,result);
  indices:=Table(i,i,1,Length(matrix),1);
  perms:=Permutations(indices);
  result:=0;
  ForEach(item,perms)
     If(item[ii] = jj,
       result:=result+
         Factorize(i,1,Length(matrix),
         If(ii=i,1,matrix[i][item[i] ])
                  )*LeviCivita(item));
  result;
];



Minor(matrix,i,j) := CoFactor(matrix,i,j)/(-1^(i+j));

Function("Inverse",{matrix})
[
  Local(perms,indices,inv,det,n);
  n:=Length(matrix);
  indices:=Table(i,i,1,n,1);
  perms:=Permutations(indices);
  inv:=ZeroMatrix(n,n);
  det:=0;
  ForEach(item,perms)
  [
    Local(i,lc);
    lc := LeviCivita(item);
    det:=det+Factorize(i,1,n,matrix[i][item[i] ])* lc;
    For(i:=1,i<=n,i++)
        [
         inv[item[i] ][i] := inv[item[i] ][i]+
           Factorize(j,1,n,
             If(j=i,1,matrix[j][item[j] ]))*lc;
        ];
  ];
  Check(det != 0, "Zero determinant");
  (1/det)*inv;
];

Tr(x_IsList) <--
[
   Local(i,j,n,d,r,aux,result);
   d:=Dimensions(x);
   r:=Length(d); // tensor rank
   n:=Min(d);    // minimal dim
   result:=0;
   For(i:=1,i<=n,i++)
   [
      aux:=x[i];
      For(j:=2,j<=r,j++)
	 aux:=aux[i];
      result:=result+aux;
   ];
   result;
];


Trace(matrix_IsList) <-- Tr(matrix);
/*TODO remove
[
  Local(i,result);
  result:=0;
  For(i:=1,i<=Length(matrix),i++)
    result:=result+matrix[i][i];
  result;
];
*/

x X y := CrossProduct(x,y);
// x . y := InProduct(x,y); // see Dot function below (dr)
Commutator(x,y):=x*y-y*x;

Function("VandermondeMatrix",{vector})[
	Local(len,i,j,item,result);
	len:=Length(vector);	
	matrix:=ZeroMatrix(len,len);

	For(i:=1,i<=Length(matrix),i++)[
		For(j:=1,j<=Length(matrix[1]),j++)[
      			matrix[j][i]:=vector[i]^(j-1);
		];
	];

	matrix;
];

/* SylvesterMatrix */

Function("SylvesterMatrix",{poly1, poly2, var})
[
  Local(i,m,p,q,y,z,result);
  y:=Degree(poly1,var);
  z:=Degree(poly2,var);
  m:=y+z;
  p:={};
  q:={};
  result:=ZeroMatrix(m,m);

  For(i:=y,i>=0,i--)
    DestructiveAppend(p,Coef(poly1,var,i));
  For(i:=z,i>=0,i--)
    DestructiveAppend(q,Coef(poly2,var,i));

  For(i:=1,i<=z,i++)
  [
    Local(j,k);
        k:=1;
    For(j:=i,k<=Length(p),j++)
        [
          result[i][j]:=p[k];
          k++;
        ];
  ];

  For(i:=1,i<=y,i++)
  [
    Local(j,k);
        k:=1;
    For(j:=i,k<=Length(q),j++)
        [
          result[i+z][j]:=q[k];
          k++;
        ];
  ];
  result;
];



Function("MatrixRow",{matrix,row})
[
  Check(row > 0, "MatrixRow: row index out of range");
  Check(row <= Length(matrix), "MatrixRow: row index out of range");

  Local(result);
  result:=matrix[row];

  result;
];

Function("MatrixColumn",{matrix,col})
[
  Local(m);
  m:=matrix[1];

  Check(col > 0, "MatrixColumn: column index out of range");
  Check(col <= Length(m), "MatrixColumn: column index out of range");

  Local(i,result);
  result:={};
  For(i:=1,i<=Length(matrix),i++)
    DestructiveAppend(result,matrix[i][col]);

  result;
];

Function("GenMatrix",{func,m,n})
[
  Local(i,j,result);
  result:=ZeroMatrix(m,n);

  For(i:=1,i<=m,i++)
    For(j:=1,j<=n,j++)
          result[i][j]:=ApplyPure(func,{i,j});
  
  result;
];
HoldArg("GenMatrix",func);
UnFence("GenMatrix",3);

// The arguments of the following functions
// should be checked

// this takes N funcs in N vars
JacobianMatrix(f,v):=GenMatrix({{i,j},Deriv(v[j])f[i]},Length(f),Length(f));

// this takes 1 func in N vars
HessianMatrix(f,v):=GenMatrix({{i,j}, Deriv(v[i]) Deriv(v[j]) f},Length(v),Length(v));

// this takes N funcs in 1 var
WronskianMatrix(f,v):=GenMatrix({{i,j}, Deriv(v,i-1) f[j]}, Length(f), Length(f) );

// notoriously hard to manipulate numerically
HilbertMatrix(n):=GenMatrix({{i,j}, 1/(i+j-1)}, n,n );
HilbertMatrix(m,n):=GenMatrix({{i,j}, 1/(i+j-1)}, m,n );
HilbertInverseMatrix(n):=GenMatrix({{i,j}, 
	(-1)^(i+j)*(i+j-1)*Bin(n+i-1,n-j)*Bin(n+j-1,n-i)*Bin(i+j-2,i-1)^2},n,n);

HankelMatrix(n):=GenMatrix({{i,j}, If(i+j-1>n,0,i+j-1) }, n,n );
HankelMatrix(m,n):=GenMatrix({{i,j}, If(i+j-1>n,0,i+j-1)}, m,n );

ToeplitzMatrix(N):=GenMatrix({{i,j},N[Abs(i-j)+1]}, Length(N), Length(N) );

10 # Norm(_v) <-- PNorm(v,2);

// p-norm, reduces to euclidean norm when p = 2
Function("PNorm",{v,p})
[
	Local(result,i);
	Check(p>=1,"PNorm: p must be >= 1");

	result:=0;
	For(i:=1,i<=Length(v),i++)[
		result:=result+Abs(v[i])^p;
	];

	// make it look nicer when p = 2	
	If(p=2,Sqrt(result),(result)^(1/p) );
];

// This is the standard textbook definition of the Gram-Schmidt
// Orthogonalization process, from:
// Friedberg,Insel,Spence "Linear Algebra"  (1997)
// TODO: This function does not check if the input vectors are LI, it
// only checks for zero vectors
Function("OrthogonalBasis",{W})[
	Local(V,j,k);

	V:=ZeroMatrix(Length(W),Length(W[1]) );

	V[1]:=W[1];
	For(k:=2,k<=Length(W),k++)[
		Check(Not IsZero(Norm(W[k])) ,
			"OrthogonalBasis: Input vectors must be linearly independent");
		V[k]:=W[k]-Sum(j,1,k-1,InProduct(W[k],V[j])*V[j]/Norm(V[j])^2);
	];	
	V;
];
// Like orthogonalization, only normalize all vectors
Function("OrthonormalBasis",{W})[
	Local(i);
	W:=OrthogonalBasis(W);
	For(i:=1,i<=Length(W),i++)[
		W[i]:=W[i]/Norm(W[i]);
	];
	W;
];


/* Code that returns the list of the dimensions of a tensor
   Code submitted by Dirk Reusch.
 */

LocalSymbols(x,i,n,m,aux,dim,result)
[
1 # Dimensions(x_IsList) <-- 
    [
      Local(i,n,m,aux,dim,result);
      result:=List(Length(x));
//Echo("GETTING ",x);
//Echo(Length(Select(IsList,x)));
//Echo("END");
      If(Length(x)>0 And Length(Select(IsList,x))=Length(x),
      [
        n:=Length(x);
	dim:=MapSingle(Dimensions,x);
	m:=Min(MapSingle(Length,dim));
	
	For(i:=1,i<=m,i++)
	[
	    aux:=Table(dim[j][i],j,1,n,1);
	    If(Min(aux)=Max(aux),
	    result:=DestructiveAppend(result,dim[1][i]),
	    i:=m+1);
        ];
      ]);
//Echo(x,result);
      result;
    ];

2 # Dimensions(_x) <-- List();
];

//////
//////

//////
// dot product for vectors and matrices (dr)
//////

_x . _y <-- Dot(x,y);

LocalSymbols(Dot0,Dot1)
[
// vector . vector
Dot(t1_IsVector,t2_IsVector)_(Length(t1)=Length(t2)) <--
   Dot0(t1,t2,Length(t1));

// matrix . vector
Dot(t1_IsMatrix,t2_IsVector)_(Length(t1[1])=Length(t2)) <--
[
   Local(i,n,m,result);
   n:=Length(t1);
   m:=Length(t2);
   result:=List();
   For(i:=1,i<=n,i++)
	DestructiveInsert(result,1,Dot0(t1[i],t2,m));
   DestructiveReverse(result);
];

// vector . matrix
Dot(t1_IsVector,t2_IsMatrix)_(Length(t1)=Length(t2)
                               And Length(t2[1])>0) <--
   Dot1(t1,t2,Length(t1),Length(t2[1]));

// matrix . matrix
Dot(t1_IsMatrix,t2_IsMatrix)_(Length(t1[1])=Length(t2)
                                  And Length(t2[1])>0) <--
[
   Local(i,n,k,l,result);
   n:=Length(t1);
   k:=Length(t2);
   l:=Length(t2[1]);
   result:=List();  
   For(i:=1,i<=n,i++)
      DestructiveInsert(result,1,Dot1(t1[i],t2,k,l));
   DestructiveReverse(result);
];
  
// vector . vector
Dot0(_t1,_t2,_n) <--
[
   Local(i,result);
   result:=0;
   For(i:=1,i<=n,i++)
      result:=result+t1[i]*t2[i];
   result;
];
  
// vector . matrix
// m vector length
// n number of matrix cols
Dot1(_t1,_t2,_m,_n) <--   
[
   Local(i,j,result);
   result:=ZeroVector(n);
   For(i:=1,i<=n,i++)
      For(j:=1,j<=m,j++)
         result[i]:=result[i]+t1[j]*t2[j][i];
   result;
];
  
]; // LocalSymbols(Dot0,Dot1)

//////
//////

//////
// power of a matrix (dr)
//////

MatrixPower(x_IsSquareMatrix, n_IsNonNegativeInteger) <--
[
   Local(result);
   result:=Identity(Length(x));
   While(n != 0)
   [
      If(IsOdd(n),
         result:=Dot(result,x));
      x:=Dot(x,x);
      n:=n>>1;
   ];
   result;
];

MatrixPower(x_IsSquareMatrix, n_IsNegativeInteger) <--
   MatrixPower(Inverse(x),-n);

//////
//////
