////////////////////////
// Written by Alberto Gonz√°lez Palomo and Ayal Pinkus.
////////////////////////

/* The read-eval-print loop */
RuleBase("OMREP",{});
LocalSymbols(input,stringOut,result)
Rule("OMREP",0,1,True)
[
  Local(input,stringOut,result);
  While(Not(IsExitRequested()))
  [
    Set(errorObject, "");
    TrapError(Set(input, FromString(ConcatStrings(ReadCmdLineString("")," "))OMRead()),Set(errorObject,OMGetCoreError()));
    If(Not(errorObject = ""), errorObject);
    If (Not(IsExitRequested()) And errorObject="",
    [
      Set(stringOut,"");
      Set(result,False);
      TrapError(Set(stringOut,ToString()[Secure(Set(result,Eval(input)));]),Set(errorObject,OMGetCoreError()));
      If(Not(errorObject = ""), errorObject);
      If(Not(stringOut = ""), WriteString(stringOut));
      Set(%,result);
      LazyGlobal(%);
      If(GetPrettyPrinter()="",
      [
        Apply("OMForm",{result});
      ],
      Apply(GetPrettyPrinter(),{result}));
      Exit();
    ]);
  ];
];


///////////////////////////////////////////////////////////////////////
// Output

10 # OMForm(_expression)
//     <-- "<OMOBJ>" : OMFormExpression(expression) : "</OMOBJ>";
     <--
     [
     omindent := 0;
     OMEcho("<OMOBJ>");
     OMIndent();
     If(IsAtom(expression),
        If(expression = Atom("%"),
           Secure(expression := Eval(expression))
           )
        );
     OMFormExpression(expression);
     OMUndent();
     OMEcho("</OMOBJ>");
     ];

10 # OMFormExpression(i_IsString)  <-- OMEcho("<OMSTR>":i:"</OMSTR>");
11 # OMFormExpression(i_IsInteger) <-- OMEcho("<OMI>":String(i):"</OMI>");
12 # OMFormExpression(i_IsNumber)  <-- OMEcho("<OMF dec=\"":String(i):"\"/>");
13 # OMFormExpression(i_IsConstant)_(OMSymbol[ String(i) ] != Empty)
     <-- OMEcho("<OMS cd=\"":OMSymbol[ String(i) ][1]
                :"\" name=\"":OMSymbol[ String(i) ][2]:"\"/>"
                );
14 # OMFormExpression(i_IsConstant)// Should we rather evaluate it?
     <-- OMEcho("<OMV name=\"":String(i):"\"/>");
15 # OMFormExpression(i_IsVariable)_(OMSymbol[ String(i) ] != Empty)
     <-- OMEcho("<OMS cd=\"":OMSymbol[ String(i) ][1]
                :"\" name=\"":OMSymbol[ String(i) ][2]:"\"/>"
                );
16 # OMFormExpression(i_IsVariable)
     <-- OMEcho("<OMV name=\"":String(i):"\"/>");
16 # OMFormExpression(i_IsVariable)_(i = Empty)
     <-- False; // This is useful for void expressions.

10 # OMFormExpression(function_IsFunction)_(Type(function) = "OMError")
     <--
     [
     Local(cd, name);
     If(IsList(function[1]),
        [ cd := function[1][1]; name := function[1][2]; ],
        [ cd := "error";        name := function[1];    ]);
     OMEcho("<OME>");
     OMIndent();
     OMEcho("<OMS cd=\"":cd:"\" name=\"":name:"\"/>");
     ForEach(i, Tail(function)) OMFormExpression(i);
     OMUndent();
     OMEcho("</OME>");
     ];
10 # OMFormExpression(function_IsFunction)_(Type(function) = "OMS")
     <-- OMEcho("<OMS cd=\"":function[1]:"\" name=\"":function[2]:"\"/>");
10 # OMFormExpression(function_IsFunction)_(Type(function) = "OMBIND")
     <--
     [
     OMEcho("<OMBIND>");
     OMIndent();
     ForEach(i, function) OMFormExpression(i);
     OMUndent();
     OMEcho("</OMBIND>");
     ];
10 # OMFormExpression(function_IsFunction)_(Type(function) = "OMBVAR")
     <--
     [
     OMEcho("<OMBVAR>");
     OMIndent();
     ForEach(i, function) OMFormExpression(i);
     OMUndent();
     OMEcho("</OMBVAR>");
     ];
11 # OMFormExpression(function_IsFunction)
     <--
     [
     Local(arity);
     arity := Length(function);
     OMEcho("<OMA>");
     OMIndent();
     OMFormFunction(function);
     OMUndent();
     OMEcho("</OMA>");
     ];

11 # OMFormFunction(_function_IsFunction)
     <--
     [
     Local(arity);
     arity := Length(function);
     OMEcho("<OMS cd=\"yacas\" name=\"":Type(function):"\"/>");
     If(arity > 0, ForEach(arg, function) OMFormExpression(arg));
     ];
10 # OMFormFunction(function_IsFunction)_(OMSymbol[ Type(function) ] != Empty)
     <--
     [
     Local(symbolDef);
     // [20051016 AGP] The "signature" feature is an old attept at pattern
     // matching, but now that we have real predicates in the mappings it's
     // probably obsolete. I'll think about removing it.
     symbolDef := OMSymbol[ OMSignature(function) ];
     If(symbolDef = Empty, symbolDef := OMSymbol[ Type(function) ] );
     If(symbolDef = Empty Or Length(symbolDef) < 3 Or symbolDef[3] = {},
        [
        OMEcho("<OMS cd=\"":symbolDef[1]:"\" name=\"":symbolDef[2]:"\"/>");
        ForEach(arg, function) OMFormExpression(arg);
        ],
        [
        Local(result);
        result := OMApplyMapping(function, symbolDef[3]);
        //Check(IsList(result), ToString()Echo("Mapping result is not a list: ", result));
        If(IsList(result),
           [
           result := UnList(Subst($, function[0]) result);
           OMFormExpression(result[0]);
           ForEach(i, result) OMFormExpression(i);
           ],
           If(result = Empty,
              Echo("No rule matched ", function, symbolDef[3]),
              Echo("Unexpected result value from OMApplyMapping(): ", result)
             )
          );
        ]
       );
     ];

omindent := 0;
OMIndentSpace() :=
[
  Space(omindent);
];

OMWrite(_expression) <--
[
  Write(expression);
];

OMEcho(_expression) <--
[
  OMIndentSpace();
  Write(expression);
  NewLine();
];
OMEcho(expression_IsString) <--
[
  OMIndentSpace();
  WriteString(expression);
  NewLine();
];
OMEcho(expression_IsList) <--
[
  ForEach(arg, expression)
  [
    If (IsString(arg), WriteString(arg), Write(arg));
  ];
  NewLine();
];

OMEscape(_expression) <--
[
  "<![CDATA[":String(expression):"]]>";
];
OMEscapeString(_expression_IsString) <--
[
  "<![CDATA[":expression:"]]>";
];
OMWriteEscape(_expression) <--
[
  WriteString(OMEscape(expression));
];
OMWriteStringEscape(expression_IsString) <--
[
  WriteString(OMEscapeString(expression));
];
OMEchoEscape(_expression) <--
[
  OMWriteEscape(expression);
  NewLine();
];
OMEchoEscape(expression_IsString) <--
[
  OMWriteStringEscape(expression);
  NewLine();
];
OMEchoEscape(expression_IsList) <--
[
  WriteString("<![CDATA[");
  ForEach(arg, expression)
  [
    If (IsString(arg), WriteString(arg), Write(arg));
  ];
  WriteString("]]>");
  NewLine();
];
OMIndent() := [omindent := omindent + 2;];
OMUndent() := [omindent := omindent - 2;];

HoldArgNr("OMForm",1,1);
//HoldArgNr("OMFormExpression",1,1);
//HoldArgNr("OMFormFunction",1,1);


OMSignature(_function) <-- "";
OMSignature(function_IsFunction) <--
[
  Local(makeSig);
  makeSig := {ConcatStrings, Type(function), "_"};
  Local(type);
  type := "";// If "function" doesn't have arguments, the signature is "f_".
  ForEach(arg, function)
  [
    If(Type(arg) = "List",
       type := "L",
       If(IsFunction(arg),
          type := "F",
          If(IsInteger(arg),
             type := "I",
             type := "V"
             )
          )
       );
    DestructiveAppend(makeSig, type);
  ];
  Secure(Eval(UnList(makeSig)));
];
HoldArgNr("OMSignature", 1, 1);



///////////////////////////////////////////////////////////////////////
// Input

OMNextToken() :=
[
  OMToken := XmlExplodeTag(String(ReadToken()));
];

OMRead():=
[
  Local(result);
  TrapError(
  [
    XmlTokenizer();
    OMNextToken();
    result := MatchOMOBJ(OMToken);
    DefaultTokenizer();
  ],
  [
    result := OMGetCoreError();
    DefaultTokenizer();
  ]);
  result;
];


OMDump(str):=
FromString(str:" EndOfFile")
[
  Local(result);
  XmlTokenizer();
  OMNextToken();
  While(OMToken != "EndOfFile")
  [
    Echo("Exploded ",OMToken);
    OMNextToken();
  ];
  DefaultTokenizer();
  True;
];



10 # MatchClose(_x)_(x = OMToken) <-- [OMNextToken();True;];
20 # MatchClose(_x) <-- Check(False,ToString()Echo("encodingError:unexpected closing brace")); //@@@ TODO better error reporting

10 # MatchOMOBJ(XmlTag("OMOBJ",_attributes,"Open")) <--
[
  // Any attributes are ignored.
  Local(result);
  OMNextToken();
  result := ReadOMOBJ(OMToken);
  MatchClose(XmlTag("OMOBJ",{},"Close"));
  result;
];
10 # MatchOMOBJ(XmlTag("OMOBJ",_attributes,"OpenClose")) <--
[
  // Any attributes are ignored.
  // This is a void expression, of the form "<OMOBJ/>".
  Empty;
];
20 # MatchOMOBJ(_rest) <-- Check(False,ToString()Echo("encodingError:not an OMOBJ :",rest));

10 # ReadOMOBJ(XmlTag("OMOBJ",_attributes,"Close")) <--
[
  // This is a void expression, of the form "<OMOBJ></OMOBJ>".
  Empty;
];

10 # ReadOMOBJ(XmlTag("OMI",{},"Open")) <--
[
  Local(result);
  OMNextToken();
  result := Atom(OMToken);
  OMNextToken();
  MatchClose(XmlTag("OMI",{},"Close"));
  result;
];

10 # ReadOMOBJ(XmlTag("OMV",{{"NAME",_name}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

10 # ReadOMOBJ(XmlTag("OMF",{{"DEC",_dec}},"OpenClose")) <--
[
  OMNextToken();
  Atom(dec);
];

10 # ReadOMOBJ(XmlTag("OMA",{},"Open")) <--
[
  Local(result, new);
  result:={};
  OMNextToken();
  While (OMToken != XmlTag("OMA",{},"Close"))
  [
    new:=ReadOMOBJ(OMToken);
    DestructiveAppend(result,new);
  ];
  MatchClose(XmlTag("OMA",{},"Close"));
  OMApplyReverseMapping(UnList(result));
];

10 # ReadOMOBJ(XmlTag("OMBIND",{},"Open")) <--
[
  Local(result, new);
  result:={};
  OMNextToken();
  While (OMToken != XmlTag("OMBIND",{},"Close"))
  [
    new:=ReadOMOBJ(OMToken);
    DestructiveAppend(result,new);
  ];
  MatchClose(XmlTag("OMBIND",{},"Close"));
  result;
];
10 # ReadOMOBJ(XmlTag("OMBVAR",{},"Open")) <--
[
  Local(result, new);
  result:={};
  OMNextToken();
  While (OMToken != XmlTag("OMBVAR",{},"Close"))
  [
    new:=ReadOMOBJ(OMToken);
    DestructiveAppend(result,new);
  ];
  MatchClose(XmlTag("OMBVAR",{},"Close"));
  result;
];

10 # OMApplyReverseMapping(yacasExp_IsFunction) <-- yacasExp;
10 # OMApplyReverseMapping(yacasExp_IsFunction)_(OMSymbol[ Type(yacasExp) ] != Empty)
     <--
     [
     Local(symbolDef);
     symbolDef := OMSymbol[ Type(yacasExp) ];
     If(symbolDef[4] = {},
        result := yacasExp,
        [
          result := OMApplyMapping(yacasExp, symbolDef[4]);
          result := Subst($, yacasExp[0]) result;
          If(IsList(result), result := UnList(result));
          //result := UnList(yacasExp[0] : result);
        ]
       );
     result;
     ];

10 # OMApplyMapping(_function, _mapping) <--
[
  Local(expandRules, result);
  expandRules := { _(_path) <- OMPathSelect(path, function) };
  expandRules[1][2][2] := function;// the "function" variable is not expanded above.
  
  mapping := (mapping /: expandRules);// "/:" has lower precedence than ":=".
  
  Local(ruleMatched);
  ruleMatched := False;
  If(Type(mapping) = "|",
     [
     mapping := Flatten(mapping, "|");
     ForEach(rule, mapping)
       If(Not ruleMatched,
          [
          If(Type(rule) = "_",
             If( Eval(rule[2]), [ result := rule[1]; ruleMatched := True; ] ),
             [ result := rule; ruleMatched := True; ]
            );
          ]
         );
     ],
     [
     If(Type(mapping) = "_",
        If(Eval(mapping[2]),
           result := mapping[1],
           result := Listify(function)
          ),
	result := mapping
       );
     ruleMatched := True;
     ]
    );
  
  If(ruleMatched, result, Empty);
];

11 # OMPathSelect(path_IsNumber, _expression) <-- expression[path];
11 # OMPathSelect(path_IsList, _expression) <--
[
  ForEach(i, path) expression := expression[i];
  expression;
];
HoldArgNr("OMPathSelect", 2, 2);

// Special handling of the symbols in the "yacas" CD:

10 # ReadOMOBJ(XmlTag("OMS",{{"CD","yacas"}, {"NAME",_name}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

10 # ReadOMOBJ(XmlTag("OMS",{{"NAME",_name}, {"CD","yacas"}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

100 # ReadOMOBJ(XmlTag("OMS",{{"NAME",_name}, {"CD",_cd}},"OpenClose")) <-- OMCheck(False,OMError("unhandled_symbol", OMS(cd, name)));
100 # ReadOMOBJ(XmlTag("OMS",{{"CD",_cd}, {"NAME",_name}},"OpenClose")) <-- OMCheck(False,OMError("unhandled_symbol", OMS(cd, name)));
101 # ReadOMOBJ(_rest) <-- OMCheck(False,OMError({"moreerrors", "encodingError"}, ToString()Echo("unhandled tag: ",rest)));



///////////////////////////////////////////////////////////////////////
// Error reporting

Macro(OMCheck,{predicate,error})
[
  If(Not(@predicate),
  [
    Assert("omErrorObject", @error) False;
    Check(False,"omErrorObject");
  ]
  ,
  True);
];
OMGetCoreError():=
[
  Local(result);
  result := GetCoreError();
  If(result != "",
     If( IsError("omErrorObject"),
        [result := GetError("omErrorObject");                     ],
        [result := OMError({"moreerrors", "unexpected"}, result); ])
    );
  result;
];



///////////////////////////////////////////////////////////////////////
// Symbol mapping tables

OMSymbol := {};
OMSymbolReverse := {};

Macro(OMSymbol,{cd,name,to})
[
  10 # ReadOMOBJ(XmlTag("OMS",_props,"OpenClose"))_(props["CD"] = (@cd) And props["NAME"] = (@name)) <--
  [
    OMNextToken();
    Atom(@to);
  ];
];

OMDef(yacasname_IsString, omcd_IsString, omname_IsString, directMapping_IsFunction, reverseMapping_IsFunction) <--
[
  OMSymbol[ yacasname ] := {omcd, omname, directMapping, reverseMapping};
  If(OMSymbolReverse[ omcd ] = Empty,
     OMSymbolReverse[ omcd ] := {{omname, yacasname}},
     If(OMSymbolReverse[ omcd ][ omname ] = Empty,
        OMSymbolReverse[ omcd ][ omname ] := yacasname
        )// If you put a ";" here, the parser freaks out!
     );
  `OMSymbol(@omcd, @omname, @yacasname);
];

OMDef(yacasname_IsString, omcd_IsString, omname_IsString)
<-- OMDef(yacasname, omcd, omname, {}, {});

OMDef(yacasalias_IsString, yacasname_IsString) <--
[
  OMSymbol[ yacasalias ] := OMSymbol[ yacasname ];
];
HoldArgNr("OMDef", 5, 4 );
HoldArgNr("OMDef", 5, 5);

// [20010916 AGP] I couldn't find these symbols in the def files:
//     "E"        ,  "nums1", "e"
//     "Gamma"    ,  "nums1", "gamma"
OMDef( "Infinity" ,  "nums1", "infinity" );
OMDef( "Undefined",  "nums1", "NaN"      );
OMDef( "Pi",         "nums1", "pi"       );
// [20010916 AGP] From stdopers.ys:
OMDef( "And"   ,  "logic1", "and"        );
OMDef( "=="    ,  "logic1", "equivalent" );
OMDef( "!=="   ,  "logic1", "not",
                { "<OMA><OMS cd=\"logic1\" name=\"equivalent\"/>",
                  1,
                  2,
                  "</OMA>"
                }
      );
OMDef( "False",  "logic1", "false" );
OMDef( "Or"   ,  "logic1", "or"    );
OMDef( "True" ,  "logic1", "true"  );
//[20010916 AGP ] Xor is not available in Yacas.
//     "Xor"  ,  "logic1", "xor"   );
OMDef( "&" ,  "yacas", "bitwise_and" );
OMDef( "|" ,  "yacas", "bitwise_or"  );
OMDef( "%" ,  "yacas", "bitwise_xor" );
OMDef( "/" ,  "arith1", "divide" );
OMDef( "-" ,  "arith1", "unary_minus");
OMDef( "-" ,  "arith1", "minus"  );
OMDef( "+" ,  "arith1", "plus"   );
OMDef( "^" ,  "arith1", "power"  );
OMDef( "*" ,  "arith1", "times"  );
OMDef( "+" ,  "arith1", "plus"   );


Use("constants.rep/om.ys");
Use("stdfuncs.rep/om.ys");
Use("stubs.rep/om.ys");
Use("logic.rep/om.ys");
Use("complex.rep/om.ys");
Use("integrate.rep/om.ys");
Use("sums.rep/om.ys");
//Alberto, this file seems to be missing?
//Use("limit.rep/om.ys");
