////////////////////////
// Written by Alberto Gonz√°lez Palomo and Ayal Pinkus.
////////////////////////

/* The read-eval-print loop */
RuleBase("OMREP",{});
LocalSymbols(input,stringOut,result)
Rule("OMREP",0,1,True)
[
  Local(input,stringOut,result);
  While(Not(IsExitRequested()))
  [
    Set(errorString, "");
    TrapError(Set(input, FromString(ConcatStrings(ReadCmdLineString("")," "))OMRead()),Set(errorString,GetCoreError()));
    If(Not(errorString = ""), OMEcho(errorString));
    If (Not(IsExitRequested()) And errorString="",
    [
      Set(stringOut,"");
      Set(result,False);
      TrapError(Set(stringOut,ToString()[Set(result,Eval(input));]),Set(errorString,GetCoreError()));
      If(Not(errorString = ""), OMEcho(errorString));
      If(Not(stringOut = ""), WriteString(stringOut));
      Set(%,result);
      LazyGlobal(%);
      If(GetPrettyPrinter()="",
      [
        Apply("OMForm",{result});
      ],
      Apply(GetPrettyPrinter(),{result}));
      Exit();
    ]);
  ];
];


// Output

10 # OMForm(_expression)
//     <-- "<OMOBJ>" : OMFormExpression(expression) : "</OMOBJ>";
     <--
     [
     omindent := 0;
     OMEcho("<OMOBJ>");
     OMIndent();
     If(IsAtom(expression),
        If(expression = Atom("%"),
           expression := Eval(expression)
           )
        );
     OMFormExpression(expression);
     OMUndent();
     OMEcho("</OMOBJ>");
     ];

10 # OMFormExpression(i_IsString)  <-- OMEcho("<OMSTR>":i:"</OMSTR>");
11 # OMFormExpression(i_IsInteger) <-- OMEcho("<OMI>":String(i):"</OMI>");
12 # OMFormExpression(i_IsNumber)  <-- OMEcho("<OMF dec=\"":String(i):"\"/>");
13 # OMFormExpression(i_IsConstant)_(OMSymbol[ String(i) ] != Empty)
     <-- OMEcho("<OMS cd=\"":OMSymbol[ String(i) ][1]
                :"\" name=\"":OMSymbol[ String(i) ][2]:"\"/>"
                );
14 # OMFormExpression(i_IsConstant)// Should we rather evaluate it?
     <-- OMEcho("<OMV name=\"":String(i):"\"/>");
15 # OMFormExpression(i_IsVariable)_(OMSymbol[ String(i) ] != Empty)
     <-- OMEcho("<OMS cd=\"":OMSymbol[ String(i) ][1]
                :"\" name=\"":OMSymbol[ String(i) ][2]:"\"/>"
                );
16 # OMFormExpression(i_IsVariable)
     <-- OMEcho("<OMV name=\"":String(i):"\"/>");

10 # OMFormExpression(function_IsFunction)
     <--
     [
     OMEcho("<OMA>");
     OMIndent();
     OMFormFunction(function);
     OMUndent();
     OMEcho("</OMA>");
     ];
10 # OMFormFunction(_function)
     <--
     [
     Local(arity);
     arity := Length(function);
     OMEcho("<OMS cd=\"yacas\" name=\"":Type(function):"\"/>");
     If(arity > 0, ForEach(arg, function) OMFormExpression(arg));
     ];
10 # OMFormFunction(_function)_(OMSymbol[ Type(function) ] != Empty)
     <--
     [
     Local(symbolDef);
     Local(arity);
     symbolDef := OMSymbol[ OMSignature(function) ];
     If(symbolDef = Empty,
        symbolDef := OMSymbol[ Type(function) ]
        );
     arity := Length(function);
     OMEcho("<OMS cd=\"":symbolDef[1]:"\" name=\"":symbolDef[2]:"\"/>");
     If(symbolDef[3] = {},
        If(arity > 0, ForEach(arg, function) OMFormExpression(arg)),
        ForEach(i, symbolDef[3])
          [
           If(IsNumber(i),
              If(i <= arity,  OMFormExpression(function[i]) ),
              If(IsString(i), OMEcho(i)                     )
              );
          ]
        );
     ];

omindent := 0;
OMIndentSpace() :=
[
  Space(omindent);
];

OMWrite(_expression) <--
[
  Write(expression);
];

OMEcho(_expression) <--
[
  OMIndentSpace();
  Write(expression);
  NewLine();
];
OMEcho(expression_IsString) <--
[
  OMIndentSpace();
  WriteString(expression);
  NewLine();
];
OMEcho(expression_IsList) <--
[
  ForEach(arg, expression)
  [
    If (IsString(arg), WriteString(arg), Write(arg));
  ];
  NewLine();
];

OMWriteEscape(_expression) <--
[
  WriteString("<![CDATA[");
  Write(expression);
  WriteString("]]>");
];
OMWriteStringEscape(expression_IsString) <--
[
  WriteString("<![CDATA[");
  WriteString(expression);
  WriteString("]]>");
];
OMEchoEscape(_expression) <--
[
  OMWriteEscape(expression);
  NewLine();
];
OMEchoEscape(expression_IsString) <--
[
  OMWriteStringEscape(expression);
  NewLine();
];
OMEchoEscape(expression_IsList) <--
[
  WriteString("<![CDATA[");
  ForEach(arg, expression)
  [
    If (IsString(arg), WriteString(arg), Write(arg));
  ];
  WriteString("]]>");
  NewLine();
];
OMIndent() := [omindent := omindent + 2;];
OMUndent() := [omindent := omindent - 2;];

HoldArgNr("OMForm",1,1);
//HoldArgNr("OMFormExpression",1,1);
//HoldArgNr("OMFormFunction",1,1);


OMSignature(_noFunction) <-- "";
OMSignature(function_IsFunction) <--
[
  Local(makeSig);
  makeSig := {ConcatStrings, Type(function), "_"};
  Local(type);
  type := "";// If "function" doesn't have arguments, the signature is "f_".
  ForEach(arg, function)
  [
    If(Type(arg) = "List",
       type := "L",
       If(IsFunction(arg),
          type := "F",
          If(IsInteger(arg),
             type := "I",
             type := "V"
             )
          )
       );
    DestructiveAppend(makeSig, type);
  ];
  Eval(UnList(makeSig));
];



//////////////////////
// Input

OMNextToken() :=
[
  OMToken := XmlExplodeTag(String(ReadToken()));
];

// [2005-09-28 11:41 matmota] These functions are probably not used any more.
10 # OMProcessToken(_l, XmlTag("OMOBJ",_values,"Open")) <--
[
  Local(obj);
  obj := {};
  Local(tagClosed);
  tagClosed := False;
  While (OMToken != "EndOfFile" And tagClosed = False)
  [
    tagClosed := OMProcessToken(obj, OMNextToken());
  ];
  If(Length(obj) > 1,
     ReportError("An OpenMath object can only have one child element.")
     );
  If(Length(obj) > 0,
     DestructiveAppend(l, obj[1])
     );
  False;
];
10 # OMProcessToken(_l, XmlTag("OMOBJ",_values,"Close")) <-- True;
10 # OMProcessToken(_l, XmlTag("OMOBJ",_values,"OpenClose")) <-- True;
10 # OMProcessToken(_l, XmlTag("OMA",_values,"Open")) <--
[
  Local(obj);
  obj := {};
  Local(tagClosed);
  tagClosed := False;
  While (OMToken != "EndOfFile" And tagClosed = False)
  [
    tagClosed := OMProcessToken(obj, OMNextToken());
  ];
  DestructiveAppend(l, UnList(obj));
  False;
];
10 # OMProcessToken(_l, XmlTag("OMA",_values,"Close")) <-- True;
10 # OMProcessToken(_l, XmlTag("OMS",_values,"OpenClose"))
     <--
[
  ReportError("OpenMath symbol not defined: cd=\"", values[ "CD" ],
              "\", name=\"", values[ "NAME" ], "\"");
  DestructiveAppend(l, Empty);// Some "Error" symbol would be better.
  False;
];
10 # OMProcessToken(_l, XmlTag("OMS",_values,"OpenClose"))
     _(OMSymbolReverse[ values[ "CD" ] ] != Empty)
     _(OMSymbolReverse[ values[ "CD" ] ][ values [ "NAME" ] ] != Empty)
     <--
[
  DestructiveAppend(l, Atom(OMSymbolReverse[ values[ "CD"   ] ]
                                           [ values[ "NAME" ] ]));
  False;
];
10 # OMProcessToken(_l, XmlTag("OMI",_values,"Open"))
     <--
[
  Local(obj);
  obj := {};
  Local(tagClosed);
  tagClosed := False;
  While (OMToken != "EndOfFile" And tagClosed = False)
  [
    tagClosed := OMProcessToken(obj, OMNextToken());
  ];
  DestructiveAppend(l, obj[1]);
  False;
];
10 # OMProcessToken(_l, XmlTag("OMI",_values,"Close")) <-- True;
10 # OMProcessToken(_l, XmlTag("OMF",_values,"OpenClose"))
     <--
[
  DestructiveAppend(l, Atom(values[ "DEC" ]));
  False;
];
10 # OMProcessToken(_l, x_IsString)
     <--
[
  DestructiveAppend(l, Atom(x));
  False;
];


//////////////////////////////////////
// Symbol tables

OMSymbol := {};
OMSymbolReverse := {};

Macro(OMSymbol,{cd,name,to})
[
  10 # ReadOMOBJ(XmlTag("OMS",_props,"OpenClose"))_(props["CD"] = (@cd) And props["NAME"] = (@name)) <--
  [
    OMNextToken();
    Atom(@to);
  ];
];

OMDef(yacasname_IsString, omcd_IsString, omname_IsString, args_IsList) <--
[
  OMSymbol[ yacasname ] := {omcd, omname, args};
  If(OMSymbolReverse[ omcd ] = Empty,
     OMSymbolReverse[ omcd ] := {{omname, yacasname}},
     If(OMSymbolReverse[ omcd ][ omname ] = Empty,
        OMSymbolReverse[ omcd ][ omname ] := yacasname
        )// If you put a ";" here, the parser freaks out!
     );
  `OMSymbol(@omcd, @omname, @yacasname);
];

OMDef(yacasname_IsString, omcd_IsString, omname_IsString)
<-- OMDef(yacasname, omcd, omname, {});

OMDef(yacasalias_IsString, yacasname_IsString) <--
[
  OMSymbol[ yacasalias ] := OMSymbol[ yacasname ];
];

// [20010916 AGP] I couldn't find these symbols in the def files:
//     "E"        ,  "nums1", "e"
//     "Gamma"    ,  "nums1", "gamma"
OMDef( "Infinity" ,  "nums1", "infinity" );
OMDef( "Undefined",  "nums1", "NaN"      );
OMDef( "Pi",         "nums1", "pi"       );
// [20010916 AGP] From stdopers.ys:
OMDef( "And"   ,  "logic1", "and"        );
OMDef( "=="    ,  "logic1", "equivalent" );
OMDef( "!=="   ,  "logic1", "not",
                { "<OMA><OMS cd=\"logic1\" name=\"equivalent\"/>",
                  1,
                  2,
                  "</OMA>"
                }
      );
OMDef( "False",  "logic1", "false" );
OMDef( "Or"   ,  "logic1", "or"    );
OMDef( "True" ,  "logic1", "true"  );
//[20010916 AGP ] Xor is not available in Yacas.
//     "Xor"  ,  "logic1", "xor"   );
OMDef( "&" ,  "yacas", "bitwise_and" );
OMDef( "|" ,  "yacas", "bitwise_or"  );
OMDef( "%" ,  "yacas", "bitwise_xor" );
OMDef( "/" ,  "arith1", "divide" );
OMDef( "-" ,  "arith1", "unary_minus");
OMDef( "-" ,  "arith1", "minus"  );
OMDef( "+" ,  "arith1", "plus"   );
OMDef( "^" ,  "arith1", "power"  );
OMDef( "*" ,  "arith1", "times"  );
OMDef( "+" ,  "arith1", "plus"   );


Use("constants.rep/om.ys");
Use("stdfuncs.rep/om.ys");
Use("stubs.rep/om.ys");
Use("logic.rep/om.ys");
Use("complex.rep/om.ys");
Use("integrate.rep/om.ys");
Use("sums.rep/om.ys");


/* The code below implements OMRead, which parses OpenMath expressions.
*/

/*OMNextToken():=
[
  OMToken:=XmlExplodeTag(String(ReadToken()));
];
*/

OMRead():=
[
  Local(result);
  TrapError(
  [
    XmlTokenizer();
    OMNextToken();
    result := MatchOMOBJ(OMToken);
    DefaultTokenizer();
  ],
  [
    DefaultTokenizer();
    result:=False;
    Echo(GetCoreError());
  ]);
  result;
];


OMDump(str):=
FromString(str:" EndOfFile")
[
  Local(result);
  XmlTokenizer();
  OMNextToken();
  While(OMToken != "EndOfFile")
  [
    Echo("Exploded ",OMToken);
    OMNextToken();
  ];
  DefaultTokenizer();
  True;
];



10 # MatchClose(_x)_(x = OMToken) <-- [OMNextToken();True;];
20 # MatchClose(_x) <-- Check(False,ToString()Echo("unexpected closing brace")); //@@@ TODO better error reporting

10 # MatchOMOBJ(XmlTag("OMOBJ",_attributes,"Open")) <--
[
  // Any attributes are ignored.
  Local(result);
  OMNextToken();
  result := ReadOMOBJ(OMToken);
  MatchClose(XmlTag("OMOBJ",{},"Close"));
  result;
];
10 # MatchOMOBJ(XmlTag("OMOBJ",_attributes,"OpenClose")) <--
[
  // Any attributes are ignored.
  // This is a void expression.
];
20 # MatchOMOBJ(_rest) <-- Check(False,ToString()Echo("Not an OMOBJ :",rest));


10 # ReadOMOBJ(XmlTag("OMI",{},"Open")) <--
[
  Local(result);
  OMNextToken();
  result := Atom(OMToken);
  OMNextToken();
  MatchClose(XmlTag("OMI",{},"Close"));
  result;
];

10 # ReadOMOBJ(XmlTag("OMV",{{"NAME",_name}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

10 # ReadOMOBJ(XmlTag("OMF",{{"DEC",_dec}},"OpenClose")) <--
[
  OMNextToken();
  Atom(dec);
];

10 # ReadOMOBJ(XmlTag("OMA",{},"Open")) <--
[
  Local(result, new);
  result:={};
  OMNextToken();
  While (OMToken != XmlTag("OMA",{},"Close"))
  [
    new:=ReadOMOBJ(OMToken);
    DestructiveAppend(result,new);
  ];
  MatchClose(XmlTag("OMA",{},"Close"));
  UnList(result);
];

// Special handling of the symbols in the "yacas" CD:

10 # ReadOMOBJ(XmlTag("OMS",{{"CD","yacas"}, {"NAME",_name}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

10 # ReadOMOBJ(XmlTag("OMS",{{"NAME",_name}, {"CD","yacas"}},"OpenClose")) <--
[
  OMNextToken();
  Atom(name);
];

100 # ReadOMOBJ(_rest) <-- Check(False,ToString()Echo("Unhandled tag: ",rest));
