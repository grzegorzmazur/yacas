
/* 
to do list:
- passing along the locals, and how to access them, in every compile call
- code to handle local variables
- code to handle global variables
- process corefunctions.h so that all these functions are automatically known
- check number of arguments passed
- implement the most important macro type functions: Prog, If, While, Local.
- actually emit compilable code
- emit system calls to compile to plugin, and load and try
*/

/* Compile : compile an expression
 */
Macro()CompileStatement(expression);
CompileStatement(Defun(_cn,_ag) (_body)) <--
[
  Local(callName,compiledName,args,stack,i,nrArgs);
  Set(callName,(@cn));
  Set(args,(@ag));
  Set(compiledName,"Compiled_":(@cn));
  Set(nrArgs,Length(@ag));  
//  Echo("CORE_KERNEL_FUNCTION(\"",Type(@f),"\",",compiledName,",",nrArgs,",YacasEvaluator::Function | YacasEvaluator::Fixed)");

//TODO remove  funcDecls := {Type(@f),compiledName,nrArgs} : funcDecls;
  funcDecls[(@cn)] := {compiledName,Function,Fixed,nrArgs};

  Echo("void ",compiledName,"(LispEnvironment& aEnvironment,LispInt aStackTop)");
  Echo("{");
  Set(stack,NewStack());
  PushStackFrame(stack,fenced);
  For(i:=1,i<=nrArgs,i++)
  [
    AddToStack(stack,String(args[i]));
    FindOnStack(stack,String(args[i]))["call"] := "ARGUMENT(":String(i):")";
  ];  
  CompileBody(Hold(@body),stack);
  PopStackFrame(stack);
  Echo("  RESULT.Set(STACK(STACKTOP()-1).Get());");
  Echo("  POP(1);");
  Echo("}");
];



CompileStatement(f_IsFunction := _body) <--
[
  Local(callName,compiledName,args,stack,i,nrArgs);
  Set(callName,Type(@f));
  Set(args,Tail(Listify(@f)));
  Set(compiledName,"Compiled_":Type(@f));
  Set(nrArgs,NrArgs(@f));  
//  Echo("CORE_KERNEL_FUNCTION(\"",Type(@f),"\",",compiledName,",",nrArgs,",YacasEvaluator::Function | YacasEvaluator::Fixed)");

//TODO remove  funcDecls := {Type(@f),compiledName,nrArgs} : funcDecls;
  funcDecls[Type(@f)] := {compiledName,Function,Fixed,nrArgs};

  Echo("void ",compiledName,"(LispEnvironment& aEnvironment,LispInt aStackTop)");
  Echo("{");
  Set(stack,NewStack());
  PushStackFrame(stack,fenced);
  For(i:=1,i<=nrArgs,i++)
  [
    AddToStack(stack,String(args[i]));
    FindOnStack(stack,String(args[i]))["call"] := "ARGUMENT(":String(i):")";
  ];  
  CompileBody(Hold(@body),stack);
  PopStackFrame(stack);
  Echo("  RESULT.Set(STACK(STACKTOP()-1).Get());");
  Echo("  POP(1);");
  Echo("}");
];

Use("corefunctions.ys");
10  # CompileFn(_fname)_(coreFunctions[fname] != Empty And
                         coreFunctions[fname][2]=Function And
                         coreFunctions[fname][3]=Fixed) <-- coreFunctions[fname][1];

30  # CompileFn(_fname)_(funcDecls[fname] != Empty) <-- funcDecls[fname][1];
100 # CompileFn(_rest) <-- Empty;



//


10 # CompileBody(body_IsNumber,_stack) <--
[
  Echo("/* number : ",body," */");
  Echo("  PUSH(",CompiledConstant(String(body)),");");
//  Echo("  PUSH(ATOM(",String(String(body)),"));");
];

10 # CompileBody(body_IsString,_stack) <--
[
  Echo("/* string : ",body," */");
  Echo("  PUSH(",CompiledConstant("\\\"":body:"\\\""),");");
//  Echo("  PUSH(ATOM(\"\\\"",body,"\\\"\"));");
];

11 # CompileBody(body_IsAtom,_stack)_(IsOnStack(stack,String(body))) <--
[
  Echo("/* local : ",body," */");
  Echo("  PUSH(",FindOnStack(stack,String(body))["call"],".Get());");
];

//TODO handle global variables
12 # CompileBody(body_IsAtom,_stack) <--
[
  Echo("/* atom : ",body," */");
  Echo("  PUSH(",CompiledConstant(String(body)),");");
//  Echo("  PUSH(ATOM(",String(String(body)),"));");
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Local") <--
[
  Echo("/* ",body," */");
  Set(body,Tail(Listify(body)));
  Local(i,nr);
  Set(nr,Length(body));
  For(i:=1,i<=nr,i++)
  [
    //TODO handle initialization


    Echo("LispPtr ",body[i],"; ",body[i],".Set(",CompiledConstant(String(body[i])),");");
//    Echo("LispPtr ",body[i],"; ",body[i],".Set(ATOM(",String(String(body[i])),"));");
    AddToStack(stack,String(body[i]));
    FindOnStack(stack,String(body[i]))["call"] := String(body[i]);
  ];
  Echo("  PUSH(",CompiledConstant("True"),");");
];
  

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Set") <--
[
  Echo("/* ",body," */");
  Set(body,Tail(Listify(body)));
  CompileBody(body[2],stack);
  Echo("  ",FindOnStack(stack,String(body[1]))["call"],".Set(STACK(STACKTOP()-1).Get());");
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Prog") <--
[
  Set(body,Tail(Listify(body)));
  PushStackFrame(stack,unfenced);
  Echo("  PUSH(",CompiledConstant("True"),");");
  While(body != {})
  [
    Echo("  POP(1);");
    CompileBody(Head(body),stack);
    Set(body,Tail(body));
  ];
  PopStackFrame();
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "While") <--
[
  Set(body,Tail(Listify(body)));
  Echo("/* While (",body[1],") */");
  Echo("   for(;;)");
  Echo("{");
  CompileBody(body[1],stack);
//Echo("printf(\"Got here\\\n\");");
//Echo("printf(\"atom is [%s]\\n\",STACK(STACKTOP()-1).Get()->String()->String());");
  Echo("   if (ISFALSE(STACK(STACKTOP()-1))) break;");
  CompileBody(body[2],stack);
  Echo("  POP(2);");
  Echo("}");
];


20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "If") <--
[
  Set(body,Tail(Listify(body)));
  Echo("/* If (",body[1],") ",body[2]," */");
  If(Length(body) = 3,Echo("/* else ",body[3]," */"));

  CompileBody(body[1],stack);
  Echo("   if (ISTRUE(STACK(STACKTOP()-1)))");
  Echo("  {");
  Echo("    POP(1);");
  CompileBody(body[2],stack);
  Echo("  }");
  If(Length(body) = 3,
  [
    Echo("  else");
    Echo("  {");
    Echo("    POP(1);");
    CompileBody(body[3],stack);
    Echo("  }");
  ]);
];



90 # CompileBody(body_IsFunction,_stack)_(CompileFn(Type(body)) != Empty) <--
[
  Echo("  PUSH(NULL);");
  Echo("  {");

  Local(i,args,nrArgs,compileFn);
  Set(compileFn,CompileFn(Type(body)));
  Set(args,Tail(Listify(body)));
  Set(nrArgs,NrArgs(body));
  For(i:=1,i<=nrArgs,i++)
  [
    CompileBody(args[i],stack);
  ];
  Echo("    ",compileFn,"(aEnvironment,STACKTOP()-",(nrArgs+1),");");
  Echo("    POP(",nrArgs,");");
  Echo("  }");
];

100 # CompileBody(_body,_stack) <-- 
[
  
  
  Check(False,ToString()Echo("Unhandled expression type ",body));
];


fileCompileString:=
"
<?
LocalSymbols(expression)
FromFile(file)
[
  Local(expression);
  Set(expression,Read());
//Echo(expression);
  While(expression != EndOfFile)
  [
    `CompileStatement(@expression);
    Set(expression,Read());
//Echo(expression);
  ];
];
?>
";

fileBuildString:=
"
/* This file was automatically generated with compilecpp.
*/

//#include <stdio.h>

#include \"lisptype.h\"
#include \"lispenvironment.h\"
#include \"lispatom.h\"
#include \"standard.h\"
#include \"arggetter.h\"
#include \"lispplugin.h\"
#include \"platmath.h\"
#include \"stubs.h\"
#include \"genericstructs.h\"
#include \"mathcommands.h\"


#define ATOM(_x) LispAtom::New(aEnvironment,_x)
#define RESULT aEnvironment.iStack.GetElement(aStackTop)
#define ARGUMENT(i) aEnvironment.iStack.GetElement(aStackTop+i)
#define PUSH(_x)   aEnvironment.iStack.PushArgOnStack(_x)
#define POP(_i)    aEnvironment.iStack.PopTo(aEnvironment.iStack.GetStackTop() - _i)
#define STACKTOP() aEnvironment.iStack.GetStackTop()
#define STACK(_i)  aEnvironment.iStack.GetElement(_i)

#define ISTRUE(_x) IsTrue(aEnvironment, _x)
#define ISFALSE(_x) IsFalse(aEnvironment, _x)


<?
  ForEach(item,constDefs)
  [
    Echo(\"LispObject * \",item[2],\";\");
  ];
?>


<?
WriteString(funcDefs);
?>


class <?WriteString(\"Plugin_\":pluginName);?> : public LispPluginBase
{
public:
    virtual void Add(LispEnvironment& aEnvironment);
    virtual void Remove(LispEnvironment& aEnvironment);
};

void <?WriteString(\"Plugin_\":pluginName);?>::Add(LispEnvironment& aEnvironment)
{

<?
  ForEach(item,constDefs)
  [
    Echo(item[2],\" = ATOM(\",String(item[1]),\");\");
    Echo(item[2],\"->IncreaseRefCount();\");
  ];
?>

<?
[
  Local(cname,fname,nrargs,t1,t2);
  ForEach(item,funcDecls)
  [
    {fname,{cname,t1,t2,nrargs}}:=item;   
Echo(\"  aEnvironment.SetCommand(\",cname,\",\",String(fname),\",\",nrargs,\",YacasEvaluator::Function | YacasEvaluator::Fixed);\");
  ];
];
?>
}
void <?WriteString(\"Plugin_\":pluginName);?>::Remove(LispEnvironment& aEnvironment)
{
<?
  ForEach(item,constDefs)
  [
    Echo(item[2],\"->DecreaseRefCount();\");
  ];
?>

<?
[
  Local(cname,fname,nrargs,t1,t2);
  ForEach(item,funcDecls)
  [
    {fname,{cname,t1,t2,nrargs}}:=item;   
    Echo(\"aEnvironment.RemoveCoreCommand(\",String(fname),\");\");
  ];
];
?>
}


extern \"C\" {
// #ifdef EXE_DLL_PLUGINS
LispPluginBase* <?WriteString(\"make_\":pluginName);?>(void)
//#else
//LispPluginBase* maker(void)
//#endif
{
    return NEW <?WriteString(\"Plugin_\":pluginName);?>;
}
};
";
//{cname,fname,nrargs}

10 # CompiledConstant(string_IsString)_(constDefs[string] = Empty) 
   <--
   [
     Local(cst);
     Set(cst,"_constant":String(constCount));
     constDefs[string] := cst;
     constCount++;
     cst;
   ];
20 # CompiledConstant(string_IsString) <-- constDefs[string];

CompileCpp(file_IsString,pluginName_IsString)<--
[
  Local(funcDefs);
  Set(funcDecls,{});
  Set(constDefs,{});
  Set(constCount,0);
  Echo("Converting ",file," to C++ code");
  Set(funcDefs,PatchString(fileCompileString));
  Echo("Generating C++ file ",pluginName,".cpp");
  ToFile(pluginName:".cpp")WriteString(PatchString(fileBuildString));
];

CcMacOSX(file_IsString,pluginName_IsString)<--
[
  Echo("Compiling C++ file ",pluginName,".cpp into plugin ",pluginName,".so");
  SystemCall("/bin/sh ./libtool --mode=compile g++ -DHAVE_CONFIG_H  -I. -Isrc -Isrc/plat/linux32/ -O9 -Wall -pedantic -c ":pluginName:".cpp -o ":pluginName:".lo");
  SystemCall("/bin/sh ./libtool --mode=link    g++  -O9 -Wall -pedantic -o ":pluginName:".la -rpath /usr/local/lib/yacas -module -avoid-version -no-undefined  ":pluginName:".lo");
];


