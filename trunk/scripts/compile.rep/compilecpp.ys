
/* 
to do list:
- passing along the locals, and how to access them, in every compile call
- code to handle local variables
- code to handle global variables
- process corefunctions.h so that all these functions are automatically known
- check number of arguments passed
- implement the most important macro type functions: Prog, If, While, Local.
- actually emit compilable code
- emit system calls to compile to plugin, and load and try
*/

/* Compile : compile an expression
 */
 

Macro()CompileStatement(expression);

1000 # CompileStatement(_rest) <--
[
  Check(False,
    ToString()
    [
      Echo("Base statement can not be compiled ");
    ]);
];

CompileStatement(Defun(_cn,_ag) (_body)) <--
[
  Local(callName,compiledName,args,stack,i,nrArgs);
  Set(callName,(@cn));
  Set(args,(@ag));
  Set(compiledName,"Compiled_":(@cn));
  Set(nrArgs,Length(@ag));  
//  Echo("CORE_KERNEL_FUNCTION(\"",Type(@f),"\",",compiledName,",",nrArgs,",YacasEvaluator::Function | YacasEvaluator::Fixed)");

//TODO remove  funcDecls := {Type(@f),compiledName,nrArgs} : funcDecls;
  ForwardDeclareFixedFunction(@cn,nrArgs);
//  funcDecls[(@cn)] := {compiledName,Function,Fixed,nrArgs};

  Echo("void ",compiledName,"(LispEnvironment& aEnvironment,LispInt aStackTop)");
  Echo("{
    register LispEnvironment::YacasArgStack& _this_stack = aEnvironment.iStack;
    ");
  Set(stack,NewStack());
  PushStackFrame(stack,fenced);
  For(i:=1,i<=nrArgs,i++)
  [
    AddToStack(stack,String(args[i]));
    FindOnStack(stack,String(args[i]))["call"] := "ARGUMENT(":String(i):")";
  ];  
  CompileBody(Hold(@body),stack);
  PopStackFrame(stack);
  Echo("  RESULT.Set(STACK(STACKTOP()-1).Get());");
  Echo("  POP(1);");
  Echo("}");
];



CompileStatement(ForwardDeclareFixedFunction(_name,_nrArgs)) <--
[
//Echo("Name is ",@name," nrArgs is",@nrArgs);
//  /* funcDecls[name] := */ {"Compiled_bla",Function,Fixed,nrArgs};
  ForwardDeclareFixedFunction(@name,@nrArgs);
];
ForwardDeclareFixedFunction(name,nrArgs):=
[
  Local(newEntry,compiledName);
  Set(compiledName,"Compiled_":(name));
  Set(newEntry,{compiledName,Function,Fixed,nrArgs});
  If (funcDecls[name] = Empty,
    [
      funcDecls[name] := newEntry;
funcPrototypes := funcPrototypes:
"extern void ":compiledName:"(LispEnvironment& aEnvironment,LispInt aStackTop);
";

    ]);
  Check(funcDecls[name] = newEntry,
    ToString()
    [
      Echo("Function prototype for ",name," is declared more than once, incompatibly.");
      Echo("  Original definition: ",funcDecls[name]);
      Echo("  New definition: ",newEntry);
    ]
       );  
  
  True;
];

CompileStatement(f_IsFunction := _body) <--
[
  Local(callName,compiledName,args,stack,i,nrArgs);
  Set(callName,Type(@f));
  Set(args,Tail(Listify(@f)));
  Set(compiledName,"Compiled_":Type(@f));
  Set(nrArgs,NrArgs(@f));  
//  Echo("CORE_KERNEL_FUNCTION(\"",Type(@f),"\",",compiledName,",",nrArgs,",YacasEvaluator::Function | YacasEvaluator::Fixed)");

//TODO remove  funcDecls := {Type(@f),compiledName,nrArgs} : funcDecls;
//  funcDecls[Type(@f)] := {compiledName,Function,Fixed,nrArgs};
  ForwardDeclareFixedFunction(Type(@f),nrArgs);

  Echo("void ",compiledName,"(LispEnvironment& aEnvironment,LispInt aStackTop)");
  Echo("{");
  Set(stack,NewStack());
  PushStackFrame(stack,fenced);
  For(i:=1,i<=nrArgs,i++)
  [
    AddToStack(stack,String(args[i]));
    FindOnStack(stack,String(args[i]))["call"] := "ARGUMENT(":String(i):")";
  ];  
  CompileBody(Hold(@body),stack);
  PopStackFrame(stack);
  Echo("  RESULT.Set(STACK(STACKTOP()-1).Get());");
  Echo("  POP(1);");
  Echo("}");
];

Use("corefunctions.ys");
10  # CompileFn(_fname)_(coreFunctions[fname] != Empty 
                        /* And
                         coreFunctions[fname][2]=Function And
                         coreFunctions[fname][3]=Fixed */) <-- coreFunctions[fname] /*[1] */;


30  # CompileFn(_fname)_(funcDecls[fname] != Empty) <-- funcDecls[fname] /*[1]*/;
//hier
// 40  # CompileFn(_fname) <-- "Compiled_":fname;

100 # CompileFn(_rest) <-- Empty;



//


10 # CompileBody(body_IsNumber,_stack) <--
[
  Echo("/* number : ",body," */");
  Echo("  PUSH(",CompiledConstant(String(body)),");");
//  Echo("  PUSH(ATOM(",String(String(body)),"));");
];

10 # CompileBody(body_IsString,_stack) <--
[
  Echo("/* string : ",body," */");
  Echo("  PUSH(",CompiledConstant("\\\"":body:"\\\""),");");
//  Echo("  PUSH(ATOM(\"\\\"",body,"\\\"\"));");
];

11 # CompileBody(body_IsAtom,_stack)_(IsOnStack(stack,String(body))) <--
[
  Echo("/* local : ",body," */");
  Echo("  PUSH(",FindOnStack(stack,String(body))["call"],".Get());");
];

//TODO handle global variables
12 # CompileBody(body_IsAtom,_stack) <--
[
  Echo("/* atom : ",body," */");
  Echo("  PUSH(",CompiledConstant(String(body)),");");
//  Echo("  PUSH(ATOM(",String(String(body)),"));");
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Local") <--
[
  Echo("/* ",body," */");
  Set(body,Tail(Listify(body)));
  Local(i,nr);
  Set(nr,Length(body));
  For(i:=1,i<=nr,i++)
  [
    //TODO handle initialization


    Echo("LispPtr ",body[i],"; ",body[i],".Set(",CompiledConstant(String(body[i])),");");
//    Echo("LispPtr ",body[i],"; ",body[i],".Set(ATOM(",String(String(body[i])),"));");
    AddToStack(stack,String(body[i]));
    FindOnStack(stack,String(body[i]))["call"] := String(body[i]);
  ];
  Echo("  PUSH(",CompiledConstant("True"),");");
];
  

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Set") <--
[
  Echo("/* ",body," */");
  Set(body,Tail(Listify(body)));
  CompileBody(body[2],stack);
  Echo("  ",FindOnStack(stack,String(body[1]))["call"],".Set(STACK(STACKTOP()-1).Get());");
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "Prog") <--
[
  Set(body,Tail(Listify(body)));
  If(Length(body)=0,Set(body,{True}));
  PushStackFrame(stack,unfenced);
//  Echo("  PUSH(",CompiledConstant("True"),");");
  While(body != {})
  [
    CompileBody(Head(body),stack);
    Set(body,Tail(body));
    If(Length(body)>0,Echo("  POP(1);"));
  ];
  PopStackFrame();
];

20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "While") <--
[
  Set(body,Tail(Listify(body)));
  Echo("/* While (",body[1],") */");
  Echo("   for(;;)");
  Echo("{");
  CompileBody(body[1],stack);
//Echo("printf(\"Got here\\\n\");");
//Echo("printf(\"atom is [%s]\\n\",STACK(STACKTOP()-1).Get()->String()->String());");
  Echo("   if (ISFALSE(STACK(STACKTOP()-1))) break;");
  CompileBody(body[2],stack);
  Echo("  POP(2);");
  Echo("}");
];


20 # CompileBody(body_IsFunction,_stack)_(Type(body) = "If") <--
[
  Set(body,Tail(Listify(body)));
  Echo("/* If (",body[1],") ",body[2]," */");
  If(Length(body) = 3,Echo("/* else ",body[3]," */"));

  CompileBody(body[1],stack);
  Echo("   if (ISTRUE(STACK(STACKTOP()-1)))");
  Echo("  {");
  Echo("    POP(1);");
  CompileBody(body[2],stack);
  Echo("  }");
  If(Length(body) = 3,
  [
    Echo("  else");
    Echo("  {");
    Echo("    POP(1);");
    CompileBody(body[3],stack);
    Echo("  }");
  ]);
];

//LocalSymbols(item,body,stack)
[
  30 # CompileBody(body_IsList,_stack) <--
  [
  Echo("  PUSH(NULL);");
  Echo("  {");
  Echo("    LispPtr all;");
  Echo("    all.Set(aEnvironment.iList->Copy(LispFalse));");
  Echo("    LispIterator tail(all);");
  Echo("    tail.GoNext();");
  
  ForEach(item,body)
  [
    CompileBody(item,stack);
  
  Echo("      tail.Ptr()->Set(STACK(STACKTOP()-1).Get()->Copy(LispFalse));");
  Echo("      tail.GoNext();");
  Echo("      POP(1);");
  ];
  Echo("    STACK(STACKTOP()-1).Set(LispSubList::New(all.Get()));");
  Echo("  }");
  ];
];

LocalSymbols(cFn)
[
  90 # CompileBody(body_IsFunction,_stack)_
       [
         Set(cFn,CompileFn(Type(body)));
         (cFn != Empty);
       ] <--
  [
    Local(compileFn);
    Set(compileFn,cFn);
    Echo("  PUSH(NULL);");
    Echo("  {");
  
    Local(i,args,nrArgs);
    Set(args,Tail(Listify(body)));
    Set(nrArgs,NrArgs(body));

    Check(compileFn[2]=Function,ToString()[Echo("Trying to call non-function ",Type(body));]);
    Check(compileFn[3]=Fixed,ToString()[Echo("Trying to call function with variable number of arguments ",Type(body));]);
    Check(compileFn[4]=nrArgs,ToString()[Echo("Trying to call function ",Type(body)," with ",nrArgs," arguments, expected ",compileFn[4]);]);

    For(i:=1,i<=nrArgs,i++)
    [
      CompileBody(args[i],stack);
    ];
  
  //hier
  //  Echo("    void ",compileFn,"(LispEnvironment& aEnvironment,LispInt aStackTop);");
  
    Echo("    ",compileFn[1],"(aEnvironment,STACKTOP()-",(nrArgs+1),");");
    If(nrArgs != 0,Echo("    POP(",nrArgs,");"));
    Echo("  }");
  ];
];


400 # CompileBody(_body,_stack) <-- 
[
  Check(False,ToString()Echo("Unhandled expression type ",body));
];


fileCompileString:=
"
<?
LocalSymbols(expression)
FromFile(file)
[
  Local(expression);
  Set(expression,Read());
//Echo(expression);
  While(expression != EndOfFile)
  [
    `CompileStatement(@expression);
    Set(expression,Read());
//Echo(expression);
  ];
];
?>
";

fileBuildString:=
"
/* This file was automatically generated with compilecpp.
*/

#include <stdio.h>

#include \"lisptype.h\"
#include \"lispenvironment.h\"
#include \"lispatom.h\"
#include \"standard.h\"
#include \"arggetter.h\"
#include \"lispplugin.h\"
#include \"platmath.h\"
#include \"stubs.h\"
#include \"genericstructs.h\"
#include \"mathcommands.h\"

//#define _this_stack (aEnvironment.iStack)
#define ATOM(_x) LispAtom::New(aEnvironment,_x)
#define RESULT _this_stack.GetElement(aStackTop)
#define ARGUMENT(i) _this_stack.GetElement(aStackTop+i)
#define PUSH(_x)   _this_stack.PushArgOnStack(_x)
#define POP(_i)    _this_stack.PopTo(_this_stack.GetStackTop() - _i)
#define STACKTOP() _this_stack.GetStackTop()
#define STACK(_i)  _this_stack.GetElement(_i)

#define ISTRUE(_x) IsTrue(aEnvironment, _x)
#define ISFALSE(_x) IsFalse(aEnvironment, _x)


<?
  ForEach(item,constDefs)
  [
    Echo(\"LispObject * \",item[2],\";\");
  ];
  Echo(funcPrototypes);
?>


<?
WriteString(funcDefs);
?>


class <?WriteString(\"Plugin_\":pluginName);?> : public LispPluginBase
{
public:
    virtual void Add(LispEnvironment& aEnvironment);
    virtual void Remove(LispEnvironment& aEnvironment);
};

void <?WriteString(\"Plugin_\":pluginName);?>::Add(LispEnvironment& aEnvironment)
{

<?
  ForEach(item,constDefs)
  [
    Echo(item[2],\" = ATOM(\",String(item[1]),\");\");
    Echo(item[2],\"->IncreaseRefCount();\");
  ];
?>

<?
[
  Local(cname,fname,nrargs,t1,t2);
  ForEach(item,funcDecls)
  [
    {fname,{cname,t1,t2,nrargs}}:=item;   
Echo(\"  aEnvironment.SetCommand(\",cname,\",\",String(fname),\",\",nrargs,\",YacasEvaluator::Function | YacasEvaluator::Fixed);\");
  ];
];
?>
}
void <?WriteString(\"Plugin_\":pluginName);?>::Remove(LispEnvironment& aEnvironment)
{
<?
  ForEach(item,constDefs)
  [
    Echo(item[2],\"->DecreaseRefCount();\");
  ];
?>

<?
[
  Local(cname,fname,nrargs,t1,t2);
  ForEach(item,funcDecls)
  [
    {fname,{cname,t1,t2,nrargs}}:=item;   
    Echo(\"aEnvironment.RemoveCoreCommand(\",String(fname),\");\");
  ];
];
?>
}


extern \"C\" {
// #ifdef EXE_DLL_PLUGINS
LispPluginBase* <?WriteString(\"make_\":pluginName);?>(void)
//#else
//LispPluginBase* maker(void)
//#endif
{
    return NEW <?WriteString(\"Plugin_\":pluginName);?>;
}
};
";
//{cname,fname,nrargs}

10 # CompiledConstant(string_IsString)_(constDefs[string] = Empty) 
   <--
   [
     Local(cst);
     Set(cst,"_constant":String(constCount));
     constDefs[string] := cst;
     constCount++;
     cst;
   ];
20 # CompiledConstant(string_IsString) <-- constDefs[string];

CompileCpp(file_IsString,pluginName_IsString)<--
[
  Local(funcDefs);
  Set(funcDecls,{});
  Set(funcPrototypes,"");
  Set(constDefs,{});
  Set(constCount,0);
  Echo("Converting ",file," to C++ code");
  Set(funcDefs,PatchString(fileCompileString));
  Echo("Generating C++ file ",pluginName,".cpp");
  ToFile(pluginName:".cpp")WriteString(PatchString(fileBuildString));
];

CcMacOSX(file_IsString,pluginName_IsString)<--
[
  Echo("Compiling C++ file ",pluginName,".cpp into plugin ",pluginName,".so");
  SystemCall("/bin/sh ./libtool --mode=compile g++ -DHAVE_CONFIG_H  -I. -Isrc -Isrc/plat/linux32/ -O9 -Wall -pedantic -c ":pluginName:".cpp -o ":pluginName:".lo");
  SystemCall("/bin/sh ./libtool --mode=link    g++  -O9 -Wall -pedantic -o ":pluginName:".la -rpath /usr/local/lib/yacas -module -avoid-version -no-undefined  ":pluginName:".lo");
];


