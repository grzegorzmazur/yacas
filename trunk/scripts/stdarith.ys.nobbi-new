/***********************/
/* Standard arithmetic */
/***********************/

/* Written by Norbert Nemec, Mar 22, 2003
   loosely based on former works found in the yacas library */

/*
This file deals with terms made up of
    unary "+","-"
    binary "+","-","*","/","^"

The following identities are assumed
[ a,b,c <- general objects, X,Y,Z <- numeric values ]
    (a+b)+c = a+(b+c)
    (a*b)*c = a*(b*c)
    + a = a
    -(-a) = a
    -(a+b) = (-a)+(-b)
    a-b = a+(-b)
    (-a)*b = a*(-b) = -(a*b)
    a*X = X*a
    a+X = X+a
    a+0 = a
    a*1 = a
    a/b = a*(1/b) = (1/b)*a   // inverse factors do commute -> see (*)
    1/(1/a) = b
    (1/a)*(1/b) = 1/(a*b)
    1/(-a) = -(1/a)
    X*a + Y*a = (X+Y)*a
    a/a = 1
furthermore all the usual rules for exact calculation with numeric values

The following is guaranteed for fully transformed terms
* there are no unary "+", superfluous 0 or 1
* products with divisions are normalized to something like (X*a*b*..*c)/(Y*d*e*..*f)
* unary "-" may only appear at the first summand of a sum (pulled out of products and
  cancelled out with additions/subtractions wherever possible)
* numeric factors are pulled to the front of every division free product
* numeric and rational summands are pulled to the rear of every sum
* numeric values are fully contracted and evaluated as far as possible in an exact way
* rationals and integer factors in divisions are fully normalized
* sums are expressed completely left-associative like (((a+b)+c)+X)
* products are expressed completely right-associative like (X*(a*(b*c)))
* directly neighboring identical summands are pulled together
* simple fraction normalizations are done. Only guarantee given: the first non-numeric
  factor of Numerator and Denomitator is cancelled out if identical.

Additional annotations:
* neither products nor sums are ever reordered except for sorting out numeric values
  and normalizing fractions to the format (a*b*..*c)/(d*e*..*f)
* products of sums are never expanded, except for the distribution of numerical factors
* sums of products with common factors are never contracted except where the remaining
  sum is purely numeric
* In general more simplifications might be done within the above set of identities,
  but by design, no rules should be added unless necessary to meet the guarantees.

(*) even though all the rules are safe for non-abelian algebras, this is not true for
    divisions. To be safe, use something like "inv" instead of division. ("inv" does not
    exist at the time of writing, but it would be the straightforward way when implementing
    advanced algebra stuff.)

The rules for powers are not very elaborate yet.
Neighboring identical factors are pulled together, and integer powers are calculated
where that's possible, but that's about it.

Historic remarks:
* Infinity has been completely removed. In a general context, it is not a well defined
  quantity. It should therefore be up to more specific packages (esp. limes) to use it
  where appropriate. In this general context, x/0 simply is undefined.
* Handling of lists and matrices has not been put into this file (yet?)
  There were ambiguities in the definitions which I didn't want to solve on my own.
  IMO, list and matrix handling should go to a separate file anyway.

*/


// unary "+" is simply removed as meaningless
100 # + _x  <-- x;


// "Undefined" is spread in every case
10 # Undefined + _y <-- Undefined;
10 # _x + Undefined <-- Undefined;

10 # - Undefined    <-- Undefined;

10 # Undefined - _y <-- Undefined;
10 # _x - Undefined <-- Undefined;

10 # Undefined * _y <-- Undefined;
10 # _x * Undefined <-- Undefined;

10 # Undefined / _y <-- Undefined;
10 # _x / Undefined <-- Undefined;


// handle special values
30 # z_IsZero + _x <-- x;
30 # _x + z_IsZero <-- x;

30 # z_IsZero - _x <-- -x;
30 # _x - z_IsZero <-- x;

30 # o_IsOne  * _x <-- x;
30 # _x * o_IsOne  <-- x;
30 # z_IsZero * _x <-- 0;
30 # _x * z_IsZero <-- 0;

30 # _x / o_IsOne  <-- x;
30 # z_IsZero / _x <-- 0;

// See infinity below
// 30 # _x / z_IsZero <-- Undefined;

// do numerics where it is exact
50 # x_IsNumber + y_IsNumber <-- MathAdd(x,y);
50 # - x_IsNumber <-- MathSubtract(0,x);
50 # x_IsNumber - y_IsNumber <-- MathSubtract(x,y);
50 # x_IsNumber * y_IsNumber <-- MathMultiply(x,y);
50 # (x_IsNumber / y_IsNumber)_Numeric <-- MathDivide(x,y);




// Normalize rational fractions
// TODO: check whether this might be to expensive
55 # (x_IsInteger / y_IsInteger)_(MathGcd(x,y) > 1) <--
    [
        Local(gcd);
        Set(x,x);
        Set(y,y);
        Set(gcd,MathGcd(x,y));
        MathDiv(x,gcd)/MathDiv(y,gcd);
    ];

55 # ((x_IsInteger * _z) / y_IsInteger)_(MathGcd(x,y) > 1) <--
    [
        Local(gcd);
        Set(x,x);
        Set(y,y);
        Set(gcd,MathGcd(x,y));
        (MathDiv(x,gcd)*z)/MathDiv(y,gcd);
    ];

55 # (x_IsInteger / (y_IsInteger * _z))_(MathGcd(x,y) > 1) <--
    [
        Local(gcd);
        Set(x,x);
        Set(y,y);
        Set(gcd,MathGcd(x,y));
        MathDiv(x,gcd)/(MathDiv(y,gcd)*z);
    ];

55 # ((x_IsInteger * _z) / (y_IsInteger * _v))_(MathGcd(x,y) > 1) <--
    [
        Local(gcd);
        Set(x,x);
        Set(y,y);
        Set(gcd,MathGcd(x,y));
        (MathDiv(x,gcd)*z)/(MathDiv(y,gcd)*v);
    ];

// numeric fractions
60 # x_IsNumber + y_IsNumber / z_IsNumber <--(x*z+y)/z;
60 # y_IsNumber / z_IsNumber + x_IsNumber <--(x*z+y)/z;
60 # x_IsNumber / v_IsNumber + y_IsNumber / z_IsNumber <--(x*z+y*v)/(v*z);

60 # x_IsNumber - y_IsNumber / z_IsNumber <--(x*z-y)/z;
60 # y_IsNumber / z_IsNumber - x_IsNumber <--(y-x*z)/z;
60 # x_IsNumber / v_IsNumber - y_IsNumber / z_IsNumber <--(x*z-y*v)/(v*z);

60 # (- (y_IsNumber / z_IsNumber)) - x_IsNumber <-- -((y+x*z)/z);
60 # (- (x_IsNumber / v_IsNumber)) - y_IsNumber / z_IsNumber <-- -((x*z+y*v)/(v*z));


/***************************/
/* Handling of minus signs */
/***************************/

// cancel out
 70 # - (- _x)    <-- x;

// pull into sums
 70 # - (_x - _y) <-- y - x;
 70 # - (_x + _y) <-- (-x) - y;

// Avoid unnecessary minus operators
 70 # _x + (- _y) <-- x-y;
 70 # _x - (- _y) <-- x+y;
// and, just for visual appearance:
 70 # _x + y_IsNegativeNumber <-- x-(-y);
 70 # _x - y_IsNegativeNumber <-- x+(-y);

// Pull minus operators and signs out of products
 70 # _x * (- _y) <-- -(x*y);
 70 # (- _x) * _y <-- -(x*y);
 70 # x_IsNegativeNumber * _y <-- -((-x)*y);

 70 # _x / (- _y) <-- -(x/y);
 70 # (- _x) / _y <-- -(x/y);
 70 # x_IsNegativeNumber / _y <-- -((-x)/y);
 70 # _x / y_IsNegativeNumber <-- -(x/(-y));





// pull together identical neighbors with plain numerical coefficients
100 # _x + _x   <-- 2*x;
100 # _x + n_IsNumber * _x   <-- (1+n)*x;
100 # n_IsNumber * _x + _x   <-- (n+1)*x;
100 # n1_IsNumber * _x + n2_IsNumber * _x   <-- (n1+n2)*x;

100 # (_y + _x) + _x   <-- y + 2*x;
100 # (_y + _x) + n_IsNumber * _x   <-- y + (1+n)*x;
100 # (_y + n_IsNumber * _x) + _x   <-- y + (n+1)*x;
100 # (_y + n1_IsNumber * _x) + n2_IsNumber * _x   <-- y + (n1+n2)*x;

100 # (_y - _x) + _x   <-- y;
100 # (_y - _x) + n_IsNumber * _x   <-- y + (n-1)*x;
100 # (_y - n_IsNumber * _x) + _x   <-- y - (n-1)*x;
100 # (_y - n1_IsNumber * _x) + n2_IsNumber * _x   <-- y + (n2-n1)*x;


100 # _x - _x   <-- 0;
100 # _x - n_IsNumber * _x   <-- (1-n)*x;
100 # n_IsNumber * _x - _x   <-- (n-1)*x;
100 # n1_IsNumber * _x - n2_IsNumber * _x   <-- (n1-n2)*x;

100 # (_y + _x) - _x   <-- y;
100 # (_y + _x) - n_IsNumber * _x   <-- y - (n-1)*x;
100 # (_y + n_IsNumber * _x) - _x   <-- y + (n-1)*x;
100 # (_y + n1_IsNumber * _x) - n2_IsNumber * _x   <-- y + (n1-n2)*x;

100 # (_y - _x) - _x   <-- y - 2*x;
100 # (_y - _x) - n_IsNumber * _x   <-- y - (n+1)*x;
100 # (_y - n_IsNumber * _x) - _x   <-- y - (1+n)*x;
100 # (_y - n1_IsNumber * _x) - n2_IsNumber * _x   <-- y - (n2+n1)*x;

100 # (- _x) - _x   <-- -(2*x);
100 # (- _x) - n_IsNumber * _x   <-- -((1+n)*x);
100 # (- (n_IsNumber * _x)) - _x   <-- -((n+1)*x);
100 # (- (n1_IsNumber * _x)) - n2_IsNumber * _x   <-- -((n1+n2)*x);

// Normalize simple fractions
// a and b are supposed to be numbers, but the rules only become simpler
// by generalizing to anything
100 # _x / _x <-- 1;
100 # _x / (_x * _z) <-- 1/z;
100 # (_x * _y) / _x <-- y;
100 # (_x * _y) / (_x * _z) <-- y/z;

100 # (_a * _x) / _x <-- a;
100 # (_a * _x) / (_x * _z) <-- a/z;
100 # (_a * (_x * _y)) / _x <-- a*y;
100 # (_a * (_x * _y)) / (_x * _z) <-- (a*y)/z;

100 # _x / (_b * _x) <-- 1/b;
100 # _x / (_b * (_x * _z)) <-- 1/(b*z);
100 # (_x * _y) / (_b * _x) <-- y/b;
100 # (_x * _y) / (_b * (_x * _z)) <-- y/(b*z);

100 # (_a * _x) / (_b * _x) <-- a/b;
100 # (_a * _x) / (_b * (_x * _z)) <-- a/(b*z);
100 # (_a * (_x * _y)) / (_b * _x) <-- (a*y)/b;
100 # (_a * (_x * _y)) / (_b * (_x * _z)) <-- (a*y)/(b*z);

// distribute numerical factors over sums
100 # x_IsRationalOrNumber * (_y + _z) <-- (x*y)+(x*z);
100 # x_IsRationalOrNumber * (_y - _z) <-- (x*y)-(x*z);


// sort plain numbers and rationals to the rear of sums
100 # (_x + y_IsRationalOrNumber) + z_IsRationalOrNumber <-- x+(y+z);
100 # (_x + y_IsRationalOrNumber) - z_IsRationalOrNumber <-- x+(y-z);
100 # (_x - y_IsRationalOrNumber) + z_IsRationalOrNumber <-- x-(y-z);
100 # (_x - y_IsRationalOrNumber) - z_IsRationalOrNumber <-- x-(y+z);
100 # x_IsRationalOrNumber + _y <-- y+x;
100 # x_IsRationalOrNumber - _y <-- (-y)+x;
110 # (_y + x_IsRationalOrNumber) + _z <-- (y+z)+x;
110 # (_y + x_IsRationalOrNumber) - _z <-- (y-z)+x;
110 # (_y - x_IsRationalOrNumber) + _z <-- (y+z)-x;
110 # (_y - x_IsRationalOrNumber) - _z <-- (y-z)-x;

// sort plain numbers to the front of products
100 # x_IsNumber * (y_IsNumber * _z) <-- (x*y)*z;
100 # _x * y_IsNumber <-- y*x;
110 # _x * (y_IsNumber * _z) <-- y*(x*z);

// Sort out fractions
100 # _x * (_y / _z) <-- (x*y)/z;
100 # (_x / _z) * _y <-- (x*y)/z;

// Reduce doublefractions
100 # _x / (_y / _z) <-- (x*z)/y;
100 # (_x / _y) / _z <-- x/(y*z);



// Assoziativity-Sorting
// sums are sorted to left associatitity
100 # _x + (_y + _z) <-- (x+y)+z;
100 # _x + (_y - _z) <-- (x+y)-z;

100 # _x - (_y + _z) <-- (x-y)-z;
100 # _x - (_y - _z) <-- (x-y)+z;

// sums are sorted to right associatitity
// (so that numerical factors at the front are at the top level of the tree)
100 # (_x * _y) * _z <-- x*(y*z);





/**********/
/* Powers */
/**********/

/* Powers are handled separately, since they are somewhat more complicated
   matter any might be split out some day
   there is much left to be cleaned up here */

// Combine neighboring identical factors to powers
1000 # _x * _x <-- x^2;
100 # _x * _x ^ n_IsNumber <-- x^(n+1);
100 # _x ^ n_IsNumber * _x <-- x^(n+1);
100 # _x ^ n1_IsNumber * _x ^ n2_IsNumber <-- x^(n1+n2);
100 # _x * (_x * _y) <-- x^2 * y;
100 # _x ^ n_IsNumber * (_x * _y) <-- x^(n+1) * y;
100 # _x * (_x ^ n_IsNumber * _y) <-- x^(n+1) * y;
100 # _x ^ n1_IsNumber * (_x ^ n2_IsNumber * _y) <-- x^(n1+n2) * y;


10 # Undefined ^ _y <-- Undefined;
10 # _x ^ Undefined <-- Undefined;

25 # z_IsZero ^ z_IsZero  <-- Undefined;
30 # o_IsOne  ^ _x <-- 1;
30 # z_IsZero ^ x_IsPositiveNumber <-- 0;
30 # _x ^ o_IsOne  <-- x;
30 # _x ^ z_IsZero <-- 1;

// doing some cosmetics before numeric evaluation
40 # (-_x)^m_IsEven <-- x^m;
40 # (x_IsConstant ^ (m_IsOdd / p_IsOdd))_(IsNegativeNumber(Re(N(x)))) <--
     -((-x)^(m/p));

// Faster version of raising power to 0.5
45 # (x_IsPositiveNumber ^ (1/2))_Numeric <-- MathSqrt(x);
45 # (x_IsPositiveNumber ^ 0.5)_Numeric <-- MathSqrt(x);
46 # (x_IsPositiveInteger ^ (1/2))_IsInteger(MathSqrt(x)) <-- MathSqrt(x);

50 # (x_IsNumber/y_IsNumber) ^ n_IsPositiveInteger <-- x^n/y^n;
50 # (x_IsNumber/y_IsNumber) ^ n_IsNegativeInteger <-- y^(-n)/x^(-n);
50 # x_IsNegativeNumber ^ n_IsEven <-- (-x)^n;
50 # x_IsNegativeNumber ^ n_IsOdd <-- -((-x)^n);
50 # x_IsPositiveNumber ^ n_IsPositiveInteger <-- MathPower(x,n);
50 # x_IsPositiveNumber ^ n_IsNegativeInteger <-- 1/MathPower(x,-n);
55 # (x_IsNumber ^ y_IsNumber)_Numeric <-- Exp(y*Ln(x));

70  # (_x ^ m_IsPositiveInteger) ^ n_IsPositiveInteger <-- x^(n*m);



/************/
/* Infinity */
/************/

/*
   The whole subject of Infinity without the context of a proper limes
   is mathematically extremely flaky.
   As a simple example, just consider the function 1/x which has
   a sign changing pole at x=0. So is 1/0=Infinity or -Infinity?
   Now, if the sign of Infinity cannot be distinguished, most of the
   following rules should collaps to Undefined and the whole concept
   of Infinity can be dropped as well.

   For the moment, I'll leave arithmetics on Infinity in for compatibility
   reasons. In the long run it should be dropped (keeping Infinity only as
   a symbol for specifying limits.
*/

20  # x_IsZero / y_IsZero <-- Sign(x)*Infinity;
30  # x_IsNumber / y_IsZero <-- Sign(x)*Infinity;
30  # x_IsZero * Infinity <-- Undefined;


50  # Infinity + Infinity <-- Infinity;
50  # Infinity - Infinity <-- Undefined;
50  # (-Infinity) + Infinity <-- Undefined;
50  # (-Infinity) - Infinity <-- -Infinity;
50  # (_a + Infinity) + Infinity <-- a+Infinity;
50  # (_a + Infinity) - Infinity <-- Undefined;
50  # (_a - Infinity) + Infinity <-- Undefined;
50  # (_a - Infinity) - Infinity <-- a-Infinity;
50  # Infinity / Infinity <-- Undefined;
50  # Infinity * Infinity <-- Infinity;

50  # Infinity + y_IsRationalOrNumber <-- Infinity;
50  # Infinity - y_IsRationalOrNumber <-- Infinity;
50  # (-Infinity) + y_IsRationalOrNumber <-- -Infinity;
50  # (-Infinity) - y_IsRationalOrNumber <-- -Infinity;
50  # (_a + Infinity) + y_IsRationalOrNumber <-- a+Infinity;
50  # (_a + Infinity) - y_IsRationalOrNumber <-- a+Infinity;
50  # (_a - Infinity) + y_IsRationalOrNumber <-- a-Infinity;
50  # (_a - Infinity) - y_IsRationalOrNumber <-- a-Infinity;

50  # x_IsNumber / Infinity <-- 0;

80  # y_IsNumber * Infinity <-- Sign(y)*Infinity;
80  # Infinity / y_IsNumber <-- Sign(y)*Infinity;


30  # 1 ^ n_IsInfinity <-- Undefined;
30  # Infinity ^ (y_IsNegativeNumber) <-- 0;
30  # (-Infinity) ^ (y_IsNegativeNumber) <-- 0;
30  # Infinity ^ 0 <-- Undefined;
30  # (-Infinity) ^ 0 <-- Undefined;

50  # Infinity ^ (_n) <-- Infinity;
50  # ((-Infinity) ^ (n_IsNumber))_(IsEven(n)) <-- Infinity;
50  # ((-Infinity) ^ (n_IsNumber))_(IsOdd(n)) <-- -Infinity;
50  # (x_IsNumber ^ Infinity)_(x> -1 And x < 1) <-- 0;
50  # (x_IsNumber ^ Infinity)_(x< -1) <-- - Infinity;
50  # (x_IsNumber ^ Infinity)_(x> 1) <-- Infinity;
50  # (x_IsNumber ^ -Infinity)_(x> -1 And x < 1) <-- Infinity;
50  # (x_IsNumber ^ -Infinity)_(x< -1) <-- 0;
50  # (x_IsNumber ^ -Infinity)_(x> 1) <-- 0;

100 # Infinity + _a <-- a + Infinity;
100 # Infinity - _a <-- (-a) + Infinity;
100 # (-Infinity) + _a <-- a - Infinity;
100 # (-Infinity) - _a <-- (-a) -Infinity;
100 # (_a + Infinity) + _b <-- (a+b)+Infinity;
100 # (_a + Infinity) - _b <-- (a-b)-Infinity;
100 # (_a - Infinity) + _b <-- (a+b)-Infinity;
100 # (_a - Infinity) - _b <-- (a-b)-Infinity;

100 # _a * Infinity <-- Infinity*a;




/**********************/
/* Lists and Matrices */
/**********************/

/*
    The list arithmetics are not yet well defined.
    (To some extend, lists act like vectors, but then
    rules like element-wise multiplication are just garbage)
     In my opinion, there should be a proper concept of vectors
     and matrices with their correct arithmetics, which should
    not be mangled with the element-wise operations defined here.

    For the moment, though, the former ad-hoc rules are left in
    place for compatibility.
*/

// first, handle matrix products, since they are lists as well.
90 # x_IsMatrix * y_IsMatrix <--
[
   Local(i,j,k,row,result);
   result:=ZeroMatrix(Length(x),Length(y[1]));
   For(i:=1,i<=Length(x),i++)
   For(j:=1,j<=Length(y),j++)
   For(k:=1,k<=Length(y[1]),k++)
   [
     row:=result[i];
     row[k]:= row[k]+x[i][j]*y[j][k];
   ];
   result;
];

LocalSymbols(xarg,yarg) [

95 # x_IsMatrix * y_IsList <-- Map({{xarg},xarg.y},{x});

100 # - (x_IsList) <-- MapSingle("-",x);

100 # (x_IsList + y_IsList)_(Length(x)=Length(y)) <-- Map("+",{x,y});
100 # (x_IsList - y_IsList)_(Length(x)=Length(y)) <-- Map("-",{x,y});
100 # (x_IsList * y_IsList)_(Length(x)=Length(y)) <-- Map("*",{x,y});
100 # (x_IsList / y_IsList)_(Length(x)=Length(y)) <-- Map("/",{x,y});
100 # (x_IsList ^ y_IsList)_(Length(x)=Length(y)) <-- Map("^",{x,y});

100 # (x_IsList + _y)_(Not IsList(y)) <-- Map({{xarg},xarg+y},{x});
100 # (_x + y_IsList)_(Not IsList(x)) <-- Map({{yarg},x+yarg},{y});

100 # (x_IsList - _y)_(Not IsList(y)) <-- Map({{xarg},xarg-y},{x});
100 # (_x - y_IsList)_(Not IsList(x)) <-- Map({{yarg},x-yarg},{y});

100 # (x_IsList * _y)_(Not IsList(y)) <-- Map({{xarg},xarg*y},{x});
100 # (_x * y_IsList)_(Not IsList(x)) <-- Map({{yarg},x*yarg},{y});

100 # (x_IsList / _y)_(Not IsList(y)) <-- Map({{xarg},xarg/y},{x});
100 # (_x / y_IsList)_(Not IsList(x)) <-- Map({{yarg},x/yarg},{y});

100 # (x_IsList ^ _y)_(Not IsList(y)) <-- Map({{xarg},xarg^y},{x});
100 # (_x ^ y_IsList)_(Not IsList(x)) <-- Map({{yarg},x^yarg},{y});

];
