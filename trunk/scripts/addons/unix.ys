/*
	MakeFunctionPlugin() - create an external plugin for a numerical function
	Version 0.1
	Requires: compiler named "c++" with ELF .so support; Yacas headers in FindFile("")/include; current directory must be writable
	Usage: MakeFunctionPlugin(ExtName, ArgList, Body)
*/

MakeArgumentList(argList, padding) := [ /* may assume to have a nonempty list */
	Local(item, result);
	/* build a list and add commas after 1st element */
	result := padding : String(Head(argList));
	ForEach(item, Tail(argList))
	  result := result : "," : padding : String(item);
	result;
];

MakeFunctionPrototype(name, argList) := [
	"double " : name : "(" : MakeArgumentList(argList, "double ") : ")";
];

// predicate to test whether plugins work
MakeFunctionPlugin() <--
[
	/* FIXME: We want all platform-dependent code to depend on the PlatformOS().
	   However, at the moment MakeFunctionPlugin only works on Linux computers. */
	If(OSVersion() = "linux-gnu" And FindFile("include/") != "", True, False);
];



MakeFunctionPlugin(_extName, _fBody) <--
[
	Local(dirBase, fileBase, intName, exportName, includeDir, dllName, dllPath, commandLine, argList);
	Check(MakeFunctionPlugin(), "MakeFunctionPlugin: error: the function plugin facility is not available.");
	/* check argument type */
	argList := VarList(fBody);
	Check(IsString(extName) And Length(argList) > 0,
	  "MakeFunctionPlugin: error: " : extName
	  : " must be a string and " : argList : " a nonempty list.");
	includeDir := FindFile("include/");
	Check(includeDir != "",
	  "MakeFunctionPlugin: error: cannot compile, no include/ under " : FindFile(""));
	/* determine file names */
	dirBase := "plugins.tmp/";	// where all plugin files will be kept
    Check(MakeDir(dirBase), "MakeFunctionPlugin: error: cannot create a temporary directory.");
	fileBase := dirBase : extName : "_plugin";
	intName := extName : "_plugin_cc";	// name of C++ function
	exportName := extName : "'plugin"; // name of intermediate Yacas function
	dllName := "lib" : intName : ".so";
	dllPath := dirBase : dllName;
	/* specify more include dirs to be able to compile from different places */
	commandLine := "c++ -shared -I. -I.. -I" : includeDir : " -I" : includeDir : "plat/linux32 -Wl,-soname," : dllName : " -o " : dllPath : " " : fileBase : ".cc " : fileBase : "_api.cc >& " : fileBase : ".log";
	/* write C++ header */
	ToFile(fileBase : ".h")
	  WriteString(
		"// GENERATED FILE: " : fileBase : ".h" : Nl()
		: MakeFunctionPrototype(intName, argList) : ";" : Nl()
	  );
	/* write C++ body */
	ToFile(fileBase : ".cc")
	  WriteString(
		"// GENERATED FILE: " : fileBase : ".cc" : Nl()
		: "#include \"stubs.h\"" : Nl()
		: "#include \"" : fileBase : ".h\"": Nl()
		: "#include <math.h>" : Nl()
		: "const double Pi=" : CForm(Hold(4.*ArcTan(1.))): ";" : Nl()
		: MakeFunctionPrototype(intName, argList) : " {" : Nl()
		: "return " : CForm(fBody) : ";" : Nl()
		: "}" : Nl()
	  );
	/* write Yacas stub */
	ToFile(fileBase : ".stub") [
	  WriteString(
	    "/* GENERATED FILE: " : fileBase : ".stub */" : Nl()
	    : "Use(\"cstubgen.rep/code.ys\"); StubApiCStart(\"" : String(UniqueConstant()) : "\");" : Nl()
	    : "StubApiCInclude(\"\\\"" : fileBase : ".h\\\"\");" : Nl()
	    : "StubApiCFunction(\"double\", \"" : intName : "\", \"" : exportName : "\",");
	  Write(FillList("double", Length(argList)));
	  WriteString(
	    ");" : Nl()
	    : "StubApiCFile(\"":fileBase:"\",\"" : fileBase : "_api\");" : Nl()
	  );
	];
	/* generate C++ stub */
	Load(fileBase : ".stub");
	/* compile plugin for Linux */
	ToFile(fileBase : ".compile") WriteString(commandLine : Nl());
	/* delete old file */
	DeleteFile(dllPath);
	SystemCall(commandLine);
	/* If compilation succeeds, DLL file is present */
	Check(FindFile(dllPath) = dllPath, "MakeFunctionPlugin: error: compilation of '" : dllPath : "' failed, consult " : fileBase : ".log");
	/* Load DLL file */
	DllUnload(dllPath);
	DllLoad(dllPath);
	Echo({"Function " : extName : "(" : MakeArgumentList(argList, ""): ") loaded from " : dllPath});
	/* define wrapper */
	NFunction(extName, exportName, argList);
];

/* Example code to read the PID of the Yacas process into the variable PID
	We have to jump through the hoops here because we can't redirect STDOUT to a Yacas stream... ideally it would be just this:
	PID := FromString(ToString() SystemCall("echo $PPID ';'")) Read();
*/
GetYacasPID() := [
	Check(PlatformOS()="Unix", "Error in GetYacasPID: need a Unix OS.");
	SystemCall("echo $PPID ';' > /tmp/yacas-tmpfile");
	{
		FromFile("/tmp/yacas-tmpfile") Read(),
		DeleteFile("/tmp/yacas-tmpfile")
	} [1];
];

/* show a Yacas expression graphically in a PS file */
/* The following global variable will define the available PS viewer */
If(Not(IsBound(PSViewCommand)), PSViewCommand := "gv");

ShowPS(expr) := [
	Check(PlatformOS()="Unix", "ShowPS: error: need a Unix OS.");
	/* Create a temporary file */
	SystemCall("echo \\\"/tmp/yacas-tmpfile-$$\\\" ';' > /tmp/yacas-tmpfile");
	filename := FromFile("/tmp/yacas-tmpfile") Read();
	SystemCall("rm -f /tmp/yacas-tmpfile");
	ToFile(filename : ".tex") WriteString(
"\\documentclass{article} \\usepackage{geometry} \\geometry{paperwidth=22in,paperheight=17in,tmargin=3in} \\begin{document} \\thispagestyle{empty}
" : TeXForm(expr) : "
\\end{document}
");
	WriteString("Expression exported as " : filename : ".tex" : Nl());
	/* Make PS file */
	SystemCall("cd /tmp; latex " : filename : " > /dev/null; dvips -E -q -T 22in,17in -o " : filename : ".ps " : filename : ".dvi");
	/* Show PS file */
	SystemCall(PSViewCommand : " " : filename : ".ps; rm -f " : filename : ".*");
];
