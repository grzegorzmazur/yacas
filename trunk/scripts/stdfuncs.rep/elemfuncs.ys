/** This file contains routines for numerical evaluation of elementary functions:
 *  MathPower, MathExp, MathSin etc.
 *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {Numeric} flag does not have to be set.)
 *  The result is an exact integer or a floating-point number correct to GetPrecision() digits.
 *
 *  If a better optimized version of these functions is available through the kernel,
 *  then the kernel version will automatically shadow these functions.
 *  These implementations are not necessarily the best optimized versions.
 */

/// MathMul2Exp(x,n): multiply x by 2^n.
10 # MathMul2Exp(_x,0) <-- x;
20 # MathMul2Exp(_x,_n)_(n>0) <-- MathMultiply(x, MathPower(2,n));
30 # MathMul2Exp(_x,_n)_(n<0) <-- MathDivide(x, MathPower(2,-n));


/*: Count number of bits in an integer or a float number. MathBitCount(0)=1. */
10 # MathBitCount(0) <-- 1;
20 # MathBitCount(_x) _ (x<0) <-- MathBitCount(-x);

30 # MathBitCount(_value) <--
[
	Local(nbits);
	nbits:=0;
  	If(value<1,
	[	// float value < 1, need to multiply by 2
		nbits := 1;
		While(value<1)
		[
			nbits--;
			value := MathMul2Exp(value,1); //FIXME this should work for floats too
		];
	],
	[	// need to divide by 2
		While(value>=1)
		[
			nbits++;
			value := MathMul2Exp(value, -1);
		];
	]);
	nbits;
];

// tests - can move to tests/ Serge? Shouldn't this move? Also, there was a typo, indicating
// there is no test code? ;-)
Verify(MathBitCount(4),3);
Verify(MathBitCount(-3), 2);
Verify(MathBitCount(3), 2);
Verify(MathBitCount(0), 1);
Verify(MathBitCount(-0.6), 0);
Verify(MathBitCount(0.5), 0);
Verify(MathBitCount(0.3),-1);


/// MathPower(x,y).
/// Compute x^y. Generally, x must be positive, except for integer y.
/// FIXME: No precision tracking yet.
// identities:
5 # MathPower(0, _y) <-- 0;
5 # MathPower(1, _y) <-- 1;
// integer powers:
10 # MathPower(_x, y_IsInteger) <-- IntPowerNum(x, y, MathMultiply, 1);
// real powers:
20 # MathPower(_x, _y) <-- MathExp(MathMultiply(y,MathLn(x)));


/// MathSqrt(x).
/// Compute square root(x) with nonnegative x. FIXME: No precision tracking yet.
10 # MathSqrt(0) <-- 0;
// BisectSqrt() works only on integers
//20 # MathSqrt(x_IsInteger) <-- BisectSqrt(x);
30 # MathSqrt(x_IsPositiveNumber) <-- x*NewtonNum({{r}, r+r*(1-x*r^2)/2}, FastPower(x,-0.5), 4, 2);

//{BisectSqrt(N)} computes the integer part of $ Sqrt(N) $ for integer $N$.
	//sqrt(1) = 1, sqrt(0) = 0
10 # BisectSqrt(0) <-- 0;
10 # BisectSqrt(1) <-- 1;

20 # BisectSqrt(N_IsPositiveInteger) <--
[
  Local(l2,u,v,u2,v2,uv2,n);

  // Find highest set bit, l2
  u  := N;
  l2 := MathBitCount(u)-1;

  // 1<<(l2/2) now would be a good under estimate 
  // for the square root. 1<<(l2/2) is definitely 
  // set in the result. Also it is the highest
  // set bit.
  l2 := l2>>1;

  // initialize u and u2 (u2==u^2).
  u  := 1 << l2;
  u2 := u << l2;
 
  // Now for each lower bit:
  While( l2 != 0 )
  [
 	 l2--;
     // Get that bit in v, and v2 == v^2.
      v  := 1<<l2;
      v2 := v<<l2;

      // uv2 == 2*u*v, where 2==1<<1, and 
      // v==1<<l2, thus 2*u*v == 
      // (1<<1)*u*(1<<l2) == u<<(l2+1)
      uv2 := u<<(l2 + 1);
 
      // n = (u+v)^2  = u^2 + 2*u*v + v^2 
      //   = u2+uv2+v2
       n := u2 + uv2 + v2;

      // if n (possible new best estimate for 
      // sqrt(N)^2 is smaller than N, then the 
      // bit l2 is set in the result, and 
      // add v to u.
      if( n <= N )
      [
	u  := u+v;  // u <- u+v
	u2 := n;    // u^2 <- u^2 + 2*u*v + v^2
      ];
    ];
    u; // return result, accumulated in u.
];

/// MathGcd(x,y). Compute the GCD of two integers using the binary Euclidean algorithm.
5 # MathGcd(x_IsNegativeInteger, y_IsInteger) <-- MathGcd(-x, y);
5 # MathGcd(y_IsNegativeInteger, x_IsNegativeInteger) <-- MathGcd(x, -y);
6 # MathGcd(0, _x) <-- 0;
6 # MathGcd(_x, 0) <-- 0;

10 # MathGcd(x_IsInteger, y_IsInteger) <--
[
	Local(z);
	While(x!=y)
	[
		While(x<y)
		[
			y:=y-x;
			While((y&1) = 0)
			[
				y := ShiftRight(y,1);
			];
		];
		z:=x;
		x:=y;
		y:=z;
	];
	x;
];

/// MathExp(x). Use the shifted squaring argument reduction and Taylor series.
/// FIXME: No precision tracking yet.

10 # MathExp(0) <-- 1;
20 # MathExp(_x)_(x<0) <-- MathDivide(1, MathExp(-x));
30 # MathExp(_x)_(x>1) <-- MathExp(MathMul2Exp(x,-1))^2;
40 # MathExp(_x) <--
// now 0<x<1
[	Local(y, prec, shift, result);
	prec:=GetPrecision();
	// find the optimal number of divisions by 2.
	// it is approximately (P*Ln(10)/Ln(2))^(1/3)-BitCount(P)
	shift := IntNthRoot(Div(prec*28738,8651),3)-MathBitCount(prec);
	// increase precision by some bits to allow for roundoff
	Precision(prec+IntLog(prec, 10)+2);
	// compute Exp(x/2^shift) - 1
	result := MathExp'Taylor1(MathMul2Exp(x,-shift));
	While(shift>0)
	[	// lose 'shift' bits of precision here
		result := MathMul2Exp(result, 1) + MathMultiply(result, result);
		shift--;
	];
	
	Precision(prec);
	RoundTo(1+result, prec);
];

/// Straightforward Taylor series, compute (Exp(x)-1)/x.
MathExp'Taylor1(x) :=
[
	Local(num'terms, prec, Bx);
	prec := MathDiv(GetPrecision()*3919, 1702); // P*Ln(10)
	Bx := -MathDiv(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2
	num'terms := MathDiv( prec-1, MathDiv( MathBitCount( prec-1)*1588, 2291)+Bx)+1;
	// (P*Ln(10)-1)/(Ln(P*Ln(10)-1)-Ln(x)-2); use Ln(x)<=B(x)*Ln(2)
	x*SumTaylorNum(x, 1, {{k}, 1/(k+1)}, num'terms);
];

/// Sin(x), Taylor series for Sin(x)/x
MathSin'Taylor(x) :=
[
	Local(num'terms, prec, Bx);
	prec := MathDiv(GetPrecision()*3919, 1702); // P*Ln(10)
	Bx := -MathDiv(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2
	num'terms := MathDiv( MathDiv( prec+Bx, MathDiv( MathBitCount( prec+Bx)*1588, 2291)+Bx)+1, 2)+1;
	// (P*Ln(10)-Ln(x)-2)/(Ln(P*Ln(10)-Ln(x)-2)-Ln(x)-2); use Ln(x)<=B(x)*Ln(2)
	x*SumTaylorNum(MathMultiply(x,x), 1, {{k}, -1/(2*k*(2*k+1))}, num'terms);
];

/// Cos(x), Taylor series
MathCos'Taylor(x) :=
[
	Local(num'terms, prec, Bx);
	prec := MathDiv(GetPrecision()*3919, 1702); // P*Ln(10)
	Bx := -MathDiv(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2
	num'terms := MathDiv( MathDiv( prec-1, MathDiv( MathBitCount( prec-1)*1588, 2291)+Bx), 2)+1;
	// (P*Ln(10)-1)/(Ln(P*Ln(10)-1)-Ln(x)-2); use Ln(x)<=B(x)*Ln(2)
	SumTaylorNum(MathMultiply(x,x), 1, {{k}, -1/(2*k*(2*k-1))}, num'terms);
];

/// Ln(x), Taylor series for Ln(1+y)/y, use only with 1/2<x<3/2
MathLn'Taylor(x) :=
[
	Local(num'terms, y);
	y := x-1;
	num'terms := MathDiv(GetPrecision()*2136, -643*MathBitCount(y))+1;
	// (P*Ln(10))/(-Ln(y)); use Ln(y)<=B(y)*Ln(2), only good for |y|<1/2
	// here -Ln(y) must be positive
	y*SumTaylorNum(-y, {{k}, 1/(k+1)}, num'terms);
];

/// ArcTan(x), Taylor series for ArcTan(x)/x, use only with -1/2<x<1/2
MathArcTan'Taylor(x) :=
[
	Local(num'terms);
	num'terms := MathDiv(GetPrecision()*1068, -643*MathBitCount(x))+1;
	// (P*Ln(10))/(-2*Ln(x)); use Ln(x)<=B(x)*Ln(2), only good for |x|<1/2
	// here -Ln(x) must be positive
	x*SumTaylorNum(-MathMultiply(x,x), {{k}, 1/(2*k+1)}, num'terms);
];

/// The constant Pi. Using a simple method, solve Cos(x)=0.
// iterate x := x + Cos(x) + 1/6 *Cos(x)^3 + ... to converge to x=Pi/2
MathPi() :=
[
	Local(result, delta, deltasq, k, order, prec, curprec);
	order := 13;	// order of approximation
	prec := GetPrecision();
	GlobalPush(Numeric);
	Numeric := True;
	/* initial approximation */
	curprec := 20;
	Precision(curprec);
	result := 3.14159265358979323846*0.5;
	// find optimal initial precision
	For(k:=prec, k>=curprec, k:=Div(k,order)+2) True;
	If(k<5, curprec:=5, curprec:=k);
//	Echo("initial precision", curprec);
	// now k is the iteration counter
	For(k:=0, curprec < prec, k := k+1) [
	// at this iteration we know the result to curprec digits
		curprec := Min(prec, curprec * order-2);	// 2 guard digits
		Precision(curprec+2);
		Echo("Iteration ", k, " setting precision to ", GetPrecision());
//		Echo("old result=", MathCos(result));
		Time([
		delta := MathCos(result);
		]);
		Time([
		deltasq := MathMultiply(delta,delta);
		]);
		result := Time(result + delta*(1 + deltasq*(1/6 + deltasq*(3/40 + deltasq*(5/112 + deltasq*(35/1152 + (deltasq*63)/2816))))));
	];
	Echo({"Method 3, using Pi/2 and order", order, ":", k, "iterations"});
	Numeric := GlobalPop();
	result*2;
];

