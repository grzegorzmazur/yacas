/* Tests on logic */

/* Small theorem prover for propositional logic, based on the
 * resolution principle.
 * Written by Ayal Pinkus
 * Version 0.1 initial implementation.
 *
 *
 * Examples:
CanProve(( (a=>b) And (b=>c)=>(a=>c) ))  <-- True
CanProve(a  Or   Not a)                  <-- True
CanProve(True  Or  a)                    <-- True
CanProve(False  Or  a)                   <-- a
CanProve(a  And   Not a)                 <-- False
CanProve(a  Or b Or (a And b))           <-- a Or b
 */

RuleBase("=>",{a,b});


/* Simplify a boolean expression. LogicSimplify is responsible
   for converting an expression to a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
   That is, a conjunction of disjunctions.
*/

10  # LogicSimplify( Not  True)                  <-- False;
11  # LogicSimplify( Not  False)                 <-- True;
12  # LogicSimplify(True   And  _x)              <-- LogicSimplify(x);
13  # LogicSimplify(False  And  _x)              <-- False;
14  # LogicSimplify(_x   And  True)              <-- LogicSimplify(x);
15  # LogicSimplify(_x  And  False)              <-- False;
16  # LogicSimplify(True   Or  _x)               <-- True;
17  # LogicSimplify(False  Or  _x)               <-- LogicSimplify(x);
18  # LogicSimplify(_x  Or  True )               <-- True;
19  # LogicSimplify(_x  Or  False)               <-- LogicSimplify(x);

/*TODO Vladimir: these break CanProve!
21  # LogicSimplify(_x  Or  _x)                  <-- LogicSimplify(x);
22  # LogicSimplify(_x  And  _x)                 <-- LogicSimplify(x);
23  # LogicSimplify(_x  Or Not (_x))             <-- True;
14  # LogicSimplify(Not (_x)  Or _x)             <-- True;
25  # LogicSimplify(_x  And Not (_x))            <-- False;
26  # LogicSimplify(Not (_x)  And _x)            <-- False;
*/

30  # LogicSimplify((_x)  Or  (_y))_(x!= LogicSimplify(x) Or y!=LogicSimplify(y))               /* Transform subexpression */
                                                <-- LogicSimplify(LogicSimplify(x) Or LogicSimplify(y));
35  # LogicSimplify( Not  (_x))_(x != LogicSimplify(x))
                                                <-- LogicSimplify(Not LogicSimplify(x));        /* Transform subexpression */

40 # LogicSimplify( Not ( Not  (_x)))           <-- LogicSimplify(x);                           /* eliminate double negation */
45 # LogicSimplify((_x)=>(_y))                  <-- LogicSimplify( Not x  Or  y);               /* eliminate implication */

50 # LogicSimplify( Not ((_x)  And  (_y)))      <-- LogicSimplify( Not x Or Not y );            /* De Morgan's law */
60 # LogicSimplify( Not ((_x)  Or  (_y)))       <-- LogicSimplify(Not x) And LogicSimplify(Not y); /* De Morgan's law */

70 # LogicSimplify(((_x)  And  (_y))  Or  (_z)) <-- LogicSimplify(x Or z) And LogicSimplify(y Or z);       /* Distribution */
80 # LogicSimplify((_x)  Or  ((_y)  And  (_z))) <-- LogicSimplify(x Or y) And LogicSimplify(x Or z);       /* Distribution */

90 # LogicSimplify((_x)  And  (_y))             <-- LogicSimplify(x) And LogicSimplify(y);      /* Transform subexpression */

101 # LogicSimplify( (_x) < (_y) )               <-- Simplify(x <   y);
102 # LogicSimplify( (_x) > (_y) )               <-- Simplify(x >   y);
103 # LogicSimplify( (_x) >= (_y) )              <-- Simplify(x >=  y);
104 # LogicSimplify( (_x) <= (_y) )              <-- Simplify(x <=  y);
105 # LogicSimplify( (_x) == (_y) )              <-- Simplify(x ==  y);
106 # LogicSimplify( (_x) !== (_y) )             <-- Simplify(x !== y);

111 # LogicSimplify( Not((_x) <  (_y)) )         <-- Simplify( x >= y );
112 # LogicSimplify( Not((_x) >  (_y)) )         <-- Simplify( x <= y );
113 # LogicSimplify( Not((_x) <= (_y)) )         <-- Simplify( x > y );
114 # LogicSimplify( Not((_x) >= (_y)) )         <-- Simplify( x < y );
115 # LogicSimplify( Not((_x) == (_y)) )         <-- Simplify( x !== y );
116 # LogicSimplify( Not((_x) !== (_y)) )        <-- Simplify( x == y );

200 # LogicSimplify(_x)                          <-- x;                          /* Accept as fully simplified, fallthrough case */


/* Simplify the logic expression to see if it is true. */
CanProveAux(_proposition) <--
[
  Local(negated,list,clauses);
  /* First get the LogicSimplify version of the negation of the proposition */
  negated:=LogicSimplify(proposition);
  list:=Flatten(negated,"And");
  clauses:={};
  ForEach(clause,list)
  [
    Local(newclause);
    newclause:=LogicRemoveTautologies(RemoveDuplicates(Flatten(clause,"Or")));
    If(newclause != {}, DestructiveAppend(clauses,newclause));
  ];

  clauses:=RemoveDuplicates(clauses);
  clauses:=LogicCombine(clauses);

  Local(result);
  result:=True;
  ForEach(item,clauses)
  [
    result:= result And UnFlatten(item,"Or",False);
  ];

  /* Second pass: simplify the resulting expression */

  LogicSimplify(result);
];

/* CanProve tries to prove that the negation of the negation of
   the proposition is true. Negating twice is just a trick to
   allow all the simplification rules a la De Morgan to operate
 */
CanProve(_proposition) <-- CanProveAux( Not CanProveAux( Not proposition));

/* LogicRemoveTautologies scans a list representing e1 Or e2 Or ... to find
   if there are elements p and  Not p in the list. This signifies p Or   Not p,
   which is always true. These are removed. Another function that is used
   is RemoveDuplicates, which converts p Or p into p.
 */
LogicRemoveTautologies(_e)<--
[
  Local(i);
  For(i:=1,i<=Length(e),i++)
  [
    Local(n);
    n:=LogicSimplify( Not  (e[i]));
    If(Contains(e,n),
       [
        If(i>=Find(e,n), Echo({"WRONG!!!"}));
         DestructiveDelete(e,Find(e,n));
         DestructiveDelete(e,i);
         i--;
       ]);
  ];
  e;
];

LogicFindWith(_list,_n)<--
[
  Local(i);
  Local(result);
  result:= -1;
  For(i:=1,(result<0) And (i<=Length(list)),i++)
  [
    If( /*Length(list[i])>1 And */ Contains(list[i],n),result:=i);
  ];
  result;
];

/* LogicCombine is responsible for scanning a list of lists, which represent
   a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ... by scanning the lists
   for combinations x Or Y  And   Not x Or Z => Y Or Z . If Y Or Z is empty then this clause
   is false, and thus the entire proposition is false.
 */
LogicCombine(_list) <--
[
  Local(i,j);
  For(i:=1,i<=Length(list),i++)
  [
    Local(redo);
    redo:=False;
/*    if (Length(list[i]) > 1) */
    For(j:=1,Not(redo) And (j<=Length(list[i])),j++)
    [
      Local(tocombine,n);
      n:=LogicSimplify( Not (list[i][j]));

      tocombine:=LogicFindWith(list,n);
      If(tocombine > 0 And i<tocombine,
         [
           If(i>=tocombine,Echo({"WRONG!!!"}));

           DestructiveDelete(list[i],j);
           DestructiveDelete(list[tocombine],Find(list[tocombine],n));
           list[i]:=
             LogicRemoveTautologies(RemoveDuplicates(Concat(list[i],list[tocombine])));
           DestructiveDelete(list,tocombine);
           If(list[i] = {False},list[i]:={});
           If(list[i] = {},
              [
               list:={{}};
               i:=Length(list)+1;
              ],
              i:=0);
           redo:=True;
         ]
        );
    ];
  ];
  list;
];