
Chapter()"The Yacas plugin structure";
Text()
"Yacas supports dynamically loading libraries at runtime. This allows
it to interface with other libraries that support additional
functionality. For example, there could be a plugin enabling
the user to script a user interface from within Yacas, or a
specific powerful library to do numeric calculations.
<p>
The plugin feature is currently in an experimental stage. There
are some examples in the plugins/ directory. These are not built
by default because they cannot be guaranteed to compile on every
platform (yet). The plugins need to be compiled after Yacas itself
has been compiled and installed successfully. The plugins/ directory
contains a README file with more details on compilation. 
<p>
In addition to the plugin structure in the Yacas engine, there is
a 'cstubgen' module (currently still in development) that allows
rapid scripting of a plugin. Essentially all that is required is
to write a file that looks like the header file of the original
library, but written in Yacas syntax. the 'cstubgen' module is then
able to write out a c++ file that can be compiled and linked with
the original library, and then loaded from within Yacas. Including
a function in the plugin will typically take just one line of
Yacas code. There are a few examples in the plugins/
directory (the files ending with api.stub). The make file
makefile.plugin is configured to automatically convert these to
the required c++ files.
<p>
In addition to the c++ stub file cstubgen also automatically generates
some documentation on the functions included in the stub. This
documentation is put in a file with extension 'description'.
<p>
The plugin facility is not supported for each platform yet. Specifically,
it is only supported on platforms that support the elf binary format.
(loading DLLs is platform-dependent).
<p>
This chapter assumes the reader is comfortable programming in c++.
";

AddAnchor("DllLoad");
SubSection()"DllLoad";
BuiltIn();
Topical()"Calling Sequence";
Text()"DllLoad(file)";

Topical()"Parameters";
Text()"file - file name of the plugin";

Topical()"Description";
Text()
"DllLoad forces Yacas to load the dynamic link library (.so file
under Linux). The full path to the DLL has to be specified,
or the file needs to be in a path where dlopen can find it.";

Topical()"Examples";
Text()
HtmlCommand(
"In> DllLoad(\"./libopengl.so\");
Out> True;
");

Topical()"See Also"; 
SeeAlso({});



AddAnchor("StubApiCStart");
SubSection()"StubApiCStart";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCStart()";

Topical()"Parameters";
Text()"";

Topical()"Description";
Text()
"To start up generating a c stub file for linking a c library with
Yacas. A stub specification file needs to start with this
function call, to reset the internal state of Yacas for emitting
a stub c++ file.";

Topical()"See Also"; 
SeeAlso({"StubApiCShortIntegerConstant",
"StubApiCInclude", "StubApiCFunction",
"StubApiCFile", "StubApiCSetEnv"
});



AddAnchor("StubApiCShortIntegerConstant");
SubSection()"StubApiCShortIntegerConstant";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCShortIntegerConstant(const,value)";

Topical()"Parameters";
Text()"const - string representing the global variable to be bound runtime <br>
       value - integer value the global should be bound to";

Topical()"Description";
Text()
"define a constant 'const' to have value 'value'.  The value should
be short integer constant. This is useful for linking in
defines and enumerated values into Yacas.
If the library for instance has a define <br>
#define FOO 10 <br>
Then  <br>
StubApiCShortIntegerConstant(\"FOO\",\"FOO\") <br>
will bind the global variable FOO to the value for FOO defined in
the library header file.
";

Topical()"See Also"; 
SeeAlso({ "StubApiCStart", "StubApiCInclude",
          "StubApiCFunction", "StubApiCFile", "StubApiCSetEnv"

});


 



AddAnchor("StubApiCInclude");
SubSection()"StubApiCInclude";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCInclude(file)";

Topical()"Parameters";
Text()"file - file to include from the library the plugin is based on";

Topical()"Description";
Text()
"Declare an include file (a header file for the library, for instance)
The delimiters need to be specified too. So, for a standard library
like the one needed for opengl, you need to specify <br>
StubApiCInclude(\"":Lt():"GL/gl.h":Gt():"\") <BR>
and for user include file:
StubApiCInclude(\"\\\"GL/gl.h\\\"\") <BR>
";

Topical()"See Also"; 
SeeAlso({"StubApiCStart",
"StubApiCShortIntegerConstant", "StubApiCFunction",
"StubApiCFile", "StubApiCSetEnv"
});




AddAnchor("StubApiCFunction");
SubSection()"StubApiCFunction";
StandardLib();
Topical()"Calling Sequence";
Text()
"StubApiCFunction(returntype,fname,args) <br>
StubApiCFunction(returntype,fname,fname2,args)
";

Topical()"Parameters";
Text()
"
returntype - return type of library function <br>
fname - function of built-in function <br>
fname2 - (optional) function name to be used from within Yacas <br>
args - list of arguments to the function
";

Topical()"Description";
Text()
"This function declares a library function, along with its
calling sequence. cstubgen will then generate the c++ code
required to call this function.
<p>
Return type, function name, and list of arguments should be
literal strings (surrounded by quotes).
<p>
If fname2 is not supplied, it will be assumed to be the same as fname.
<p>
The return types currently supported are \"int\", \"double\" and \"void\".

The argument values that are currently supported
are \"int\", \"double\", and \"input_string\".

Argument types can be specified simply as a string referring to their
type, like \"int\", or they can be lists with an additional element
stating the name of the variable: {\"int\",\"n\"}. The variable
will then show up in the automatically generated documentation as
having the name n.
";

Topical()"Examples";
Text()
"To define the opengl function glVertex3d that accepts three
doubles and returns void:":
HtmlCommand(
"StubApiCFunction(\"void\",\"glVertex3d\",{\"double\",\"double\",\"double\"});
"):
""
;

Topical()"See Also"; 
SeeAlso({"StubApiCStart",
"StubApiCShortIntegerConstant", "StubApiCInclude",
"StubApiCFile", "StubApiCSetEnv"
});


AddAnchor("StubApiCRemark");
SubSection()"StubApiCRemark";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCRemark(string)";

Topical()"Parameters";
Text()"string - remark string to be added to the documentation";

Topical()"Description";
Text()
"StubApiCRemark adds a piece of text to the stub documentation
file that gets generated automatically. The documentation is put in
a .description file while the input file is being processed, so adding
a remark on a function just after a function declaration adds a remark
on that function.
";

Topical()"See Also"; 
SeeAlso({"StubApiCShortIntegerConstant", "StubApiCInclude",
"StubApiCFunction", "StubApiCSetEnv", "StubApiCFile"
});




AddAnchor("StubApiCSetEnv");
SubSection()"StubApiCSetEnv";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCSetEnv(func)";

Topical()"Parameters";
Text()"func - function to call to set the environment variable";

Topical()"Description";
Text()
"This function forces the plugin to call the function func, with as
argument LispEnvironment& aEnvironment. This lets the plugin store
the environment class (which is needed for almost any thing to do with
Yacas), somewhere in a global variable. aEnvironment can then be used
from within a callback function in the plugin that doesn't take the
extra argument by design.
<p>
There needs to ba a function in the plugin somewhere of the form 

":HtmlCommand(
"static LispEnvironment* env = NULL;
void GlutSetEnv(LispEnvironment& aEnv)
{
    env = &aEnv;
}
"):"
Then calling

":HtmlCommand(
"StubApiCSetEnv(\"GlutSetEnv\");

"):"
will force the plugin to call GlutSetEnv at load time. All functions
in the plugin will then have access to the Yacas environment.
";


Topical()"See Also"; 
SeeAlso({"StubApiCStart",
"StubApiCShortIntegerConstant", "StubApiCInclude",
"StubApiCFunction", "StubApiCFile"
});


AddAnchor("StubApiCFile");
SubSection()"StubApiCFile";
StandardLib();
Topical()"Calling Sequence";
Text()"StubApiCFile(basename)";

Topical()"Parameters";
Text()"basename - basename for the generation of the stub file";

Topical()"Description";
Text()
"Generate the c++ stub file, \"basename.cc\", and a documentation file
named \"basename.description\". The descriptions are automatically
generated while adding functions and constants to the stub.
";


Topical()"See Also"; 
SeeAlso({"StubApiCStart",
"StubApiCShortIntegerConstant", "StubApiCInclude",
"StubApiCFunction", "StubApiCSetEnv"
});










AddAnchor("StubApiCStruct");
SubSection()"StubApiCStruct";
StandardLib();
Topical()"Calling Sequence";
Text()
"StubApiCStruct(name) <br>
StubApiCStruct(name,freefunction)
";

Topical()"Parameters";
Text()
"name - name of structure <br>
freefunction - function that can be called to clean up the object
";

Topical()"Description";
Text()
"StubApiCStruct declares a struct in a specific library. The name
should be followed by an asterisk (clearly showing it is a pointer).
After that, in the stub api definition, this type can be used as
argument or return type to functions to the library.
<p>
By default the struct will be deleted from memory with a normal
call to free(...). This can be overriden with a function given
as second argument, freefunction. This is needed in the case where
there are additional operations that need to be performed in order
to delete the object from memory.
";

Topical()"Examples";
Text()
"in a library header file, define:":
HtmlCommand(
"typedef struct SomeStruct
{
  int a;
  int b;
} SomeStruct;
"):
"Then in the stub file you can declare this struct by calling:
":HtmlCommand(
"StubApiCStruct(\"SomeStruct*\")
"):"

";

Topical()"See Also"; 
SeeAlso({"",""});





