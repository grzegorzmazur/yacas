
			Arithmetic and other operations on numbers

*INTRO Besides the usual arithmetical operations, Yacas defines some more advanced operations on
numbers. Many of them also work on polynomials.


*CMD + --- arithmetic addition
*STD
*CALL

	x+y
	+x
Precedence:
*EVAL OpPrecedence("+")

*PARMS

{x} and {y} -- objects for which arithmetic addition is defined


*DESC

The addition operators can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 2+3
	Out> 5;



*CMD - --- arithmetic subtraction or negation
*STD
*CALL

	x-y
Precedence: left-side:
*EVAL OpPrecedence("-")
, right-side:
*EVAL OpRightPrecedence("-")

	-x

*PARMS

{x} and {y} -- objects for which subtraction is defined

*DESC

The subtraction operators can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 2-3
	Out> -1;
	In> - 3
	Out> -3;


*CMD * --- arithmetic multiplication
*STD
*CALL

	x*y
Precedence:
*EVAL OpPrecedence("*")

*PARMS

{x} and {y} -- objects for which arithmetic multiplication is defined

*DESC

The multiplication operator can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

This operator is implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 2*3
	Out> 6;


*CMD / --- arithmetic division
*STD
*CALL

	x/y
Precedence:
*EVAL OpPrecedence("/")

*PARMS

{x} and {y} -- objects for which arithmetic division is defined

*DESC

The division operator can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

This operator is implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 6/2
	Out> 3;


*CMD ^ --- arithmetic power
*STD
*CALL

	x^y
Precedence:
*EVAL OpPrecedence("^")

*PARMS

{x} and {y} -- objects for which arithmetic operations are defined

*DESC

These are the basic arithmetic operations. They can work on integers,
rational numbers, complex numbers, vectors, matrices and lists.

These operators are implemented in the standard math library (as opposed
to being built-in). This means that they can be extended by the user.

*E.G.

	In> 2^3
	Out> 8;


*CMD Div --- Determine divisor of two mathematical objects
*CMD Mod --- Determine remainder of two mathematical objects after dividing one by the other

*STD
*CALL
	Div(x,y)
	Mod(x,y)

*PARMS

{x}, {y} -- integers or univariate polynomials

*DESC

{Div} performs integer division and {Mod} returns the remainder after division. {Div} and
{Mod} are also defined for polynomials.

If {Div(x,y)} returns "a" and {Mod(x,y)} equals "b", then these numbers satisfy $x =a*y + b$ and $0 <= b < y$.

*E.G.

	In> Div(5,3)
	Out> 1;
	In> Mod(5,3)
	Out> 2;

*SEE Gcd, Lcm

*CMD Gcd --- greatest common divisor
*STD
*CALL
	Gcd(n,m)
	Gcd(list)

*PARMS

{n}, {m} -- integers or Gaussian integers or univariate polynomials

{list} -- a list of all integers or all univariate polynomials

*DESC

This function returns the greatest common divisor of "n" and "m".
The gcd is the largest number that divides "n" and "m".  It is
also known as the highest common factor (hcf).  The library code calls
{MathGcd}, which is an internal function.  This
function implements the "binary Euclidean algorithm" for determining the
greatest common divisor:

*HEAD	Routine for calculating {Gcd(n,m)}
	
*	1. if $n = m$ then return $n$
*	2. if both $n$ and $m$ are even then return $2*Gcd(n/2,m/2)$
*	3. if exactly one of $n$ or $m$ (say $n$) is even then return $Gcd(n/2,m)$
*	4. if both $n$ and $m$ are odd and, say, $n>m$ then return $Gcd((n-m)/2,m)$

This is a rather fast algorithm on computers that can efficiently shift
integers. When factoring Gaussian integers, a slower recursive algorithm is used.

If the second calling form is used, {Gcd} will
return the greatest common divisor of all the integers or polynomials
in "list". It uses the identity
$$Gcd(a,b,c) = Gcd(Gcd(a,b),c)$$.

*E.G.

	In> Gcd(55,10)
	Out> 5;
	In> Gcd({60,24,120})
	Out> 12;
	In> Gcd( 7300 + 12*I, 2700 + 100*I)
	Out> Complex(-4,4);


*SEE Lcm

*CMD Lcm --- least common multiple
*STD
*CALL
	Lcm(n,m)
	Lcm(list)

*PARMS

{n}, {m} -- integers or univariate polynomials
{list}	 -- list of integers

*DESC

This command returns the least common multiple of "n" and "m" or all of
the integers in the list {list}.
The least common multiple of two numbers "n" and "m" is the lowest
number which is an integer multiple of both "n" and "m".
It is calculated with the formula
$$Lcm(n,m) = Div(n*m,Gcd(n,m))$$.

This means it also works on polynomials, since {Div}, {Gcd} and multiplication are also defined for
them.

*E.G.

	In> Lcm(60,24)
	Out> 120;
	In> Lcm({3,5,7,9})
	Out> 315;


*SEE Gcd

*CMD << --- binary shift left operator
*CMD >> --- binary shift right operator
*STD
*CALL
	n<<m
	n>>m

*PARMS

{n}, {m} -- integers

*DESC

These operators shift integers to the left or to the right.
They are similar to the C shift operators. These are sign-extended
shifts, so they act as multiplication or division by powers of 2.

*E.G.

	In> 1 << 10
	Out> 1024;
	In> -1024 >> 10
	Out> -1;

*CMD FromBase --- conversion of a number from non-decimal base to decimal base
*CMD ToBase --- conversion of a number in decimal base to non-decimal base
*CORE
*CALL
	FromBase(base,"string")
	ToBase(base, number)

*PARMS

{base} -- integer, base to convert to/from

{number} -- integer, number to write out in a different base

{"string"} -- string representing a number in a different base

*DESC

In Yacas, all numbers are written in decimal notation (base 10).
The two functions {FromBase}, {ToBase} convert numbers between base 10 and a different base.
Numbers in non-decimal notation are represented by strings.

{FromBase} converts an integer, written as a string in base
{base}, to base 10. {ToBase} converts {number},
written in base 10, to base {base}.

*REM where is this p-adic capability? - sw
These functions use the p-adic expansion capabilities of the built-in
arbitrary precision math libraries.

Non-integer arguments are not supported.

*E.G.

Write the binary number {111111} as a decimal number:

	In> FromBase(2,"111111")
	Out> 63;

Write the (decimal) number {255} in hexadecimal notation:

	In> ToBase(16,255)
	Out> "ff";

*SEE PAdicExpand


*CMD N --- try determine numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {Yacas} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make Yacas
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only 
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Pi

*CMD Rationalize --- convert floating point numbers to fractions
*STD
*CALL
	Rationalize(expr)

*PARMS

{expr} -- an expression containing real numbers

*DESC

This command converts every real number in the expression "expr"
into a rational number. This is useful when a calculation needs to be
done on floating point numbers and the algorithm is unstable.
Converting the floating point numbers to rational numbers will force
calculations to be done with infinite precision (by using rational
numbers as representations).

It does this by finding the smallest integer $n$ such that multiplying
the number with $10^n$ is an integer. Then it divides by $10^n$ again,
depending on the internal gcd calculation to reduce the resulting
division of integers.

*E.G.

	In> {1.2,3.123,4.5}
	Out> {1.2,3.123,4.5};
	In> Rationalize(%)
	Out> {6/5,3123/1000,9/2};

*SEE IsRational



*CMD ContFrac --- continued fraction expansion
*STD
*CALL
	ContFrac(x)
	ContFrac(x, depth)

*PARMS

{x} -- number or polynomial to expand in continued fractions

{depth} -- integer, maximum required depth of result

*DESC

This command returns the continued fraction expansion of {x}, which
should be either a floating point number or a polynomial. If
{depth} is not specified, it defaults to 6. The remainder is
denoted by {rest}.

This is especially useful for polynomials, since series expansions
that converge slowly will typically converge a lot faster if
calculated using a continued fraction expansion.

*E.G.

	In> PrettyForm(ContFrac(N(Pi)))
	
	             1
	--------------------------- + 3
	           1
	----------------------- + 7
	        1
	------------------ + 15
	      1
	-------------- + 1
	   1
	-------- + 292
	rest + 1

	Out> True;
	In> PrettyForm(ContFrac(x^2+x+1, 3))
	
	       x
	---------------- + 1
	         x
	1 - ------------
	       x
	    -------- + 1
	    rest + 1
	
	Out> True;

*SEE PAdicExpand, N



*CMD Decimal --- decimal representation of a rational
*STD
*CALL
	Decimal(frac)

*PARMS

{frac} -- a rational number

*DESC

This function returns the infinite decimal representation of a
rational number {frac}.  It returns a list, with the first element
being the number before the decimal point and the last element the
sequence of digits that will repeat forever. All the intermediate list
elements are the initial digits before the period sets in.

*E.G.

	In> Decimal(1/22)
	Out> {0,0,{4,5}};
	In> N(1/22,30)
	Out> 0.045454545454545454545454545454;

*SEE N


*CMD Floor --- round a number downwards
*STD
*CALL
	Floor(x)

*PARMS

{x} -- a number

*DESC

This function returns $Floor(x)$, the largest integer smaller than or equal to $x$.

*E.G.

	In> Floor(1.1)
	Out> 1;
	In> Floor(-1.1)
	Out> -2;

*SEE Ceil, Round

*CMD Ceil --- round a number upwards
*STD
*CALL
	Ceil(x)

*PARMS

{x} -- a number

*DESC

This function returns $Ceil(x)$, the smallest integer larger than or equal to $x$.

*E.G.

	In> Ceil(1.1)
	Out> 2;
	In> Ceil(-1.1)
	Out> -1;

*SEE Floor, Round

*CMD Round --- round a number to the nearest integer
*STD
*CALL
	Round(x)

*PARMS

{x} -- a number

*DESC

This function returns the integer closest to $x$. Half-integers
(i.e. numbers of the form $n + 0.5$, with $n$ an integer) are
rounded upwards.

*E.G.

	In> Round(1.49)
	Out> 1;
	In> Round(1.51)
	Out> 2;
	In> Round(-1.49)
	Out> -1;
	In> Round(-1.51)
	Out> -2;

*SEE Floor, Ceil

*CMD Min --- minimum of a number of values
*STD
*CALL
	Min(x,y)
	Min(list)

*PARMS

{x}, {y} -- pair of values to determine the minimum of

{list} -- list of values from which the minimum is sought

*DESC

This function returns the minimum value of its argument(s). If the
first calling sequence is used, the smaller of "x" and "y" is
returned. If one uses the second form, the smallest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.

*E.G.

	In> Min(2,3);
	Out> 2;
	In> Min({5,8,4});
	Out> 4;

*SEE Max, Sum

*CMD Max --- maximum of a number of values
*STD
*CALL
	Max(x,y)
	Max(list)

*PARMS

{x}, {y} -- pair of values to determine the maximum of

{list} -- list of values from which the maximum is sought

*DESC

This function returns the maximum value of its argument(s). If the
first calling sequence is used, the larger of "x" and "y" is
returned. If one uses the second form, the largest of the entries in
"list" is returned. In both cases, this function can only be used
with numerical values and not with symbolic arguments.

*E.G.

	In> Max(2,3);
	Out> 3;
	In> Max({5,8,4});
	Out> 8;

*SEE Min, Sum

*CMD Numer --- numerator of an expression
*STD
*CALL
	Numer(expr)

*PARMS

{expr} -- expression to determine numerator of

*DESC

This function determines the numerator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns this number. If "expr" is neither
rational nor numeric, the function returns unevaluated.

*E.G.

	In> Numer(2/7)
	Out> 2;
	In> Numer(a / x^2)
	Out> a;
	In> Numer(5)
	Out> 5;

*SEE Denom, IsRational, IsNumber

*CMD Denom --- denominator of an expression
*STD
*CALL
	Denom(expr)

*PARMS

{expr} -- expression to determine denominator of

*DESC

This function determines the denominator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns {1}. If "expr" is
neither rational nor numeric, the function returns unevaluated.

*E.G.

	In> Denom(2/7)
	Out> 7;
	In> Denom(a / x^2)
	Out> x^2;
	In> Denom(5)
	Out> 1;

*SEE Numer, IsRational, IsNumber

*CMD Pslq --- search for integer relations between reals
*STD
*CALL
	Pslq(xlist,precision)

*PARMS

{xlist} -- list of numbers

{precision} -- required number of digits precision of calculation

*DESC

This function is an integer relation detection algorithm. This means
that, given the numbers $x[i]$ in the list "xlist", it tries
to find integer coefficients $a[i]$ such that
$a[1]*x[1]$ + ... + $a[n]*x[n] = 0$.
The list of integer coefficients is returned.

The numbers in "xlist" must evaluate to floating point numbers if
the {N} operator is applied on them.

*EG

	In> Pslq({ 2*Pi+3*Exp(1), Pi, Exp(1) },20)
	Out> {1,-2,-3};

Note: in this example the system detects correctly that
$1 * (2*Pi+3*e) + (-2) * Pi + (-3) * e = 0$.

*SEE N




			Predicates relating to numbers


*CMD < --- test for "less than"
*STD
*CALL
	e1 < e2
Precedence:
*EVAL OpPrecedence("<")

*PARMS

{e1}, {e2} -- expressions to be compared

*DESC

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is smaller than the second one,
the result is {True} and it is {False} otherwise. If either of the expression is not numeric, after
evaluation, the expression is returned with evaluated arguments.

The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. {IsNumber} returns {True}), or the
quotient of two numbers, or an infinity (i.e. {IsInfinity} returns {True}). Yacas will try to 
coerce the arguments passed to this comparison operator to a real value before making the comparison.

*E.G.

	In> 2 < 5;
	Out> True;
	In> Cos(1) < 5;
	Out> True;

*SEE IsNumber, IsInfinity, N

*CMD > --- test for "greater than"
*STD
*CALL
	e1 > e2
Precedence:
*EVAL OpPrecedence(">")


*PARMS

{e1}, {e2} -- expressions to be compared

*DESC

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is larger than the second one,
the result is {True} and it is {False} otherwise. If either of the expression is not numeric, after
evaluation, the expression is returned with evaluated arguments.

The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. {IsNumber} returns {True}), or the
quotient of two numbers, or an infinity (i.e. {IsInfinity} returns {True}). Yacas will try to 
coerce the arguments passed to this comparison operator to a real value before making the comparison.

*E.G.

	In> 2 > 5;
	Out> False;
	In> Cos(1) > 5;
	Out> False

*SEE IsNumber, IsInfinity, N

*CMD <= --- test for "less or equal"
*STD
*CALL
	e1 <= e2
Precedence:
*EVAL OpPrecedence("<=")


*PARMS

{e1}, {e2} -- expressions to be compared

*DESC

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is smaller than or equals the
second one, the result is {True} and it is {False} otherwise. If either of the expression is not
numeric, after evaluation, the expression is returned with evaluated
arguments.

The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. {IsNumber} returns {True}), or the
quotient of two numbers, or an infinity (i.e. {IsInfinity} returns {True}). Yacas will try to 
coerce the arguments passed to this comparison operator to a real value before making the comparison.

*E.G.

	In> 2 <= 5;
	Out> True;
	In> Cos(1) <= 5;
	Out> True

*SEE IsNumber, IsInfinity, N

*CMD >= --- test for "greater or equal"
*STD
*CALL
	e1 >= e2
Precedence:
*EVAL OpPrecedence(">=")


*PARMS

{e1}, {e2} -- expressions to be compared

*DESC

The two expression are evaluated. If both results are numeric, they
are compared. If the first expression is larger than or equals the
second one, the result is {True} and it is {False} otherwise. If either of the expression is not
numeric, after evaluation, the expression is returned with evaluated
arguments.

The word "numeric" in the previous paragraph has the following
meaning. An expression is numeric if it is either a number (i.e. {IsNumber} returns {True}), or the
quotient of two numbers, or an infinity (i.e. {IsInfinity} returns {True}). Yacas will try to 
coerce the arguments passed to this comparison operator to a real value before making the comparison.

*E.G.

	In> 2 >= 5;
	Out> False;
	In> Cos(1) >= 5;
	Out> False

*SEE IsNumber, IsInfinity, N



*CMD IsZero --- test whether argument is zero
*STD
*CALL
	IsZero(n)

*PARMS

{n} -- number to test

*DESC

{IsZero(n)} evaluates to {True} if
"n" is zero. In case "n" is not a number, the function returns
{False}.

*E.G.

	In> IsZero(3.25)
	Out> False;
	In> IsZero(0)
	Out> True;
	In> IsZero(x)
	Out> False;

*SEE IsNumber, IsNotZero

*CMD IsRational --- test whether argument is a rational
*STD
*CALL
	IsRational(expr)

*PARMS

{expr} -- expression to test

*DESC

This commands tests whether the expression "expr" is a rational
number, i.e. an integer or a fraction of integers.

*E.G.

	In> IsRational(5)
	Out> False;
	In> IsRational(2/7)
	Out> True;
	In> IsRational(0.5)
	Out> False;
	In> IsRational(a/b)
	Out> False;
	In> IsRational(x + 1/x)
	Out> False;

*SEE Numer, Denom


