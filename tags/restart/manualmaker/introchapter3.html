<HTML>
<A NAME="c3">

</A>
<HEAD><TITLE>Let's learn some more</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Let's learn some more
</H1>
<A NAME="c3s1">

</A>
<H2>
<HR>Command-line options and yacas_client
</H2>
The default operation of Yacas is to run in the interactive console mode. Yacas accepts several options that modify its operation. Options can be combined, for example, :
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -c
</PRE>
</TABLE>
Inhibit printing of prompts "In>" and "Out>". Useful for non-interactive sessions.
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -f
</PRE>
</TABLE>
Reads standard input as one file, but executes only the first statement in it. (You may want to use a statement block to have several statements executed.)
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -p
</PRE>
</TABLE>
Does not use terminal capabilities, no fancy editing on the command line and no escape sequences printed. Useful for non-interactive sessions.
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -t
</PRE>
</TABLE>
Enable some extra history recall functionality in console mode: after executing a command from the history list, the next unmodified command from the history list will be automatically entered on the command line.
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas {filename}
</PRE>
</TABLE>
Reads and executes commands in the filename and exits. Equivalent to "Load()".
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -v
</PRE>
</TABLE>
Prints version information and exits.
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
yacas -d
</PRE>
</TABLE>
Prints the path to the Yacas library directory and exits.

<P>
In addition to the console mode, an experimental persistent session facility is provided through the script <B><TT>yacas_client</TT></B>. By means of this script, the user can configure third-party applications to pass commands to a constantly running "Yacas server" and get output. The "Yacas server" is automatically started by <B><TT>yacas_client</TT></B>. It may run on a remote computer; in that case the user should have a user account on the remote computer and privileges to execute <B><TT>yacas_client</TT></B> there, as well as <B><TT>rsh</TT></B> or <B><TT>ssh</TT></B> access. The purpose of <B><TT>yacas_client</TT></B> is to enable users to pass commands to Yacas within a persistent session while running another application such as a text editor. 
<P>
The script <B><TT>yacas_client</TT></B> reads Yacas commands from the standard input and passes them to the running "Yacas server"; it then waits 2 seconds and prints whatever output Yacas produced up to this time. Usage may looks like this:
<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
8:20pm Unix>echo "x:=3" | yacas_client 
Starting server.
[editvi] [gnuplot] 
True;
To exit Yacas, enter  Exit(); or quit or Ctrl-c. Type ?? for help.
Or type ?function for help on a function.
Type 'restart' to restart Yacas.
To see example commands, keep typing Example();
In> x:=3
Out> 3;
In> 8:21pm Unix>echo "x:=3+x" | yacas_client
In> x:=3+x
Out> 6;
In> 8:23pm Unix>yacas_client -stop
In> quit
Quitting...
Server stopped.
8:23pm Unix>
</PRE>
</TABLE>
Persistence of the session means that Yacas remembered the value of "x" between invocations of <B><TT>yacas_client</TT></B>. If there is not enough time for Yacas to produce output within 2 seconds, the output will be displayed the next time you call <B><TT>yacas_client</TT></B>. 
<P>
The "Yacas server" is started automatically when first used and can be stopped either by quitting Yacas or by an explicit option <B><TT>yacas_client -stop</TT></B>, in which case <B><TT>yacas_client</TT></B> does not read standard input. 
<P>
The script <B><TT>yacas_client</TT></B> reads standard input and writes to standard output, so it can be used via remote shell execution. For instance, if an account "user" on a remote computer "remote.host" is accessible through ssh, then <B><TT>yacas_client</TT></B> can be used remotely like this: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
echo "x:=2;" | ssh user@remote.host yacas_client
</PRE>
</TABLE>

 On a given host computer running the "Yacas server", each user currently may have only one persistent Yacas session.

<A NAME="c3s2">

</A>
<H2>
<HR>Compound statements
</H2>
Multiple statements can be grouped together using the [ and ] brackets.
The compound <B><TT>[a;b;c;];</TT></B> evaluates a, then b, then c, and returns the result
of evaluating c.
<P>
A variable can be declared
local to a compound statement block by the function <B><TT>Local(var1, var2,...)</TT></B>.
<A NAME="c3s3">

</A>
<H2>
<HR>"Threading" of functions
</H2>
Some functions in Yacas can be <I>threaded</I>. This means that calling the function
with a list as argument will result in a list with that function being
called on each item in the list. E.g. <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Sin({a,b,c});</PRE>
</TABLE>
will result in <B><TT>{Sin(a),Sin(b),Sin(c)}</TT></B>. This functionality is implemented for most normal analytic functions and arithmetic
operators. 
<A NAME="c3s4">

</A>
<H2>
<HR>Functions as lists
</H2>
Internally, Yacas represents all atomic expressions (numbers and variables) as strings and all compound expressions as lists, just like LISP. Try <B><TT>FullForm(a+b*c);</TT></B> and you will see
the text <B><TT>(+ a (* b c ))</TT></B> appear on the screen. Also, any expression can be converted to a list by the function Listify() or back to an expression by the function UnList():<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Listify(a+b*(c+d));
Out> {+,a,b*(c+d)};
In> UnList({Atom("+"),x,1});
Out> x+1;
</PRE>
</TABLE>
Note that the first element of the list is the name of the function <B><TT>+</TT></B> which is equivalently represented as <B><TT>Atom("+")</TT></B> and that the subexpression "b*(c+d)" was not converted to the list form.
<I>Pure functions</I> are the equivalent of "lambda expressions"
of LISP. They are currently implemented using lists and the operator
Apply(). The following line: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>Apply( {{x,y},x+y} , {2,3} );</PRE>
</TABLE>
would evaluate to 5.
<P>
Here, <B><TT>{{x,y},x+y}</TT></B> is a list that is treated as a pure
function by the operator <B><TT>Apply</TT></B>, the symbols "x" and "y" become
local variables bound to the parameters passed, and <B><TT>x+y</TT></B>
becomes the body of the function.
<A NAME="c3s5">

</A>
<H2>
<HR>More on syntax
</H2>
The syntax is handled by an infix grammar parser. Precedence of operations
can be specified explicitly by parentheses <B><TT>( )</TT></B> when the
normal precedence is not what you want. This means that most of the time
you will have to enter expressions of the form <B><TT>Func(var1,
var2)</TT></B>, or using infix operators, <B><TT>a*(b+c)</TT></B>, prefix
operators: <B><TT>-x</TT></B>, or postfix operators: <B><TT>x++</TT></B>.
The parser is case-sensitive and overall the syntax conventions resemble
the C language. Last but not least there are the so called "bodied"
functions, which unlike normal functions such as <B><TT>f(x,y)</TT></B>
keep the last argument outside of the bracketed argument list:
"<B><TT>f(x) y</TT></B>". This looks somewhat like a mathematical
"operator" <I>f(x)</I> acting on <I>y</I>. A
typical example is the function <B><TT>While</TT></B> which looks like
"<B><TT>While (predicate) body;</TT></B>". The derivative operator D(x)
is also defined as a "bodied" function. Note that if we defined a
"bodied" function <B><TT>A</TT></B> with only one argument, we'd have to
use it like this: "<B><TT>A() x;</TT></B>" and it would look a bit odd.
In this case we could make "A" a prefix operator and then the syntax
would become somewhat cleaner: "<B><TT>A x;</TT></B>"

<P>
However, regardess of presentation, internally all functions and operators
are equal and merely take a certain number of arguments. The user may
define or redefine any operators with either "normal" names such as "A"
or names made of one or more of the special symbols <B><TT>+ - * / = `
~ : ! @ # $ ^ & * _ | < ></TT></B> and declare them to be infix, postfix, or
prefix operators, as well as normal or bodied functions. (The symbol <B><TT>%</TT></B> is reserved for the result of the previous expression.)
Some of these operators and combinations are already defined in Yacas's
script library, for instance the "syntactic sugar" operators such as
<B><TT>:=</TT></B> or <B><TT><--</TT></B>, but they can be in principle
re-defined too. These "special" operators are in no way special, except
for their syntax. All infix, prefix, and postfix operators and bodied
functions can be assigned a precedence; infix operators in addition have a
left and a right precedence. All this will only affect the syntax of input
and could be arranged for the user's convenience.
<P>
The only caveat is to make sure you always type a space between any
symbols that could make up an operator. For instance, after you define a
new function "<B><TT>@@(x):=x^2;</TT></B>" expressions such as
"<B><TT>a:=@@(b);</TT></B>" typed without spaces will cause an error
unless you also define the operator "<B><TT>:=@@</TT></B>". This is
because the parser will not stop at "<B><TT>:=</TT></B>" when trying to
make sense of that expression. The correct way to deal with this is to
insert a space: "<B><TT>a:=&nbsp;@@(b);</TT></B>" Spaces are
<I>not</I> required in situations such as
"<B><TT>a:=-1</TT></B>", but this is so only because the operator
<B><TT>:=-</TT></B> is actually defined in Yacas.
<P>
Let's now have a hands-on primer for these syntactic constructions. Suppose we wanted to define a function <I>F(x,y)=x/y+y/x</I>. We could use the standard syntax: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> F(a,b) := a/b + b/a;
Out> True;
</PRE>
</TABLE>
 and then use the function as <B><TT>F(1,2);</TT></B> We might also declare an equivalent infix operation, let's call it "<B><TT>xx</TT></B>", so that we could write simply "1 xx 2". Infix operators must have a precedence, so let's assign it the precedence of the usual division operator. The declaration goes as follows: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Infix("xx", OpPrecedence("/"));
Out> True;
In> a xx b := a/b + b/a;
Out> True;
In> 3 xx 2 + 1;
Out> 19/6;
</PRE>
</TABLE>
Check the math and note how the precedence works! We have chosen the name "<B><TT>xx</TT></B>" just to show that we don't need to use the special characters in the infix operator's name. However we must define this operator as infix before using it in expressions, or we'd get syntax errors.
<P>
Finally, we might decide to be completely flexible with this important
function and also define it as a mathematical operator
<I>##</I>. First we define <I>##</I> as a
"bodied" function and then proceed as before:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE> In>
Bodied("##", OpPrecedence("/")); Out> True; In> ##(a) b := a xx b; Out>
True; In> ##(1) 3 + 2; Out> 16/3; </PRE>
</TABLE>
We have used the name "##" but we
could have used any other name such as "xx" or "F" or even "_-+@+-_".
Apart from possibly confusing yourself, it doesn't matter what you call the
functions you define. There is currently one limitation in Yacas: once a
function name is declared as infix (prefix, postfix) or bodied, it will
always be interpretedthat way. If we declare "f" to be "bodied", we may
later define different functions named "f" with different numbers of
arguments, however all of these functions must be "bodied".
<A NAME="c3s6">

</A>
<H2>
<HR>Writing simplification rules
</H2>
Mathematical calculations require versatile transformations on symbolic
quantities. Instead of trying to define all possible transformations, Yacas
provides a simple and easy to use pattern matching scheme for manipulating
expressions according to user-defined <I>rules</I>. Yacas itself is designed as a small core with a large library of rules that match and replace patterns. Examples can be found in the library files "standard", "stdfuncs", "deriv" and "solve" that
come with the Yacas distribution.
<P>
One simple application of pattern-matching rules is to define new
functions. (This is actually the only way Yacas can learn about new
functions.) As an example, let's define a function "f" that will evaluate
factorials of non-negative integers. We'll first define a predicate to
check whether our argument is indeed a non-negative integer, and we'll use
this predicate and the obvious recursion f(n)=n*f(n-1) to evaluate the
factorial. Tll this is accomplished by the following three lines:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
IsIntegerGreaterThanZero(_n) <-- IsInteger(n) And n>0;
10 # f(0) <-- 1;
20 # f(n_IsIntegerGreaterThanZero) <-- n*f(n-1);
</PRE>
</TABLE>
We have first defined a new predicate
<B><TT>IsIntegerGreaterThanZero()</TT></B> and then defined two
"simplification rules" for a new function <B><TT>f()</TT></B>. A
predicate equivalent to <B><TT>IsIntegerGreaterThanZero()</TT></B> is
actually already defined in the standard library and it's called
<B><TT>IsPositiveInteger</TT></B>, so it was not necessary, strictly
speaking, to define our own predicate to do the same thing and we did it
here just for illustration. The other two lines obviously define a
factorial function f(n)=n*(n-1)*...*1, and the rules are given precedence
values 10 and 20, so the first rule will be applied first. Incidentally,
the factorial is also defined in the standard library as the operator
"<B><TT>!</TT></B>" and it is bound to an internal routine much faster
than the recursion in our example.
<P>
The operator <B><TT><--</TT></B> defines a rule to be applied to a
specific function. The <B><TT>_n</TT></B> in the rule for
IsIntegerGreaterThanZero() specifies that any object which happens to be
the argument of that predicate is matched and assigned to the local
variable "n". The expression to the right of <B><TT><--</TT></B> can then
just use <B><TT>n</TT></B> (without the underscore) as a variable.
<P>
Now we consider the rules for the function <I>f</I>. The
first rule just specifies that f(0) should be replaced by 1 in any
expression. The second rule is a little more involved.
<B><TT>n_IsIntegerGreaterThanZero</TT></B> is a match for the argument of
<I>f</I>, with the proviso that the predicate <B><TT>IsIntegerGreaterThanZero(n)</TT></B> should return
<B><TT>True</TT></B>, otherwise the pattern is not matched. The underscore
operator is to be used only on the left hand side of the rule operator
<B><TT><--</TT></B>.
<P>
There are actually another equivalent way of writing the second rule: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
20 # f(_n)_(IsIntegerGreaterThanZero(n)) <-- n*f(n-1);
</PRE>
</TABLE>
The underscore <I>after</I> the function object is a predicate that should return True, or else there is no match. This predicate may be a complicated expression involving several logical operations, unlike the simple checking of just one predicate in the <B><TT>n_IsIntegerGreaterThanZero</TT></B> construct.
<P>
Precedence values for rules are given by a number followed by the
<B><TT>#</TT></B> operator. This number determines the ordering of
precedence for the pattern matching rules, with 0 the lowest allowed
precedence value, i.e. rules with precedence 0 will be tried first.
Multiple rules can have the same number: this just means that it doesn't
matter what order these patterns are tried in. If no number is supplied, 0
is assumed. In our example, the rule <I>f(0)=1</I> must be
applied earlier than the recursive rule, or else the recursion will never
terminate. But as long as there are no other rules concerning the function
<I>f</I>, the assignment of numbers 10 and 20 is arbitrary,
and they could have been 500 and 501 just as well.
<P>
Additional predicates can be specified too. <B><TT>IsIntegerGreaterThanZero</TT></B> could also have been defined as:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
10 # IsIntegerGreaterThanZero(n_IsInteger)_(n>0) <-- True;
20 # IsIntegerGreaterThanZero(_n) <-- False;
</PRE>
</TABLE>
Where the first rule specifies that if n is an integer, and greater than
zero, the predicate is true, and the second rule states that the
predicate is false otherwise.
<P>
The left hand side of a rule has the form 
<P>
"pattern _ postpredicate <-- replacement".
<P>
The <B><TT>(n>0)</TT></B> clause is added
after the pattern and allows the pattern to match only if this predicate return <B><TT>True</TT></B>. This is a useful syntax for defining rules with complicated predicates. There is no difference between the rules <B><TT>F(n_IsPositiveInteger)<--...</TT></B> and <B><TT>F(_n)_(IsPositiveInteger(n)) <-- ...</TT></B> except that the first syntax is a little more concise.
<P>
Some more examples of rules:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
_x + 0 <-- x;
_x - _x <-- 0;
ArcSin(Sin(_x)) <-- x;
</PRE>
</TABLE>
Yacas will first try to match the pattern like a template. Names preceded
or followed by an underscore can match any one object: a number, a
function, a list, etc. Yacas will assign the relevant variables as local
variables within the rule, and try the predicates as stated in the pattern.
The post-predicate (defined after the pattern) is tried after all these
matched. As an example, the simplification rule <B><TT>_x - _x <--
0;</TT></B> specifies that the two objects at left and at right of the minus
sign should be the same.
<P>
There is a slightly more complex and general way of
defining rules using the <B><TT>RuleBase()</TT></B> and
<B><TT>Rule()</TT></B> functions, but the "<B><TT>... # ... <--
...</TT></B>" construct is usually sufficiently flexible and much more readable. 

</BODY>

</FONT>

</HTML>
