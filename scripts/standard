
/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */


/* Implementation of Nth that allows extending. */
RuleBase("Nth",{alist,aindex});
Rule("Nth",2,10,
    MathAnd(Equals(IsFunction(alist),True),
            Equals(IsInteger(aindex),True),
            Not(Equals(Head(Listify(alist)),Nth))
            ))
     MathNth(alist,aindex);

Rule("Nth",2,11,Equals(IsList(aindex),True))
[
  Map({{ii},alist[ii]},{aindex});
];

Rule("Nth",2,12,
   MathAnd(
           Equals(IsGeneric(alist),True),
           Equals(GenericTypeName(alist),"Array"),
           Equals(IsInteger(aindex),True)
          )
    )
[
  ArrayGet(alist,aindex);
];

Rule("Nth",2,13,Equals(IsString(aindex),True))
[
  Local(as);
  as := Assoc(aindex,alist);
  If (Not(Equals(as,Empty)),Set(as,Nth(as,2)));
  as;
];



Function("NrArgs",{aLeft}) Length(Listify(aLeft))-1;

10 # IsNonObject(Object(_x)) <-- False;
20 # IsNonObject(_x)         <-- True;

1 # Numer(_x / _y)      <-- x;
2 # Numer(x_IsNumber)   <-- x;
1 # Denom(_x / _y)      <-- y;
2 # Denom(x_IsNumber)   <-- 1;



Set(Numeric,False);
Clear(Pi);
Function("N",{aNumberBody})
[
  Local(prevNumeric,prevPi,numericresult);
  Set(prevNumeric,Numeric);
  Set(prevPi,Pi);
  Set(Pi,Pi());
  Set(Numeric,True);
  Set(numericresult,Eval(aNumberBody));
  Set(Numeric,prevNumeric);
  Set(Pi,prevPi);
  numericresult;
];


UnFence("N",1);
Function("N",{aNumberBody,aDigits})
[
  Local(prevNumeric,prevPi,numericresult,prevdigits);
  Set(prevNumeric,Numeric);
  Set(prevPi,Pi);
  Set(prevdigits,GetPrecision());
  Precision(aDigits);
  Set(Pi,Pi());
  Set(Numeric,True);
  Set(numericresult,Eval(aNumberBody));
  Set(Numeric,prevNumeric);
  Set(Pi,prevPi);
  Precision(prevdigits);
  numericresult;
];
HoldArg("N",aNumberBody); 
UnFence("N",2);


Set(Verbose,False);
Function("V",{aNumberBody})
[
  Local(prevVerbose,result);
  Set(prevVerbose,Verbose);
  Set(Verbose,True);
  Set(result,Eval(aNumberBody));
  Set(Verbose,prevVerbose);
  result;
];
HoldArg("V",aNumberBody); 
UnFence("V",1);

Function("++",{aVar})
[
   MacroSet(aVar,MathAdd(Eval(aVar),1));
];
UnFence("++",1);
HoldArg("++",aVar);


Function("--",{aVar})
[
   MacroSet(aVar,MathSubtract(Eval(aVar),1));
];
UnFence("--",1);
HoldArg("--",aVar);


Function("TableForm",{list})
[
  Local(i);
  ForEach(i,list)
  [
    Write(i);
    NewLine();
  ];
  True;
];



/* Standard arithmetic */


/* Addition */

100 # + _x  <-- x;

50 # x_IsNumber + y_IsNumber <-- MathAdd(x,y);

100 # 0 + _x    <-- x;
100 # _x + 0    <-- x;
100 # _x + _x   <-- 2*x;
101 # _x + - _y <-- x-y;
101 # _x + (- _y)/(_z) <-- x-(y/z);
101 # (- _y)/(_z) + _x  <-- x-(y/z);
101 # (- _x) + _y <-- y-x;
150 # _n1 / _d + _n2 / _d <-- (n1+n2)/d;

210 # x_IsNumber + (y_IsNumber / z_IsNumber) <--(x*z+y)/z;
210 # (y_IsNumber / z_IsNumber) + x_IsNumber <--(x*z+y)/z;
210 # (x_IsNumber / v_IsNumber) + (y_IsNumber / z_IsNumber) <--(x*z+y*v)/(v*z);


220 # + x_IsList          <-- MapSingle("+",x);
220 # x_IsList + y_IsList <-- Map("+",{x,y});

240 # (x_IsList + y_IsNonObject)_Not(IsList(y)) <-- y+x;
241 # (x_IsNonObject + y_IsList)_Not(IsList(x)) <--
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(y),i++)
   [ DestructiveInsert(result,i,x + y[i]); ];
   result;
];

250 # Infinity + _y <-- Infinity;
250 # _x + Infinity <-- Infinity;


/* Subtraction arity 1 */

50 # -0 <-- 0;
55 # - (x_IsNumber) <-- MathSubtract(x);
110 # - (- _x)      <-- x;
110 # - (_x - _y) <-- y-x;
111 # - (x_IsNumber / _y) <-- (-x)/y;
200 # - (x_IsList) <-- MapSingle("-",x);

/* Subtraction arity 2 */
50  # x_IsNumber - y_IsNumber <-- MathSubtract(x,y);
50  # x_IsNumber - y_IsNumber <-- MathSubtract(x,y);
100 # 0 - _x <-- -x;
100 # _x - 0 <-- x;
100 # _x - _x <-- 0;

110 # _x - (- _y) <-- x + y;
111 # (_x + _y)- _x <-- y;
111 # (_x + _y)- _y <-- x;
112 # _x - (_x + _y) <-- - y;
112 # _y - (_x + _y) <-- - x;
113 # (- _x) - _y <-- -(x+y);

/* TODO move to this precedence everywhere? */
10 # (x_IsList) - (y_IsList) <-- Map({{xarg,yarg},xarg-yarg},{x,y});

240 # (x_IsList - y_IsNonObject)_Not(IsList(y)) <-- -(y-x);

241 # (x_IsNonObject - y_IsList)_Not(IsList(x)) <--
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(y),i++)
   [ DestructiveInsert(result,i,x - y[i]); ];
   result;
];

250  # Infinity - _y <-- Infinity;
250  # _x - Infinity <-- - Infinity;


210 # x_IsNumber - (y_IsNumber / z_IsNumber) <--(x*z-y)/z;
210 # (y_IsNumber / z_IsNumber) - x_IsNumber <--(y-x*z)/z;
210 # (x_IsNumber / v_IsNumber) - (y_IsNumber / z_IsNumber) <--(x*z-y*v)/(v*z);


/* Multiplication */

50  # x_IsNumber * y_IsNumber <-- MathMultiply(x,y);
100 #  1  * _x  <-- x;
100 # _x  *  1  <-- x;
100 # (_f  * _x)_(f= -1)  <-- -x;
100 # (_x  * _f)_(f= -1)  <-- -x;

100 # x_IsNumber * (y_IsNumber * _z) <-- (x*y)*z;
100 # x_IsNumber * (_y * z_IsNumber) <-- (x*z)*y;

100 # (_x * _y) * _y <-- x * y^2;
100 # (_x * _y) * _x <-- y * x^2;
100 # _y * (_x * _y) <-- x * y^2;
100 # _x * (_x * _y) <-- y * x^2;
100 # _x * (_y / _z) <-- (x*y)/z;
100 # (_y / _z) * _x <-- (x*y)/z;
100 # (_x * y_IsNumber)_Not(IsNumber(x)) <-- y*x;

100 # (_x * _y)* _x ^ n_IsInteger <-- y * x^(n+1);
100 # (_y * _x)* _x ^ n_IsInteger <-- y * x^(n+1);

105 # x_IsNumber * -(_y) <-- (-x)*y;
105 # (-(_x)) * (y_IsNumber) <-- (-y)*x;

106 # _x * -(_y) <-- -(x*y);
106 # (- _x) * _y <-- -(x*y);

107 # -( (-(_x))/(_y)) <-- x/y;
107 # -( (_x)/(-(_y))) <-- x/y;



200 # x_IsMatrix * y_IsMatrix <-- 
[
   Local(i,j,k,row,result);
   result:=ZeroMatrix(Length(x),Length(y[1]));
   For(i:=1,i<=Length(x),i++)
   For(j:=1,j<=Length(y),j++)
   For(k:=1,k<=Length(y[1]),k++)
   [
     row:=result[i];
     row[k]:= row[k]+x[i][j]*y[j][k];
   ];
   result;
];


210 # x_IsMatrix * y_IsList <-- 
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(x),i++)
   [ DestructiveInsert(result,i,x[i] . y); ];
   result;
];


240 # (x_IsList * y_IsNonObject)_Not(IsList(y)) <-- y*x;
241 # (x_IsNonObject * y_IsList)_Not(IsList(x)) <--
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(y),i++)
   [ DestructiveInsert(result,i,x * y[i]); ];
   result;
];

250  # _x * Infinity <-- Infinity;
250  # Infinity * (_y) <-- Infinity;


/* Note: this rule MUST be past all the transformations on
 * matrices, since they are lists also.
 */
230 # aLeft_IsList * aRight_IsList <-- Map("*",{aLeft,aRight});
242 # (x_IsInteger / y_IsInteger) * (v_IsInteger / w_IsInteger) <-- (x*v)/(y*w);
243 #  x_IsInteger * (y_IsInteger / z_IsInteger) <--  (x*y)/z;
243 #  (y_IsInteger / z_IsInteger) * x_IsInteger <--  (x*y)/z;

400 # _x * _x <-- x^2;
401 # 0 * _x <-- 0;
401 # _x * 0 <-- 0;


/* Division */

50 # _x / 0 <-- Infinity;
51 # 0 / _x <-- 0;
52 # (x_IsNumber / y_IsNumber)_((Numeric = True) Or
                                Not(IsInteger(x) And IsInteger(y))) <--
    MathDivide(x,y);


51 # x_IsNumber / y_IsNegativeNumber <-- (-x)/(-y);

51 # (x_IsNonZeroInteger / y_IsNonZeroInteger)_(MathGcd(x,y) > 1) <--
     [
       Local(gcd);
       Set(gcd,MathGcd(x,y));
       MathDivide(x,gcd)/MathDivide(y,gcd);
     ];
    

100 # _x / _x <-- 1;
100 # _x /  1 <-- x;
100 # (_x / y_IsNegativeNumber) <-- -x/(-y);
100 # (_x / - _y) <-- -x/y;
200 # (_x / _y)/ _z <-- x/(y*z);

230 # _x / (_y / _z) <-- (x*z)/y;
240 # x_IsList / y_IsList <-- Map("/",{x,y});


250 # x_IsList / _y <--
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(x),i++)
   [ DestructiveInsert(result,i,x[i] / y); ];
   result;
];

250 # _x / y_IsList <--
[
   Local(i,result);
   result:={};
   For(i:=1,i<=Length(y),i++)
   [ DestructiveInsert(result,i,x/y[i]); ];
   result;
];

250 # _x / Infinity <-- 0;
250 # _x / (-Infinity) <-- 0;


400 # 0 / _x <-- 0;

/* Faster version of raising power to 0.5 */
50 # (x_IsNumber ^ (1/2))_(Numeric) <-- Sqrt(x);
50 # (x_IsNumber ^ (1/2))_IsInteger(MathSqrt(x)) <-- MathSqrt(x);
60 # _x ^ 1 <-- x;
60 # 1 ^ _n <-- 1;
/* Regular raising to the power. */
61 # x_IsNumber ^ y_IsPositiveNumber <-- MathPower(x,y);
61 # x_IsNumber ^ y_IsNegativeNumber <-- (1/MathPower(x,-y));
70  # (_x ^ m_IsRationalOrNumber) ^ n_IsRationalOrNumber <-- x^(n*m);
80 # x_IsRationalOrNumber ^ n_IsPositiveInteger <-- x*x^(n-1);

100  # ((_x)*(_x ^ _m)) <-- x^(m+1);
100  # ((_x)^(_n))*((_y)^(_n)) <-- (x*y)^n;

100  # ((x_IsNumber)^(_n/(_m)))_(n>1) <-- MathPower(x,n)^(1/m);

100 # Sqrt(_n)^(m_IsEven) <-- n^(m/2);


/*
100 # ((_x)^(_n))^((_m)/(_p)) <-- x^(n*m/p);
100 # ((_x)^((_m)/(_p)))^(_n) <-- x^(n*m/p);

100 # ((_x)^((_m)/(_p)))^((_n)/(_q)) <-- x^((n*m)/(p*q));
 */
200 # xlist_IsList ^ nlist_IsList <-- Map("^",{xlist,nlist});
201 # xlist_IsList ^ n_IsPositiveInteger <-- Map({{xx},xx^n},{xlist});
202 # _x ^ n_IsList <-- Map({{xx},x^xx},{n});

250 # Infinity ^ (_n) <-- Infinity;
250 # ((-Infinity) ^ (n_IsNumber))_(IsEven(n)) <-- Infinity;
250 # ((-Infinity) ^ (n_IsNumber))_(IsOdd(n)) <-- -Infinity;

250 # (x_IsNumber ^ Infinity)_(x> -1 And x < 1) <-- 0;
250 # (x_IsNumber ^ Infinity)_(x< -1) <-- - Infinity;
250 # (x_IsNumber ^ Infinity)_(x> 1) <-- Infinity;

250 # (x_IsNumber ^ -Infinity)_(x> -1 And x < 1) <-- Infinity;
250 # (x_IsNumber ^ -Infinity)_(x< -1) <-- 0;
250 # (x_IsNumber ^ -Infinity)_(x> 1) <-- 0;


400 # _x ^ 0 <-- 1;


RuleBase("==",{left,right});
RuleBase("!==",{left,right});


Function("+-",{x,y})  x + -y;
Function("/-",{x,y})  x / -y;
Function("*-",{x,y})  x * -y;
Function("^-",{x,y})  x ^ -y;

Function(":=-",{xleft,yminright}) Apply(":=",{xleft,-yminright}); 
HoldArg(":=-",xleft);
HoldArg(":=-",yminright);

Function(":=+",{xleft,yright}) Apply(":=",{xleft,yright}); 
HoldArg(":=+",xleft);
HoldArg(":=+",yright);


a_IsPositiveInteger & b_IsPositiveInteger <-- BitAnd(a,b);
a_IsPositiveInteger | b_IsPositiveInteger <-- BitOr(a,b);
a_IsPositiveInteger % b_IsPositiveInteger <-- Mod(a,b);

RuleBase("if",{predicate,body});
if(_predicate) _body <-- If(Eval(predicate),Eval(body));
HoldArg("if",predicate);
HoldArg("if",body);
UnFence("if",2);

RuleBase("else",{ifthen,otherwise});
(if (_predicate) _body else _otherwise) <-- If(Eval(predicate),Eval(body), Eval(otherwise));
HoldArg("else",ifthen);
HoldArg("else",otherwise);
UnFence("else",2);



