/* Tests on logic */

/* Small theorem prover for propositional logic, based on the
 * resolution principle.
 * Written by Ayal Pinkus
 * Version 0.1 initial implementation.
 *
 *
 * Examples:
CanProve(( (a=>b) And (b=>c)=>(a=>c) ))   <-- True
CanProve(a  Or   Not a)                      <-- True
CanProve(True  Or  a)                    <-- True
CanProve(False  Or  a)                   <-- a
CanProve(a  And   Not a)                      <-- False
CanProve(a  Or b Or (a And b))                  <-- a Or b
 */

RuleBase("=>",{a,b});


/* Simplify a boolean expression. LogicSimplify is responsible
   for converting an expression to a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ...
 */

5  # LogicSimplify( Not  True) <-- False;
5  # LogicSimplify( Not  False) <-- True;
5  # LogicSimplify(True   And  _x) <-- LogicSimplify(x);
5  # LogicSimplify(False  And  _x) <-- False;
5  # LogicSimplify(_x   And  True) <-- LogicSimplify(x);
5  # LogicSimplify(_x  And  False) <-- False;
5  # LogicSimplify(True   Or  _x) <-- True;
5  # LogicSimplify(False  Or  _x) <-- LogicSimplify(x);
5  # LogicSimplify(_x  Or  True ) <-- True;
5  # LogicSimplify(_x  Or  False) <-- LogicSimplify(x);

6  # LogicSimplify(_x  Or  _x)       <-- LogicSimplify(x);
6  # LogicSimplify(_x  And  _x)      <-- LogicSimplify(x);
6  # LogicSimplify(_x  Or Not (_x))  <-- True;
6  # LogicSimplify(Not (_x)  Or _x)  <-- True;
6  # LogicSimplify(_x  And Not (_x)) <-- False;
6  # LogicSimplify(Not (_x)  And _x) <-- False;

10 # LogicSimplify( Not ( Not  (_x))) <-- LogicSimplify(x);        /* eliminate double negation */
20 # LogicSimplify((_x)=>(_y)) <-- LogicSimplify( Not x  Or  y);      /* eliminate implication */
30 # LogicSimplify( Not ((_x)  And  (_y))) <-- LogicSimplify( Not x  Or   Not y); /* De Morgan's law */
40 # LogicSimplify( Not ((_x)  Or  (_y))) <-- LogicSimplify( Not x  And   Not y); /* De Morgan's law */
50 # LogicSimplify(((_x)  And  (_y))  Or  (_z)) <-- LogicSimplify((x Or z) And (y Or z)); /* Distribution */
60 # LogicSimplify((_x)  Or  ((_y)  And  (_z))) <-- LogicSimplify((x Or y) And (x Or z)); /* Distribution */

70 # LogicSimplify((_x)  Or  (_y))_
     (x!= LogicSimplify(x) Or y!=LogicSimplify(y)) <--
     LogicSimplify(LogicSimplify(x) Or LogicSimplify(y)); /* Transform subexpression */
70 # LogicSimplify( Not  (_x))_
     (x != LogicSimplify(x))<--
     LogicSimplify( Not LogicSimplify(x));           /* Transform subexpression */

80 # LogicSimplify((_x)  Or  (_y)) <--
     LogicSimplify(x) Or LogicSimplify(y); /* Transform subexpression */
80 # LogicSimplify( Not  (_x)) <--
      Not LogicSimplify(x);           /* Transform subexpression */
80 # LogicSimplify((_x)  And  (_y)) <--
     LogicSimplify(x) And LogicSimplify(y); /* Transform subexpression */

85 # LogicSimplify( (_x) < (_y) ) <-- Simplify(x<y);
85 # LogicSimplify( (_x) > (_y) ) <-- Simplify(x>y);
85 # LogicSimplify( (_x) >= (_y) ) <-- Simplify(x>=y);
85 # LogicSimplify( (_x) <= (_y) ) <-- Simplify(x<=y);
85 # LogicSimplify( (_x) == (_y) ) <-- Simplify(x==y);
85 # LogicSimplify( (_x) !== (_y) ) <-- Simplify(x!==y);


60 # LogicSimplify( Not((_x) <  (_y)) ) <--LogicSimplify( x >= y );
60 # LogicSimplify( Not((_x) >  (_y)) ) <--LogicSimplify( x <= y );
60 # LogicSimplify( Not((_x) <= (_y)) ) <--LogicSimplify( x > y );
60 # LogicSimplify( Not((_x) >= (_y)) ) <--LogicSimplify( x < y );
60 # LogicSimplify( Not((_x) == (_y)) ) <--LogicSimplify( x !== y );
60 # LogicSimplify( Not((_x) !== (_y)) ) <--LogicSimplify( x == y );




90 # LogicSimplify(_x) <-- x; /* Accept as fully simplified */

/* Simplify the logic expression to see if it is true. */
CanProveAux(_proposition) <--
[
  Local(negated,list,clauses);
  /* First get the LogicSimplify version of the negation of the proposition */
  negated:=LogicSimplify(proposition);
  list:=Flatten(negated,"And");
  clauses:={};
  ForEach(clause,list)
  [
    Local(newclause);
    newclause:=LogicRemoveTautologies(RemoveDuplicates(Flatten(clause,"Or")));
    If(newclause != {}, DestructiveAppend(clauses,newclause));
  ];

  clauses:=RemoveDuplicates(clauses);
  clauses:=LogicCombine(clauses);

  Local(result);
  result:=True;
  ForEach(item,clauses)
  [
    result:= result And UnFlatten(item,"Or",False);
  ];

  /* Second pass: simplify the resulting expression */

  LogicSimplify(result);
];

/* CanProve tries to prove that the negation of the negation of
   the proposition is true. Negating twice is just a trick to
   allow all the simplification rules a la De Morgan to operate
 */
CanProve(_proposition) <-- CanProveAux( Not CanProveAux( Not proposition));

/* LogicRemoveTautologies scans a list representing e1 Or e2 Or ... to find
   if there are elements p and  Not p in the list. This signifies p Or   Not p,
   which is always true. These are removed. Another function that is used
   is RemoveDuplicates, which converts p Or p into p.
 */
LogicRemoveTautologies(_e)<--
[
  Local(i);
  For(i:=1,i<=Length(e),i++)
  [
    Local(n);
    n:=LogicSimplify( Not  (e[i]));
    If(Contains(e,n),
       [

If(i>=Find(e,n),Echo({"WRONG!!!"}));

         DestructiveDelete(e,Find(e,n));
         DestructiveDelete(e,i);
         i--;
       ]);
  ];
  e;
];

LogicFindWith(_list,_n)<--
[
  Local(i);
  Local(result);
  result:= -1;
  For(i:=1,(result<0) And (i<=Length(list)),i++)
  [
    If(Length(list[i])>1 And Contains(list[i],n),result:=i);
  ];
  result;
];

/* LogicCombine is responsible for scanning a list of lists, which represent
   a form (p1  Or  p2  Or  ...)  And  (q1  Or  q2  Or  ...)  And ... by scanning the lists
   for combinations x Or Y  And   Not x Or Z => Y Or Z . If Y Or Z is empty then this clause
   is false, and thus the entire proposition is false.
 */
LogicCombine(_list) <--
[
  Local(i,j);
  For(i:=1,i<=Length(list),i++)
  [
    Local(redo);
    redo:=False;
    if (Length(list[i]) > 1)
    For(j:=1,Not(redo) And (j<=Length(list[i])),j++)
    [
      Local(tocombine,n);
      n:=LogicSimplify( Not (list[i][j]));

      tocombine:=LogicFindWith(list,n);
      If(tocombine > 0 And i<tocombine,
         [
If(i>=tocombine,Echo({"WRONG!!!"}));

           DestructiveDelete(list[i],j);
           DestructiveDelete(list[tocombine],Find(list[tocombine],n));
           list[i]:=
             LogicRemoveTautologies(RemoveDuplicates(Concat(list[i],list[tocombine])));
           DestructiveDelete(list,tocombine);
           If(list[i] = {False},list[i]:={});
           If(list[i] = {},
              [
               list:={{}};
               i:=Length(list)+1;
              ],
              i:=0);
           redo:=True;
         ]
        );
    ];
  ];
  list;
];