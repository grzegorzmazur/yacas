<HTML>
<A NAME="c1">

</A>
<HEAD><TITLE>Getting started with Yacas</TITLE></HEAD><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="3">
<BODY BGCOLOR="ffffff" LINK="0000ff" VLINK="0000ff">
<H1>
Getting started with Yacas
</H1>
<A NAME="c1s1">

</A>
<H2>
<HR>Introduction
</H2>
Yacas (Yet Another Computer Algebra System) is a small and highly flexible
general-purpose computer algebra language. The syntax uses a infix-operator
grammar parser. The distribution contains a small library of mathematical
functions, but its real strength is in the language in which you can easily
write your own symbolic manipulation algorithms. The core engine supports
arbitrary precision arithmetic (it can also optionally be linked with
the GNU arbitrary precision math library <B><TT>libgmp2</TT></B>) and is able to execute symbolic manipulations on various mathematical objects by following user-defined rules.

<A NAME="c1s2">

</A>
<H2>
<HR>Installing Yacas
</H2>
Read the file <B><TT>INSTALL</TT></B> for instructions on how to compile Yacas. Yacas is
portable across most Unix-ish platforms and requires only a standard C++
compiler such as <B><TT>g++</TT></B>.
<P>

At the base Yacas accepts text as input and returns text as output.
This makes it very platform-independent. Apart from Unix Yacas has been
compiled on Windows and EPOC32 aka Psion (which doesn't come with a standard c++
library!).
The source code to compile Yacas for Windows can be found at the
Sourceforge repository.

<P>

For Unix, compilation basically amounts to the standard sequence <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
./configure
make
make install
</PRE>
</TABLE>

The arbitrary precision math in Yacas will be generally faster if you compile Yacas with the "libgmp" library (configure option --enable-gmp). Precompiled Red Hat (RPM) and Debian (DEB) packages are also available.
<A NAME="c1s3">

</A>
<H2>
<HR>Using the console mode
</H2>
You can run Yacas in the console mode simply by typing <B><TT>yacas</TT></B>. The Yacas command prompt looks like this: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In>
</PRE>
</TABLE>
and Yacas's answers appear after the prompt<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
Out>
</PRE>
</TABLE>
A Yacas session may be terminated by typing <B><TT>Exit()</TT></B> or
<B><TT>quit</TT></B>. Pressing ^C will also quit Yacas;
however, pressing ^C while Yacas is busy with a calculation will stop
just that calculation.
A session can be restarted (forgetting all previous
definitions and results) by typing <B><TT>restart</TT></B>
<P>
Typically, you would enter one statement per line, for example <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Sin(Pi/2);
Out> 1;
</PRE>
</TABLE>
Statements should end with a semicolon (<B><TT>;</TT></B>) although this is not required (Yacas will append a <B><TT>;</TT></B> at end of line to finish the statement).
<P>
All documentation is accessible from the Yacas prompt. If you type <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ??</PRE>
</TABLE>
 you should be able to read all available manuals (Yacas will run <B><TT>lynx</TT></B> to show you the HTML documentation). You can also get help on individual functions: to read about the function <B><TT>Sum()</TT></B>, type <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> ?Sum</PRE>
</TABLE>
You can also type <B><TT>Example();</TT></B> to get some random examples of Yacas calculations.
<P>
The command line has a history list, so it should be easy to
browse through the expressions you entered previously using the Up and Down arrow keys.
Typing the first few characters of a previous expression and then
hitting the TAB key makes Yacas recall the last expression
in the history list that matches these first characters.
<P>
Commands spanning multiple lines can (and actually have to) be entered by using a trailing backslash \ at end of each continued line. For example: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> a:=2+3+
Error on line 1 in file [CommandLine]
Line error occurred on:
>>>
Error parsing expression

In> a:=2+3+ \
In> 1
Out> 6;
</PRE>
</TABLE>
The error after our first attempt occurred because Yacas has appended a semicolon at end of the first line and <B><TT>2+3+;</TT></B> is not a valid Yacas expression. Incidentally, any text Yacas prints without a prompt is either messages printed by functions as their side-effect, or error messages. Resulting values of expressions are always printed after an <B><TT>Out></TT></B>  prompt.
<A NAME="c1s4">

</A>
<H2>
<HR>Yacas as a symbolic calculator
</H2>

We are ready to try some calculations. Yacas uses a C-like infix syntax and is case-sensitive. Here are some exact manipulations with fractions for a start: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 1/14+5/21*(30-(1+1/2)*5^2);
Out> -12/7;
</PRE>
</TABLE>
The standard scripts already contain a simple math library for
symbolic simplification of basic algebraic functions. Any names such as <B><TT>x</TT></B> are treated as independent, symbolic variables and are not evaluated by default.<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 0+x;
Out> x;
In> x+1*y;
Out> x+y;
In> Sin(ArcSin(alpha))+ArcCos(Cos(beta));
Out> alpha+beta;
In> (x+y)^3-(x-y)^3
Out> (x+y)^3-(x-y)^3;
In> Simplify(%)
Out> 6*x^2*y+2*y^3;
</PRE>
</TABLE>
The special operator <B><TT>%</TT></B> automatically recalls the result from the previous line. The function Simplify attempts to reduce an expression to a simpler form. Note that standard function names in Yacas are typically capitalized. Multiple capitalization such as "ArcSin" is sometimes used. The underscore character <B><TT>_</TT></B> is a reserved operator symbol and cannot be part of variable or function names.
<P>
Yacas can deal with arbitrary precision numbers:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> 20!;<P>Out> 2432902008176640000;</PRE>
</TABLE>
When dealing with floating point numbers, the command <B><TT>Precision(n);</TT></B> can be used to specify that all floating point numbers should have a fixed precision of <B><TT>n</TT></B> digits:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Precision(30);
Out> True;
In> 1.0/243;
Out> 0.004115226337448559670781893004;
</PRE>
</TABLE>
Note that we need to enter <B><TT>1.0</TT></B> as a floating-point constant to force the approximate calculation, otherwise the fraction would have been left unevaluated. The value <B><TT>True</TT></B> is a boolean constant.
<P>
Analytic derivatives of functions can be evaluated:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> D(x) Sin(x);
Out> Cos(x);
In> D(x) D(x) Sin(x);
Out> -Sin(x);
</PRE>
</TABLE>
Rational numbers will stay rational as long as the numerator and
denominator are integers, so <B><TT>55/10</TT></B> will evaluate to
<B><TT>11/2</TT></B>. You can override this behaviour by using the
numerical evaluation function <B><TT>N()</TT></B>: for example, <B><TT>N(55/10)</TT></B> will evaluate to <B><TT>5.5</TT></B> . This
behaviour holds for most math functions. Yacas will try to maintain an
exact answer (in terms of integers or fractions) instead of using
floating point numbers, unless <B><TT>N()</TT></B> is used. If the
value for the constant <I>pi</I> is needed, use <B><TT>Pi</TT></B>.
This will be replaced by the (approximate) numerical value when
<B><TT>N(Pi)</TT></B> is called. Yacas knows some simplification rules
using <B><TT>Pi</TT></B> (especially with trigonometric functions). The
imaginary unit <I>i</I> is denoted <B><TT>I</TT></B> and complex
numbers can be entered as either expressions involving
<B><TT>I</TT></B> or explicitly <B><TT>Complex(a,b)</TT></B> for
<I>a+i*b</I>.
<P>
Some simple equation solving algorithms are in place:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> Solve(a+x*y==z,x);
Out> (z-a)/y;
In> Solve({11*x+3*y==1,2*x+y==0},{x,y})
Out> {{1/5,-2/5}};
</PRE>
</TABLE>
(Note the use of the <B><TT>==</TT></B> operator, which does not evaluate to anything, to denote an "equation" object.) Currently <B><TT>Solve</TT></B> is rather limited and only deals with equations where the variable to be solved for only occurs once in the equation. In the future there will be more sophisticated algorithms.
<P>
Taylor series are supported. Typing <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Taylor(x,0,3) Exp(x)</PRE>
</TABLE>
 will result in <B><TT>1+x+(1/2)*x^2+(1/6)*x^3</TT></B> . As this form may be a little bit hard to read, you might then type <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> PrettyForm(%);

        / 1 \    2   / 1 \    3
1 + x + | - | * x  + | - | * x 
        \ 2 /        \ 6 /     

Out> True;
</PRE>
</TABLE>
The function <B><TT>PrettyForm()</TT></B> tries to render the formula in a better format for reading, using just ASCII text.
<A NAME="c1s5">

</A>
<H2>
<HR>Variables
</H2>

Yacas supports variables:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> Set(a,Cos(0));
Out> True;
In> a:=a+1;
Out> 2;
</PRE>
</TABLE>
 The variable <B><TT>a</TT></B> has now been globally set to 2. The function Set() and the operator <B><TT>:=</TT></B> can both be used to assign values to global variables. (Variables
local to procedures can also be defined; see below the chapters on
programming.) To clear a variable binding, execute
<B><TT>Clear(a);</TT></B>. <B><TT>a;</TT></B> will now evaluate to just
<B><TT>a</TT></B>. This is one of the properties of the evaluation
scheme of Yacas: when some object can not be evaluated or transformed
any further, it is returned as the final result.
<P>
Currently there is no difference between assigning variables using Set() or using the operator <B><TT>:=</TT></B>. The latter can however also assign lists and define functions.
<A NAME="c1s6">

</A>
<H2>
<HR>Functions
</H2>
The <B><TT>:=</TT></B> operator can be used to define functions: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>f(x):=2*x*x</PRE>
</TABLE>
 will define a new function, "f", that accepts
one argument and returns twice the square of that argument.
<P>
A function name such as "f" may be used by different functions if they take different numbers of arguments: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> f(x):=x^2;
Out> True;
In> f(x,y):=x*y;
Out> True;
In> f(3)+f(3,2);
Out> 15;
</PRE>
</TABLE>

<P>
Functions may also return boolean values (<B><TT>True</TT></B> and <B><TT>False</TT></B>). Such functions are called <I>predicates</I>. For example, IsNumber() and IsInteger() are predicates defined in the standard library:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> IsNumber(2+x);
Out> False;
In> IsInteger(15/5);
Out> True;
</PRE>
</TABLE>

<P>
When assigning variables, the right hand side is evaluated before it
is assigned. Thus <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>a:=2*2</PRE>
</TABLE>
 will set <B><TT>a</TT></B>
to 4. This is however <I>not</I> the case for functions. When entering <B><TT>f(x):=x+x</TT></B> the right hand side, <B><TT>x+x</TT></B>, is
not evaluated before being assigned. This can be forced by using the
assignment in combination with Eval:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>f(x):=Eval(x+x)</PRE>
</TABLE>

will first evaluate <B><TT>x+x</TT></B> to <B><TT>2*x</TT></B> before
assigning it to the user function f. This specific example is not a
very useful one but it will come in handy when the operation being
performed on the right hand side is expensive. For example, if we
evaluate a Taylor series expansion before assigning it to the
user-defined function, the engine doesn't need to create the Taylor
series expansion each time that user-defined function is called.
<A NAME="c1s7">

</A>
<H2>
<HR>Strings and lists
</H2>
In addition to numbers and variables, Yacas supports strings and lists. Strings are simply sequences of characters enclosed by double quotes, for example: <B><TT>"this is a string with \"quotes\" in it"</TT></B>. Lists are ordered groups of items, as usual. Yacas represents lists by putting the objects between braces and separating them with commas. The list consisting of objects a, b, and c could be entered by typing <B><TT>{a,b,c}</TT></B>. In Yacas, vectors are represented as lists and matrices as lists of lists. In fact, any Yacas expression can be converted to a list (see below).
<P>
Items in a list can be accessed through the <B><TT>[ ]</TT></B>
operator. Examples: when you enter <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>uu:={a,b,c,d,e,f};</PRE>
</TABLE>
then <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>uu[2];</PRE>
</TABLE>
evaluates to b, and <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>uu[2 .. 4];</PRE>
</TABLE>
evaluates to {b,c,d}. Here <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>2 .. 4</PRE>
</TABLE>
evaluates to <B><TT>{2,3,4}</TT></B>. Note that
spaces around the <B><TT>..</TT></B> operator are necessary, or else the
parser will not be able to distinguish it from a number.
<P>
Another use of lists is the associative list, sometimes called a hash table, which is implemented in Yacas simply as a list of key-value pairs. Keys must be strings and values may be any objects. Associative lists can also work as mini-databases. As an example, first
enter <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>u:={};</PRE>
</TABLE>
 and then <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
u["name"]:="Isaia";
u["occupation"]:="prophet";
u["is alive"]:=False;
</PRE>
</TABLE>
 Then, <B><TT>u["name"]</TT></B> would return <B><TT>"Isaia"</TT></B>. The list <B><TT>u</TT></B> now contains three sublists, as we can see:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> u;
Out> { {"is alive", False}, {"occupation", "prophet"}, {"name", "Isaia"} };
</PRE>
</TABLE>

<P>
Assignment of multiple variables is also possible using lists. For instance, <B><TT>{x,y}:={2!,3!}</TT></B> will result in 2 being assigned to
x and 6 to y.
<P>
Lists evaluate their arguments, and return a list with results of evaluating each element. So, typing <B><TT>{1+2,3};</TT></B> would evaluate to <B><TT>{3,3}</TT></B>
<P>
The idea of using lists to represent expressions dates back to the
language LISP, which was developed in the 70's. Together with a
small set of operations on lists very powerful symbolic manipulation
algorithms can be built. Lists can also be used as function arguments when a variable number of arguments are expected.
<P>
Let's try some list operations now:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> m:={a,b,c};
Out> True;

In> Length(m);
Out> 3;

In> Reverse(m);
Out> {c,b,a};

In> Concat(m,m);
Out> {a,b,c,a,b,c};

In> m[1]:="blah blah";
Out> True;
In> m;
Out> {"blah blah",b,c};

In> Nth(m,2);
Out> b;
</PRE>
</TABLE>
Many more list operations are described in the reference manual.
<A NAME="c1s8">

</A>
<H2>
<HR>Linear Algebra
</H2>
Vectors of fixed dimension are represented as lists of their components. The list {1,2,3} would be a three-dimensional vector with components 1, 2 and 3. Matrices are represented as a vector of vectors.
<P>
Vector components can be assigned values just like list items, since they are in fact list items:<TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>In> l:=ZeroVector(3);<P>Out> True;<P>In> l;<P>Out> {0,0,0};<P>In> l[ 2 ]:=2;<P>Out> True;<P>In> l;<P>Out> {0,2,0};</PRE>
</TABLE>
Yacas can perform multiplication of matrices, vectors and numbers as usual
in linear algebra: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> v:={1,0,0,0}
Out> {1,0,0,0};
In> E4:={ {0,u1,0,0},{d0,0,u2,0},{0,d1,0,0},{0,0,d2,0}}
Out> {{0,u1,0,0},{d0,0,u2,0},{0,d1,0,0},{0,0,d2,0}};
In> CharacteristicEquation(E4,x)
Out> x^4-x*u2*d1*x-u1*d0*x^2;
In> Expand(%,x)
Out> x^4-(u2*d1+u1*d0)*x^2;
In> v+E4*v+E4*E4*v+E4*E4*E4*v
Out> {1+u1*d0,d0+(d0*u1+u2*d1)*d0,d1*d0,d2*d1*d0};
</PRE>
</TABLE>
The standard Yacas script library also includes taking the determinant and
inverse of a matrix, finding eigenvectors and eigenvalues (in simple cases) and solving linear sets of equations, such as <B><TT>A x = b</TT></B> where A is a matrix, and x and b are vectors. There
are several more supported matrix operations. See the reference manual for
more details.
<A NAME="c1s9">

</A>
<H2>
<HR>Control flow: conditionals, loops, blocks
</H2>
The Yacas language includes some constructs and functions for control flow. Looping can be done with either a <B><TT>ForEach()</TT></B> or a <B><TT>While()</TT></B> function call. The function <B><TT>ForEach(x, list) body</TT></B> executes its body for each element of the list and assigns the variable "x" to that element each time. The function call <B><TT>While(predicate) body</TT></B> repeats "body" until the "predicate" returns <B><TT>False</TT></B>. 
<P>
Conditional execution is implemented by the <B><TT>If(predicate, body1, body2)</TT></B> function call, which works like the C language construct <B><TT>(predicate) ? body1 : body2</TT></B>. If the condition is true, "body1" is executed, otherwise "body2" and the corresponding value is returned. For example, the absolute value of a number "x" can be computed with: <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
absx := If( x>=0, x, -x );
</PRE>
</TABLE>

<P>
If several operations need to be executed in sequence to obtain a result, you can use a <B><TT>Prog()</TT></B> function call or equivalently the [ ] construct. 
<P>
To illustrate these constructs, let us create a list of all even integers from 2 to 20 and compute the product of all those integers except those divisible by 3. (This is not necessarily the most economical way to do it in Yacas.) <TABLE CELLPADDING="3" WIDTH="90%">
<TR><TD WIDTH=100% bgcolor=e0e0e0><PRE>
In> L := {};
Out> {};
In> i := 2;
Out> 2;
In> While(i<=20) [ L:= Append(L, i); i := i+2; ]
Out> True;
In> L;
Out> {2,4,6,8,10,12,14,16,18,20};
In> answer := 1;
Out> 1;
In> ForEach(i, L) If (Mod(i, 3)!=0, answer := answer * i);
Out> True;
In> answer;
Out> 2867200;
</PRE>
</TABLE>
We used a shorter form of <B><TT>If(predicate, body)</TT></B> with only one body which is executed when the condition holds. If the condition does not hold, this function call returns <B><TT>False</TT></B>.


</BODY>

</FONT>

</HTML>
