
Book()"Introduction to Yacas: tutorial and examples";

/*Text()
"The first chapter of this book is a short tutorial on using Yacas. Later chapters may serve as a User's Guide covering the Yacas functionality in more detail.";
*/
Chapter()"Getting started with Yacas";

Section()"Introduction";
Text()
"Yacas (Yet Another Computer Algebra System) is a small and highly flexible
general-purpose computer algebra language. The syntax uses a infix-operator
grammar parser. The distribution contains a small library of mathematical
functions, but its real strength is in the language in which you can easily
write your own symbolic manipulation algorithms. The core engine supports
arbitrary precision arithmetic (it can also optionally be linked with
the GNU arbitrary precision math library ":HtmlTerm("libgmp2"):") and is able to execute symbolic manipulations on various mathematical objects by following user-defined rules.
";

Section()"Installing Yacas";
Text()
"Read the file ":HtmlTerm("INSTALL"):" for instructions on how to compile Yacas. Yacas is
portable across most Unix-ish platforms and requires only a standard C++
compiler such as ":HtmlTerm("g++"):".":
HtmlNewParagraph():
"
At the base Yacas accepts text as input and returns text as output.
This makes it very platform-independent. Apart from Unix Yacas has been
compiled on Windows and EPOC32 aka Psion (which doesn't come with a standard c++
library!).
The source code to compile Yacas for Windows can be found at the
Sourceforge repository.
":
HtmlNewParagraph():
"
For Unix, compilation basically amounts to the standard sequence ":
HtmlCommand("
./configure
make
make install
");

Text()
"The arbitrary precision math in Yacas will be generally faster if you compile Yacas with the \"libgmp\" library (configure option --enable-gmp). Precompiled Red Hat (RPM) and Debian (DEB) packages are also available.";

Section()"Using the console mode";
Text()
"You can run Yacas in the console mode simply by typing ":HtmlTerm("yacas"):". The Yacas command prompt looks like this: ":
HtmlCommand("
In>
") :
"and Yacas's answers appear after the prompt":
HtmlCommand("
Out>
") :
"A Yacas session may be terminated by typing ":HtmlTerm("Exit()"):" or
":HtmlTerm("quit"):". Pressing ^C will also quit Yacas;
however, pressing ^C while Yacas is busy with a calculation will stop
just that calculation.
A session can be restarted (forgetting all previous
definitions and results) by typing ":HtmlTerm("restart"):

HtmlNewParagraph() :

"Typically, you would enter one statement per line, for example ":
HtmlCommand("
In> Sin(Pi/2);
Out> 1;
") :
"Statements should end with a semicolon (" : HtmlTerm(";") :
") although this is not required (Yacas will append a " :
HtmlTerm(";") : " at end of line to finish the statement)." :

HtmlNewParagraph() :

"All documentation is accessible from the Yacas prompt. If you type " :
HtmlCommand("
In> ??") :
" you should be able to read all available manuals (Yacas will run " : HtmlTerm("lynx") : " to show you the HTML documentation). You can also get help on individual functions: to read about the function ":HtmlTerm("Sum()") :", type ": HtmlCommand("
In> ?Sum") :

"You can also type ":HtmlTerm("Example();"): " to get some random examples of Yacas calculations." :

HtmlNewParagraph() :
"The command line has a history list, so it should be easy to
browse through the expressions you entered previously using the Up and Down arrow keys.
Typing the first few characters of a previous expression and then
hitting the TAB key makes Yacas recall the last expression
in the history list that matches these first characters." :

HtmlNewParagraph() :
"Commands spanning multiple lines can (and actually have to) be entered by using a trailing backslash \\ at end of each continued line. For example: ":
HtmlCommand("
In> a:=2+3+
Error on line 1 in file [CommandLine]
Line error occurred on:
>>>
Error parsing expression

In> a:=2+3+ \\
In> 1
Out> 6;
") :

"The error after our first attempt occurred because Yacas has appended a semicolon at end of the first line and ":HtmlTerm("2+3+;"):" is not a valid Yacas expression. Incidentally, any text Yacas prints without a prompt is either messages printed by functions as their side-effect, or error messages. Resulting values of expressions are always printed after an ":HtmlTerm("Out>"):"  prompt.";

Section()"Yacas as a symbolic calculator";

Text()"
We are ready to try some calculations. Yacas uses a C-like infix syntax and is case-sensitive. Here are some exact manipulations with fractions for a start: ":

HtmlCommand(
"In> 1/14+5/21*(30-(1+1/2)*5^2);
Out> -12/7;
"):

"The standard scripts already contain a simple math library for
symbolic simplification of basic algebraic functions. Any names such as ":HtmlTerm("x"):" are treated as independent, symbolic variables and are not evaluated by default.":

HtmlCommand(
"In> 0+x;
Out> x;
In> x+1*y;
Out> x+y;
In> Sin(ArcSin(alpha))+ArcCos(Cos(beta));
Out> alpha+beta;
In> (x+y)^3-(x-y)^3
Out> (x+y)^3-(x-y)^3;
In> Simplify(%)
Out> 6*x^2*y+2*y^3;
"):

"The special operator ":HtmlTerm("%"):" automatically recalls the result from the previous line. The function Simplify attempts to reduce an expression to a simpler form. Note that standard function names in Yacas are typically capitalized. Multiple capitalization such as \"ArcSin\" is sometimes used. The underscore character ":HtmlTerm("_"):" is a reserved operator symbol and cannot be part of variable or function names.":

HtmlNewParagraph():

"Yacas can deal with arbitrary precision numbers:":

HtmlCommand(
"In> 20!;":HtmlBreak():
"Out> 2432902008176640000;"):

"When dealing with floating point numbers, the command ":
HtmlTerm("Precision(n);"):" can be used to specify that all floating point numbers should have a fixed precision of ":HtmlTerm("n"):" digits:":
HtmlCommand(
"In> Precision(30);
Out> True;
In> 1.0/243;
Out> 0.004115226337448559670781893004;
"):

"Note that we need to enter ":HtmlTerm("1.0"):" as a floating-point constant to force the approximate calculation, otherwise the fraction would have been left unevaluated. The value ":HtmlTerm("True"):" is a boolean constant.":

HtmlNewParagraph():

"Analytic derivatives of functions can be evaluated:":

HtmlCommand(
"In> D(x) Sin(x);
Out> Cos(x);
In> D(x) D(x) Sin(x);
Out> -Sin(x);
"):

"Rational numbers will stay rational as long as the numerator and
denominator are integers, so ":HtmlTerm("55/10"):" will evaluate to
":HtmlTerm("11/2"):". You can override this behaviour by using the
numerical evaluation function ":HtmlTerm("N()"):": for example, ":HtmlTerm("N(55/10)"):" will evaluate to ":HtmlTerm("5.5"):" . This
behaviour holds for most math functions. Yacas will try to maintain an
exact answer (in terms of integers or fractions) instead of using
floating point numbers, unless ":HtmlTerm("N()"):" is used. If the
value for the constant ":HtmlEmphasis("pi"):" is needed, use ":HtmlTerm("Pi"):".
This will be replaced by the (approximate) numerical value when
":HtmlTerm("N(Pi)"):" is called. Yacas knows some simplification rules
using ":HtmlTerm("Pi"):" (especially with trigonometric functions). The
imaginary unit ":HtmlEmphasis("i"):" is denoted ":HtmlTerm("I"):" and complex
numbers can be entered as either expressions involving
":HtmlTerm("I"):" or explicitly ":HtmlTerm("Complex(a,b)"):" for
":HtmlEmphasis("a+i*b"):".": HtmlNewParagraph():

"Some simple equation solving algorithms are in place:":

HtmlCommand(
"In> Solve(a+x*y==z,x);
Out> (z-a)/y;
In> Solve({11*x+3*y==1,2*x+y==0},{x,y})
Out> {{1/5,-2/5}};
"):

"(Note the use of the ":HtmlTerm("=="):" operator, which does not evaluate to anything, to denote an \"equation\" object.) Currently ":HtmlTerm("Solve"):" is rather limited and only deals with equations where the variable to be solved for only occurs once in the equation. In the future there will be more sophisticated algorithms.":HtmlNewParagraph():

"Taylor series are supported. Typing ":

HtmlCommand("
In> Taylor(x,0,3) Exp(x)"):
" will result in ":HtmlTerm("1+x+(1/2)*x^2+(1/6)*x^3"):" . As this form may be a little bit hard to read, you might then type ":
HtmlCommand("
In> PrettyForm(%);

        / 1 \\    2   / 1 \\    3
1 + x + | - | * x  + | - | * x 
        \\ 2 /        \\ 6 /     

Out> True;
"):
"The function ":HtmlTerm("PrettyForm()"):" tries to render the formula in a better format for reading, using just ASCII text.";

Section()"Variables";
Text()"
Yacas supports variables:":
HtmlCommand("
In> Set(a,Cos(0));
Out> True;
In> a:=a+1;
Out> 2;
"):
" The variable ":HtmlTerm("a"):" has now been globally set to 2. The function Set() and the operator ":HtmlTerm(":="):" can both be used to assign values to global variables. (Variables
local to procedures can also be defined; see below the chapters on
programming.) To clear a variable binding, execute
":HtmlTerm("Clear(a);"):". ":HtmlTerm("a;"):" will now evaluate to just
":HtmlTerm("a"):". This is one of the properties of the evaluation
scheme of Yacas: when some object can not be evaluated or transformed
any further, it is returned as the final result.":

HtmlNewParagraph():

"Currently there is no difference between assigning variables using Set() or using the operator ":HtmlTerm(":="):". The latter can however also assign lists and define functions.";

Section()"Functions";

Text()
"The ":HtmlTerm(":="):" operator can be used to define functions: ":
HtmlCommand("f(x):=2*x*x"):" will define a new function, \"f\", that accepts
one argument and returns twice the square of that argument.":
HtmlNewParagraph() :
"A function name such as \"f\" may be used by different functions if they take different numbers of arguments: ":HtmlCommand("
In> f(x):=x^2;
Out> True;
In> f(x,y):=x*y;
Out> True;
In> f(3)+f(3,2);
Out> 15;
"):

HtmlNewParagraph() :
"Functions may also return boolean values (":HtmlTerm("True"):" and ":HtmlTerm("False"):"). Such functions are called ":HtmlEmphasis("predicates"):". For example, IsNumber() and IsInteger() are predicates defined in the standard library:":HtmlCommand("
In> IsNumber(2+x);
Out> False;
In> IsInteger(15/5);
Out> True;
"):

HtmlNewParagraph() :
"When assigning variables, the right hand side is evaluated before it
is assigned. Thus ":HtmlCommand("a:=2*2"):" will set ":HtmlTerm("a"): "
to 4. This is however ":HtmlEmphasis("not"):" the case for functions. When entering ":
HtmlTerm("f(x):=x+x"):" the right hand side, ":HtmlTerm("x+x"):", is
not evaluated before being assigned. This can be forced by using the
assignment in combination with Eval:": HtmlCommand("f(x):=Eval(x+x)"):"
will first evaluate ":HtmlTerm("x+x"):" to ":HtmlTerm("2*x"):" before
assigning it to the user function f. This specific example is not a
very useful one but it will come in handy when the operation being
performed on the right hand side is expensive. For example, if we
evaluate a Taylor series expansion before assigning it to the
user-defined function, the engine doesn't need to create the Taylor
series expansion each time that user-defined function is called.";

Section()"Strings and lists";

Text()
"In addition to numbers and variables, Yacas supports strings and lists. Strings are simply sequences of characters enclosed by double quotes, for example: ":HtmlTerm("\"this is a string with \\\"quotes\\\" in it\""):". Lists are ordered groups of items, as usual. Yacas represents lists by putting the objects between braces and separating them with commas. The list consisting of objects a, b, and c could be entered by typing ":HtmlTerm("{a,b,c}"):". In Yacas, vectors are represented as lists and matrices as lists of lists. In fact, any Yacas expression can be converted to a list (see below).":

HtmlNewParagraph() :

"Items in a list can be accessed through the " : HtmlTerm("[ ]") : "
operator. Examples: when you enter " : HtmlCommand("uu:={a,b,c,d,e,f};") :
"then " : HtmlCommand("uu[2];") : "evaluates to b, and " :
HtmlCommand("uu[2 .. 4];") : "evaluates to {b,c,d}. Here " :
HtmlCommand("2 .. 4") : "evaluates to ":HtmlTerm("{2,3,4}"):". Note that
spaces around the ":HtmlTerm(".."):" operator are necessary, or else the
parser will not be able to distinguish it from a number.":
HtmlNewParagraph() :

"Another use of lists is the associative list, sometimes called a hash table, which is implemented in Yacas simply as a list of key-value pairs. Keys must be strings and values may be any objects. Associative lists can also work as mini-databases. As an example, first
enter ": HtmlCommand("u:={};"):" and then ":
HtmlCommand("
u[\"name\"]:=\"Isaia\";
u[\"occupation\"]:=\"prophet\";
u[\"is alive\"]:=False;
"):
" Then, ":HtmlTerm("u[\"name\"]"):" would return ":
HtmlTerm("\"Isaia\""):". The list ":HtmlTerm("u"):" now contains three sublists, as we can see:":
HtmlCommand("
In> u;
Out> { {\"is alive\", False}, {\"occupation\", \"prophet\"}, {\"name\", \"Isaia\"} };
"):

HtmlNewParagraph() :

"Assignment of multiple variables is also possible using lists. For instance, ":
HtmlTerm("{x,y}:={2!,3!}"):" will result in 2 being assigned to
x and 6 to y.":

HtmlNewParagraph() :

"Lists evaluate their arguments, and return a list with results of evaluating each element. So, typing ":HtmlTerm("{1+2,3};"):" would evaluate to ":HtmlTerm("{3,3}"):HtmlNewParagraph():

"The idea of using lists to represent expressions dates back to the
language LISP, which was developed in the 70's. Together with a
small set of operations on lists very powerful symbolic manipulation
algorithms can be built. Lists can also be used as function arguments when a variable number of arguments are expected.":HtmlNewParagraph():

"Let's try some list operations now:":

HtmlCommand("
In> m:={a,b,c};
Out> True;

In> Length(m);
Out> 3;

In> Reverse(m);
Out> {c,b,a};

In> Concat(m,m);
Out> {a,b,c,a,b,c};

In> m[1]:=\"blah blah\";
Out> True;
In> m;
Out> {\"blah blah\",b,c};

In> Nth(m,2);
Out> b;
"):

"Many more list operations are described in the reference manual.";

Section()"Linear Algebra";

Text()
"Vectors of fixed dimension are represented as lists of their components. The list {1,2,3} would be a three-dimensional vector with components 1, 2 and 3. Matrices are represented as a vector of vectors.":HtmlNewParagraph():

"Vector components can be assigned values just like list items, since they are in fact list items:":

HtmlCommand(
"In> l:=ZeroVector(3);":HtmlBreak():
"Out> True;":HtmlBreak():
"In> l;":HtmlBreak():
"Out> {0,0,0};":HtmlBreak():
"In> l[ 2 ]:=2;":HtmlBreak():
"Out> True;":HtmlBreak():
"In> l;":HtmlBreak():
"Out> {0,2,0};"):

"Yacas can perform multiplication of matrices, vectors and numbers as usual
in linear algebra: ":

HtmlCommand("
In> v:={1,0,0,0}
Out> {1,0,0,0};
In> E4:={ {0,u1,0,0},{d0,0,u2,0},{0,d1,0,0},{0,0,d2,0}}
Out> {{0,u1,0,0},{d0,0,u2,0},{0,d1,0,0},{0,0,d2,0}};
In> CharacteristicEquation(E4,x)
Out> x^4-x*u2*d1*x-u1*d0*x^2;
In> Expand(%,x)
Out> x^4-(u2*d1+u1*d0)*x^2;
In> v+E4*v+E4*E4*v+E4*E4*E4*v
Out> {1+u1*d0,d0+(d0*u1+u2*d1)*d0,d1*d0,d2*d1*d0};
"):

"The standard Yacas script library also includes taking the determinant and
inverse of a matrix, finding eigenvectors and eigenvalues (in simple cases) and solving linear sets of equations, such as ":HtmlTerm("A x = b"):" where A is a matrix, and x and b are vectors. There
are several more supported matrix operations. See the reference manual for
more details.";

Section()"Control flow: conditionals, loops, blocks";

Text()
"The Yacas language includes some constructs and functions for control flow. Looping can be done with either a ":HtmlTerm("ForEach()"):" or a ":HtmlTerm("While()"):" function call. The function ":HtmlTerm("ForEach(x, list) body"):" executes its body for each element of the list and assigns the variable \"x\" to that element each time. The function call ":HtmlTerm("While(predicate) body"):" repeats \"body\" until the \"predicate\" returns ":HtmlTerm("False"):". ":HtmlNewParagraph():

"Conditional execution is implemented by the ":HtmlTerm("If(predicate, body1, body2)"):" function call, which works like the C language construct ":HtmlTerm("(predicate) ? body1 : body2"):". If the condition is true, \"body1\" is executed, otherwise \"body2\" and the corresponding value is returned. For example, the absolute value of a number \"x\" can be computed with: ":HtmlCommand("
absx := If( x>=0, x, -x );
"):
HtmlNewParagraph():

"If several operations need to be executed in sequence to obtain a result, you can use a ":HtmlTerm("Prog()"):" function call or equivalently the [ ] construct. ":
HtmlNewParagraph():

"To illustrate these constructs, let us create a list of all even integers from 2 to 20 and compute the product of all those integers except those divisible by 3. (This is not necessarily the most economical way to do it in Yacas.) ":HtmlCommand("
In> L := {};
Out> {};
In> i := 2;
Out> 2;
In> While(i<=20) [ L:= Append(L, i); i := i+2; ]
Out> True;
In> L;
Out> {2,4,6,8,10,12,14,16,18,20};
In> answer := 1;
Out> 1;
In> ForEach(i, L) If (Mod(i, 3)!=0, answer := answer * i);
Out> True;
In> answer;
Out> 2867200;
"):

"We used a shorter form of ":HtmlTerm("If(predicate, body)"):" with only one body which is executed when the condition holds. If the condition does not hold, this function call returns ":HtmlTerm("False"):".
";

Chapter()"Examples";
Text()
"This is a small tour of the capabilities Yacas currently offers. Note
that this list of examples is far from complete. Yacas contains a few
hundred commands, of which only a few are shown here.":
HtmlNewParagraph():
"Additional example calculations including the results can be found
here:
<UL>
   <LI> A selection of calculations from the
        <A HREF=\"westerbench.html\">Wester benchmark</A>.
   <LI> Some additional <A HREF=\"mybench2.html\">example calculations</A> 
        that Yacas can currently perform.
</UL>";


Section()"Miscellaneous capabilities";

Text()
HtmlCommand("100!;") :"Compute a large factorial using arbitrary
precision integers." : HtmlNewParagraph();


Text()
HtmlCommand("ToBase(16,255);") :
  "Convert to another number base." : HtmlNewParagraph();

Text()
HtmlCommand("Expand((1+x)^5);") :
  "Expand the expression into a polynomial." : HtmlNewParagraph();

Text()
HtmlCommand("Apply(\"+\",{2,3});") :
  "Apply an operator to a list of arguments. This
example would evaluate to 5." : HtmlNewParagraph();



Text()
HtmlCommand("Apply({{x,y},x+y},{2,3});") :
  "Apply a pure function to a list of arguments. This
example would also evaluate to 5." : HtmlNewParagraph();

Text()
HtmlCommand("D(x)D(x) Sin(x);"):
  "Take derivatives of a function." : HtmlNewParagraph();


Text()
HtmlCommand("Solve(a+x*y==z,x);"):
  "Solve an equation for a variable." : HtmlNewParagraph();

Text()
HtmlCommand("Taylor(x,0,5) Sin(x);"):
  "Calculate the taylor series expansion of a function." : HtmlNewParagraph();

Text()
HtmlCommand("Limit(x,0) Sin(x)/x;"):
  "Calculate the limit of a function as a variable
approaches a value." : HtmlNewParagraph();

Text()
HtmlCommand("Newton(Sin(x),x,3,0.0001);"):
  "Use Newton's method for numerically finding a zero of a function." : HtmlNewParagraph();

Text()
HtmlCommand("DiagonalMatrix({a,b,c});"):
  "Create a matrix with the elements specified
in the vector on the diagonal." : HtmlNewParagraph();

Text()
HtmlCommand("Integrate(x,a,b) x*Sin(x);"):
  "Integrate a function over variable x, from a to b." : HtmlNewParagraph();

Text()
HtmlCommand("Factors(x^2-1);"):
  "Factorize a polynomial." : HtmlNewParagraph();

Text()
HtmlCommand("Apart(1/(x^2-1),x);"):
  "Create a partial fraction expansion of a polynomial." : HtmlNewParagraph();

Section()"A longer calculation with plotting";

Text()
"Here is an example of a semi-real numerical calculation using Yacas. The problem is to visualize a particular exact solution of an elliptical differential equation that is represented by an infinite series. We want to evaluate this infinite series numerically and plot it for particular values of the parameters. The series could be represented using Yacas notation as ":
HtmlCommand("
1/(2*Pi)*Sin(q*phi)/Sin(2*q*phi)+ 1/Pi*Sum(n, 0, Infinity,
  Cos(n*chi) * Sin(Sqrt(q^2-n^2)*phi) / Sin(Sqrt(q^2-n^2)*phi) )
"):

" Here ":HtmlTerm("q"):", ":HtmlTerm("phi"):" and ":HtmlTerm("chi"):" are numerical parameters of the problem. We would like to plot this series evaluated at fixed ":HtmlTerm("q"):" and ":HtmlTerm("phi"):" as function of ":HtmlTerm("chi"):" between 0 and ":HtmlTerm("2*Pi"):".":HtmlNewParagraph():

"To solve this problem, we prepare a separate file with the following Yacas code: ":
HtmlCommand("
	/* Auxiliary function */
g1(n, q, phi, chi) := [
	Local(s);
	s := q^2-n^2;
	N(Cos(n*chi) * If(s=0,
		1/2,	/* Special case of s=0: avoid division by 0 */
		Sin(Sqrt(s)*phi)/Sin(2*Sqrt(s)*phi)	/* now s != 0 */
			/* note that Sqrt(s) may be imaginary here */
		)
	);
];

	/* Main function */
g(q, phi, chi) := [ 
	Local(M, n);
	M := 16; /* Exp(-M) will be the precision */
		/* Use N() to always force evaluation */
	N(1/2*Sin(q*phi)/Sin(2*q*phi)) +
		/* Estimate the necessary number of terms in the series */
	Sum(n, 1, N(1+Sqrt(q^2+M^2/phi^2)), g1(n, q, phi, chi)) ;
];
	/* Parameters */
q:=3.5;
phi:=2;
	/* Make a function for plotting: it must have only one argument */
f(x) := g(q, phi, x);
	/* Plot from 0 to 2*Pi with 80 points */
GnuPlot(0, N(2*Pi), 80, f(x));
"):

"Name this file \"fun1\" and execute this script by typing":
HtmlCommand("Load(\"fun1\");"):

"After this you should see a window with a plot.";

Chapter()"Let's learn some more";

Section()"Command-line options and yacas_client";
Text()
"The default operation of Yacas is to run in the interactive console mode. Yacas accepts several options that modify its operation. Options can be combined, for example, :
":HtmlCommand("
yacas -c
"):"Inhibit printing of prompts \"In>\" and \"Out>\". Useful for non-interactive sessions.
":HtmlCommand("
yacas -f
"):"Reads standard input as one file, but executes only the first statement in it. (You may want to use a statement block to have several statements executed.)
":HtmlCommand("
yacas -p
"):"Does not use terminal capabilities, no fancy editing on the command line and no escape sequences printed. Useful for non-interactive sessions.
":HtmlCommand("
yacas -t
"):"Enable some extra history recall functionality in console mode: after executing a command from the history list, the next unmodified command from the history list will be automatically entered on the command line.
":HtmlCommand("
yacas {filename}
"):"Reads and executes commands in the filename and exits. Equivalent to \"Load()\".
":HtmlCommand("
yacas -v
"):"Prints version information and exits.
":HtmlCommand("
yacas -d
"):"Prints the path to the Yacas library directory and exits.
":HtmlNewParagraph():

"In addition to the console mode, an experimental persistent session facility is provided through the script ":HtmlTerm("yacas_client"):". By means of this script, the user can configure third-party applications to pass commands to a constantly running \"Yacas server\" and get output. The \"Yacas server\" is automatically started by ":HtmlTerm("yacas_client"):". It may run on a remote computer; in that case the user should have a user account on the remote computer and privileges to execute ":HtmlTerm("yacas_client"):" there, as well as ":HtmlTerm("rsh"):" or ":HtmlTerm("ssh"):" access. The purpose of ":HtmlTerm("yacas_client"):" is to enable users to pass commands to Yacas within a persistent session while running another application such as a text editor. ":HtmlNewParagraph():

"The script ":HtmlTerm("yacas_client"):" reads Yacas commands from the standard input and passes them to the running \"Yacas server\"; it then waits 2 seconds and prints whatever output Yacas produced up to this time. Usage may looks like this:
":HtmlCommand("
8:20pm Unix>echo \"x:=3\" | yacas_client 
Starting server.
[editvi] [gnuplot] 
True;
To exit Yacas, enter  Exit(); or quit or Ctrl-c. Type ?? for help.
Or type ?function for help on a function.
Type 'restart' to restart Yacas.
To see example commands, keep typing Example();
In> x:=3
Out> 3;
In> 8:21pm Unix>echo \"x:=3+x\" | yacas_client
In> x:=3+x
Out> 6;
In> 8:23pm Unix>yacas_client -stop
In> quit
Quitting...
Server stopped.
8:23pm Unix>
"):

"Persistence of the session means that Yacas remembered the value of \"x\" between invocations of ":HtmlTerm("yacas_client"):". If there is not enough time for Yacas to produce output within 2 seconds, the output will be displayed the next time you call ":HtmlTerm("yacas_client"):". ":HtmlNewParagraph():

"The \"Yacas server\" is started automatically when first used and can be stopped either by quitting Yacas or by an explicit option ":HtmlTerm("yacas_client -stop"):", in which case ":HtmlTerm("yacas_client"):" does not read standard input. ":HtmlNewParagraph():

"The script ":HtmlTerm("yacas_client"):" reads standard input and writes to standard output, so it can be used via remote shell execution. For instance, if an account \"user\" on a remote computer \"remote.host\" is accessible through ssh, then ":HtmlTerm("yacas_client"):" can be used remotely like this: ":HtmlCommand("
echo \"x:=2;\" | ssh user@remote.host yacas_client
"):"
 On a given host computer running the \"Yacas server\", each user currently may have only one persistent Yacas session.
";

Section()"Compound statements";

Text()
"Multiple statements can be grouped together using the [ and ] brackets.
The compound ":HtmlTerm("[a;b;c;];"):" evaluates a, then b, then c, and returns the result
of evaluating c.":

HtmlNewParagraph():

"A variable can be declared
local to a compound statement block by the function ":HtmlTerm("Local(var1, var2,...)") : ".";

Section()"\"Threading\" of functions";

Text()
"Some functions in Yacas can be " :
HtmlEmphasis("threaded") : ". This means that calling the function
with a list as argument will result in a list with that function being
called on each item in the list. E.g. " :
HtmlCommand("Sin({a,b,c});") :
"will result in ":HtmlTerm("{Sin(a),Sin(b),Sin(c)}"):". This functionality is implemented for most normal analytic functions and arithmetic
operators. ";

Section()"Functions as lists";

Text()
"Internally, Yacas represents all atomic expressions (numbers and variables) as strings and all compound expressions as lists, just like LISP. Try ": HtmlTerm("FullForm(a+b*c);"):" and you will see
the text ": HtmlTerm("(+ a (* b c ))"):" appear on the screen. Also, any expression can be converted to a list by the function Listify() or back to an expression by the function UnList():" :
HtmlCommand("
In> Listify(a+b*(c+d));
Out> {+,a,b*(c+d)};
In> UnList({Atom(\"+\"),x,1});
Out> x+1;
"):
"Note that the first element of the list is the name of the function ": HtmlTerm("+"):" which is equivalently represented as ": HtmlTerm("Atom(\"+\")"):" and that the subexpression \"b*(c+d)\" was not converted to the list form.";

Text() "":HtmlEmphasis("Pure functions"):" are the equivalent of \"lambda expressions\"
of LISP. They are currently implemented using lists and the operator
Apply(). The following line: " :

HtmlCommand("Apply( {{x,y},x+y} , {2,3} );") :
"would evaluate to 5." : HtmlNewParagraph() :

"Here, " : HtmlTerm("{{x,y},x+y}") : " is a list that is treated as a pure
function by the operator ":HtmlTerm("Apply"):", the symbols \"x\" and \"y\" become
local variables bound to the parameters passed, and " : HtmlTerm("x+y"): "
becomes the body of the function.";

Section()"More on syntax";

Text()

"The syntax is handled by an infix grammar parser. Precedence of operations
can be specified explicitly by parentheses ":HtmlTerm("( )"):" when the
normal precedence is not what you want. This means that most of the time
you will have to enter expressions of the form ":HtmlTerm("Func(var1,
var2)"):", or using infix operators, ":HtmlTerm("a*(b+c)"):", prefix
operators: ":HtmlTerm("-x"):", or postfix operators: ":HtmlTerm("x++"):".
The parser is case-sensitive and overall the syntax conventions resemble
the C language. Last but not least there are the so called \"bodied\"
functions, which unlike normal functions such as ":HtmlTerm("f(x,y)"):"
keep the last argument outside of the bracketed argument list:
\"":HtmlTerm("f(x) y"):"\". This looks somewhat like a mathematical
\"operator\" ":HtmlEmphasis("f(x)"):" acting on ":HtmlEmphasis("y"):". A
typical example is the function ":HtmlTerm("While"):" which looks like
\"":HtmlTerm("While (predicate) body;"):"\". The derivative operator D(x)
is also defined as a \"bodied\" function. Note that if we defined a
\"bodied\" function ":HtmlTerm("A"):" with only one argument, we'd have to
use it like this: \"":HtmlTerm("A() x;"):"\" and it would look a bit odd.
In this case we could make \"A\" a prefix operator and then the syntax
would become somewhat cleaner: \"":HtmlTerm("A x;") : "\"";

Text()
HtmlNewParagraph():

"However, regardess of presentation, internally all functions and operators
are equal and merely take a certain number of arguments. The user may
define or redefine any operators with either \"normal\" names such as \"A\"
or names made of one or more of the special symbols ":HtmlTerm("+ - * / = `
~ : ! @ # $ ^ & * _ | < >"):" and declare them to be infix, postfix, or
prefix operators, as well as normal or bodied functions. (The symbol ":HtmlTerm("%"):" is reserved for the result of the previous expression.)
Some of these operators and combinations are already defined in Yacas's
script library, for instance the \"syntactic sugar\" operators such as
":HtmlTerm(":="):" or ":HtmlTerm("<--"):", but they can be in principle
re-defined too. These \"special\" operators are in no way special, except
for their syntax. All infix, prefix, and postfix operators and bodied
functions can be assigned a precedence; infix operators in addition have a
left and a right precedence. All this will only affect the syntax of input
and could be arranged for the user's convenience.":

HtmlNewParagraph():

"The only caveat is to make sure you always type a space between any
symbols that could make up an operator. For instance, after you define a
new function \"":HtmlTerm("@@(x):=x^2;"):"\" expressions such as
\"":HtmlTerm("a:=@@(b);"):"\" typed without spaces will cause an error
unless you also define the operator \"":HtmlTerm(":=@@"):"\". This is
because the parser will not stop at \"":HtmlTerm(":="):"\" when trying to
make sense of that expression. The correct way to deal with this is to
insert a space: \"":HtmlTerm("a:=&nbsp;@@(b);"):"\" Spaces are
":HtmlEmphasis("not"):" required in situations such as
\"":HtmlTerm("a:=-1"):"\", but this is so only because the operator
":HtmlTerm(":=-"):" is actually defined in Yacas.":

HtmlNewParagraph():

"Let's now have a hands-on primer for these syntactic constructions. Suppose we wanted to define a function ":HtmlEmphasis("F(x,y)=x/y+y/x"):". We could use the standard syntax: ":
HtmlCommand("
In> F(a,b) := a/b + b/a;
Out> True;
"): " and then use the function as ":HtmlTerm("F(1,2);"):" We might also declare an equivalent infix operation, let's call it \"":HtmlTerm("xx"):"\", so that we could write simply \"1 xx 2\". Infix operators must have a precedence, so let's assign it the precedence of the usual division operator. The declaration goes as follows: ":
HtmlCommand("
In> Infix(\"xx\", OpPrecedence(\"/\"));
Out> True;
In> a xx b := a/b + b/a;
Out> True;
In> 3 xx 2 + 1;
Out> 19/6;
"):
"Check the math and note how the precedence works! We have chosen the name \"":HtmlTerm("xx"):"\" just to show that we don't need to use the special characters in the infix operator's name. However we must define this operator as infix before using it in expressions, or we'd get syntax errors.":HtmlNewParagraph():
 
"Finally, we might decide to be completely flexible with this important
function and also define it as a mathematical operator
":HtmlEmphasis("##"):". First we define ":HtmlEmphasis("##"):" as a
\"bodied\" function and then proceed as before:" : HtmlCommand(" In>
Bodied(\"##\", OpPrecedence(\"/\")); Out> True; In> ##(a) b := a xx b; Out>
True; In> ##(1) 3 + 2; Out> 16/3; ") : "We have used the name \"##\" but we
could have used any other name such as \"xx\" or \"F\" or even \"_-+@+-_\".
Apart from possibly confusing yourself, it doesn't matter what you call the
functions you define. There is currently one limitation in Yacas: once a
function name is declared as infix (prefix, postfix) or bodied, it will
always be interpretedthat way. If we declare \"f\" to be \"bodied\", we may
later define different functions named \"f\" with different numbers of
arguments, however all of these functions must be \"bodied\".";

Section()"Writing simplification rules";
Text()

"Mathematical calculations require versatile transformations on symbolic
quantities. Instead of trying to define all possible transformations, Yacas
provides a simple and easy to use pattern matching scheme for manipulating
expressions according to user-defined ":HtmlEmphasis("rules"):". Yacas itself is designed as a small core with a large library of rules that match and replace patterns. Examples can be found in the library files \"standard\", \"stdfuncs\", \"deriv\" and \"solve\" that
come with the Yacas distribution." :

HtmlNewParagraph() :

"One simple application of pattern-matching rules is to define new
functions. (This is actually the only way Yacas can learn about new
functions.) As an example, let's define a function \"f\" that will evaluate
factorials of non-negative integers. We'll first define a predicate to
check whether our argument is indeed a non-negative integer, and we'll use
this predicate and the obvious recursion f(n)=n*f(n-1) to evaluate the
factorial. Tll this is accomplished by the following three lines:":

HtmlCommand(
"
IsIntegerGreaterThanZero(_n) <-- IsInteger(n) And n>0;
10 # f(0) <-- 1;
20 # f(n_IsIntegerGreaterThanZero) <-- n*f(n-1);
"):

"We have first defined a new predicate
":HtmlTerm("IsIntegerGreaterThanZero()"):" and then defined two
\"simplification rules\" for a new function ":HtmlTerm("f()"):". A
predicate equivalent to ":HtmlTerm("IsIntegerGreaterThanZero()"):" is
actually already defined in the standard library and it's called
":HtmlTerm("IsPositiveInteger"):", so it was not necessary, strictly
speaking, to define our own predicate to do the same thing and we did it
here just for illustration. The other two lines obviously define a
factorial function f(n)=n*(n-1)*...*1, and the rules are given precedence
values 10 and 20, so the first rule will be applied first. Incidentally,
the factorial is also defined in the standard library as the operator
\"":HtmlTerm("!"):"\" and it is bound to an internal routine much faster
than the recursion in our example.": HtmlNewParagraph():

"The operator ":HtmlTerm("<--"):" defines a rule to be applied to a
specific function. The ":HtmlTerm("_n"):" in the rule for
IsIntegerGreaterThanZero() specifies that any object which happens to be
the argument of that predicate is matched and assigned to the local
variable \"n\". The expression to the right of ":HtmlTerm("<--"):" can then
just use ":HtmlTerm("n"):" (without the underscore) as a variable.":
HtmlNewParagraph():

"Now we consider the rules for the function ":HtmlEmphasis("f"):". The
first rule just specifies that f(0) should be replaced by 1 in any
expression. The second rule is a little more involved.
":HtmlTerm("n_IsIntegerGreaterThanZero"):" is a match for the argument of
":HtmlEmphasis("f"):", with the proviso that the predicate ":
HtmlTerm("IsIntegerGreaterThanZero(n)"):" should return
":HtmlTerm("True"):", otherwise the pattern is not matched. The underscore
operator is to be used only on the left hand side of the rule operator
":HtmlTerm("<--"):".":

HtmlNewParagraph():
"There are actually another equivalent way of writing the second rule: ":HtmlCommand("
20 # f(_n)_(IsIntegerGreaterThanZero(n)) <-- n*f(n-1);
"):
"The underscore ":HtmlEmphasis("after"):" the function object is a predicate that should return True, or else there is no match. This predicate may be a complicated expression involving several logical operations, unlike the simple checking of just one predicate in the ":HtmlTerm("n_IsIntegerGreaterThanZero"):" construct.":

HtmlNewParagraph():

"Precedence values for rules are given by a number followed by the
":HtmlTerm("#"): " operator. This number determines the ordering of
precedence for the pattern matching rules, with 0 the lowest allowed
precedence value, i.e. rules with precedence 0 will be tried first.
Multiple rules can have the same number: this just means that it doesn't
matter what order these patterns are tried in. If no number is supplied, 0
is assumed. In our example, the rule ":HtmlEmphasis("f(0)=1"):" must be
applied earlier than the recursive rule, or else the recursion will never
terminate. But as long as there are no other rules concerning the function
":HtmlEmphasis("f"):", the assignment of numbers 10 and 20 is arbitrary,
and they could have been 500 and 501 just as well." :

HtmlNewParagraph() :
"Additional predicates can be specified too. ":HtmlTerm("IsIntegerGreaterThanZero"):
" could also have been defined as:":
HtmlCommand(
"
10 # IsIntegerGreaterThanZero(n_IsInteger)_(n>0) <-- True;
20 # IsIntegerGreaterThanZero(_n) <-- False;
"):
"Where the first rule specifies that if n is an integer, and greater than
zero, the predicate is true, and the second rule states that the
predicate is false otherwise.":

HtmlNewParagraph():
"The left hand side of a rule has the form ":

HtmlNewParagraph():
"\"pattern _ postpredicate <-- replacement\".":
HtmlNewParagraph():

"The ":HtmlTerm("(n>0)"):" clause is added
after the pattern and allows the pattern to match only if this predicate return ":HtmlTerm("True"):". This is a useful syntax for defining rules with complicated predicates. There is no difference between the rules ":HtmlTerm("F(n_IsPositiveInteger)<--..."):" and ":HtmlTerm("F(_n)_(IsPositiveInteger(n)) <-- ..."):" except that the first syntax is a little more concise.":

HtmlNewParagraph() :

"Some more examples of rules:":
HtmlCommand(
"
_x + 0 <-- x;
_x - _x <-- 0;
ArcSin(Sin(_x)) <-- x;
"):

"Yacas will first try to match the pattern like a template. Names preceded
or followed by an underscore can match any one object: a number, a
function, a list, etc. Yacas will assign the relevant variables as local
variables within the rule, and try the predicates as stated in the pattern.
The post-predicate (defined after the pattern) is tried after all these
matched. As an example, the simplification rule ": HtmlTerm("_x - _x <--
0;"): " specifies that the two objects at left and at right of the minus
sign should be the same." :

HtmlNewParagraph() : "There is a slightly more complex and general way of
defining rules using the ":HtmlTerm("RuleBase()"):" and
":HtmlTerm("Rule()"):" functions, but the \"": HtmlTerm("... # ... <--
..."):"\" construct is usually sufficiently flexible and much more readable. ";
