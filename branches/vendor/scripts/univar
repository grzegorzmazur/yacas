




/* todos for univariates:
   - Factorize
*/


RuleBase("NormalForm",{expression});
Rule("NormalForm",1,1000,True) expression;



Rule("NormalForm",1,0,Type(expression) = "UniVariate")
    ExpandUniVariate(expression[1],expression[2],expression[3]);


Function("ExpandUniVariate",{var,first,coefs})
[
  Local(result,i);
  result:=0;
  For(i:=1,i<=Length(coefs),i++)
    result:=result+NormalForm(coefs[i])*var^(first+i-1);
  result;
];


Function("IsUniVar",{expr}) Type(expr) = "UniVariate";

RuleBase("UniVariate",{var,first,coefs});

Rule("UniVariate",3,10,Length(coefs)>0 And coefs[1]=0)
  UniVariate(var,first+1,Tail(coefs));
Rule("UniVariate",3,1000,IsComplex(var) Or IsList(var))
    ExpandUniVariate(var,first,coefs);

20 # IsZero(UniVariate(_var,_first,_coefs)) <-- IsZeroVector(coefs);

RuleBase("Degree",{expr});
Rule("Degree",1,0, IsUniVar(expr))
[
  Local(i,min,max);
  min:=expr[2];
  max:=min+Length(expr[3]);
  i:=max;
  While(i >= min And IsZero(Coef(expr,i))) i--;
  i;
];
Rule("Degree",1,1, True)
    Degree(MakeUni(expr));

Degree(_poly,_var) <-- Degree(MakeUni(poly,var));

500 # (aLeft_IsUniVar + aRight_IsUniVar)_(aLeft[1] = (aRight[1])) <--
[
  Local(from,result);
  Local(curl,curr,left,right);

  curl:=aLeft[2];
  curr:=aRight[2];
  left:=aLeft[3];
  right:=aRight[3];
  result:={};
  from:=Min(curl,curr);

  While(curl<curr And left != {})
  [
    DestructiveAppend(result,Head(left));
    left:=Tail(left);
    curl++;
  ];
  While(curl<curr)
  [
    DestructiveAppend(result,0);
    curl++;
  ];
  While(curr<curl And right != {})
  [
    DestructiveAppend(result,Head(right));
    right:=Tail(right);
    curr++;
  ];
  While(curr<curl)
  [
    DestructiveAppend(result,0);
    curr++;
  ];
  While(left != {} And right != {})
  [
    DestructiveAppend(result,Head(left)+Head(right));
    left  := Tail(left);
    right := Tail(right);
  ];


  While(left != {})
  [
    DestructiveAppend(result,Head(left));
    left  := Tail(left);
  ];
  While(right != {})
  [
    DestructiveAppend(result,Head(right));
    right := Tail(right);
  ];

  UniVariate(aLeft[1],from,result);
];


200 # aLeft_IsUniVar + aRight_IsNumber <-- aRight+aLeft;
200 # aLeft_IsNumber + aRight_IsUniVar <--
    UniVariate(aRight[1],0,{aLeft})+aRight;

200 # - (aLeft_IsUniVar) <--
     Apply("UniVariate",{aLeft[1],aLeft[2],-(aLeft[3])});


200 # aLeft_IsUniVar - aRight_IsUniVar <--
[
  Local(from,result);
  Local(curl,curr,left,right);

  curl:=aLeft[2];
  curr:=aRight[2];
  left:=aLeft[3];
  right:=aRight[3];
  result:={};
  from:=Min(curl,curr);

  While(curl<curr And left != {})
  [
    DestructiveAppend(result,Head(left));
    left:=Tail(left);
    curl++;
  ];
  While(curl<curr)
  [
    DestructiveAppend(result,0);
    curl++;
  ];
  While(curr<curl And right != {})
  [
    DestructiveAppend(result,-Head(right));
    right:=Tail(right);
    curr++;
  ];
  While(curr<curl)
  [
    DestructiveAppend(result,0);
    curr++;
  ];
  While(left != {} And right != {})
  [
    DestructiveAppend(result,Head(left)-Head(right));
    left  := Tail(left);
    right := Tail(right);
  ];


  While(left != {})
  [
    DestructiveAppend(result,Head(left));
    left  := Tail(left);
  ];
  While(right != {})
  [
    DestructiveAppend(result,-Head(right));
    right := Tail(right);
  ];

  UniVariate(aLeft[1],from,result);
];

/* Repeated squares multiplication
 TODO put somewhere else!!!
 */
10 # RepeatedSquaresMultiply(_a,- (n_IsInteger)) <-- 1/RepeatedSquaresMultiply(a,n);
20 # RepeatedSquaresMultiply(_a,n_IsInteger) <--
[
  Local(m,b);
  m:=1;
  b:=1;
  While(m<=n) m:=(m<<1);
  m:= (m>>1);
  While(m>0)
  [
    b:=b*b;
    If (BitAnd(m,n) != 0,b:=b*a);
    m:= (m>>1);
  ];
  b;
];

200 # aLeft_IsUniVar ^ aRight_IsPositiveInteger <--
[

  Local(result);
  result:=RepeatedSquaresMultiply(aLeft,aRight);
  result;

/*
  aLeft*(aLeft^(aRight-1));
*/
];


/*TODO this can be made twice as fast!*/

200 # (aLeft_IsUniVar * _aRight)_(Not(Contains(VarList(aRight),aLeft[1]))) <--
    aRight*aLeft;


200 # (_factor * UniVariate(_var,_first,_coefs))_(Not(Contains(VarList(factor),var))) <--
  UniVariate(var,first,coefs*factor);

200 # (UniVariate(_var,_first,_coefs)/_factor)_(Not(Contains(VarList(factor),var))) <--
  UniVariate(var,first,coefs/factor);


MaxUniOrder:=3000;
Function("SetOrder",{order}) MaxUniOrder:=order;


Function("ShiftUniVar",{uni,fact,shift})
[
 Apply("UniVariate",{uni[1],uni[2]+shift,fact*(uni[3])});
];

200 # (aLeft_IsUniVar * aRight_IsUniVar)_(aLeft[1] = aRight[1]) <--
[
  Local(i,j,n,shifted,result);
  result:=MakeUni(0,aLeft[1]);

  n:=Length(aLeft[3]);
  For(i:=1,i<=n,i++)
  [
    result:=result+ShiftUniVar(aRight,aLeft[3][i],aLeft[2]+i-1);
  ];
  result;
];


5 # Coef(uv_IsUniVar,order_IsList) <--
[
  Local(result);
  result:={};
  ForEach(item,order)
  [
    DestructiveAppend(result,Coef(uv,item));
  ];
  result;
];

10 # Coef(uv_IsUniVar,_order)_(order<uv[2]) <-- 0;
10 # Coef(uv_IsUniVar,_order)_(order>=uv[2]+Length(uv[3])) <-- 0;
20 # Coef(uv_IsUniVar,_order) <-- uv[3][(order-uv[2])+1];
30 # Coef(uv_CanBeUni,_order) <-- Coef(MakeUni(uv),order);

Function("Coef",{expression,var,order})
    NormalForm(Coef(MakeUni(expression,var),order));

10 # LeadingCoef(uv_IsUniVar) <-- Coef(uv,Degree(uv));

20 # LeadingCoef(uv_CanBeUni) <--
[
  Local(uvi);
  uvi:=MakeUni(uv);
  Coef(uvi,Degree(uvi));
];
10 # LeadingCoef(uv_CanBeUni,_var) <--
[
  Local(uvi);
  uvi:=MakeUni(uv,var);
  Coef(uvi,var,Degree(uvi));
];


Function("UniTaylor",{taylorfunction,taylorvariable,taylorat,taylororder})
[
  Local(n,result,dif,polf);
  result:={};
  [
    MacroLocal(taylorvariable);
    MacroSet(taylorvariable,taylorat);
    DestructiveAppend(result,Eval(taylorfunction));
  ];
  dif:=taylorfunction;
  polf:=(taylorvariable-taylorat);
  For(n:=1,n<=taylororder,n++)
  [
    dif:= Deriv(taylorvariable) dif;
    MacroLocal(taylorvariable);
    MacroSet(taylorvariable,taylorat);
    DestructiveAppend(result,(Eval(dif)/n!));
  ];
  UniVariate(taylorvariable,0,result);
];


Function("MakeUni",{expression}) MakeUni(expression,VarList(expression));

/* Convert normal form to univariate expression */
RuleBase("MakeUni",{expression,var});

Rule("MakeUni",2,1,var = {})
[
  UniVariate(dummyvar,0,{expression});
];

Rule("MakeUni",2,2,IsList(var))
[
  Local(result,item);
  result:=expression;
  ForEach(item,var)
  [
    result:=MakeUni(result,item);
  ];
  result;
];

Rule("MakeUni",2,10,Type(expression) = "UniVariate")
[
  Local(reslist,item);
  reslist:={};
  ForEach(item,expression[3])
  [
    If(IsFreeOf(item,var),
      DestructiveAppend(reslist,item),
      DestructiveAppend(reslist,MakeUni(item,var))
      );
  ];
  Apply("UniVariate",{expression[1],expression[2],reslist});
];



Rule("MakeUni",2,20,IsFreeOf(expression,var)) UniVariate(var,0,{expression});

Rule("MakeUni",2,30,expression=var)       UniVariate(var,1,{1});

Rule("MakeUni",2,30,Type(expression) = "+")
  MakeUni(expression[1],var)+MakeUni(expression[2],var);
Rule("MakeUni",2,30,Type(expression) = "*")
  MakeUni(expression[1],var)*MakeUni(expression[2],var);
Rule("MakeUni",2,30,Type(expression) = "^" And IsInteger(expression[2]))
  MakeUni(expression[1],var)^expression[2];
Rule("MakeUni",2,30,Type(expression) = "-" And NrArgs(expression) = 1)
     -(MakeUni(expression[1],var));

Rule("MakeUni",2,30,Type(expression) = "/" And
     Not(Contains(VarList(expression[2]),var)))
  MakeUni(expression[1],var)*(1/expression[2]);

Rule("MakeUni",2,30,Type(expression) = "-" And NrArgs(expression) = 2)
     MakeUni(expression[1],var)-MakeUni(expression[2],var);


0 # Div(n_IsUniVar,m_IsUniVar)_(Degree(n) < Degree(m)) <-- 0;
0 # Mod(n_IsUniVar,m_IsUniVar)_(Degree(n) < Degree(m)) <-- n;
1 # Div(n_IsUniVar,m_IsUniVar)_
    (n[1] = m[1] And Degree(n) >= Degree(m)) <--
    UniVariate(n[1],0,
               UniDivide(Concat(ZeroVector(n[2]),n[3]),
                         Concat(ZeroVector(m[2]),m[3]))[1]);
1 # Mod(n_IsUniVar,m_IsUniVar)_
    (n[1] = m[1] And Degree(n) >= Degree(m)) <--
    UniVariate(n[1],0,
               UniDivide(Concat(ZeroVector(n[2]),n[3]),
                         Concat(ZeroVector(m[2]),m[3]))[2]);




/* division algo: (for zero-base univariates:) */
Function("UniDivide",{u,v})
[
  Local(m,n,q,r,k,j);
  m := Length(u)-1;
  n := Length(v)-1;
  While (m>0 And IsZero(u[m+1])) m--;
  While (n>0 And IsZero(v[n+1])) n--;
  q := ZeroVector(m-n+1);
  r := FlatCopy(u);  /*  (m should be >= n) */
  For(k:=m-n,k>=0,k--)
  [
    q[k+1] := r[n+k+1]/v[n+1];
    For (j:=n+k-1,j>=k,j--)
    [
      r[j+1] := r[j+1] - q[k+1]*v[j-k+1];
    ];
  ];
  While (Length(r)>n) DestructiveDelete(r,Length(r));

  {q,r};
];


DropEndZeroes(list):=
  While(list[Length(list)] = 0) DestructiveDelete(list,Length(list));



Function("UniGcd",{u,v})
[
  Local(l,div,mod,m);

  DropEndZeroes(u);
  DropEndZeroes(v);
/*
  If(Length(v)>Length(u),
    [
      Locap(swap);
      swap:=u;
      u:=v;
      v:=swap;
    ] );
  If(Length(u)=Length(v) And v[Length(v)] > u[Length(u)],
    [
      Locap(swap);
      swap:=u;
      u:=v;
      v:=swap;
    ] );
  */

  
  l:=UniDivide(u,v);

  div:=l[1];
  mod:=l[2];

  DropEndZeroes(mod);
  m := Length(mod);

/* Echo({"v,mod = ",v,mod}); */
/*  If(m <= 1, */
  If(m = 0,
     v,
/*     v/v[Length(v)], */
     UniGcd(v,mod));
];



0 # Gcd(n_IsUniVar,m_IsUniVar)_
    (n[1] = m[1] And Degree(n) < Degree(m)) <-- Gcd(m,n);

1 # Gcd(nn_IsUniVar,mm_IsUniVar)_
    (nn[1] = mm[1] And Degree(nn) >= Degree(mm)) <--
[
   UniVariate(nn[1],0,
                UniGcd(Concat(ZeroVector(nn[2]),nn[3]),
                       Concat(ZeroVector(mm[2]),mm[3])));
];

RuleBase("PSolve",{uni});

Rule("PSolve",1,1,IsUniVar(uni) And Degree(uni) = 1)
    -Coef(uni,0)/Coef(uni,1);

Rule("PSolve",1,1,IsUniVar(uni) And Degree(uni) = 2)
    [
     Local(a,b,c,d);
     c:=Coef(uni,0);
     b:=Coef(uni,1);
     a:=Coef(uni,2);
     d:=b*b-4*a*c;
     {(-b+Sqrt(d))/(2*a),(-b-Sqrt(d))/(2*a)};
    ];

Function("PSolve",{uni,var})
    [
     PSolve(MakeUni(uni,var));
     ];


/* Generate a random polynomial */


RandomPoly(_var,_degree,_coefmin,_coefmax) <--
  NormalForm(UniVariate(var,0,RandomIntegerVector(degree+1,coefmin,coefmax)));


/* CanBeUni returns whether the function can be converted to a
 * univariate, with respect to a variable.
 */
Function("CanBeUni",{expression}) CanBeUni(expression,VarList(expression));


/* Accepting an expression as being convertable to univariate */

/* Dealing wiht a list of variables. The poly should be expandable
 * to each of these variables (smells like tail recursion)
 */
10 # CanBeUni(_expression,{}) <-- True;
20 # CanBeUni(_expression,var_IsList) <--
    CanBeUni(expression,Head(var)) And CanBeUni(expression,Tail(var));

/* Atom can always be a polynom to any variable */
30 # CanBeUni(expression_IsAtom,_var) <-- True;
35 # CanBeUni(_expression,_var)_IsFreeOf(expression,var) <--
    True;

/* Other patterns supported. */
40 # CanBeUni(_x + _y,_var) <-- CanBeUni(x,var) And CanBeUni(y,var);
40 # CanBeUni(_x - _y,_var) <-- CanBeUni(x,var) And CanBeUni(y,var);
40 # CanBeUni(   + _y,_var) <-- CanBeUni(y,var);
40 # CanBeUni(   - _y,_var) <-- CanBeUni(y,var);
40 # CanBeUni(_x * _y,_var) <-- CanBeUni(x,var) And CanBeUni(y,var);
40 # CanBeUni(_x / _y,_var) <-- CanBeUni(x,var) And IsFreeOf(y,var);
/* Special case again: raising powers */
40 # CanBeUni(_x ^ y_IsInteger,_var)_CanBeUni(x,var) <-- True;
41 # CanBeUni(_x ^ _y,_var)_(IsFreeOf(x,var) And IsFreeOf(y,var)) <-- True;
50 # CanBeUni(UniVariate(_var,_first,_coefs),_var) <-- True;
1000 # CanBeUni(_f,_var)_(Not(IsFreeOf(f,var))) <-- False;
1001 # CanBeUni(_f,_var) <-- True;




10 # Content(UniVariate(_var,_first,_coefs)) <-- Gcd(coefs)*var^first;
20 # Content(poly_CanBeUni) <-- NormalForm(Content(MakeUni(poly)));

10 # PrimitivePart(UniVariate(_var,_first,_coefs)) <--
	UniVariate(var,0,coefs/Gcd(coefs));
20 # PrimitivePart(poly_CanBeUni) <-- NormalForm(PrimitivePart(MakeUni(poly)));

10 # Monic(UniVariate(_var,_first,_coefs)) <--
[
  DropEndZeroes(coefs);
  UniVariate(var,first,coefs/coefs[Length(coefs)]);
];
20 # Monic(poly_CanBeUni) <-- NormalForm(Monic(MakeUni(poly)));

30 # Monic(_poly,_var)_CanBeUni(poly,var) <-- NormalForm(Monic(MakeUni(poly,var)));


10 # BigOh(UniVariate(_var,_first,_coefs),_var,_degree) <--
    [
     While(first+Length(coefs)>=(degree+1) And Length(coefs)>0) DestructiveDelete(coefs,Length(coefs));
     UniVariate(var,first,coefs);
    ];
20 # BigOh(_uv,_var,_degree)_CanBeUni(uv,var) <-- NormalForm(BigOh(MakeUni(uv,var),var,degree));

